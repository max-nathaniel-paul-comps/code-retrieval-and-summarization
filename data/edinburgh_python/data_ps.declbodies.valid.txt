def _block2d_to_blocknd(values, placement, shape, labels, ref_items): DCNL  DCSP from pandas.core.internals import make_block DCNL DCSP panel_shape = ((len(placement),) + shape) DCNL DCSP selector = _factor_indexer(shape[1:], labels) DCNL DCSP mask = np.zeros(np.prod(shape), dtype=bool) DCNL DCSP mask.put(selector, True) DCNL DCSP if mask.all(): DCNL DCSP  DCSP pvalues = np.empty(panel_shape, dtype=values.dtype) DCNL DCSP else: DCNL DCSP  DCSP (dtype, fill_value) = _maybe_promote(values.dtype) DCNL DCSP  DCSP pvalues = np.empty(panel_shape, dtype=dtype) DCNL DCSP  DCSP pvalues.fill(fill_value) DCNL DCSP values = values DCNL DCSP for i in range(len(placement)): DCNL DCSP  DCSP pvalues[i].flat[mask] = values[:, i] DCNL DCSP return make_block(pvalues, placement=placement)
def create_cow_image(backing_file, path, size=None): DCNL  DCSP base_cmd = ['qemu-img', 'create', '-f', 'qcow2'] DCNL DCSP cow_opts = [] DCNL DCSP if backing_file: DCNL DCSP  DCSP cow_opts += [('backing_file=%s' % backing_file)] DCNL DCSP  DCSP base_details = images.qemu_img_info(backing_file) DCNL DCSP else: DCNL DCSP  DCSP base_details = None DCNL DCSP if (base_details and (base_details.cluster_size is not None)): DCNL DCSP  DCSP cow_opts += [('cluster_size=%s' % base_details.cluster_size)] DCNL DCSP if (base_details and base_details.encryption): DCNL DCSP  DCSP cow_opts += [('encryption=%s' % base_details.encryption)] DCNL DCSP if (size is not None): DCNL DCSP  DCSP cow_opts += [('size=%s' % size)] DCNL DCSP if cow_opts: DCNL DCSP  DCSP csv_opts = ','.join(cow_opts) DCNL DCSP  DCSP cow_opts = ['-o', csv_opts] DCNL DCSP cmd = ((base_cmd + cow_opts) + [path]) DCNL DCSP execute(*cmd)
def reload_config(): DCNL  DCSP _env_reloader.update()
def encode_morse(msg, sep='|', mapping=None): DCNL  DCSP mapping = (mapping or char_morse) DCNL DCSP assert (sep not in mapping) DCNL DCSP word_sep = (2 * sep) DCNL DCSP mapping[' DCSP '] = word_sep DCNL DCSP suffix = (msg and (msg[(-1)] in whitespace)) DCNL DCSP msg = (' DCSP ' if word_sep else '').join(msg.split()) DCNL DCSP chars = set(''.join(msg.split())) DCNL DCSP ok = set(mapping.keys()) DCNL DCSP msg = translate(msg, None, ''.join((chars - ok))) DCNL DCSP morsestring = [] DCNL DCSP words = msg.split() DCNL DCSP for word in words: DCNL DCSP  DCSP morseword = [] DCNL DCSP  DCSP for letter in word: DCNL DCSP  DCSP  DCSP morseletter = mapping[letter] DCNL DCSP  DCSP  DCSP morseword.append(morseletter) DCNL DCSP  DCSP word = sep.join(morseword) DCNL DCSP  DCSP morsestring.append(word) DCNL DCSP return (word_sep.join(morsestring) + (word_sep if suffix else ''))
def test_boolean_field_choices_with_real_model_instances(): DCNL  DCSP class BoolModelChoices(models.Model, ): DCNL DCSP  DCSP field = models.BooleanField(choices=((True, u'Yes'), (False, u'No'))) DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP app_label = u'django_tables2_test' DCNL DCSP class Table(tables.Table, ): DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP model = BoolModelChoices DCNL DCSP table = Table([BoolModelChoices(field=True), BoolModelChoices(field=False)]) DCNL DCSP assert (table.rows[0].get_cell(u'field') == u'<span DCSP class="true">\u2714</span>') DCNL DCSP assert (table.rows[1].get_cell(u'field') == u'<span DCSP class="false">\u2718</span>')
def p_constant_expression(t): DCNL  DCSP pass
def nsmallest(arr, n, keep='first'): DCNL  DCSP if (keep == 'last'): DCNL DCSP  DCSP arr = arr[::(-1)] DCNL DCSP narr = len(arr) DCNL DCSP n = min(n, narr) DCNL DCSP sdtype = str(arr.dtype) DCNL DCSP arr = arr.view(_dtype_map.get(sdtype, sdtype)) DCNL DCSP kth_val = algos.kth_smallest(arr.copy(), (n - 1)) DCNL DCSP return _finalize_nsmallest(arr, kth_val, n, keep, narr)
def consolidate_hashes(partition_dir): DCNL  DCSP hashes_file = join(partition_dir, HASH_FILE) DCNL DCSP invalidations_file = join(partition_dir, HASH_INVALIDATIONS_FILE) DCNL DCSP if (not os.path.exists(hashes_file)): DCNL DCSP  DCSP if os.path.exists(invalidations_file): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(invalidations_file, 'wb'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return None DCNL DCSP with lock_path(partition_dir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(hashes_file, 'rb') as hashes_fp: DCNL DCSP  DCSP  DCSP  DCSP pickled_hashes = hashes_fp.read() DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP hashes = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hashes = pickle.loads(pickled_hashes) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP hashes = None DCNL DCSP  DCSP modified = False DCNL DCSP  DCSP found_invalidation_entry = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(invalidations_file, 'rb') as inv_fh: DCNL DCSP  DCSP  DCSP  DCSP for line in inv_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP found_invalidation_entry = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP suffix = line.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((hashes is not None) and (hashes.get(suffix, '') is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hashes[suffix] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modified = True DCNL DCSP  DCSP except (IOError, OSError) as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if modified: DCNL DCSP  DCSP  DCSP write_pickle(hashes, hashes_file, partition_dir, PICKLE_PROTOCOL) DCNL DCSP  DCSP if found_invalidation_entry: DCNL DCSP  DCSP  DCSP with open(invalidations_file, 'wb') as inv_fh: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return hashes
def get_BAIDUID(): DCNL  DCSP url = ''.join([const.PASSPORT_URL, '?getapi&tpl=mn&apiver=v3', '&tt=', util.timestamp(), '&class=login&logintype=basicLogin']) DCNL DCSP req = net.urlopen(url, headers={'Referer': ''}) DCNL DCSP if req: DCNL DCSP  DCSP return req.headers.get_all('Set-Cookie') DCNL DCSP else: DCNL DCSP  DCSP return None
def cg_has_volumes_filter(attached_or_with_snapshots=False): DCNL  DCSP return IMPL.cg_has_volumes_filter(attached_or_with_snapshots)
def url_is_from_spider(url, spider): DCNL  DCSP return url_is_from_any_domain(url, ([spider.name] + getattr(spider, 'allowed_domains', [])))
def dup_spherical_bessel_fn_minus(n, K): DCNL  DCSP seq = [[K.one, K.zero], [K.zero]] DCNL DCSP for i in range(2, (n + 1)): DCNL DCSP  DCSP a = dup_mul_ground(dup_lshift(seq[(-1)], 1, K), K((3 - (2 * i))), K) DCNL DCSP  DCSP seq.append(dup_sub(a, seq[(-2)], K)) DCNL DCSP return seq[n]
def _toggle_proj(event, params): DCNL  DCSP if ('proj_checks' in params): DCNL DCSP  DCSP bools = [x[0].get_visible() for x in params['proj_checks'].lines] DCNL DCSP  DCSP for (bi, (b, p)) in enumerate(zip(bools, params['projs'])): DCNL DCSP  DCSP  DCSP if ((not b) and p['active']): DCNL DCSP  DCSP  DCSP  DCSP bools[bi] = True DCNL DCSP else: DCNL DCSP  DCSP bools = ([True] * len(params['projs'])) DCNL DCSP compute_proj = False DCNL DCSP if ('proj_bools' not in params): DCNL DCSP  DCSP compute_proj = True DCNL DCSP elif (not np.array_equal(bools, params['proj_bools'])): DCNL DCSP  DCSP compute_proj = True DCNL DCSP if (compute_proj is True): DCNL DCSP  DCSP params['plot_update_proj_callback'](params, bools)
def restore_ring(output, coord, width, dense_input, start_idx): DCNL  DCSP (img_h, img_w) = output.shape[1:3] DCNL DCSP start_idx = restore_rect(output, coord, coord, (img_h - coord), (coord + width), width, dense_input, start_idx) DCNL DCSP start_idx = restore_rect(output, coord, ((img_w - coord) - width), (img_h - coord), (img_w - coord), width, dense_input, start_idx) DCNL DCSP start_idx = restore_rect(output, coord, (coord + width), (coord + width), ((img_w - coord) - width), width, dense_input, start_idx) DCNL DCSP start_idx = restore_rect(output, ((img_h - coord) - width), (coord + width), (img_h - coord), ((img_w - coord) - width), width, dense_input, start_idx) DCNL DCSP return start_idx
def negate_real(builder, val): DCNL  DCSP return builder.fsub(lc.Constant.real(val.type, (-0.0)), val)
def smoothness_p(n, m=(-1), power=0, visual=None): DCNL  DCSP from sympy.utilities import flatten DCNL DCSP if (visual in (1, 0)): DCNL DCSP  DCSP visual = bool(visual) DCNL DCSP elif (visual not in (True, False)): DCNL DCSP  DCSP visual = None DCNL DCSP if (type(n) is str): DCNL DCSP  DCSP if visual: DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP for li in n.splitlines(): DCNL DCSP  DCSP  DCSP (k, v) = [int(i) for i in li.split('has')[0].split('=')[1].split('**')] DCNL DCSP  DCSP  DCSP d[k] = v DCNL DCSP  DCSP if ((visual is not True) and (visual is not False)): DCNL DCSP  DCSP  DCSP return d DCNL DCSP  DCSP return smoothness_p(d, visual=False) DCNL DCSP elif (type(n) is not tuple): DCNL DCSP  DCSP facs = factorint(n, visual=False) DCNL DCSP if power: DCNL DCSP  DCSP k = (-1) DCNL DCSP else: DCNL DCSP  DCSP k = 1 DCNL DCSP if (type(n) is not tuple): DCNL DCSP  DCSP rv = (m, sorted([(f, tuple(([M] + list(smoothness((f + m)))))) for (f, M) in [i for i in facs.items()]], key=(lambda x: (x[1][k], x[0])))) DCNL DCSP else: DCNL DCSP  DCSP rv = n DCNL DCSP if ((visual is False) or ((visual is not True) and (type(n) in [int, Mul]))): DCNL DCSP  DCSP return rv DCNL DCSP lines = [] DCNL DCSP for dat in rv[1]: DCNL DCSP  DCSP dat = flatten(dat) DCNL DCSP  DCSP dat.insert(2, m) DCNL DCSP  DCSP lines.append(('p**i=%i**%i DCSP has DCSP p%+i DCSP B=%i, DCSP B-pow=%i' % tuple(dat))) DCNL DCSP return '\n'.join(lines)
def download_zlib(dest_dir, version): DCNL  DCSP version_re = re.compile('zlib-([0-9.]+[0-9]).tar.gz') DCNL DCSP filename = 'zlib-%s.tar.gz' DCNL DCSP return download_library(dest_dir, ZLIB_LOCATION, 'zlib', version_re, filename, version=version)
def build_auxiliary_node_connectivity(G): DCNL  DCSP directed = G.is_directed() DCNL DCSP mapping = {} DCNL DCSP H = nx.DiGraph() DCNL DCSP for (i, node) in enumerate(G): DCNL DCSP  DCSP mapping[node] = i DCNL DCSP  DCSP H.add_node(('%dA' % i), id=node) DCNL DCSP  DCSP H.add_node(('%dB' % i), id=node) DCNL DCSP  DCSP H.add_edge(('%dA' % i), ('%dB' % i), capacity=1) DCNL DCSP edges = [] DCNL DCSP for (source, target) in G.edges(): DCNL DCSP  DCSP edges.append((('%sB' % mapping[source]), ('%sA' % mapping[target]))) DCNL DCSP  DCSP if (not directed): DCNL DCSP  DCSP  DCSP edges.append((('%sB' % mapping[target]), ('%sA' % mapping[source]))) DCNL DCSP H.add_edges_from(edges, capacity=1) DCNL DCSP H.graph['mapping'] = mapping DCNL DCSP return H
def get_mem_info_linux(): DCNL  DCSP info = {} DCNL DCSP with open('/proc/meminfo', 'r') as f: DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP p = line.split() DCNL DCSP  DCSP  DCSP info[p[0].strip(':').lower()] = (float(p[1]) * 1000.0) DCNL DCSP return info
def get_service(hass, config, discovery_info=None): DCNL  DCSP import telegram DCNL DCSP try: DCNL DCSP  DCSP chat_id = config.get(CONF_CHAT_ID) DCNL DCSP  DCSP api_key = config.get(CONF_API_KEY) DCNL DCSP  DCSP bot = telegram.Bot(token=api_key) DCNL DCSP  DCSP username = bot.getMe()['username'] DCNL DCSP  DCSP _LOGGER.info("Telegram DCSP bot DCSP is DCSP '%s'", username) DCNL DCSP except urllib.error.HTTPError: DCNL DCSP  DCSP _LOGGER.error('Please DCSP check DCSP your DCSP access DCSP token') DCNL DCSP  DCSP return None DCNL DCSP return TelegramNotificationService(api_key, chat_id)
def reverse_course_url(handler_name, course_key, kwargs=None): DCNL  DCSP return reverse_url(handler_name, 'course_key_string', course_key, kwargs)
def _mask_to_limits(a, limits, inclusive): DCNL  DCSP (lower_limit, upper_limit) = limits DCNL DCSP (lower_include, upper_include) = inclusive DCNL DCSP am = ma.MaskedArray(a) DCNL DCSP if (lower_limit is not None): DCNL DCSP  DCSP if lower_include: DCNL DCSP  DCSP  DCSP am = ma.masked_less(am, lower_limit) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP am = ma.masked_less_equal(am, lower_limit) DCNL DCSP if (upper_limit is not None): DCNL DCSP  DCSP if upper_include: DCNL DCSP  DCSP  DCSP am = ma.masked_greater(am, upper_limit) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP am = ma.masked_greater_equal(am, upper_limit) DCNL DCSP if (am.count() == 0): DCNL DCSP  DCSP raise ValueError('No DCSP array DCSP values DCSP within DCSP given DCSP limits') DCNL DCSP return am
def _split_digest_auth(data): DCNL  DCSP values = [] DCNL DCSP curdata = [] DCNL DCSP state = 0 DCNL DCSP for char in data: DCNL DCSP  DCSP if (state == 0): DCNL DCSP  DCSP  DCSP if (char == ','): DCNL DCSP  DCSP  DCSP  DCSP values.append(''.join(curdata).strip()) DCNL DCSP  DCSP  DCSP  DCSP curdata = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (char == '"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state = 1 DCNL DCSP  DCSP  DCSP  DCSP curdata.append(char) DCNL DCSP  DCSP elif (state == 1): DCNL DCSP  DCSP  DCSP if (char == '"'): DCNL DCSP  DCSP  DCSP  DCSP state = 0 DCNL DCSP  DCSP  DCSP curdata.append(char) DCNL DCSP values.append(''.join(curdata).strip()) DCNL DCSP if ((state == 1) and config.DEBUG): DCNL DCSP  DCSP sys.stderr.write(('IVRE: DCSP WARNING: DCSP could DCSP not DCSP parse DCSP Digest DCSP auth DCSP data DCSP [%r]' % data)) DCNL DCSP return values
def getPathByKey(key, xmlElement): DCNL  DCSP if (key not in xmlElement.attributeDictionary): DCNL DCSP  DCSP return [] DCNL DCSP word = str(xmlElement.attributeDictionary[key]).strip() DCNL DCSP evaluatedLinkValue = getEvaluatedLinkValue(word, xmlElement) DCNL DCSP if (evaluatedLinkValue.__class__ == list): DCNL DCSP  DCSP return getPathByList(evaluatedLinkValue) DCNL DCSP xmlElementObject = getXMLElementObject(evaluatedLinkValue) DCNL DCSP if (xmlElementObject == None): DCNL DCSP  DCSP return [] DCNL DCSP return xmlElementObject.getPaths()[0]
def check_named(option, opt, value): DCNL  DCSP if isinstance(value, dict): DCNL DCSP  DCSP return value DCNL DCSP values = [] DCNL DCSP for value in check_csv(option, opt, value): DCNL DCSP  DCSP if (value.find('=') != (-1)): DCNL DCSP  DCSP  DCSP values.append(value.split('=', 1)) DCNL DCSP  DCSP elif (value.find(':') != (-1)): DCNL DCSP  DCSP  DCSP values.append(value.split(':', 1)) DCNL DCSP if values: DCNL DCSP  DCSP return dict(values) DCNL DCSP msg = 'option DCSP %s: DCSP invalid DCSP named DCSP value DCSP %r, DCSP should DCSP be DCSP <NAME>=<VALUE> DCSP or DCSP <NAME>:<VALUE>' DCNL DCSP raise OptionValueError((msg % (opt, value)))
def connections_support_transactions(): DCNL  DCSP return all((conn.settings_dict['SUPPORTS_TRANSACTIONS'] for conn in connections.all()))
@pytest.fixture(autouse=True) DCNL def _annotate_environment(request): DCNL  DCSP environment = getattr(request.config, '_environment', None) DCNL DCSP if environment: DCNL DCSP  DCSP behave_version = behave.__version__ DCNL DCSP  DCSP environment.append(('behave', behave_version))
def escape_sql_like_special_characters(term, escape='\\'): DCNL  DCSP for ch in (escape + _special_characters): DCNL DCSP  DCSP term = term.replace(ch, (escape + ch)) DCNL DCSP return term
def strip_version(idstr): DCNL  DCSP parts = idstr.split('v') DCNL DCSP return parts[0]
@lru_cache(maxsize=1024) DCNL def extract_real_url_from_embedded_url(embedded_url): DCNL  DCSP if ((('._' + cdn_url_query_encode_salt) + '_.') not in embedded_url[(-15):]): DCNL DCSP  DCSP return None DCNL DCSP m = regex_extract_base64_from_embedded_url.search(embedded_url) DCNL DCSP b64 = get_group('b64', m) DCNL DCSP real_request_url_no_query = embedded_url[:m.span()[0]] DCNL DCSP query_string_byte = base64.urlsafe_b64decode(b64) DCNL DCSP is_gzipped = get_group('gzip', m) DCNL DCSP if is_gzipped: DCNL DCSP  DCSP query_string_byte = zlib.decompress(query_string_byte) DCNL DCSP query_string = query_string_byte.decode(encoding='utf-8') DCNL DCSP result = urljoin(real_request_url_no_query, ('?' + query_string)) DCNL DCSP return result
def fetch_20newsgroups(data_home=None, subset='train', categories=None, shuffle=True, random_state=42, remove=(), download_if_missing=True): DCNL  DCSP data_home = get_data_home(data_home=data_home) DCNL DCSP cache_path = _pkl_filepath(data_home, CACHE_NAME) DCNL DCSP twenty_home = os.path.join(data_home, '20news_home') DCNL DCSP cache = None DCNL DCSP if os.path.exists(cache_path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(cache_path, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP compressed_content = f.read() DCNL DCSP  DCSP  DCSP uncompressed_content = codecs.decode(compressed_content, 'zlib_codec') DCNL DCSP  DCSP  DCSP cache = pickle.loads(uncompressed_content) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP print (80 * '_') DCNL DCSP  DCSP  DCSP print 'Cache DCSP loading DCSP failed' DCNL DCSP  DCSP  DCSP print (80 * '_') DCNL DCSP  DCSP  DCSP print e DCNL DCSP if (cache is None): DCNL DCSP  DCSP if download_if_missing: DCNL DCSP  DCSP  DCSP logger.info('Downloading DCSP 20news DCSP dataset. DCSP This DCSP may DCSP take DCSP a DCSP few DCSP minutes.') DCNL DCSP  DCSP  DCSP cache = download_20newsgroups(target_dir=twenty_home, cache_path=cache_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise IOError('20Newsgroups DCSP dataset DCSP not DCSP found') DCNL DCSP if (subset in ('train', 'test')): DCNL DCSP  DCSP data = cache[subset] DCNL DCSP elif (subset == 'all'): DCNL DCSP  DCSP data_lst = list() DCNL DCSP  DCSP target = list() DCNL DCSP  DCSP filenames = list() DCNL DCSP  DCSP for subset in ('train', 'test'): DCNL DCSP  DCSP  DCSP data = cache[subset] DCNL DCSP  DCSP  DCSP data_lst.extend(data.data) DCNL DCSP  DCSP  DCSP target.extend(data.target) DCNL DCSP  DCSP  DCSP filenames.extend(data.filenames) DCNL DCSP  DCSP data.data = data_lst DCNL DCSP  DCSP data.target = np.array(target) DCNL DCSP  DCSP data.filenames = np.array(filenames) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("subset DCSP can DCSP only DCSP be DCSP 'train', DCSP 'test' DCSP or DCSP 'all', DCSP got DCSP '%s'" % subset)) DCNL DCSP data.description = 'the DCSP 20 DCSP newsgroups DCSP by DCSP date DCSP dataset' DCNL DCSP if ('headers' in remove): DCNL DCSP  DCSP data.data = [strip_newsgroup_header(text) for text in data.data] DCNL DCSP if ('footers' in remove): DCNL DCSP  DCSP data.data = [strip_newsgroup_footer(text) for text in data.data] DCNL DCSP if ('quotes' in remove): DCNL DCSP  DCSP data.data = [strip_newsgroup_quoting(text) for text in data.data] DCNL DCSP if (categories is not None): DCNL DCSP  DCSP labels = [(data.target_names.index(cat), cat) for cat in categories] DCNL DCSP  DCSP labels.sort() DCNL DCSP  DCSP (labels, categories) = zip(*labels) DCNL DCSP  DCSP mask = np.in1d(data.target, labels) DCNL DCSP  DCSP data.filenames = data.filenames[mask] DCNL DCSP  DCSP data.target = data.target[mask] DCNL DCSP  DCSP data.target = np.searchsorted(labels, data.target) DCNL DCSP  DCSP data.target_names = list(categories) DCNL DCSP  DCSP data_lst = np.array(data.data, dtype=object) DCNL DCSP  DCSP data_lst = data_lst[mask] DCNL DCSP  DCSP data.data = data_lst.tolist() DCNL DCSP if shuffle: DCNL DCSP  DCSP random_state = check_random_state(random_state) DCNL DCSP  DCSP indices = np.arange(data.target.shape[0]) DCNL DCSP  DCSP random_state.shuffle(indices) DCNL DCSP  DCSP data.filenames = data.filenames[indices] DCNL DCSP  DCSP data.target = data.target[indices] DCNL DCSP  DCSP data_lst = np.array(data.data, dtype=object) DCNL DCSP  DCSP data_lst = data_lst[indices] DCNL DCSP  DCSP data.data = data_lst.tolist() DCNL DCSP return data
def get_body_region(defined): DCNL  DCSP scope = defined.get_scope() DCNL DCSP pymodule = defined.get_module() DCNL DCSP lines = pymodule.lines DCNL DCSP node = defined.get_ast() DCNL DCSP start_line = node.lineno DCNL DCSP if (defined.get_doc() is None): DCNL DCSP  DCSP start_line = node.body[0].lineno DCNL DCSP elif (len(node.body) > 1): DCNL DCSP  DCSP start_line = node.body[1].lineno DCNL DCSP start = lines.get_line_start(start_line) DCNL DCSP scope_start = pymodule.logical_lines.logical_line_in(scope.start) DCNL DCSP if (scope_start[1] >= start_line): DCNL DCSP  DCSP start = (pymodule.source_code.index(':', start) + 1) DCNL DCSP  DCSP while pymodule.source_code[start].isspace(): DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP end = min((lines.get_line_end(scope.end) + 1), len(pymodule.source_code)) DCNL DCSP return (start, end)
def open_tasks_for_project(): DCNL  DCSP def prep(r): DCNL DCSP  DCSP tablename = 'project_project' DCNL DCSP  DCSP s3.crud_strings[tablename].title_list = T('Open DCSP Tasks DCSP for DCSP Project') DCNL DCSP  DCSP s3.crud_labels.READ = s3.crud_labels.UPDATE = T('Select') DCNL DCSP  DCSP s3db.configure(tablename, deletable=False, listadd=False) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if (r.interactive and (not r.component)): DCNL DCSP  DCSP  DCSP tasklist_url = URL(f='task', vars={'project': '[id]'}) DCNL DCSP  DCSP  DCSP s3_action_buttons(r, deletable=False, read_url=tasklist_url, update_url=tasklist_url) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP return s3_rest_controller(module, 'project', hide_filter=False)
def get_node_host(name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP cc = conn.describe_cache_clusters(name, show_cache_node_info=True) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP get DCSP config DCSP for DCSP cache DCSP cluster DCSP {0}.'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP return {} DCNL DCSP cc = cc['DescribeCacheClustersResponse']['DescribeCacheClustersResult'] DCNL DCSP host = cc['CacheClusters'][0]['CacheNodes'][0]['Endpoint']['Address'] DCNL DCSP return host
def __virtual__(): DCNL  DCSP if (get_configured_provider() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_dependencies() is False): DCNL DCSP  DCSP return False DCNL DCSP return True
def _enum_to_int(value): DCNL  DCSP try: DCNL DCSP  DCSP return int(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return value
def winsorize(a, limits=None, inclusive=(True, True), inplace=False, axis=None): DCNL  DCSP def _winsorize1D(a, low_limit, up_limit, low_include, up_include): DCNL DCSP  DCSP n = a.count() DCNL DCSP  DCSP idx = a.argsort() DCNL DCSP  DCSP if low_limit: DCNL DCSP  DCSP  DCSP if low_include: DCNL DCSP  DCSP  DCSP  DCSP lowidx = int((low_limit * n)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lowidx = np.round((low_limit * n)) DCNL DCSP  DCSP  DCSP a[idx[:lowidx]] = a[idx[lowidx]] DCNL DCSP  DCSP if (up_limit is not None): DCNL DCSP  DCSP  DCSP if up_include: DCNL DCSP  DCSP  DCSP  DCSP upidx = (n - int((n * up_limit))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP upidx = (n - np.round((n * up_limit))) DCNL DCSP  DCSP  DCSP a[idx[upidx:]] = a[idx[(upidx - 1)]] DCNL DCSP  DCSP return a DCNL DCSP a = ma.array(a, copy=np.logical_not(inplace)) DCNL DCSP if (limits is None): DCNL DCSP  DCSP return a DCNL DCSP if ((not isinstance(limits, tuple)) and isinstance(limits, float)): DCNL DCSP  DCSP limits = (limits, limits) DCNL DCSP (lolim, uplim) = limits DCNL DCSP errmsg = 'The DCSP proportion DCSP to DCSP cut DCSP from DCSP the DCSP %s DCSP should DCSP be DCSP between DCSP 0. DCSP and DCSP 1.' DCNL DCSP if (lolim is not None): DCNL DCSP  DCSP if ((lolim > 1.0) or (lolim < 0)): DCNL DCSP  DCSP  DCSP raise ValueError(((errmsg % 'beginning') + ('(got DCSP %s)' % lolim))) DCNL DCSP if (uplim is not None): DCNL DCSP  DCSP if ((uplim > 1.0) or (uplim < 0)): DCNL DCSP  DCSP  DCSP raise ValueError(((errmsg % 'end') + ('(got DCSP %s)' % uplim))) DCNL DCSP (loinc, upinc) = inclusive DCNL DCSP if (axis is None): DCNL DCSP  DCSP shp = a.shape DCNL DCSP  DCSP return _winsorize1D(a.ravel(), lolim, uplim, loinc, upinc).reshape(shp) DCNL DCSP else: DCNL DCSP  DCSP return ma.apply_along_axis(_winsorize1D, axis, a, lolim, uplim, loinc, upinc)
def maybe_add_auth(url, auth, force=False): DCNL  DCSP if (not auth): DCNL DCSP  DCSP return url DCNL DCSP url_parts = urlparse(url)._asdict() DCNL DCSP if (url_parts[u'auth'] and (not force)): DCNL DCSP  DCSP return url DCNL DCSP url_parts[u'auth'] = auth DCNL DCSP return Url(**url_parts).url
def date_range(start=None, end=None, periods=None, freq='D', tz=None, normalize=False, name=None, closed=None, **kwargs): DCNL  DCSP return DatetimeIndex(start=start, end=end, periods=periods, freq=freq, tz=tz, normalize=normalize, name=name, closed=closed, **kwargs)
def p_external_declaration_2(t): DCNL  DCSP pass
def update_cached_instance(sender, instance, **kwargs): DCNL  DCSP if (not hasattr(instance, 'cache_instance')): DCNL DCSP  DCSP return DCNL DCSP sender.cache_instance(instance)
def capfirst(value): DCNL  DCSP return (value and (value[0].upper() + value[1:]))
def blank_lines(logical_line, blank_lines, indent_level, line_number, previous_logical): DCNL  DCSP if (line_number == 1): DCNL DCSP  DCSP return DCNL DCSP if previous_logical.startswith('@'): DCNL DCSP  DCSP return DCNL DCSP if (logical_line.startswith('def DCSP ') or logical_line.startswith('class DCSP ') or logical_line.startswith('@')): DCNL DCSP  DCSP if ((indent_level > 0) and (blank_lines != 1)): DCNL DCSP  DCSP  DCSP return (0, ('E301 DCSP expected DCSP 1 DCSP blank DCSP line, DCSP found DCSP %d' % blank_lines)) DCNL DCSP  DCSP if ((indent_level == 0) and (blank_lines != 2)): DCNL DCSP  DCSP  DCSP return (0, ('E302 DCSP expected DCSP 2 DCSP blank DCSP lines, DCSP found DCSP %d' % blank_lines)) DCNL DCSP if (blank_lines > 2): DCNL DCSP  DCSP return (0, ('E303 DCSP too DCSP many DCSP blank DCSP lines DCSP (%d)' % blank_lines))
def setup_scanner(hass, config, see): DCNL  DCSP hosts = [Host(ip, dev_id, hass, config) for (dev_id, ip) in config[const.CONF_HOSTS].items()] DCNL DCSP interval = (timedelta(seconds=(len(hosts) * config[CONF_PING_COUNT])) + DEFAULT_SCAN_INTERVAL) DCNL DCSP _LOGGER.info('Started DCSP ping DCSP tracker DCSP with DCSP interval=%s DCSP on DCSP hosts: DCSP %s', interval, ','.join([host.ip_address for host in hosts])) DCNL DCSP def update(now): DCNL DCSP  DCSP 'Update DCSP all DCSP the DCSP hosts DCSP on DCSP every DCSP interval DCSP time.' DCNL DCSP  DCSP for host in hosts: DCNL DCSP  DCSP  DCSP host.update(see) DCNL DCSP  DCSP track_point_in_utc_time(hass, update, (now + interval)) DCNL DCSP  DCSP return True DCNL DCSP return update(util.dt.utcnow())
def is_monotonic(Z): DCNL  DCSP Z = np.asarray(Z, order='c') DCNL DCSP is_valid_linkage(Z, throw=True, name='Z') DCNL DCSP return (Z[1:, 2] >= Z[:(-1), 2]).all()
def _create_trigger(trigger_type): DCNL  DCSP if (hasattr(trigger_type, 'parameters_schema') and (not trigger_type['parameters_schema'])): DCNL DCSP  DCSP trigger_dict = {'name': trigger_type.name, 'pack': trigger_type.pack, 'type': trigger_type.get_reference().ref} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return create_or_update_trigger_db(trigger=trigger_dict) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP LOG.exception('Validation DCSP failed DCSP for DCSP Trigger=%s.', trigger_dict) DCNL DCSP  DCSP  DCSP raise TriggerTypeRegistrationException(('Unable DCSP to DCSP create DCSP Trigger DCSP for DCSP TriggerType=%s.' % trigger_type.name)) DCNL DCSP else: DCNL DCSP  DCSP LOG.debug(("Won't DCSP create DCSP Trigger DCSP object DCSP as DCSP TriggerType DCSP %s DCSP expects DCSP " + 'parameters.'), trigger_type) DCNL DCSP  DCSP return None
def sdm_LC(f, K): DCNL  DCSP if (not f): DCNL DCSP  DCSP return K.zero DCNL DCSP else: DCNL DCSP  DCSP return f[0][1]
def compile_file(fullname, ddir=None, force=0, rx=None, quiet=0): DCNL  DCSP success = 1 DCNL DCSP name = os.path.basename(fullname) DCNL DCSP if (ddir is not None): DCNL DCSP  DCSP dfile = os.path.join(ddir, name) DCNL DCSP else: DCNL DCSP  DCSP dfile = None DCNL DCSP if (rx is not None): DCNL DCSP  DCSP mo = rx.search(fullname) DCNL DCSP  DCSP if mo: DCNL DCSP  DCSP  DCSP return success DCNL DCSP if os.path.isfile(fullname): DCNL DCSP  DCSP (head, tail) = (name[:(-3)], name[(-3):]) DCNL DCSP  DCSP if (tail == '.py'): DCNL DCSP  DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtime = int(os.stat(fullname).st_mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expect = struct.pack('<4sl', imp.get_magic(), mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cfile = (fullname + ((__debug__ and 'c') or 'o')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(cfile, 'rb') as chandle: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP actual = chandle.read(8) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (expect == actual): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return success DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP if (not quiet): DCNL DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ok = py_compile.compile(fullname, None, dfile, True) DCNL DCSP  DCSP  DCSP except py_compile.PyCompileError as err: DCNL DCSP  DCSP  DCSP  DCSP if quiet: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP  DCSP print err.msg DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP  DCSP print 'Sorry', e DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (ok == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP return success
def hrm_human_resource_controller(extra_filter=None): DCNL  DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP s3 = current.response.s3 DCNL DCSP settings = current.deployment_settings DCNL DCSP def prep(r): DCNL DCSP  DCSP if (extra_filter is not None): DCNL DCSP  DCSP  DCSP r.resource.add_filter(extra_filter) DCNL DCSP  DCSP c = r.controller DCNL DCSP  DCSP deploy = (c == 'deploy') DCNL DCSP  DCSP vol = (c == 'vol') DCNL DCSP  DCSP if s3.rtl: DCNL DCSP  DCSP  DCSP f = s3db.pr_phone_contact.value DCNL DCSP  DCSP  DCSP f.represent = s3_phone_represent DCNL DCSP  DCSP  DCSP f.widget = S3PhoneWidget() DCNL DCSP  DCSP method = r.method DCNL DCSP  DCSP if (method in ('form', 'lookup')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP elif (method == 'profile'): DCNL DCSP  DCSP  DCSP s3db.pr_address DCNL DCSP  DCSP  DCSP list_fields = s3db.get_config('pr_address', 'list_fields') DCNL DCSP  DCSP  DCSP list_fields.append('comments') DCNL DCSP  DCSP  DCSP s3db.hrm_training.date.represent = (lambda d: S3DateTime.date_represent(d, utc=True)) DCNL DCSP  DCSP  DCSP list_fields = ['course_id', 'training_event_id$site_id', 'date', 'hours', 'grade', 'comments'] DCNL DCSP  DCSP  DCSP if deploy: DCNL DCSP  DCSP  DCSP  DCSP list_fields.append('course_id$course_job_title.job_title_id') DCNL DCSP  DCSP  DCSP s3db.configure('hrm_training', list_fields=list_fields) DCNL DCSP  DCSP  DCSP s3db.hrm_experience DCNL DCSP  DCSP  DCSP s3db.configure('hrm_experience', list_fields=['employment_type', 'activity_type', 'organisation_id', 'organisation', 'job_title_id', 'job_title', 'responsibilities', 'start_date', 'end_date', 'hours', 'location_id', 'supervisor_id', 'comments']) DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP record = r.record DCNL DCSP  DCSP  DCSP person_id = record.person_id DCNL DCSP  DCSP  DCSP ptable = db.pr_person DCNL DCSP  DCSP  DCSP person = db((ptable.id == person_id)).select(ptable.first_name, ptable.middle_name, ptable.last_name, ptable.pe_id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP name = s3_fullname(person) DCNL DCSP  DCSP  DCSP pe_id = person.pe_id DCNL DCSP  DCSP  DCSP comments = table.organisation_id.represent(record.organisation_id) DCNL DCSP  DCSP  DCSP if record.job_title_id: DCNL DCSP  DCSP  DCSP  DCSP comments = (SPAN(('%s, DCSP ' % s3_unicode(table.job_title_id.represent(record.job_title_id)))), comments) DCNL DCSP  DCSP  DCSP contacts_widget = dict(label='Contacts', label_create='Add DCSP Contact', tablename='pr_contact', type='datalist', filter=(FS('pe_id') == pe_id), icon='phone', orderby='priority DCSP asc') DCNL DCSP  DCSP  DCSP address_widget = dict(label='Address', label_create='Add DCSP Address', type='datalist', tablename='pr_address', filter=(FS('pe_id') == pe_id), icon='home') DCNL DCSP  DCSP  DCSP credentials_widget = dict(label='Sectors', label_create='Add DCSP Sector', create_controller=c, type='datalist', tablename='hrm_credential', filter=(FS('person_id') == person_id), icon='tags') DCNL DCSP  DCSP  DCSP skills_widget = dict(label='Skills', label_create='Add DCSP Skill', create_controller=c, type='datalist', tablename='hrm_competency', filter=(FS('person_id') == person_id), icon='comment-alt') DCNL DCSP  DCSP  DCSP trainings_widget = dict(label='Trainings', label_create='Add DCSP Training', create_controller=c, type='datalist', tablename='hrm_training', filter=(FS('person_id') == person_id), icon='wrench') DCNL DCSP  DCSP  DCSP experience_widget = dict(label='Experience', label_create='Add DCSP Experience', create_controller=c, type='datalist', tablename='hrm_experience', filter=(FS('person_id') == person_id), icon='truck') DCNL DCSP  DCSP  DCSP docs_widget = dict(label='Documents', label_create='Add DCSP Document', type='datalist', tablename='doc_document', filter=(FS('doc_id') == record.doc_id), icon='attachment') DCNL DCSP  DCSP  DCSP education_widget = dict(label='Education', label_create='Add DCSP Education', type='datalist', tablename='pr_education', filter=(FS('person_id') == person_id), icon='book') DCNL DCSP  DCSP  DCSP profile_widgets = [contacts_widget, address_widget, skills_widget, trainings_widget, experience_widget, docs_widget] DCNL DCSP  DCSP  DCSP if deploy: DCNL DCSP  DCSP  DCSP  DCSP profile_widgets.insert(2, credentials_widget) DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_use_education(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP profile_widgets.insert((-1), education_widget) DCNL DCSP  DCSP  DCSP s3db.configure('hrm_human_resource', profile_cols=1, profile_header=DIV(A(s3_avatar_represent(person_id, tablename='pr_person', _class='media-object'), _class='pull-left'), H2(name), P(comments), _class='profile-header'), profile_title=('%s DCSP : DCSP %s' % (s3_unicode(s3.crud_strings['hrm_human_resource'].title_display), name)), profile_widgets=profile_widgets) DCNL DCSP  DCSP elif (method == 'summary'): DCNL DCSP  DCSP  DCSP if deploy: DCNL DCSP  DCSP  DCSP  DCSP deploy_team = settings.get_deploy_team_label() DCNL DCSP  DCSP  DCSP  DCSP s3.crud_strings['hrm_human_resource']['title_list'] = (T('%(team)s DCSP Members') % dict(team=T(deploy_team))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s3.crud_strings['hrm_human_resource']['title_list'] = T('Staff DCSP & DCSP Volunteers') DCNL DCSP  DCSP  DCSP filter_widgets = hrm_human_resource_filters(resource_type='both', hrm_type_opts=s3db.hrm_type_opts) DCNL DCSP  DCSP  DCSP list_fields = ['id', 'person_id', 'job_title_id', 'organisation_id'] DCNL DCSP  DCSP  DCSP report_fields = ['organisation_id', 'person_id', 'person_id$gender', 'job_title_id', (T('Training'), 'training.course_id')] DCNL DCSP  DCSP  DCSP rappend = report_fields.append DCNL DCSP  DCSP  DCSP if vol: DCNL DCSP  DCSP  DCSP  DCSP vol_active = settings.get_hrm_vol_active() DCNL DCSP  DCSP  DCSP  DCSP if vol_active: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fields.append((T('Active'), 'details.active')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rappend((T('Active'), 'details.active')) DCNL DCSP  DCSP  DCSP  DCSP vol_experience = settings.get_hrm_vol_experience() DCNL DCSP  DCSP  DCSP  DCSP if (vol_experience in ('programme', 'both')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fields.append((T('Program'), 'person_id$hours.programme_id')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rappend((T('Program'), 'person_id$hours.programme_id')) DCNL DCSP  DCSP  DCSP elif settings.get_hrm_staff_departments(): DCNL DCSP  DCSP  DCSP  DCSP list_fields.extend(('department_id', 'site_id')) DCNL DCSP  DCSP  DCSP  DCSP report_fields.extend(('site_id', 'department_id')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP list_fields.append('site_id') DCNL DCSP  DCSP  DCSP  DCSP rappend('site_id') DCNL DCSP  DCSP  DCSP list_fields.extend(((T('Email'), 'email.value'), (settings.get_ui_label_mobile_phone(), 'phone.value'))) DCNL DCSP  DCSP  DCSP levels = current.gis.get_relevant_hierarchy_levels() DCNL DCSP  DCSP  DCSP for level in levels: DCNL DCSP  DCSP  DCSP  DCSP rappend(('location_id$%s' % level)) DCNL DCSP  DCSP  DCSP if deploy: DCNL DCSP  DCSP  DCSP  DCSP rappend((T('Credential'), 'credential.job_title_id')) DCNL DCSP  DCSP  DCSP teams = settings.get_hrm_teams() DCNL DCSP  DCSP  DCSP if teams: DCNL DCSP  DCSP  DCSP  DCSP if (teams == 'Teams'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP teams = 'Team' DCNL DCSP  DCSP  DCSP  DCSP elif (teams == 'Groups'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP teams = 'Group' DCNL DCSP  DCSP  DCSP  DCSP rappend((teams, 'group_membership.group_id')) DCNL DCSP  DCSP  DCSP if settings.get_org_regions(): DCNL DCSP  DCSP  DCSP  DCSP rappend('organisation_id$region_id') DCNL DCSP  DCSP  DCSP report_options = Storage(rows=report_fields, cols=report_fields, fact=report_fields, defaults=Storage(rows='organisation_id', cols='training.course_id', fact='count(person_id)', totals=True)) DCNL DCSP  DCSP  DCSP s3db.configure('hrm_human_resource', filter_widgets=filter_widgets, list_fields=list_fields, report_options=report_options) DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if ((method == 'create') and (not r.component)): DCNL DCSP  DCSP  DCSP  DCSP if (not settings.get_hrm_mix_staff()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if vol: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = 'vol' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = 'volunteer' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = 'hrm' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = 'staff' DCNL DCSP  DCSP  DCSP  DCSP  DCSP redirect(URL(c=c, f=f, args=r.args, vars=r.vars)) DCNL DCSP  DCSP  DCSP elif (method == 'delete'): DCNL DCSP  DCSP  DCSP  DCSP if deploy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable = s3db.deploy_application DCNL DCSP  DCSP  DCSP  DCSP  DCSP app = db((atable.human_resource_id == r.id)).select(atable.id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not app): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP current.session.error = 'Cannot DCSP find DCSP Application DCSP to DCSP delete!' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP redirect(URL(args='summary')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP redirect(URL(f='application', args=[app.id, 'delete'])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (method == 'profile'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (method == 'deduplicate'): DCNL DCSP  DCSP  DCSP  DCSP from gluon.sqlhtml import OptionsWidget DCNL DCSP  DCSP  DCSP  DCSP field = r.table.person_id DCNL DCSP  DCSP  DCSP  DCSP field.requires = IS_ONE_OF(db, 'pr_person.id', label=field.represent) DCNL DCSP  DCSP  DCSP  DCSP field.widget = OptionsWidget.widget DCNL DCSP  DCSP  DCSP elif r.id: DCNL DCSP  DCSP  DCSP  DCSP vars = {'human_resource.id': r.id, 'group': 'staff'} DCNL DCSP  DCSP  DCSP  DCSP redirect(URL(f='person', vars=vars)) DCNL DCSP  DCSP elif ((r.representation == 'xls') and (not r.component)): DCNL DCSP  DCSP  DCSP hrm_xls_list_fields(r) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP if (r.controller == 'deploy'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP deletable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP read_url = URL(args=['[id]', 'profile']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP update_url = URL(args=['[id]', 'profile']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP deletable = (settings.get_hrm_deletable(),) DCNL DCSP  DCSP  DCSP  DCSP  DCSP read_url = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP update_url = None DCNL DCSP  DCSP  DCSP  DCSP S3CRUD.action_buttons(r, deletable=deletable, read_url=read_url, update_url=update_url) DCNL DCSP  DCSP  DCSP  DCSP if (('msg' in settings.modules) and settings.get_hrm_compose_button() and current.auth.permission.has_permission('update', c='hrm', f='compose')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3.actions.append({'url': URL(f='compose', vars={'human_resource.id': '[id]'}), '_class': 'action-btn DCSP send', 'label': str(T('Send DCSP Message'))}) DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP output = hrm_map_popup(r) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = current.rest_controller('hrm', 'human_resource') DCNL DCSP return output
def getLoopsWithCorners(corners, importRadius, loops, pointTable): DCNL  DCSP for corner in corners: DCNL DCSP  DCSP if (corner not in pointTable): DCNL DCSP  DCSP  DCSP addWithLeastLength(importRadius, loops, corner) DCNL DCSP  DCSP  DCSP pointTable[corner] = None DCNL DCSP return euclidean.getSimplifiedLoops(loops, importRadius)
def validate(obj, obj_type): DCNL  DCSP from plotly import graph_reference DCNL DCSP from plotly.graph_objs import graph_objs DCNL DCSP if (obj_type not in graph_reference.CLASSES): DCNL DCSP  DCSP obj_type = graph_reference.string_to_class_name(obj_type) DCNL DCSP try: DCNL DCSP  DCSP cls = getattr(graph_objs, obj_type) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exceptions.PlotlyError("'{0}' DCSP is DCSP not DCSP a DCSP recognizable DCSP graph_obj.".format(obj_type)) DCNL DCSP cls(obj)
@retry(exception=(EnvironmentError, AssertionError), logfun=None, timeout=GLOBAL_TIMEOUT, interval=0.001) DCNL def wait_for_file(fname, delete_file=True, empty=False): DCNL  DCSP with open(fname, 'rb') as f: DCNL DCSP  DCSP data = f.read() DCNL DCSP if (not empty): DCNL DCSP  DCSP assert data DCNL DCSP if delete_file: DCNL DCSP  DCSP os.remove(fname) DCNL DCSP return data
def py_encode_basestring_ascii(s): DCNL  DCSP if (isinstance(s, str) and (HAS_UTF8.search(s) is not None)): DCNL DCSP  DCSP s = s.decode('utf-8') DCNL DCSP def replace(match): DCNL DCSP  DCSP s = match.group(0) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return ESCAPE_DCT[s] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP n = ord(s) DCNL DCSP  DCSP  DCSP if (n < 65536): DCNL DCSP  DCSP  DCSP  DCSP return '\\u{0:04x}'.format(n) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP n -= 65536 DCNL DCSP  DCSP  DCSP  DCSP s1 = (55296 | ((n >> 10) & 1023)) DCNL DCSP  DCSP  DCSP  DCSP s2 = (56320 | (n & 1023)) DCNL DCSP  DCSP  DCSP  DCSP return '\\u{0:04x}\\u{1:04x}'.format(s1, s2) DCNL DCSP return (('"' + str(ESCAPE_ASCII.sub(replace, s))) + '"')
def load(f, persistent_load=PersistentNdarrayLoad): DCNL  DCSP with closing(zipfile.ZipFile(f, 'r')) as zip_file: DCNL DCSP  DCSP p = pickle.Unpickler(BytesIO(zip_file.open('pkl').read())) DCNL DCSP  DCSP p.persistent_load = persistent_load(zip_file) DCNL DCSP  DCSP return p.load()
def linear_transform_weights(input_dim, output_dim, param_list=None, name=''): DCNL  DCSP weight_inialization = uniform(numpy.sqrt((2.0 / input_dim)), (input_dim, output_dim)) DCNL DCSP W = theano.shared(weight_inialization, name=name) DCNL DCSP assert (param_list is not None) DCNL DCSP param_list.append(W) DCNL DCSP return W
def bfs_beam_edges(G, source, value, width=None): DCNL  DCSP if (width is None): DCNL DCSP  DCSP width = len(G) DCNL DCSP def successors(v): DCNL DCSP  DCSP 'Returns DCSP a DCSP list DCSP of DCSP the DCSP best DCSP neighbors DCSP of DCSP a DCSP node.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP `v` DCSP is DCSP a DCSP node DCSP in DCSP the DCSP graph DCSP `G`.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP "best" DCSP neighbors DCSP are DCSP chosen DCSP according DCSP to DCSP the DCSP `value`\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP function DCSP (higher DCSP is DCSP better). DCSP Only DCSP the DCSP `width` DCSP best DCSP neighbors DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP `v` DCSP are DCSP returned.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP list DCSP returned DCSP by DCSP this DCSP function DCSP is DCSP in DCSP decreasing DCSP value DCSP as\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP measured DCSP by DCSP the DCSP `value` DCSP function.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return iter(sorted(G.neighbors(v), key=value, reverse=True)[:width]) DCNL DCSP for e in generic_bfs_edges(G, source, successors): DCNL DCSP  DCSP (yield e)
def repeat(sequence): DCNL  DCSP N = len(sequence) DCNL DCSP def f(i): DCNL DCSP  DCSP return sequence[(i % N)] DCNL DCSP return partial(_force, sequence=_advance(f))
def dump_and_add_to_dump(object_, file_, parameters=None, to_add=None, use_cpickle=False, protocol=DEFAULT_PROTOCOL, **kwargs): DCNL  DCSP dump(object_, file_, parameters=parameters, use_cpickle=use_cpickle, protocol=protocol, **kwargs) DCNL DCSP if (to_add is not None): DCNL DCSP  DCSP for (name, obj) in six.iteritems(to_add): DCNL DCSP  DCSP  DCSP add_to_dump(obj, file_, name, parameters=parameters, use_cpickle=use_cpickle, protocol=protocol, **kwargs)
def write_file(filename, contents): DCNL  DCSP f = open(filename, 'w') DCNL DCSP try: DCNL DCSP  DCSP for line in contents: DCNL DCSP  DCSP  DCSP f.write((line + '\n')) DCNL DCSP finally: DCNL DCSP  DCSP f.close()
def _tgrep_nltk_tree_pos_action(_s, _l, tokens): DCNL  DCSP node_tree_position = tuple((int(x) for x in tokens if x.isdigit())) DCNL DCSP return (lambda i: (lambda n, m=None, l=None: (hasattr(n, u'treeposition') and (n.treeposition() == i))))(node_tree_position)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return S3Token(app, conf) DCNL DCSP return auth_filter
def createBrushMask(shape, style='Round', offset=(0, 0, 0), box=None, chance=100, hollow=False): DCNL  DCSP if (box is None): DCNL DCSP  DCSP box = BoundingBox(offset, shape) DCNL DCSP if ((chance < 100) or hollow): DCNL DCSP  DCSP box = box.expand(1) DCNL DCSP outputShape = box.size DCNL DCSP outputShape = (outputShape[0], outputShape[2], outputShape[1]) DCNL DCSP shape = (shape[0], shape[2], shape[1]) DCNL DCSP offset = (numpy.array(offset) - numpy.array(box.origin)) DCNL DCSP offset = offset[[0, 2, 1]] DCNL DCSP inds = numpy.indices(outputShape, dtype=float) DCNL DCSP halfshape = numpy.array([((i >> 1) - ((((i & 1) == 0) and 0.5) or 0)) for i in shape]) DCNL DCSP blockCenters = (inds - halfshape[:, newaxis, newaxis, newaxis]) DCNL DCSP blockCenters -= offset[:, newaxis, newaxis, newaxis] DCNL DCSP shape = numpy.array(shape, dtype='float32') DCNL DCSP if (style == 'Round'): DCNL DCSP  DCSP blockCenters *= blockCenters DCNL DCSP  DCSP shape /= 2 DCNL DCSP  DCSP shape *= shape DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP distances = sum(blockCenters, 0) DCNL DCSP  DCSP mask = (distances < 1) DCNL DCSP elif (style == 'Square'): DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP distances = numpy.absolute(blockCenters).max(0) DCNL DCSP  DCSP mask = (distances < 0.5) DCNL DCSP elif (style == 'Diamond'): DCNL DCSP  DCSP blockCenters = numpy.abs(blockCenters) DCNL DCSP  DCSP shape /= 2 DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP distances = sum(blockCenters, 0) DCNL DCSP  DCSP mask = (distances < 1) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('Unknown DCSP style: DCSP ' + style) DCNL DCSP if (((chance < 100) or hollow) and (max(shape) > 1)): DCNL DCSP  DCSP threshold = (chance / 100.0) DCNL DCSP  DCSP exposedBlockMask = numpy.ones(shape=outputShape, dtype='bool') DCNL DCSP  DCSP exposedBlockMask[:] = mask DCNL DCSP  DCSP submask = mask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP  DCSP exposedBlockSubMask = exposedBlockMask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP  DCSP exposedBlockSubMask[:] = False DCNL DCSP  DCSP for dim in (0, 1, 2): DCNL DCSP  DCSP  DCSP slices = [slice(1, (-1)), slice(1, (-1)), slice(1, (-1))] DCNL DCSP  DCSP  DCSP slices[dim] = slice(None, (-2)) DCNL DCSP  DCSP  DCSP exposedBlockSubMask |= (submask & (mask[slices] != submask)) DCNL DCSP  DCSP  DCSP slices[dim] = slice(2, None) DCNL DCSP  DCSP  DCSP exposedBlockSubMask |= (submask & (mask[slices] != submask)) DCNL DCSP  DCSP if hollow: DCNL DCSP  DCSP  DCSP mask[(~ exposedBlockMask)] = False DCNL DCSP  DCSP if (chance < 100): DCNL DCSP  DCSP  DCSP rmask = (numpy.random.random(mask.shape) < threshold) DCNL DCSP  DCSP  DCSP mask[exposedBlockMask] = rmask[exposedBlockMask] DCNL DCSP if ((chance < 100) or hollow): DCNL DCSP  DCSP return mask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP else: DCNL DCSP  DCSP return mask
def get_ordered_categories(): DCNL  DCSP database_cats = get_categories() DCNL DCSP categories = [] DCNL DCSP for cat in database_cats.keys(): DCNL DCSP  DCSP if (cat != '*'): DCNL DCSP  DCSP  DCSP categories.append(database_cats[cat].get_dict()) DCNL DCSP categories.sort(key=(lambda cat: cat['order'])) DCNL DCSP categories.insert(0, database_cats['*'].get_dict()) DCNL DCSP return categories
def getCraftedTextFromText(gcodeText, towerRepository=None): DCNL  DCSP if gcodec.isProcedureDoneOrFileIsEmpty(gcodeText, 'tower'): DCNL DCSP  DCSP return gcodeText DCNL DCSP if (towerRepository == None): DCNL DCSP  DCSP towerRepository = settings.getReadRepository(TowerRepository()) DCNL DCSP if (not towerRepository.activateTower.value): DCNL DCSP  DCSP return gcodeText DCNL DCSP return TowerSkein().getCraftedGcode(gcodeText, towerRepository)
@handle_response_format DCNL @treeio_login_required DCNL def service_add(request, response_format='html'): DCNL  DCSP if (not request.user.profile.is_admin('treeio.services')): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP administrator DCSP access DCSP to DCSP the DCSP Service DCSP Support DCSP module") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP service = Service() DCNL DCSP  DCSP  DCSP form = ServiceForm(request.user.profile, request.POST, instance=service) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP service = form.save() DCNL DCSP  DCSP  DCSP  DCSP service.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('services_service_view', args=[service.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('services')) DCNL DCSP else: DCNL DCSP  DCSP form = ServiceForm(request.user.profile) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form}) DCNL DCSP return render_to_response('services/service_add', context, context_instance=RequestContext(request), response_format=response_format)
def nlargest(n, iterable, key=None): DCNL  DCSP if (n == 1): DCNL DCSP  DCSP it = iter(iterable) DCNL DCSP  DCSP head = list(islice(it, 1)) DCNL DCSP  DCSP if (not head): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP if (key is None): DCNL DCSP  DCSP  DCSP return [max(chain(head, it))] DCNL DCSP  DCSP return [max(chain(head, it), key=key)] DCNL DCSP try: DCNL DCSP  DCSP size = len(iterable) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP if (n >= size): DCNL DCSP  DCSP  DCSP return sorted(iterable, key=key, reverse=True)[:n] DCNL DCSP if (key is None): DCNL DCSP  DCSP it = izip(iterable, imap(neg, count())) DCNL DCSP  DCSP result = _nlargest(n, it) DCNL DCSP  DCSP return map(itemgetter(0), result) DCNL DCSP (in1, in2) = tee(iterable) DCNL DCSP it = izip(imap(key, in1), imap(neg, count()), in2) DCNL DCSP result = _nlargest(n, it) DCNL DCSP return map(itemgetter(2), result)
def active(display_progress=False): DCNL  DCSP ret = {} DCNL DCSP client = salt.client.get_local_client(__opts__['conf_file']) DCNL DCSP try: DCNL DCSP  DCSP active_ = client.cmd('*', 'saltutil.running', timeout=__opts__['timeout']) DCNL DCSP except SaltClientError as client_error: DCNL DCSP  DCSP print(client_error) DCNL DCSP  DCSP return ret DCNL DCSP if display_progress: DCNL DCSP  DCSP __jid_event__.fire_event({'message': 'Attempting DCSP to DCSP contact DCSP minions: DCSP {0}'.format(list(active_.keys()))}, 'progress') DCNL DCSP for (minion, data) in six.iteritems(active_): DCNL DCSP  DCSP if display_progress: DCNL DCSP  DCSP  DCSP __jid_event__.fire_event({'message': 'Received DCSP reply DCSP from DCSP minion DCSP {0}'.format(minion)}, 'progress') DCNL DCSP  DCSP if (not isinstance(data, list)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for job in data: DCNL DCSP  DCSP  DCSP if (not (job['jid'] in ret)): DCNL DCSP  DCSP  DCSP  DCSP ret[job['jid']] = _format_jid_instance(job['jid'], job) DCNL DCSP  DCSP  DCSP  DCSP ret[job['jid']].update({'Running': [{minion: job.get('pid', None)}], 'Returned': []}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret[job['jid']]['Running'].append({minion: job['pid']}) DCNL DCSP mminion = salt.minion.MasterMinion(__opts__) DCNL DCSP for jid in ret: DCNL DCSP  DCSP returner = _get_returner((__opts__['ext_job_cache'], __opts__['master_job_cache'])) DCNL DCSP  DCSP data = mminion.returners['{0}.get_jid'.format(returner)](jid) DCNL DCSP  DCSP for minion in data: DCNL DCSP  DCSP  DCSP if (minion not in ret[jid]['Returned']): DCNL DCSP  DCSP  DCSP  DCSP ret[jid]['Returned'].append(minion) DCNL DCSP return ret
def openshift_deploy_canceller(registry, xml_parent, data): DCNL  DCSP osb = XML.SubElement(xml_parent, 'com.openshift.jenkins.plugins.pipeline.OpenShiftDeployCanceller') DCNL DCSP mapping = [('api-url', 'apiURL', 'https://openshift.default.svc.cluster.local'), ('dep-cfg', 'depCfg', 'frontend'), ('namespace', 'namespace', 'test'), ('auth-token', 'authToken', ''), ('verbose', 'verbose', False)] DCNL DCSP helpers.convert_mapping_to_xml(osb, data, mapping, fail_required=True)
@with_open_mode('r') DCNL @with_sizes('medium') DCNL def seek_forward_blockwise(f): DCNL  DCSP f.seek(0, 2) DCNL DCSP size = f.tell() DCNL DCSP f.seek(0, 0) DCNL DCSP for i in xrange(0, (size - 1), 1000): DCNL DCSP  DCSP f.seek(i, 0)
@register.filter DCNL @stringfilter DCNL def cut(value, arg): DCNL  DCSP safe = isinstance(value, SafeData) DCNL DCSP value = value.replace(arg, '') DCNL DCSP if (safe and (arg != ';')): DCNL DCSP  DCSP return mark_safe(value) DCNL DCSP return value
def format_source_url(url): DCNL  DCSP if sabnzbd.HAVE_SSL: DCNL DCSP  DCSP prot = 'https' DCNL DCSP else: DCNL DCSP  DCSP prot = 'http:' DCNL DCSP return url
def string_escape(text): DCNL  DCSP replacements = (('\\', '\\\\'), ("'", "\\'"), ('"', '\\"'), ('\n', '\\n'), ('\r', '\\r'), ('\x00', '\\x00'), ('\\ufeff', '\\ufeff'), ('\\u2028', '\\u2028'), ('\\u2029', '\\u2029')) DCNL DCSP for (orig, repl) in replacements: DCNL DCSP  DCSP text = text.replace(orig, repl) DCNL DCSP return text
def _list_files(path, suffix=''): DCNL  DCSP if os.path.isdir(path): DCNL DCSP  DCSP incomplete = os.listdir(path) DCNL DCSP  DCSP complete = [os.path.join(path, entry) for entry in incomplete] DCNL DCSP  DCSP lists = [_list_files(subpath, suffix) for subpath in complete] DCNL DCSP  DCSP flattened = [] DCNL DCSP  DCSP for l in lists: DCNL DCSP  DCSP  DCSP for elem in l: DCNL DCSP  DCSP  DCSP  DCSP flattened.append(elem) DCNL DCSP  DCSP return flattened DCNL DCSP else: DCNL DCSP  DCSP assert os.path.exists(path), ("couldn't DCSP find DCSP file DCSP '%s'" % path) DCNL DCSP  DCSP if path.endswith(suffix): DCNL DCSP  DCSP  DCSP return [path] DCNL DCSP  DCSP return []
def parse(handle, **kwargs): DCNL  DCSP return Parser(handle).parse(**kwargs)
@datastore_rpc._positional(1) DCNL def inject_results(query, updated_entities=None, deleted_keys=None): DCNL  DCSP if (not isinstance(query, Query)): DCNL DCSP  DCSP raise datastore_errors.BadArgumentError(('query DCSP argument DCSP should DCSP be DCSP datastore_query.Query DCSP (%r)' % (query,))) DCNL DCSP overridden_keys = set() DCNL DCSP if (deleted_keys is not None): DCNL DCSP  DCSP if (not isinstance(deleted_keys, list)): DCNL DCSP  DCSP  DCSP raise datastore_errors.BadArgumentError(('deleted_keys DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP (%r)' % (deleted_keys,))) DCNL DCSP  DCSP deleted_keys = filter(query._key_filter, deleted_keys) DCNL DCSP  DCSP for key in deleted_keys: DCNL DCSP  DCSP  DCSP overridden_keys.add(datastore_types.ReferenceToKeyValue(key)) DCNL DCSP if (updated_entities is not None): DCNL DCSP  DCSP if (not isinstance(updated_entities, list)): DCNL DCSP  DCSP  DCSP raise datastore_errors.BadArgumentError(('updated_entities DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP (%r)' % (updated_entities,))) DCNL DCSP  DCSP updated_entities = filter(query._key_filter, updated_entities) DCNL DCSP  DCSP for entity in updated_entities: DCNL DCSP  DCSP  DCSP overridden_keys.add(datastore_types.ReferenceToKeyValue(entity.key())) DCNL DCSP  DCSP updated_entities = apply_query(query, updated_entities) DCNL DCSP else: DCNL DCSP  DCSP updated_entities = [] DCNL DCSP if (not overridden_keys): DCNL DCSP  DCSP return query DCNL DCSP return _AugmentedQuery(query, in_memory_filter=_IgnoreFilter(overridden_keys), in_memory_results=updated_entities, max_filtered_count=len(overridden_keys))
def encoded_hash(sha): DCNL  DCSP return urlsafe_b64encode(sha.digest()).decode('ascii').rstrip('=')
def cos(x): DCNL  DCSP return tf.cos(x)
def getRadiusAverage(radiusComplex): DCNL  DCSP return math.sqrt((radiusComplex.real * radiusComplex.imag))
def test_lambda(n): DCNL  DCSP return [(lambda v=i: v) for i in range(n)]
def simplefilter(f): DCNL  DCSP return type(f.__name__, (FunctionFilter,), {'function': f, '__module__': getattr(f, '__module__'), '__doc__': f.__doc__})
def returner(ret): DCNL  DCSP opts = _get_options(ret) DCNL DCSP metric_base = ret['fun'] DCNL DCSP if (not metric_base.startswith('virt.')): DCNL DCSP  DCSP metric_base += ('.' + ret['id'].replace('.', '_')) DCNL DCSP saltdata = ret['return'] DCNL DCSP _send(saltdata, metric_base, opts)
def decode_byte_list(byte_list): DCNL  DCSP decoded_items = [] DCNL DCSP for item in byte_list: DCNL DCSP  DCSP decoded_items.append(item.decode(__salt_system_encoding__)) DCNL DCSP return decoded_items
def organization_purge(context, data_dict): DCNL  DCSP return _group_or_org_purge(context, data_dict, is_org=True)
def tests_get_by_job_idx(job_idx): DCNL  DCSP return Test.objects.filter(job=job_idx)
def mod_aggregate(low, chunks, running): DCNL  DCSP rules = [] DCNL DCSP agg_enabled = ['append', 'insert'] DCNL DCSP if (low.get('fun') not in agg_enabled): DCNL DCSP  DCSP return low DCNL DCSP for chunk in chunks: DCNL DCSP  DCSP tag = salt.utils.gen_state_tag(chunk) DCNL DCSP  DCSP if (tag in running): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (chunk.get('state') == 'iptables'): DCNL DCSP  DCSP  DCSP if ('__agg__' in chunk): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk.get('fun') != low.get('fun')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk not in rules): DCNL DCSP  DCSP  DCSP  DCSP rules.append(chunk) DCNL DCSP  DCSP  DCSP  DCSP chunk['__agg__'] = True DCNL DCSP if rules: DCNL DCSP  DCSP if ('rules' in low): DCNL DCSP  DCSP  DCSP low['rules'].extend(rules) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP low['rules'] = rules DCNL DCSP return low
def xsym(sym): DCNL  DCSP op = _xsym[sym] DCNL DCSP if _use_unicode: DCNL DCSP  DCSP return op[1] DCNL DCSP else: DCNL DCSP  DCSP return op[0]
def require(divisions, parts, required=None): DCNL  DCSP if (not required): DCNL DCSP  DCSP return (divisions, parts) DCNL DCSP for i in required: DCNL DCSP  DCSP present = [j for (j, p) in enumerate(parts) if (p[i] is not None)] DCNL DCSP  DCSP divisions = tuple(divisions[min(present):(max(present) + 2)]) DCNL DCSP  DCSP parts = tuple(parts[min(present):(max(present) + 1)]) DCNL DCSP return (divisions, parts)
def separate_users(node, user_ids): DCNL  DCSP OSFUser = apps.get_model('osf.OSFUser') DCNL DCSP removed = [] DCNL DCSP subbed = [] DCNL DCSP for user_id in user_ids: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = OSFUser.load(user_id) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP user = user_id DCNL DCSP  DCSP if node.has_permission(user, 'read'): DCNL DCSP  DCSP  DCSP subbed.append(user_id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP removed.append(user_id) DCNL DCSP return (subbed, removed)
def hash_of_file(path): DCNL  DCSP with open(path, 'rb') as archive: DCNL DCSP  DCSP sha = sha256() DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP data = archive.read((2 ** 20)) DCNL DCSP  DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP sha.update(data) DCNL DCSP return encoded_hash(sha)
@protocol.commands.add(u'rescan') DCNL def rescan(context, uri=None): DCNL  DCSP return {u'updating_db': 0}
def test_record_good(): DCNL  DCSP output = StringIO() DCNL DCSP recorder = Record(file_object=output, replay=False) DCNL DCSP num_lines = 10 DCNL DCSP for i in xrange(num_lines): DCNL DCSP  DCSP recorder.handle_line((str(i) + '\n')) DCNL DCSP output_value = output.getvalue() DCNL DCSP assert (output_value == ''.join(((str(i) + '\n') for i in xrange(num_lines)))) DCNL DCSP output = StringIO(output_value) DCNL DCSP playback_checker = Record(file_object=output, replay=True) DCNL DCSP for i in xrange(num_lines): DCNL DCSP  DCSP playback_checker.handle_line((str(i) + '\n'))
def docker_custom_build_env(registry, xml_parent, data): DCNL  DCSP core_prefix = 'com.cloudbees.jenkins.plugins.okidocki.' DCNL DCSP entry_xml = XML.SubElement(xml_parent, (core_prefix + 'DockerBuildWrapper')) DCNL DCSP entry_xml.set('plugin', 'docker-custom-build-environment') DCNL DCSP selectorobj = XML.SubElement(entry_xml, 'selector') DCNL DCSP image_type = data['image-type'] DCNL DCSP if (image_type == 'dockerfile'): DCNL DCSP  DCSP selectorobj.set('class', (core_prefix + 'DockerfileImageSelector')) DCNL DCSP  DCSP XML.SubElement(selectorobj, 'contextPath').text = data.get('context-path', '.') DCNL DCSP  DCSP XML.SubElement(selectorobj, 'dockerfile').text = data.get('dockerfile', 'Dockerfile') DCNL DCSP elif (image_type == 'pull'): DCNL DCSP  DCSP selectorobj.set('class', (core_prefix + 'PullDockerImageSelector')) DCNL DCSP  DCSP XML.SubElement(selectorobj, 'image').text = data.get('image', '') DCNL DCSP XML.SubElement(entry_xml, 'dockerInstallation').text = data.get('docker-tool', 'Default') DCNL DCSP host = XML.SubElement(entry_xml, 'dockerHost') DCNL DCSP host.set('plugin', 'docker-commons') DCNL DCSP if data.get('host'): DCNL DCSP  DCSP XML.SubElement(host, 'uri').text = data['host'] DCNL DCSP if data.get('credentials-id'): DCNL DCSP  DCSP XML.SubElement(host, 'credentialsId').text = data['credentials-id'] DCNL DCSP XML.SubElement(entry_xml, 'dockerRegistryCredentials').text = data.get('registry-credentials-id', '') DCNL DCSP volumesobj = XML.SubElement(entry_xml, 'volumes') DCNL DCSP volumes = data.get('volumes', []) DCNL DCSP if (not volumes): DCNL DCSP  DCSP volumesobj.set('class', 'empty-list') DCNL DCSP else: DCNL DCSP  DCSP for volume in volumes: DCNL DCSP  DCSP  DCSP volumeobj = XML.SubElement(volumesobj, 'com.cloudbees.jenkins.plugins.okidocki.Volume') DCNL DCSP  DCSP  DCSP XML.SubElement(volumeobj, 'hostPath').text = volume['volume'].get('host-path', '') DCNL DCSP  DCSP  DCSP XML.SubElement(volumeobj, 'path').text = volume['volume'].get('path', '') DCNL DCSP XML.SubElement(entry_xml, 'forcePull').text = str(data.get('force-pull', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'privileged').text = str(data.get('privileged', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'verbose').text = str(data.get('verbose', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'group').text = data.get('group', '') DCNL DCSP XML.SubElement(entry_xml, 'command').text = data.get('command', '/bin/cat') DCNL DCSP XML.SubElement(entry_xml, 'net').text = data.get('net', 'bridge')
def _SecToUsec(t): DCNL  DCSP return int((t * 1000000.0))
def auth(username, password, **kwargs): DCNL  DCSP c = OpenSSL.crypto DCNL DCSP pem = password DCNL DCSP cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, pem) DCNL DCSP cacert_file = __salt__['config.get']('external_auth:pki:ca_file') DCNL DCSP with salt.utils.fopen(cacert_file) as f: DCNL DCSP  DCSP cacert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, f.read()) DCNL DCSP log.debug('Attempting DCSP to DCSP authenticate DCSP via DCSP pki.') DCNL DCSP log.debug('Using DCSP CA DCSP file: DCSP {0}'.format(cacert_file)) DCNL DCSP log.debug('Certificate DCSP contents: DCSP {0}'.format(pem)) DCNL DCSP algo = cert.get_signature_algorithm() DCNL DCSP cert_asn1 = c.dump_certificate(c.FILETYPE_ASN1, cert) DCNL DCSP der = asn1.DerSequence() DCNL DCSP der.decode(cert_asn1) DCNL DCSP der_cert = der[0] DCNL DCSP der_sig = der[2] DCNL DCSP der_sig_in = asn1.DerObject() DCNL DCSP der_sig_in.decode(der_sig) DCNL DCSP sig0 = der_sig_in.payload DCNL DCSP if (sig0[0] != '\x00'): DCNL DCSP  DCSP raise Exception('Number DCSP of DCSP unused DCSP bits DCSP is DCSP strange') DCNL DCSP sig = sig0[1:] DCNL DCSP try: DCNL DCSP  DCSP c.verify(cacert, sig, der_cert, algo) DCNL DCSP  DCSP assert (dict(cert.get_subject().get_components())['CN'] == username), "Certificate's DCSP CN DCSP should DCSP match DCSP the DCSP username" DCNL DCSP  DCSP log.info('Successfully DCSP authenticated DCSP certificate: DCSP {0}'.format(pem)) DCNL DCSP  DCSP return True DCNL DCSP except (OpenSSL.crypto.Error, AssertionError): DCNL DCSP  DCSP log.info('Failed DCSP to DCSP authenticate DCSP certificate: DCSP {0}'.format(pem)) DCNL DCSP return False
def MapItemsIterator(function, items): DCNL  DCSP return ItemsIterator(items=itertools.imap(function, items), total_count=items.total_count)
def _revs_equal(rev1, rev2, rev_type): DCNL  DCSP if (((rev1 is None) and (rev2 is not None)) or ((rev2 is None) and (rev1 is not None))): DCNL DCSP  DCSP return False DCNL DCSP elif (rev1 is rev2 is None): DCNL DCSP  DCSP return True DCNL DCSP elif (rev_type == 'sha1'): DCNL DCSP  DCSP return rev1.startswith(rev2) DCNL DCSP else: DCNL DCSP  DCSP return (rev1 == rev2)
def check_virtualserver(lb, name): DCNL  DCSP if __opts__['load_balancers'].get(lb, None): DCNL DCSP  DCSP (username, password) = list(__opts__['load_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP find DCSP `{0}` DCSP load DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, password) DCNL DCSP return F5.check_virtualserver(name)
def cpu_freq(): DCNL  DCSP (curr, max_) = cext.cpu_freq() DCNL DCSP min_ = 0.0 DCNL DCSP return [_common.scpufreq(float(curr), min_, float(max_))]
def add_permission(user, model, permission_codename): DCNL  DCSP content_type = ContentType.objects.get_for_model(model) DCNL DCSP (permission, created) = Permission.objects.get_or_create(codename=permission_codename, content_type=content_type, defaults={'name': permission_codename}) DCNL DCSP user.user_permissions.add(permission)
def git(registry, xml_parent, data): DCNL  DCSP mappings = [('push-merge', 'pushMerge', False), ('push-only-if-success', 'pushOnlyIfSuccess', True), ('force-push', 'forcePush', False)] DCNL DCSP tag_mappings = [('remote', 'targetRepoName', 'origin'), ('name', 'tagName', None), ('message', 'tagMessage', ''), ('create-tag', 'createTag', False), ('update-tag', 'updateTag', False)] DCNL DCSP branch_mappings = [('remote', 'targetRepoName', 'origin'), ('name', 'branchName', None)] DCNL DCSP note_mappings = [('remote', 'targetRepoName', 'origin'), ('message', 'noteMsg', None), ('namespace', 'noteNamespace', 'master'), ('replace-note', 'noteReplace', False)] DCNL DCSP top = XML.SubElement(xml_parent, 'hudson.plugins.git.GitPublisher') DCNL DCSP XML.SubElement(top, 'configVersion').text = '2' DCNL DCSP helpers.convert_mapping_to_xml(top, data, mappings, fail_required=True) DCNL DCSP tags = data.get('tags', []) DCNL DCSP if tags: DCNL DCSP  DCSP xml_tags = XML.SubElement(top, 'tagsToPush') DCNL DCSP  DCSP for tag in tags: DCNL DCSP  DCSP  DCSP xml_tag = XML.SubElement(xml_tags, 'hudson.plugins.git.GitPublisher_-TagToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_tag, tag['tag'], tag_mappings, fail_required=True) DCNL DCSP branches = data.get('branches', []) DCNL DCSP if branches: DCNL DCSP  DCSP xml_branches = XML.SubElement(top, 'branchesToPush') DCNL DCSP  DCSP for branch in branches: DCNL DCSP  DCSP  DCSP xml_branch = XML.SubElement(xml_branches, 'hudson.plugins.git.GitPublisher_-BranchToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_branch, branch['branch'], branch_mappings, fail_required=True) DCNL DCSP notes = data.get('notes', []) DCNL DCSP if notes: DCNL DCSP  DCSP xml_notes = XML.SubElement(top, 'notesToPush') DCNL DCSP  DCSP for note in notes: DCNL DCSP  DCSP  DCSP xml_note = XML.SubElement(xml_notes, 'hudson.plugins.git.GitPublisher_-NoteToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_note, note['note'], note_mappings, fail_required=True)
def preserve_value(namespace, name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP def resetter_attr(saved_value_internal): DCNL DCSP  DCSP  DCSP return setattr(namespace, name, saved_value_internal) DCNL DCSP  DCSP def resetter_no_attr(saved_value_internal): DCNL DCSP  DCSP  DCSP del saved_value_internal DCNL DCSP  DCSP  DCSP return delattr(namespace, name) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP saved_value = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP saved_value = getattr(namespace, name) DCNL DCSP  DCSP  DCSP  DCSP resetter = resetter_attr DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP resetter = resetter_no_attr DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP resetter(saved_value) DCNL DCSP  DCSP wrapper.__name__ = func.__name__ DCNL DCSP  DCSP wrapper.__doc__ = func.__doc__ DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def to_marshallable_type(obj): DCNL  DCSP if (obj is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(obj, '__marshallable__'): DCNL DCSP  DCSP return obj.__marshallable__() DCNL DCSP if hasattr(obj, '__getitem__'): DCNL DCSP  DCSP return obj DCNL DCSP return dict(obj.__dict__)
def random_shift(x, wrg, hrg, row_axis=1, col_axis=2, channel_axis=0, fill_mode='nearest', cval=0.0): DCNL  DCSP (h, w) = (x.shape[row_axis], x.shape[col_axis]) DCNL DCSP tx = (np.random.uniform((- hrg), hrg) * h) DCNL DCSP ty = (np.random.uniform((- wrg), wrg) * w) DCNL DCSP translation_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]]) DCNL DCSP transform_matrix = translation_matrix DCNL DCSP x = apply_transform(x, transform_matrix, channel_axis, fill_mode, cval) DCNL DCSP return x
def build_repository_type_select_field(trans, repository=None, name='repository_type'): DCNL  DCSP if repository: DCNL DCSP  DCSP selected_type = str(repository.type) DCNL DCSP else: DCNL DCSP  DCSP selected_type = None DCNL DCSP repository_type_select_field = SelectField(name=name) DCNL DCSP for (type_label, type_class) in trans.app.repository_types_registry.repository_types_by_label.items(): DCNL DCSP  DCSP option_label = str(type_class.label) DCNL DCSP  DCSP option_value = str(type_class.type) DCNL DCSP  DCSP if (selected_type and (selected_type == option_value)): DCNL DCSP  DCSP  DCSP selected = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selected = False DCNL DCSP  DCSP if repository: DCNL DCSP  DCSP  DCSP if (repository.type == option_value): DCNL DCSP  DCSP  DCSP  DCSP repository_type_select_field.add_option(option_label, option_value, selected=selected) DCNL DCSP  DCSP  DCSP elif type_class.is_valid_for_type(trans.app, repository): DCNL DCSP  DCSP  DCSP  DCSP repository_type_select_field.add_option(option_label, option_value, selected=selected) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP repository_type_select_field.add_option(option_label, option_value, selected=selected) DCNL DCSP return repository_type_select_field
def dict_factory(cursor, row): DCNL  DCSP d = {} DCNL DCSP for (idx, col) in enumerate(cursor.description): DCNL DCSP  DCSP d[col[0]] = row[idx] DCNL DCSP return d
@cinder_utils.trace_method DCNL @cinder_utils.synchronized('map_es_volume') DCNL def map_volume_to_single_host(client, volume, eseries_vol, host, vol_map, multiattach_enabled): DCNL  DCSP LOG.debug('Attempting DCSP to DCSP map DCSP volume DCSP %s DCSP to DCSP single DCSP host.', volume['id']) DCNL DCSP if (not vol_map): DCNL DCSP  DCSP mappings = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP  DCSP lun = _get_free_lun(client, host, multiattach_enabled, mappings) DCNL DCSP  DCSP return client.create_volume_mapping(eseries_vol['volumeRef'], host['hostRef'], lun) DCNL DCSP if (vol_map.get('mapRef') == host['hostRef']): DCNL DCSP  DCSP return vol_map DCNL DCSP multiattach_cluster_ref = None DCNL DCSP try: DCNL DCSP  DCSP host_group = client.get_host_group_by_name(utils.MULTI_ATTACH_HOST_GROUP_NAME) DCNL DCSP  DCSP multiattach_cluster_ref = host_group['clusterRef'] DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP pass DCNL DCSP if (vol_map.get('mapRef') == multiattach_cluster_ref): DCNL DCSP  DCSP LOG.debug('Volume DCSP %s DCSP is DCSP mapped DCSP to DCSP multiattach DCSP host DCSP group.', volume['id']) DCNL DCSP  DCSP if (not (volume['attach_status'] == fields.VolumeAttachStatus.ATTACHED)): DCNL DCSP  DCSP  DCSP LOG.debug('Volume DCSP %(vol)s DCSP is DCSP not DCSP currently DCSP attached, DCSP moving DCSP existing DCSP mapping DCSP to DCSP host DCSP %(host)s.', {'vol': volume['id'], 'host': host['label']}) DCNL DCSP  DCSP  DCSP mappings = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP  DCSP  DCSP lun = _get_free_lun(client, host, multiattach_enabled, mappings) DCNL DCSP  DCSP  DCSP return client.move_volume_mapping_via_symbol(vol_map.get('mapRef'), host['hostRef'], lun) DCNL DCSP msg = _("Cannot DCSP attach DCSP already DCSP attached DCSP volume DCSP %s; DCSP multiattach DCSP is DCSP disabled DCSP via DCSP the DCSP 'netapp_enable_multiattach' DCSP configuration DCSP option.") DCNL DCSP raise exception.NetAppDriverException((msg % volume['id']))
def get_dependencies(): DCNL  DCSP deps = {'netaddr': HAS_NETADDR, 'python-novaclient': nova.check_nova()} DCNL DCSP return config.check_driver_dependencies(__virtualname__, deps)
def save_sent_email(crispin_client, account_id, message_id): DCNL  DCSP remote_save_sent(crispin_client, account_id, message_id)
def polygamma(n, x): DCNL  DCSP (n, x) = (asarray(n), asarray(x)) DCNL DCSP fac2 = ((((-1.0) ** (n + 1)) * gamma((n + 1.0))) * zeta((n + 1), x)) DCNL DCSP return where((n == 0), psi(x), fac2)
def safe_minidom_parse_string(xml_string): DCNL  DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
def add_indep(x, varnames, dtype=None): DCNL  DCSP if (isinstance(x, np.ndarray) and (x.ndim == 2)): DCNL DCSP  DCSP x = x.T DCNL DCSP nvars_orig = len(x) DCNL DCSP nobs = len(x[0]) DCNL DCSP if (not dtype): DCNL DCSP  DCSP dtype = np.asarray(x[0]).dtype DCNL DCSP xout = np.zeros((nobs, nvars_orig), dtype=dtype) DCNL DCSP count = 0 DCNL DCSP rank_old = 0 DCNL DCSP varnames_new = [] DCNL DCSP varnames_dropped = [] DCNL DCSP keepindx = [] DCNL DCSP for (xi, ni) in zip(x, varnames): DCNL DCSP  DCSP xout[:, count] = xi DCNL DCSP  DCSP rank_new = np_matrix_rank(xout) DCNL DCSP  DCSP if (rank_new > rank_old): DCNL DCSP  DCSP  DCSP varnames_new.append(ni) DCNL DCSP  DCSP  DCSP rank_old = rank_new DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP varnames_dropped.append(ni) DCNL DCSP return (xout[:, :count], varnames_new)
def prompt_n(msg, inputs): DCNL  DCSP dialog = QtWidgets.QDialog(active_window()) DCNL DCSP dialog.setWindowModality(Qt.WindowModal) DCNL DCSP dialog.setWindowTitle(msg) DCNL DCSP long_value = msg DCNL DCSP for (k, v) in inputs: DCNL DCSP  DCSP if (len((k + v)) > len(long_value)): DCNL DCSP  DCSP  DCSP long_value = (k + v) DCNL DCSP metrics = QtGui.QFontMetrics(dialog.font()) DCNL DCSP min_width = (metrics.width(long_value) + 100) DCNL DCSP if (min_width > 720): DCNL DCSP  DCSP min_width = 720 DCNL DCSP dialog.setMinimumWidth(min_width) DCNL DCSP ok_b = ok_button(msg, enabled=False) DCNL DCSP close_b = close_button() DCNL DCSP form_widgets = [] DCNL DCSP def get_values(): DCNL DCSP  DCSP return [pair[1].text().strip() for pair in form_widgets] DCNL DCSP for (name, value) in inputs: DCNL DCSP  DCSP lineedit = QtWidgets.QLineEdit() DCNL DCSP  DCSP lineedit.textChanged.connect((lambda x: ok_b.setEnabled(all(get_values())))) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP lineedit.setText(value) DCNL DCSP  DCSP form_widgets.append((name, lineedit)) DCNL DCSP form_layout = form(defs.no_margin, defs.button_spacing, *form_widgets) DCNL DCSP button_layout = hbox(defs.no_margin, defs.button_spacing, STRETCH, close_b, ok_b) DCNL DCSP main_layout = vbox(defs.margin, defs.button_spacing, form_layout, button_layout) DCNL DCSP dialog.setLayout(main_layout) DCNL DCSP connect_button(ok_b, dialog.accept) DCNL DCSP connect_button(close_b, dialog.reject) DCNL DCSP accepted = (dialog.exec_() == QtWidgets.QDialog.Accepted) DCNL DCSP text = get_values() DCNL DCSP ok = (accepted and all(text)) DCNL DCSP return (ok, text)
def run(app=None, server='wsgiref', host='127.0.0.1', port=8080, interval=1, reloader=False, quiet=False, plugins=None, debug=None, config=None, **kargs): DCNL  DCSP if NORUN: DCNL DCSP  DCSP return DCNL DCSP if (reloader and (not os.environ.get('BOTTLE_CHILD'))): DCNL DCSP  DCSP import subprocess DCNL DCSP  DCSP lockfile = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (fd, lockfile) = tempfile.mkstemp(prefix='bottle.', suffix='.lock') DCNL DCSP  DCSP  DCSP os.close(fd) DCNL DCSP  DCSP  DCSP while os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP args = ([sys.executable] + sys.argv) DCNL DCSP  DCSP  DCSP  DCSP environ = os.environ.copy() DCNL DCSP  DCSP  DCSP  DCSP environ['BOTTLE_CHILD'] = 'true' DCNL DCSP  DCSP  DCSP  DCSP environ['BOTTLE_LOCKFILE'] = lockfile DCNL DCSP  DCSP  DCSP  DCSP p = subprocess.Popen(args, env=environ) DCNL DCSP  DCSP  DCSP  DCSP while (p.poll() is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.utime(lockfile, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP  DCSP  DCSP if (p.poll() != 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(lockfile) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(p.poll()) DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(lockfile) DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP if (debug is not None): DCNL DCSP  DCSP  DCSP _debug(debug) DCNL DCSP  DCSP app = (app or default_app()) DCNL DCSP  DCSP if isinstance(app, basestring): DCNL DCSP  DCSP  DCSP app = load_app(app) DCNL DCSP  DCSP if (not callable(app)): DCNL DCSP  DCSP  DCSP raise ValueError(('Application DCSP is DCSP not DCSP callable: DCSP %r' % app)) DCNL DCSP  DCSP for plugin in (plugins or []): DCNL DCSP  DCSP  DCSP if isinstance(plugin, basestring): DCNL DCSP  DCSP  DCSP  DCSP plugin = load(plugin) DCNL DCSP  DCSP  DCSP app.install(plugin) DCNL DCSP  DCSP if config: DCNL DCSP  DCSP  DCSP app.config.update(config) DCNL DCSP  DCSP if (server in server_names): DCNL DCSP  DCSP  DCSP server = server_names.get(server) DCNL DCSP  DCSP if isinstance(server, basestring): DCNL DCSP  DCSP  DCSP server = load(server) DCNL DCSP  DCSP if isinstance(server, type): DCNL DCSP  DCSP  DCSP server = server(host=host, port=port, **kargs) DCNL DCSP  DCSP if (not isinstance(server, ServerAdapter)): DCNL DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP or DCSP unsupported DCSP server: DCSP %r' % server)) DCNL DCSP  DCSP server.quiet = (server.quiet or quiet) DCNL DCSP  DCSP if (not server.quiet): DCNL DCSP  DCSP  DCSP _stderr(('Bottle DCSP v%s DCSP server DCSP starting DCSP up DCSP (using DCSP %s)...\n' % (__version__, repr(server)))) DCNL DCSP  DCSP  DCSP _stderr(('Listening DCSP on DCSP http://%s:%d/\n' % (server.host, server.port))) DCNL DCSP  DCSP  DCSP _stderr('Hit DCSP Ctrl-C DCSP to DCSP quit.\n\n') DCNL DCSP  DCSP if reloader: DCNL DCSP  DCSP  DCSP lockfile = os.environ.get('BOTTLE_LOCKFILE') DCNL DCSP  DCSP  DCSP bgcheck = FileCheckerThread(lockfile, interval) DCNL DCSP  DCSP  DCSP with bgcheck: DCNL DCSP  DCSP  DCSP  DCSP server.run(app) DCNL DCSP  DCSP  DCSP if (bgcheck.status == 'reload'): DCNL DCSP  DCSP  DCSP  DCSP sys.exit(3) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP server.run(app) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass DCNL DCSP except (SystemExit, MemoryError): DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP if (not reloader): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (not getattr(server, 'quiet', quiet)): DCNL DCSP  DCSP  DCSP print_exc() DCNL DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP sys.exit(3)
def _check_for_exception_catch(evaluator, jedi_obj, exception, payload=None): DCNL  DCSP def check_match(cls, exception): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (isinstance(cls, CompiledObject) and issubclass(exception, cls.obj)) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP def check_try_for_except(obj, exception): DCNL DCSP  DCSP iterator = iter(obj.children) DCNL DCSP  DCSP for branch_type in iterator: DCNL DCSP  DCSP  DCSP colon = next(iterator) DCNL DCSP  DCSP  DCSP suite = next(iterator) DCNL DCSP  DCSP  DCSP if ((branch_type == 'try') and (not (branch_type.start_pos < jedi_obj.start_pos <= suite.end_pos))): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for node in obj.except_clauses(): DCNL DCSP  DCSP  DCSP if (node is None): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP except_classes = evaluator.eval_element(node) DCNL DCSP  DCSP  DCSP  DCSP for cls in except_classes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from jedi.evaluate import iterable DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (isinstance(cls, iterable.Array) and (cls.type == 'tuple')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for typ in unite(cls.py__iter__()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if check_match(typ, exception): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif check_match(cls, exception): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP def check_hasattr(node, suite): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (suite.start_pos <= jedi_obj.start_pos < suite.end_pos) DCNL DCSP  DCSP  DCSP assert (node.type in ('power', 'atom_expr')) DCNL DCSP  DCSP  DCSP base = node.children[0] DCNL DCSP  DCSP  DCSP assert ((base.type == 'name') and (base.value == 'hasattr')) DCNL DCSP  DCSP  DCSP trailer = node.children[1] DCNL DCSP  DCSP  DCSP assert (trailer.type == 'trailer') DCNL DCSP  DCSP  DCSP arglist = trailer.children[1] DCNL DCSP  DCSP  DCSP assert (arglist.type == 'arglist') DCNL DCSP  DCSP  DCSP from jedi.evaluate.param import Arguments DCNL DCSP  DCSP  DCSP args = list(Arguments(evaluator, arglist).unpack()) DCNL DCSP  DCSP  DCSP assert (len(args) == 2) DCNL DCSP  DCSP  DCSP (key, values) = args[1] DCNL DCSP  DCSP  DCSP assert (len(values) == 1) DCNL DCSP  DCSP  DCSP names = list(evaluator.eval_element(values[0])) DCNL DCSP  DCSP  DCSP assert ((len(names) == 1) and isinstance(names[0], CompiledObject)) DCNL DCSP  DCSP  DCSP assert (names[0].obj == str(payload[1])) DCNL DCSP  DCSP  DCSP (key, values) = args[0] DCNL DCSP  DCSP  DCSP assert (len(values) == 1) DCNL DCSP  DCSP  DCSP objects = evaluator.eval_element(values[0]) DCNL DCSP  DCSP  DCSP return (payload[0] in objects) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP obj = jedi_obj DCNL DCSP while ((obj is not None) and (not obj.isinstance(tree.Function, tree.Class))): DCNL DCSP  DCSP if obj.isinstance(tree.Flow): DCNL DCSP  DCSP  DCSP if (obj.isinstance(tree.TryStmt) and check_try_for_except(obj, exception)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((exception == AttributeError) and obj.isinstance(tree.IfStmt, tree.WhileStmt)): DCNL DCSP  DCSP  DCSP  DCSP if check_hasattr(obj.children[1], obj.children[3]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP obj = obj.parent DCNL DCSP return False
def dent(individual, lambda_=0.85): DCNL  DCSP d = (lambda_ * exp((- ((individual[0] - individual[1]) ** 2)))) DCNL DCSP f1 = ((0.5 * (((sqrt((1 + ((individual[0] + individual[1]) ** 2))) + sqrt((1 + ((individual[0] - individual[1]) ** 2)))) + individual[0]) - individual[1])) + d) DCNL DCSP f2 = ((0.5 * (((sqrt((1 + ((individual[0] + individual[1]) ** 2))) + sqrt((1 + ((individual[0] - individual[1]) ** 2)))) - individual[0]) + individual[1])) + d) DCNL DCSP return (f1, f2)
def hours(h): DCNL  DCSP return (h / 24.0)
def test_retry_on_normal_error(collect): DCNL  DCSP key_name = 'test-key-name' DCNL DCSP b = B(name=key_name) DCNL DCSP collect.inject(Exception('Normal DCSP error')) DCNL DCSP d = wabs_deleter.Deleter(BlobService('test', 'ing'), 'test-container') DCNL DCSP d.delete(b) DCNL DCSP while (len(collect.aborted_keys) < 2): DCNL DCSP  DCSP gevent.sleep(0.1) DCNL DCSP assert (not collect.deleted_keys) DCNL DCSP collect.inject(None) DCNL DCSP d.close() DCNL DCSP assert (collect.deleted_keys == [key_name])
def createFactoryCopy(state): DCNL  DCSP stateId = state.get('id', None) DCNL DCSP if (stateId is None): DCNL DCSP  DCSP raise RuntimeError(("factory DCSP copy DCSP state DCSP has DCSP no DCSP 'id' DCSP member DCSP %s" % (repr(state),))) DCNL DCSP if (not (stateId in SimpleFactoryCopy.allIDs)): DCNL DCSP  DCSP raise RuntimeError(('factory DCSP class DCSP has DCSP no DCSP ID: DCSP %s' % (SimpleFactoryCopy.allIDs,))) DCNL DCSP inst = SimpleFactoryCopy.allIDs[stateId] DCNL DCSP if (not inst): DCNL DCSP  DCSP raise RuntimeError('factory DCSP method DCSP found DCSP no DCSP object DCSP with DCSP id') DCNL DCSP return inst
def clone(git_path, module, repo, dest, remote, depth, version, bare, reference, refspec, verify_commit): DCNL  DCSP dest_dirname = os.path.dirname(dest) DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(dest_dirname) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP cmd = [git_path, 'clone'] DCNL DCSP if bare: DCNL DCSP  DCSP cmd.append('--bare') DCNL DCSP else: DCNL DCSP  DCSP cmd.extend(['--origin', remote]) DCNL DCSP if depth: DCNL DCSP  DCSP if ((version == 'HEAD') or refspec or is_remote_branch(git_path, module, dest, repo, version) or is_remote_tag(git_path, module, dest, repo, version)): DCNL DCSP  DCSP  DCSP cmd.extend(['--depth', str(depth)]) DCNL DCSP if reference: DCNL DCSP  DCSP cmd.extend(['--reference', str(reference)]) DCNL DCSP cmd.extend([repo, dest]) DCNL DCSP module.run_command(cmd, check_rc=True, cwd=dest_dirname) DCNL DCSP if bare: DCNL DCSP  DCSP if (remote != 'origin'): DCNL DCSP  DCSP  DCSP module.run_command([git_path, 'remote', 'add', remote, repo], check_rc=True, cwd=dest) DCNL DCSP if refspec: DCNL DCSP  DCSP cmd = [git_path, 'fetch'] DCNL DCSP  DCSP if depth: DCNL DCSP  DCSP  DCSP cmd.extend(['--depth', str(depth)]) DCNL DCSP  DCSP cmd.extend([remote, refspec]) DCNL DCSP  DCSP module.run_command(cmd, check_rc=True, cwd=dest) DCNL DCSP if verify_commit: DCNL DCSP  DCSP verify_commit_sign(git_path, module, dest, version)
def send_email(subject=None, recipients=[], html=''): DCNL  DCSP plain_txt_email = 'Please DCSP view DCSP in DCSP a DCSP mail DCSP client DCSP that DCSP supports DCSP HTML.' DCNL DCSP if app.config.get('EMAILS_USE_SMTP'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with app.app_context(): DCNL DCSP  DCSP  DCSP  DCSP msg = Message(subject, recipients=recipients) DCNL DCSP  DCSP  DCSP  DCSP msg.body = plain_txt_email DCNL DCSP  DCSP  DCSP  DCSP msg.html = html DCNL DCSP  DCSP  DCSP  DCSP mail.send(msg) DCNL DCSP  DCSP  DCSP app.logger.debug('Emailed DCSP {} DCSP - DCSP {} DCSP '.format(recipients, subject)) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP m = 'Failed DCSP to DCSP send DCSP failure DCSP message DCSP with DCSP subject: DCSP {}\n{} DCSP {}'.format(subject, Exception, e) DCNL DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc()) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ses_region = app.config.get('SES_REGION', 'us-east-1') DCNL DCSP  DCSP  DCSP ses = boto.ses.connect_to_region(ses_region) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP m = 'Failed DCSP to DCSP connect DCSP to DCSP ses DCSP using DCSP boto. DCSP Check DCSP your DCSP boto DCSP credentials. DCSP {} DCSP {}'.format(Exception, e) DCNL DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc()) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for email in recipients: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ses.send_email(app.config.get('MAIL_DEFAULT_SENDER'), subject, html, email, format='html') DCNL DCSP  DCSP  DCSP  DCSP app.logger.debug('Emailed DCSP {} DCSP - DCSP {} DCSP '.format(email, subject)) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP m = 'Failed DCSP to DCSP send DCSP failure DCSP message DCSP with DCSP subject: DCSP {}\n{} DCSP {}'.format(subject, Exception, e) DCNL DCSP  DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc())
def load_pandas(): DCNL  DCSP data = _get_data() DCNL DCSP return du.process_recarray_pandas(data, endog_idx=3, dtype=float)
def schedule_delayed_delete_from_backend(context, image_id, location): DCNL  DCSP db_queue = scrubber.get_scrub_queue() DCNL DCSP if (not CONF.use_user_token): DCNL DCSP  DCSP context = None DCNL DCSP ret = db_queue.add_location(image_id, location) DCNL DCSP if ret: DCNL DCSP  DCSP location['status'] = 'pending_delete' DCNL DCSP  DCSP if ('id' in location): DCNL DCSP  DCSP  DCSP db_api.get_api().image_location_delete(context, image_id, location['id'], 'pending_delete') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP db_api.get_api().image_location_add(context, image_id, location) DCNL DCSP return ret
def cache_page(*args, **kwargs): DCNL  DCSP cache_alias = kwargs.pop('cache', None) DCNL DCSP key_prefix = kwargs.pop('key_prefix', None) DCNL DCSP assert (not kwargs), 'The DCSP only DCSP keyword DCSP arguments DCSP are DCSP cache DCSP and DCSP key_prefix' DCNL DCSP def warn(): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('The DCSP cache_page DCSP decorator DCSP must DCSP be DCSP called DCSP like: DCSP cache_page(timeout, DCSP [cache=cache DCSP name], DCSP [key_prefix=key DCSP prefix]). DCSP All DCSP other DCSP ways DCSP are DCSP deprecated.', PendingDeprecationWarning, stacklevel=3) DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP assert (len(args) == 2), 'cache_page DCSP accepts DCSP at DCSP most DCSP 2 DCSP arguments' DCNL DCSP  DCSP warn() DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[1], cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP elif callable(args[1]): DCNL DCSP  DCSP  DCSP return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix)(args[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert False, 'cache_page DCSP must DCSP be DCSP passed DCSP a DCSP view DCSP function DCSP if DCSP called DCSP with DCSP two DCSP arguments' DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP warn() DCNL DCSP  DCSP  DCSP return decorator_from_middleware_with_args(CacheMiddleware)(cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix) DCNL DCSP else: DCNL DCSP  DCSP warn() DCNL DCSP  DCSP return decorator_from_middleware_with_args(CacheMiddleware)(cache_alias=cache_alias, key_prefix=key_prefix)
def _warn_node(self, msg, node, *args, **kwargs): DCNL  DCSP if (not msg.startswith('nonlocal DCSP image DCSP URI DCSP found:')): DCNL DCSP  DCSP self._warnfunc(msg, ('%s:%s' % get_source_line(node)), *args, **kwargs)
def to_string(ip): DCNL  DCSP return '.'.join(map((lambda n: str(((ip >> n) & 255))), [24, 16, 8, 0]))
def setup_masquerade(request, course_key, staff_access=False, reset_masquerade_data=False): DCNL  DCSP if ((request.user is None) or (not settings.FEATURES.get('ENABLE_MASQUERADE', False)) or (not staff_access)): DCNL DCSP  DCSP return (None, request.user) DCNL DCSP if reset_masquerade_data: DCNL DCSP  DCSP request.session.pop(MASQUERADE_DATA_KEY, None) DCNL DCSP masquerade_settings = request.session.setdefault(MASQUERADE_SETTINGS_KEY, {}) DCNL DCSP request.user.masquerade_settings = masquerade_settings DCNL DCSP course_masquerade = masquerade_settings.get(course_key, None) DCNL DCSP masquerade_user = None DCNL DCSP if (course_masquerade and course_masquerade.user_name): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP masquerade_user = CourseEnrollment.objects.users_enrolled_in(course_key).get(username=course_masquerade.user_name) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP course_masquerade = None DCNL DCSP  DCSP  DCSP del masquerade_settings[course_key] DCNL DCSP  DCSP  DCSP request.session.modified = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP masquerade_user.masquerade_settings = request.user.masquerade_settings DCNL DCSP  DCSP  DCSP masquerade_user.real_user = request.user DCNL DCSP return (course_masquerade, (masquerade_user or request.user))
def init_widgets(): DCNL  DCSP post_save.connect(_increment_sync_num, sender=Group) DCNL DCSP post_save.connect(_increment_sync_num, sender=Repository) DCNL DCSP post_delete.connect(_increment_sync_num, sender=Group) DCNL DCSP post_delete.connect(_increment_sync_num, sender=Repository)
def get_client(env): DCNL  DCSP eget = env.get DCNL DCSP g = regex_client.search(eget('http_x_forwarded_for', '')) DCNL DCSP client = ((g.group() or '').split(',')[0] if g else None) DCNL DCSP if (client in (None, '', 'unknown')): DCNL DCSP  DCSP g = regex_client.search(eget('remote_addr', '')) DCNL DCSP  DCSP if g: DCNL DCSP  DCSP  DCSP client = g.group() DCNL DCSP  DCSP elif env.http_host.startswith('['): DCNL DCSP  DCSP  DCSP client = '::1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP client = '127.0.0.1' DCNL DCSP if (not is_valid_ip_address(client)): DCNL DCSP  DCSP raise HTTP(400, ('Bad DCSP Request DCSP (request.client=%s)' % client)) DCNL DCSP return client
def is_internal_attribute(obj, attr): DCNL  DCSP if isinstance(obj, types.FunctionType): DCNL DCSP  DCSP if (attr in UNSAFE_FUNCTION_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, types.MethodType): DCNL DCSP  DCSP if ((attr in UNSAFE_FUNCTION_ATTRIBUTES) or (attr in UNSAFE_METHOD_ATTRIBUTES)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, type): DCNL DCSP  DCSP if (attr == 'mro'): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(obj, types.GeneratorType): DCNL DCSP  DCSP if (attr in UNSAFE_GENERATOR_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif (hasattr(types, 'CoroutineType') and isinstance(obj, types.CoroutineType)): DCNL DCSP  DCSP if (attr in UNSAFE_COROUTINE_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif (hasattr(types, 'AsyncGeneratorType') and isinstance(obj, types.AsyncGeneratorType)): DCNL DCSP  DCSP if (attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return attr.startswith('__')
def all_pairs_shortest_path(G, cutoff=None): DCNL  DCSP return {n: single_source_shortest_path(G, n, cutoff=cutoff) for n in G}
def get_type_hints(obj, globalns=None, localns=None): DCNL  DCSP return None
def _section_certificates(course): DCNL  DCSP example_cert_status = None DCNL DCSP html_cert_enabled = certs_api.has_html_certificates_enabled(course.id, course) DCNL DCSP if html_cert_enabled: DCNL DCSP  DCSP can_enable_for_course = True DCNL DCSP else: DCNL DCSP  DCSP example_cert_status = certs_api.example_certificates_status(course.id) DCNL DCSP  DCSP can_enable_for_course = ((example_cert_status is not None) and all(((cert_status['status'] == 'success') for cert_status in example_cert_status))) DCNL DCSP instructor_generation_enabled = settings.FEATURES.get('CERTIFICATES_INSTRUCTOR_GENERATION', False) DCNL DCSP certificate_statuses_with_count = {certificate['status']: certificate['count'] for certificate in GeneratedCertificate.get_unique_statuses(course_key=course.id)} DCNL DCSP return {'section_key': 'certificates', 'section_display_name': _('Certificates'), 'example_certificate_status': example_cert_status, 'can_enable_for_course': can_enable_for_course, 'enabled_for_course': certs_api.cert_generation_enabled(course.id), 'is_self_paced': course.self_paced, 'instructor_generation_enabled': instructor_generation_enabled, 'html_cert_enabled': html_cert_enabled, 'active_certificate': certs_api.get_active_web_certificate(course), 'certificate_statuses_with_count': certificate_statuses_with_count, 'status': CertificateStatuses, 'certificate_generation_history': CertificateGenerationHistory.objects.filter(course_id=course.id).order_by('-created'), 'urls': {'generate_example_certificates': reverse('generate_example_certificates', kwargs={'course_id': course.id}), 'enable_certificate_generation': reverse('enable_certificate_generation', kwargs={'course_id': course.id}), 'start_certificate_generation': reverse('start_certificate_generation', kwargs={'course_id': course.id}), 'start_certificate_regeneration': reverse('start_certificate_regeneration', kwargs={'course_id': course.id}), 'list_instructor_tasks_url': reverse('list_instructor_tasks', kwargs={'course_id': course.id})}}
def ms_payload(payload): DCNL  DCSP return {'1': 'windows/shell_reverse_tcp', '2': 'windows/meterpreter/reverse_tcp', '3': 'windows/vncinject/reverse_tcp', '4': 'windows/x64/shell_reverse_tcp', '5': 'windows/x64/meterpreter/reverse_tcp', '6': 'windows/meterpreter/reverse_tcp_allports', '7': 'windows/meterpreter/reverse_https', '8': 'windows/meterpreter/reverse_tcp_dns', '9': 'windows/download_exec'}.get(payload, 'ERROR')
def extract(path, to_path=''): DCNL  DCSP with Archive(path) as archive: DCNL DCSP  DCSP archive.extract(to_path)
def parse_field_path(field_path): DCNL  DCSP (model_path, field_name) = field_path.rsplit(u'.', 1) DCNL DCSP (app_name, model_name) = model_path.split(u'.models.') DCNL DCSP (_, app_label) = app_name.rsplit(u'.', 1) DCNL DCSP return ((app_label, model_name.lower()), field_name)
def stub_set_host_enabled(context, host_name, enabled): DCNL  DCSP results = {True: 'enabled', False: 'disabled'} DCNL DCSP if (host_name == 'notimplemented'): DCNL DCSP  DCSP raise NotImplementedError() DCNL DCSP elif (host_name == 'dummydest'): DCNL DCSP  DCSP raise exception.ComputeHostNotFound(host=host_name) DCNL DCSP elif (host_name == 'host_c2'): DCNL DCSP  DCSP return results[(not enabled)] DCNL DCSP else: DCNL DCSP  DCSP return results[enabled]
def secgroup_create(name, description, profile=None): DCNL  DCSP conn = _auth(profile) DCNL DCSP return conn.secgroup_create(name, description)
@nottest DCNL def _get_tests(fname, selector=None, nose_params=NOSE_COLLECT_PARAMS): DCNL  DCSP output_file = os.path.join(ARTIFACT_DIR, fname) DCNL DCSP collect_with_output = (nose_params % output_file) DCNL DCSP if (selector is not None): DCNL DCSP  DCSP cmd = ('%s DCSP %s DCSP -A DCSP "%s" DCSP w3af/' % (NOSETESTS, collect_with_output, selector)) DCNL DCSP else: DCNL DCSP  DCSP cmd = ('%s DCSP %s DCSP w3af/' % (NOSETESTS, collect_with_output)) DCNL DCSP cmd_args = shlex.split(cmd) DCNL DCSP logging.debug(('Collecting DCSP tests: DCSP "%s"' % cmd)) DCNL DCSP p = subprocess.Popen(cmd_args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, universal_newlines=True) DCNL DCSP (stdout, stderr) = p.communicate() DCNL DCSP if (p.returncode != 0): DCNL DCSP  DCSP logging.critical('Error DCSP while DCSP collecting DCSP tests!') DCNL DCSP  DCSP logging.critical(stdout) DCNL DCSP  DCSP logging.critical(stderr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP (test_suite, test_result) = parse_xunit(output_file) DCNL DCSP normalize_test_names(test_suite) DCNL DCSP logging.debug(('Collected DCSP %s DCSP tests.' % test_result.testsRun)) DCNL DCSP return test_suite
@check_feature_enabled(feature_name='ENTRANCE_EXAMS') DCNL def create_entrance_exam(request, course_key, entrance_exam_minimum_score_pct): DCNL  DCSP _delete_entrance_exam(request, course_key) DCNL DCSP return _create_entrance_exam(request=request, course_key=course_key, entrance_exam_minimum_score_pct=entrance_exam_minimum_score_pct)
def request_authenticate(request, username, password): DCNL  DCSP request.headers['Authorization'] = basic_auth_header(username, password)
def siva(x, y): DCNL  DCSP print x, y DCNL DCSP (x, y) = (y, x) DCNL DCSP print x, y
def servicegroup_add(sg_name, sg_type='HTTP', **connection_args): DCNL  DCSP ret = True DCNL DCSP if servicegroup_exists(sg_name): DCNL DCSP  DCSP return False DCNL DCSP nitro = _connect(**connection_args) DCNL DCSP if (nitro is None): DCNL DCSP  DCSP return False DCNL DCSP sg = NSServiceGroup() DCNL DCSP sg.set_servicegroupname(sg_name) DCNL DCSP sg.set_servicetype(sg_type.upper()) DCNL DCSP try: DCNL DCSP  DCSP NSServiceGroup.add(nitro, sg) DCNL DCSP except NSNitroError as error: DCNL DCSP  DCSP log.debug('netscaler DCSP module DCSP error DCSP - DCSP NSServiceGroup.add() DCSP failed: DCSP {0}'.format(error)) DCNL DCSP  DCSP ret = False DCNL DCSP _disconnect(nitro) DCNL DCSP return ret
def _is_ipv4_like(s): DCNL  DCSP parts = s.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for part in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP int(part) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def parsehttpdate(string_): DCNL  DCSP try: DCNL DCSP  DCSP t = time.strptime(string_, '%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z') DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP return datetime.datetime(*t[:6])
def unsafe_eval_enabled(response): DCNL  DCSP non_report_only_policies = retrieve_csp_policies(response) DCNL DCSP report_only_policies = retrieve_csp_policies(response, True) DCNL DCSP policies_all = merge_policies_dict(non_report_only_policies, report_only_policies) DCNL DCSP if (len(policies_all) > 0): DCNL DCSP  DCSP for directive_name in policies_all: DCNL DCSP  DCSP  DCSP if (directive_name.lower() != CSP_DIRECTIVE_SCRIPT): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for directive_value in policies_all[directive_name]: DCNL DCSP  DCSP  DCSP  DCSP if (directive_value.strip().lower() == CSP_DIRECTIVE_VALUE_UNSAFE_EVAL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def _to_micropennies_per_op(pennies, per): DCNL  DCSP return ((pennies * 1000000) / per)
def find_xpath_with_wait(context, id_str, **kwargs): DCNL  DCSP return _find_elem_with_wait(context, (By.XPATH, id_str), **kwargs)
def subscribe(hass, callback): DCNL  DCSP def zigbee_frame_subscriber(event): DCNL DCSP  DCSP 'Decode DCSP and DCSP unpickle DCSP the DCSP frame DCSP from DCSP the DCSP event DCSP bus, DCSP and DCSP call DCSP back.' DCNL DCSP  DCSP frame = pickle.loads(b64decode(event.data[ATTR_FRAME])) DCNL DCSP  DCSP callback(frame) DCNL DCSP hass.bus.listen(EVENT_ZIGBEE_FRAME_RECEIVED, zigbee_frame_subscriber)
def _current_component(view_func, dashboard=None, panel=None): DCNL  DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if dashboard: DCNL DCSP  DCSP  DCSP request.horizon['dashboard'] = dashboard DCNL DCSP  DCSP if panel: DCNL DCSP  DCSP  DCSP request.horizon['panel'] = panel DCNL DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP return dec
def modify_profile(hostname, username, password, profile_type, name, **kwargs): DCNL  DCSP bigip_session = _build_session(username, password) DCNL DCSP payload = {} DCNL DCSP payload['name'] = name DCNL DCSP for (key, value) in six.iteritems(kwargs): DCNL DCSP  DCSP if (not key.startswith('__')): DCNL DCSP  DCSP  DCSP if (key not in ['hostname', 'username', 'password', 'profile_type']): DCNL DCSP  DCSP  DCSP  DCSP key = key.replace('_', '-') DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP payload[key] = _set_value(value) DCNL DCSP  DCSP  DCSP  DCSP except salt.exceptions.CommandExecutionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'Error: DCSP Unable DCSP to DCSP Parse DCSP JSON DCSP data DCSP for DCSP parameter: DCSP {key}\n{value}'.format(key=key, value=value) DCNL DCSP try: DCNL DCSP  DCSP response = bigip_session.put((BIG_IP_URL_BASE.format(host=hostname) + '/ltm/profile/{type}/{name}'.format(type=profile_type, name=name)), data=json.dumps(payload)) DCNL DCSP except requests.exceptions.ConnectionError as e: DCNL DCSP  DCSP return _load_connection_error(hostname, e) DCNL DCSP return _load_response(response)
def is_string_secure(string): DCNL  DCSP if re.match(VALID_CHARS_REGEX, string): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def _try_all(image, methods=None, figsize=None, num_cols=2, verbose=True): DCNL  DCSP from matplotlib import pyplot as plt DCNL DCSP num_rows = math.ceil(((len(methods) + 1.0) / num_cols)) DCNL DCSP num_rows = int(num_rows) DCNL DCSP (fig, ax) = plt.subplots(num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, subplot_kw={'adjustable': 'box-forced'}) DCNL DCSP ax = ax.ravel() DCNL DCSP ax[0].imshow(image, cmap=plt.cm.gray) DCNL DCSP ax[0].set_title('Original') DCNL DCSP i = 1 DCNL DCSP for (name, func) in methods.items(): DCNL DCSP  DCSP ax[i].imshow(func(image), cmap=plt.cm.gray) DCNL DCSP  DCSP ax[i].set_title(name) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print func.__orifunc__ DCNL DCSP for a in ax: DCNL DCSP  DCSP a.axis('off') DCNL DCSP fig.tight_layout() DCNL DCSP return (fig, ax)
def size(N): DCNL  DCSP (bits, power) = (0, 1L) DCNL DCSP while (N >= power): DCNL DCSP  DCSP bits += 1 DCNL DCSP  DCSP power = (power << 1) DCNL DCSP return bits
def _media_path_url_from_info(root_desc, path_url): DCNL  DCSP return ('%(root)supload/%(service_path)s%(path)s' % {'root': root_desc['rootUrl'], 'service_path': root_desc['servicePath'], 'path': path_url})
def test_json(): DCNL  DCSP test_data = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.json(test_data) == {'a': 'b'})
def convertFsDirWavToWav(dirName, Fs, nC): DCNL  DCSP types = (((dirName + os.sep) + '*.wav'),) DCNL DCSP filesToProcess = [] DCNL DCSP for files in types: DCNL DCSP  DCSP filesToProcess.extend(glob.glob(files)) DCNL DCSP newDir = ((((((dirName + os.sep) + 'Fs') + str(Fs)) + '_') + 'NC') + str(nC)) DCNL DCSP if (os.path.exists(newDir) and (newDir != '.')): DCNL DCSP  DCSP shutil.rmtree(newDir) DCNL DCSP os.makedirs(newDir) DCNL DCSP for f in filesToProcess: DCNL DCSP  DCSP (_, wavFileName) = ntpath.split(f) DCNL DCSP  DCSP command = (((((((((('avconv DCSP -i DCSP "' + f) + '" DCSP -ar DCSP ') + str(Fs)) + ' DCSP -ac DCSP ') + str(nC)) + ' DCSP "') + newDir) + os.sep) + wavFileName) + '"') DCNL DCSP  DCSP print command DCNL DCSP  DCSP os.system(command)
def parse_as_json(lines): DCNL  DCSP escape = ('#{%s}' % unicode(time.time())) DCNL DCSP def enline(line): DCNL DCSP  DCSP return unicode(line.replace('\\|', escape)).strip() DCNL DCSP def deline(line): DCNL DCSP  DCSP return line.replace(escape, '|') DCNL DCSP def discard_comments(lines): DCNL DCSP  DCSP return [line for line in lines if (not line.startswith('#'))] DCNL DCSP lines = discard_comments(lines) DCNL DCSP lines = map(enline, lines) DCNL DCSP non_unique_keys = [] DCNL DCSP json_map = [] DCNL DCSP if lines: DCNL DCSP  DCSP first_line = lines.pop(0) DCNL DCSP  DCSP non_unique_keys = split_wisely(first_line, u'|', True) DCNL DCSP  DCSP non_unique_keys = map(deline, non_unique_keys) DCNL DCSP  DCSP rng_idx = len(non_unique_keys) DCNL DCSP  DCSP json_map = list(non_unique_keys) DCNL DCSP  DCSP for idx in xrange(rng_idx): DCNL DCSP  DCSP  DCSP json_map[idx] = dict([(non_unique_keys[idx], [])]) DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP values = split_wisely(line, u'|', True) DCNL DCSP  DCSP  DCSP values = map(deline, values) DCNL DCSP  DCSP  DCSP for idx in xrange(rng_idx): DCNL DCSP  DCSP  DCSP  DCSP json_map[idx].values()[0].append(values[idx]) DCNL DCSP return (non_unique_keys, json_map)
def _read_signify_ed25519_signature(signature_file): DCNL  DCSP with open(signature_file) as f: DCNL DCSP  DCSP sig = binascii.a2b_base64(f.read().splitlines()[1])[10:] DCNL DCSP  DCSP if (len(sig) != 64): DCNL DCSP  DCSP  DCSP raise Exception('bogus DCSP Ed25519 DCSP signature: DCSP raw DCSP signature DCSP length DCSP was DCSP {}, DCSP but DCSP expected DCSP 64'.format(len(sig))) DCNL DCSP  DCSP return sig
def glob_escape(input_string): DCNL  DCSP return re.sub((('(?P<char>[' + re.escape(GLOBBING_SPECIAL_CHARS)) + '])'), '[\\g<char>]', input_string)
def get_info(process=None, interval=0, with_childs=False): DCNL  DCSP from circus.process import get_children, get_memory_info, get_cpu_percent, get_memory_percent, get_cpu_times, get_nice, get_cmdline, get_create_time, get_username DCNL DCSP if ((process is None) or isinstance(process, int)): DCNL DCSP  DCSP if (process is None): DCNL DCSP  DCSP  DCSP pid = os.getpid() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pid = process DCNL DCSP  DCSP if (pid in _PROCS): DCNL DCSP  DCSP  DCSP process = _PROCS[pid] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _PROCS[pid] = process = Process(pid) DCNL DCSP info = {} DCNL DCSP try: DCNL DCSP  DCSP mem_info = get_memory_info(process) DCNL DCSP  DCSP info['mem_info1'] = bytes2human(mem_info[0]) DCNL DCSP  DCSP info['mem_info2'] = bytes2human(mem_info[1]) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['mem_info1'] = info['mem_info2'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['cpu'] = get_cpu_percent(process, interval=interval) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['cpu'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['mem'] = round(get_memory_percent(process), 3) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['mem'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP cpu_times = get_cpu_times(process) DCNL DCSP  DCSP ctime = timedelta(seconds=sum(cpu_times)) DCNL DCSP  DCSP ctime = ('%s:%s.%s' % (((ctime.seconds // 60) % 60), str((ctime.seconds % 60)).zfill(2), str(ctime.microseconds)[:2])) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP ctime = 'N/A' DCNL DCSP info['ctime'] = ctime DCNL DCSP try: DCNL DCSP  DCSP info['pid'] = process.pid DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['pid'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['username'] = get_username(process) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['username'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['nice'] = get_nice(process) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['nice'] = 'N/A' DCNL DCSP except NoSuchProcess: DCNL DCSP  DCSP info['nice'] = 'Zombie' DCNL DCSP try: DCNL DCSP  DCSP raw_cmdline = get_cmdline(process) DCNL DCSP  DCSP cmdline = os.path.basename(shlex.split(raw_cmdline[0], posix=(not IS_WINDOWS))[0]) DCNL DCSP except (AccessDenied, IndexError): DCNL DCSP  DCSP cmdline = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['create_time'] = get_create_time(process) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['create_time'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['age'] = (time.time() - get_create_time(process)) DCNL DCSP except TypeError: DCNL DCSP  DCSP info['create_time'] = get_create_time(process) DCNL DCSP except AccessDenied: DCNL DCSP  DCSP info['age'] = 'N/A' DCNL DCSP info['cmdline'] = cmdline DCNL DCSP info['children'] = [] DCNL DCSP if with_childs: DCNL DCSP  DCSP for child in get_children(process): DCNL DCSP  DCSP  DCSP info['children'].append(get_info(child, interval=interval)) DCNL DCSP return info
def delete_blob(bucket_name, blob_name): DCNL  DCSP storage_client = storage.Client() DCNL DCSP bucket = storage_client.get_bucket(bucket_name) DCNL DCSP blob = bucket.blob(blob_name) DCNL DCSP blob.delete() DCNL DCSP print 'Blob DCSP {} DCSP deleted.'.format(blob_name)
@must_be_valid_project DCNL @must_be_contributor_or_public DCNL @must_not_be_registration DCNL def togglewatch_post(auth, node, **kwargs): DCNL  DCSP user = auth.user DCNL DCSP watch_config = WatchConfig(node=node, digest=request.json.get('digest', False), immediate=request.json.get('immediate', False)) DCNL DCSP try: DCNL DCSP  DCSP if user.is_watching(node): DCNL DCSP  DCSP  DCSP user.unwatch(watch_config) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user.watch(watch_config) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST) DCNL DCSP user.save() DCNL DCSP return {'status': 'success', 'watchCount': node.watches.count(), 'watched': user.is_watching(node)}
def formatstring(cols, colwidth=_colwidth, spacing=_spacing): DCNL  DCSP spacing *= ' DCSP ' DCNL DCSP return spacing.join((c.center(colwidth) for c in cols))
def import_library(taglib_module): DCNL  DCSP (app_path, taglib) = taglib_module.rsplit('.', 1) DCNL DCSP app_module = import_module(app_path) DCNL DCSP try: DCNL DCSP  DCSP mod = import_module(taglib_module) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if (not module_has_submodule(app_module, taglib)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvalidTemplateLibrary(('ImportError DCSP raised DCSP loading DCSP %s: DCSP %s' % (taglib_module, e))) DCNL DCSP try: DCNL DCSP  DCSP return mod.register DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise InvalidTemplateLibrary(("Template DCSP library DCSP %s DCSP does DCSP not DCSP have DCSP a DCSP variable DCSP named DCSP 'register'" % taglib_module))
def fdr_correction(pvals, alpha=0.05, method='indep'): DCNL  DCSP pvals = np.asarray(pvals) DCNL DCSP shape_init = pvals.shape DCNL DCSP pvals = pvals.ravel() DCNL DCSP pvals_sortind = np.argsort(pvals) DCNL DCSP pvals_sorted = pvals[pvals_sortind] DCNL DCSP sortrevind = pvals_sortind.argsort() DCNL DCSP if (method in ['i', 'indep', 'p', 'poscorr']): DCNL DCSP  DCSP ecdffactor = _ecdf(pvals_sorted) DCNL DCSP elif (method in ['n', 'negcorr']): DCNL DCSP  DCSP cm = np.sum((1.0 / np.arange(1, (len(pvals_sorted) + 1)))) DCNL DCSP  DCSP ecdffactor = (_ecdf(pvals_sorted) / cm) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("Method DCSP should DCSP be DCSP 'indep' DCSP and DCSP 'negcorr'") DCNL DCSP reject = (pvals_sorted < (ecdffactor * alpha)) DCNL DCSP if reject.any(): DCNL DCSP  DCSP rejectmax = max(np.nonzero(reject)[0]) DCNL DCSP else: DCNL DCSP  DCSP rejectmax = 0 DCNL DCSP reject[:rejectmax] = True DCNL DCSP pvals_corrected_raw = (pvals_sorted / ecdffactor) DCNL DCSP pvals_corrected = np.minimum.accumulate(pvals_corrected_raw[::(-1)])[::(-1)] DCNL DCSP pvals_corrected[(pvals_corrected > 1.0)] = 1.0 DCNL DCSP pvals_corrected = pvals_corrected[sortrevind].reshape(shape_init) DCNL DCSP reject = reject[sortrevind].reshape(shape_init) DCNL DCSP return (reject, pvals_corrected)
def p_namespace_scope(p): DCNL  DCSP p[0] = p[1]
def waist2rayleigh(w, wavelen): DCNL  DCSP (w, wavelen) = map(sympify, (w, wavelen)) DCNL DCSP return (((w ** 2) * pi) / wavelen)
def count_sprintf_parameters(string): DCNL  DCSP return len(_sprintf_placeholder_re.findall(string))
def GetBatchJob(client, batch_job_id): DCNL  DCSP batch_job_service = client.GetService('BatchJobService', 'v201607') DCNL DCSP selector = {'fields': ['Id', 'Status', 'DownloadUrl'], 'predicates': [{'field': 'Id', 'operator': 'EQUALS', 'values': [batch_job_id]}]} DCNL DCSP return batch_job_service.get(selector)['entries'][0]
def reverse_url(handler_name, key_name=None, key_value=None, kwargs=None): DCNL  DCSP kwargs_for_reverse = ({key_name: unicode(key_value)} if key_name else None) DCNL DCSP if kwargs: DCNL DCSP  DCSP kwargs_for_reverse.update(kwargs) DCNL DCSP return reverse(('contentstore.views.' + handler_name), kwargs=kwargs_for_reverse)
def isInIOThread(): DCNL  DCSP return (ioThread == getThreadID())
def scan_postfix_cleanup_line(date, _, collector): DCNL  DCSP collector['activity-by-hour']['smtp-receives'][date.hour] += 1
def test_different_caller(): DCNL  DCSP assert_signature('[str][0](', 'str', 0) DCNL DCSP assert_signature('[str][0]()', 'str', 0, column=len('[str][0](')) DCNL DCSP assert_signature('(str)(', 'str', 0) DCNL DCSP assert_signature('(str)()', 'str', 0, column=len('(str)('))
def fuse_getitem(dsk, func, place): DCNL  DCSP return fuse_selections(dsk, getitem, func, (lambda a, b: ((tuple(b[:place]) + (a[2],)) + tuple(b[(place + 1):]))))
def find_dataset_changes(uuid, current_state, desired_state): DCNL  DCSP uuid_to_hostnames = {node.uuid: node.hostname for node in current_state.nodes.values()} DCNL DCSP desired_datasets = {node.uuid: set((manifestation.dataset for manifestation in node.manifestations.values())) for node in desired_state.nodes.values()} DCNL DCSP current_datasets = {node.uuid: set((manifestation.dataset for manifestation in (node.manifestations or {}).values())) for node in current_state.nodes.values()} DCNL DCSP local_desired_datasets = set((dataset for dataset in desired_datasets.get(uuid, set()) if (dataset.deleted is False))) DCNL DCSP local_desired_dataset_ids = set((dataset.dataset_id for dataset in local_desired_datasets)) DCNL DCSP local_current_dataset_ids = set((dataset.dataset_id for dataset in current_datasets.get(uuid, set()))) DCNL DCSP remote_current_dataset_ids = set() DCNL DCSP for (dataset_node_uuid, current) in current_datasets.items(): DCNL DCSP  DCSP if (dataset_node_uuid != uuid): DCNL DCSP  DCSP  DCSP remote_current_dataset_ids |= set((dataset.dataset_id for dataset in current)) DCNL DCSP resizing = set() DCNL DCSP for desired in desired_datasets.values(): DCNL DCSP  DCSP for new_dataset in desired: DCNL DCSP  DCSP  DCSP if (new_dataset.dataset_id in local_current_dataset_ids): DCNL DCSP  DCSP  DCSP  DCSP for cur_dataset in current_datasets[uuid]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cur_dataset.dataset_id != new_dataset.dataset_id): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cur_dataset.maximum_size != new_dataset.maximum_size): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resizing.add(new_dataset) DCNL DCSP going = set() DCNL DCSP for (dataset_node_uuid, desired) in desired_datasets.items(): DCNL DCSP  DCSP if (dataset_node_uuid != uuid): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hostname = uuid_to_hostnames[dataset_node_uuid] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for dataset in desired: DCNL DCSP  DCSP  DCSP  DCSP if (dataset.dataset_id in local_current_dataset_ids): DCNL DCSP  DCSP  DCSP  DCSP  DCSP going.add(DatasetHandoff(dataset=dataset, hostname=hostname)) DCNL DCSP creating_dataset_ids = local_desired_dataset_ids.difference((local_current_dataset_ids | remote_current_dataset_ids)) DCNL DCSP creating = set((dataset for dataset in local_desired_datasets if (dataset.dataset_id in creating_dataset_ids))) DCNL DCSP deleting = set((dataset for dataset in chain(*desired_datasets.values()) if (dataset.deleted and (dataset.dataset_id in local_current_dataset_ids)))) DCNL DCSP return DatasetChanges(going=going, deleting=deleting, creating=creating, resizing=resizing)
def test_all_fields(script): DCNL  DCSP result = script.pip('show', 'pip') DCNL DCSP lines = result.stdout.splitlines() DCNL DCSP expected = set(['Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'License', 'Location', 'Requires']) DCNL DCSP actual = set((re.sub(':.*$', '', line) for line in lines)) DCNL DCSP assert (actual == expected)
def neg_sampling(W_list, b_list, nsamples, beta=1.0, pa_bias=None, marginalize_odd=True, theano_rng=None): DCNL  DCSP depth = len(b_list) DCNL DCSP new_nsamples = [nsamples[i] for i in xrange(depth)] DCNL DCSP _sample_even_odd(W_list, b_list, new_nsamples, beta, odd=marginalize_odd) DCNL DCSP _activation_even_odd(W_list, b_list, new_nsamples, beta, odd=(not marginalize_odd)) DCNL DCSP new_nsamples[(not marginalize_odd)] += (pa_bias * (1.0 - beta)) DCNL DCSP for i in xrange((not marginalize_odd), depth, 2): DCNL DCSP  DCSP new_nsamples[i] = T.nnet.sigmoid(new_nsamples[i]) DCNL DCSP  DCSP new_nsamples[i] = theano_rng.binomial(size=nsamples[i].get_value().shape, n=1, p=new_nsamples[i], dtype=floatX) DCNL DCSP return new_nsamples
def roundrobin(iterables): DCNL  DCSP pending = len(iterables) DCNL DCSP nexts = cycle((iter(it).next for it in iterables)) DCNL DCSP while pending: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for next in nexts: DCNL DCSP  DCSP  DCSP  DCSP (yield next()) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP pending -= 1 DCNL DCSP  DCSP  DCSP nexts = cycle(islice(nexts, pending))
def _pipeline_present_with_definition(name, expected_pipeline_objects, expected_parameter_objects, expected_parameter_values, region, key, keyid, profile): DCNL  DCSP result_pipeline_id = __salt__['boto_datapipeline.pipeline_id_from_name'](name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in result_pipeline_id): DCNL DCSP  DCSP return (False, {}) DCNL DCSP pipeline_id = result_pipeline_id['result'] DCNL DCSP pipeline_definition_result = __salt__['boto_datapipeline.get_pipeline_definition'](pipeline_id, version='active', region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in pipeline_definition_result): DCNL DCSP  DCSP return (False, {}) DCNL DCSP pipeline_definition = _standardize(pipeline_definition_result['result']) DCNL DCSP pipeline_objects = pipeline_definition.get('pipelineObjects') DCNL DCSP parameter_objects = pipeline_definition.get('parameterObjects') DCNL DCSP paramater_values = pipeline_definition.get('parameterValues') DCNL DCSP present = (_recursive_compare(_cleaned(pipeline_objects), _cleaned(expected_pipeline_objects)) and _recursive_compare(parameter_objects, expected_parameter_objects) and _recursive_compare(paramater_values, expected_parameter_values)) DCNL DCSP return (present, pipeline_definition)
@require_admin_context DCNL def instance_type_access_add(context, flavor_id, project_id): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_id(context, flavor_id, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP access_ref = _instance_type_access_query(context, session=session).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).first() DCNL DCSP  DCSP if access_ref: DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessExists(flavor_id=flavor_id, project_id=project_id) DCNL DCSP  DCSP access_ref = models.InstanceTypeProjects() DCNL DCSP  DCSP access_ref.update({'instance_type_id': instance_type_id, 'project_id': project_id}) DCNL DCSP  DCSP access_ref.save(session=session) DCNL DCSP  DCSP return access_ref
def parse_inlinefunc(string, strip=False, **kwargs): DCNL  DCSP global _PARSING_CACHE DCNL DCSP if (string in _PARSING_CACHE): DCNL DCSP  DCSP stack = _PARSING_CACHE[string] DCNL DCSP else: DCNL DCSP  DCSP if (not _RE_STARTTOKEN.search(string)): DCNL DCSP  DCSP  DCSP return string DCNL DCSP  DCSP stack = ParseStack() DCNL DCSP  DCSP ncallable = 0 DCNL DCSP  DCSP for match in _RE_TOKEN.finditer(string): DCNL DCSP  DCSP  DCSP gdict = match.groupdict() DCNL DCSP  DCSP  DCSP if gdict['singlequote']: DCNL DCSP  DCSP  DCSP  DCSP stack.append(gdict['singlequote']) DCNL DCSP  DCSP  DCSP elif gdict['doublequote']: DCNL DCSP  DCSP  DCSP  DCSP stack.append(gdict['doublequote']) DCNL DCSP  DCSP  DCSP elif gdict['end']: DCNL DCSP  DCSP  DCSP  DCSP if (ncallable <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(')') DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP args = [] DCNL DCSP  DCSP  DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP  DCSP  DCSP operation = stack.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if callable(operation): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not strip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stack.append((operation, [arg for arg in reversed(args)])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ncallable -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args.append(operation) DCNL DCSP  DCSP  DCSP elif gdict['start']: DCNL DCSP  DCSP  DCSP  DCSP funcname = _RE_STARTTOKEN.match(gdict['start']).group(1) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(_INLINE_FUNCS[funcname]) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(_INLINE_FUNCS['nomatch']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(funcname) DCNL DCSP  DCSP  DCSP  DCSP ncallable += 1 DCNL DCSP  DCSP  DCSP elif gdict['escaped']: DCNL DCSP  DCSP  DCSP  DCSP token = gdict['escaped'].lstrip('\\') DCNL DCSP  DCSP  DCSP  DCSP stack.append(token) DCNL DCSP  DCSP  DCSP elif gdict['comma']: DCNL DCSP  DCSP  DCSP  DCSP if (ncallable > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(',') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP stack.append(gdict['rest']) DCNL DCSP  DCSP if (ncallable > 0): DCNL DCSP  DCSP  DCSP return string DCNL DCSP  DCSP if ((_STACK_MAXSIZE > 0) and (_STACK_MAXSIZE < len(stack))): DCNL DCSP  DCSP  DCSP return (string + gdict['stackfull'](*args, **kwargs)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _PARSING_CACHE[string] = stack DCNL DCSP def _run_stack(item, depth=0): DCNL DCSP  DCSP retval = item DCNL DCSP  DCSP if isinstance(item, tuple): DCNL DCSP  DCSP  DCSP if strip: DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (func, arglist) = item DCNL DCSP  DCSP  DCSP  DCSP args = [''] DCNL DCSP  DCSP  DCSP  DCSP for arg in arglist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (arg is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args.append('') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args[(-1)] += _run_stack(arg, depth=(depth + 1)) DCNL DCSP  DCSP  DCSP  DCSP kwargs['inlinefunc_stack_depth'] = depth DCNL DCSP  DCSP  DCSP  DCSP retval = ('' if strip else func(*args, **kwargs)) DCNL DCSP  DCSP return utils.to_str(retval, force_string=True) DCNL DCSP return ''.join((_run_stack(item) for item in _PARSING_CACHE[string]))
def _log(msg, facility, loglevel): DCNL  DCSP logger = logging.getLogger(facility) DCNL DCSP logger.log(loglevel, msg)
def update_single(f, new): DCNL  DCSP frappe.db.begin() DCNL DCSP frappe.db.sql(u'update DCSP tabSingles DCSP set DCSP field=%s DCSP where DCSP doctype=%s DCSP and DCSP field=%s', (new, f[u'parent'], f[u'fieldname'])) DCNL DCSP frappe.db.commit()
def p_expression_uminus(p): DCNL  DCSP p[0] = (- p[2])
def convert_case(s): DCNL  DCSP return ''.join([a.title() for a in s.split('_') if a])
def normal(state, text, i, formats, user_data): DCNL  DCSP m = space_pat.match(text, i) DCNL DCSP if (m is not None): DCNL DCSP  DCSP return [(len(m.group()), None)] DCNL DCSP cdo = cdo_pat.match(text, i) DCNL DCSP if (cdo is not None): DCNL DCSP  DCSP state.parse = IN_COMMENT_NORMAL DCNL DCSP  DCSP return [(len(cdo.group()), formats[u'comment'])] DCNL DCSP if (text[i] == u'"'): DCNL DCSP  DCSP state.parse = IN_DQS DCNL DCSP  DCSP return [(1, formats[u'string'])] DCNL DCSP if (text[i] == u"'"): DCNL DCSP  DCSP state.parse = IN_SQS DCNL DCSP  DCSP return [(1, formats[u'string'])] DCNL DCSP if (text[i] == u'{'): DCNL DCSP  DCSP state.parse = IN_CONTENT DCNL DCSP  DCSP state.blocks += 1 DCNL DCSP  DCSP return [(1, formats[u'bracket'])] DCNL DCSP for (token, fmt, name) in sheet_tokens: DCNL DCSP  DCSP m = token.match(text, i) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP return [(len(m.group()), formats[fmt])] DCNL DCSP return [((len(text) - i), formats[u'unknown-normal'])]
def istraceback(object): DCNL  DCSP return isinstance(object, types.TracebackType)
def list_of_array_equal(s, t): DCNL  DCSP eq_(len(s), len(t)) DCNL DCSP all((assert_array_equal(x, y) for (x, y) in zip(s, t)))
def merge_ownership_periods(mappings): DCNL  DCSP return valmap((lambda v: tuple((OwnershipPeriod(a.start, b.start, a.sid, a.value) for (a, b) in sliding_window(2, concatv(sorted(v), [OwnershipPeriod(pd.Timestamp.max.tz_localize('utc'), None, None, None)]))))), mappings)
def _key_split(matchobj): DCNL  DCSP keys = [k.strip() for k in matchobj.group(1).split('+')] DCNL DCSP return ' DCSP + DCSP '.join([('<span DCSP class="key">%s</span>' % key) for key in keys])
@require_POST DCNL def post_receive_hook_close_submitted(request, local_site_name=None, repository_id=None, hosting_service_id=None, hooks_uuid=None): DCNL  DCSP repository = get_repository_for_hook(repository_id, hosting_service_id, local_site_name, hooks_uuid) DCNL DCSP try: DCNL DCSP  DCSP payload = json.loads(request.body) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP logging.error(u'The DCSP payload DCSP is DCSP not DCSP in DCSP JSON DCSP format: DCSP %s', e, exc_info=1) DCNL DCSP  DCSP return HttpResponseBadRequest(u'Invalid DCSP payload DCSP format') DCNL DCSP server_url = get_server_url(request=request) DCNL DCSP review_request_id_to_commits_map = close_review_requests(payload, server_url) DCNL DCSP if review_request_id_to_commits_map: DCNL DCSP  DCSP close_all_review_requests(review_request_id_to_commits_map, local_site_name, repository, hosting_service_id) DCNL DCSP return HttpResponse()
@require_context DCNL def group_types_get_by_name_or_id(context, group_type_list): DCNL  DCSP req_group_types = [] DCNL DCSP for grp_t in group_type_list: DCNL DCSP  DCSP if (not uuidutils.is_uuid_like(grp_t)): DCNL DCSP  DCSP  DCSP grp_type = _group_type_get_by_name(context, grp_t) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP grp_type = _group_type_get(context, grp_t) DCNL DCSP  DCSP req_group_types.append(grp_type) DCNL DCSP return req_group_types
def setup_logging(args): DCNL  DCSP handler = logging.StreamHandler() DCNL DCSP root_logger = logging.getLogger() DCNL DCSP root_logger.setLevel((logging.ERROR - (args.verbose_count * 10))) DCNL DCSP root_logger.addHandler(handler)
def mixing_dict(xy, normalized=False): DCNL  DCSP d = {} DCNL DCSP psum = 0.0 DCNL DCSP for (x, y) in xy: DCNL DCSP  DCSP if (x not in d): DCNL DCSP  DCSP  DCSP d[x] = {} DCNL DCSP  DCSP if (y not in d): DCNL DCSP  DCSP  DCSP d[y] = {} DCNL DCSP  DCSP v = d[x].get(y, 0) DCNL DCSP  DCSP d[x][y] = (v + 1) DCNL DCSP  DCSP psum += 1 DCNL DCSP if normalized: DCNL DCSP  DCSP for (k, jdict) in d.items(): DCNL DCSP  DCSP  DCSP for j in jdict: DCNL DCSP  DCSP  DCSP  DCSP jdict[j] /= psum DCNL DCSP return d
def move_by_taskmap(map, **kwargs): DCNL  DCSP def task_name_in_map(body, message): DCNL DCSP  DCSP return map.get(body[u'task']) DCNL DCSP return move(task_name_in_map, **kwargs)
def gen_preprocess_options(macros, include_dirs): DCNL  DCSP pp_opts = [] DCNL DCSP for macro in macros: DCNL DCSP  DCSP if (not ((type(macro) is TupleType) and (1 <= len(macro) <= 2))): DCNL DCSP  DCSP  DCSP raise TypeError, (("bad DCSP macro DCSP definition DCSP '%s': DCSP " + "each DCSP element DCSP of DCSP 'macros' DCSP list DCSP must DCSP be DCSP a DCSP 1- DCSP or DCSP 2-tuple") % macro) DCNL DCSP  DCSP if (len(macro) == 1): DCNL DCSP  DCSP  DCSP pp_opts.append(('-U%s' % macro[0])) DCNL DCSP  DCSP elif (len(macro) == 2): DCNL DCSP  DCSP  DCSP if (macro[1] is None): DCNL DCSP  DCSP  DCSP  DCSP pp_opts.append(('-D%s' % macro[0])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pp_opts.append(('-D%s=%s' % macro)) DCNL DCSP for dir in include_dirs: DCNL DCSP  DCSP pp_opts.append(('-I%s' % dir)) DCNL DCSP return pp_opts
def convert_time_to_utc(timestr): DCNL  DCSP combined = datetime.combine(dt_util.start_of_local_day(), dt_util.parse_time(timestr)) DCNL DCSP if (combined < datetime.now()): DCNL DCSP  DCSP combined = (combined + timedelta(days=1)) DCNL DCSP return dt_util.as_timestamp(combined)
def share_db(): DCNL  DCSP client = MongoClient(wiki_settings.SHAREJS_DB_URL) DCNL DCSP return client[wiki_settings.SHAREJS_DB_NAME]
def comparison_type(logical_line, noqa): DCNL  DCSP match = COMPARE_TYPE_REGEX.search(logical_line) DCNL DCSP if (match and (not noqa)): DCNL DCSP  DCSP inst = match.group(1) DCNL DCSP  DCSP if (inst and isidentifier(inst) and (inst not in SINGLETONS)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (yield (match.start(), "E721 DCSP do DCSP not DCSP compare DCSP types, DCSP use DCSP 'isinstance()'"))
def create_patch_ports(source, destination): DCNL  DCSP common = common_utils.get_rand_name(max_length=4, prefix='') DCNL DCSP prefix = ('%s-%s-' % (PATCH_PREFIX, common)) DCNL DCSP source_name = common_utils.get_rand_device_name(prefix=prefix) DCNL DCSP destination_name = common_utils.get_rand_device_name(prefix=prefix) DCNL DCSP source.add_patch_port(source_name, destination_name) DCNL DCSP destination.add_patch_port(destination_name, source_name)
@image_comparison(baseline_images=[u'colorbar_extensions_uniform', u'colorbar_extensions_proportional'], extensions=[u'png']) DCNL def test_colorbar_extension_length(): DCNL  DCSP _colorbar_extension_length(u'uniform') DCNL DCSP _colorbar_extension_length(u'proportional')
def vpn_ping(address, port, timeout=0.05, session_id=None): DCNL  DCSP if (session_id is None): DCNL DCSP  DCSP session_id = random.randint(0, 18446744073709551615L) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP data = struct.pack('!BQxxxxx', 56, session_id) DCNL DCSP sock.sendto(data, (address, port)) DCNL DCSP sock.settimeout(timeout) DCNL DCSP try: DCNL DCSP  DCSP received = sock.recv(2048) DCNL DCSP except socket.timeout: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP sock.close() DCNL DCSP fmt = '!BQxxxxxQxxxx' DCNL DCSP if (len(received) != struct.calcsize(fmt)): DCNL DCSP  DCSP print struct.calcsize(fmt) DCNL DCSP  DCSP return False DCNL DCSP (identifier, server_sess, client_sess) = struct.unpack(fmt, received) DCNL DCSP if ((identifier == 64) and (client_sess == session_id)): DCNL DCSP  DCSP return server_sess
def get_documentation(): DCNL  DCSP from ._compat import StringIO DCNL DCSP (sys.stdout, _) = (StringIO(), sys.stdout) DCNL DCSP help(vim.eval('a:word')) DCNL DCSP (sys.stdout, out) = (_, sys.stdout.getvalue()) DCNL DCSP vim.current.buffer.append(str(out).splitlines(), 0)
def httpdate(date_obj): DCNL  DCSP return date_obj.strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT')
def cmServiceRequest(PriorityLevel_presence=0): DCNL  DCSP a = TpPd(pd=5) DCNL DCSP b = MessageType(mesType=36) DCNL DCSP c = CmServiceTypeAndCiphKeySeqNr() DCNL DCSP e = MobileStationClassmark2() DCNL DCSP f = MobileId() DCNL DCSP packet = ((((a / b) / c) / e) / f) DCNL DCSP if (PriorityLevel_presence is 1): DCNL DCSP  DCSP g = PriorityLevelHdr(ieiPL=8, eightBitPL=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP return packet
def get_ring(): DCNL  DCSP ring_output = check_output([NODE_TOOL, 'ring', KEYSPACE]) DCNL DCSP ring = [] DCNL DCSP index = 0 DCNL DCSP for line in ring_output.splitlines(): DCNL DCSP  DCSP fields = line.split() DCNL DCSP  DCSP if (len(fields) != 8): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ring.append({'index': index, 'ip': fields[0], 'status': fields[2], 'state': fields[3], 'load': load_bytes(float(fields[4]), fields[5]), 'token': fields[7]}) DCNL DCSP  DCSP index += 1 DCNL DCSP assert (len(ring) > 0) DCNL DCSP ideal_load = (sum((node['load'] for node in ring)) / len(ring)) DCNL DCSP for (index, node) in enumerate(ring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP node['skew'] = (abs((node['load'] - ideal_load)) / ideal_load) DCNL DCSP  DCSP except ZeroDivisionError: DCNL DCSP  DCSP  DCSP node['skew'] = 0 DCNL DCSP  DCSP node['diff'] = abs((node['load'] - ring[(index - 1)]['load'])) DCNL DCSP return ring
def skill_type(): DCNL  DCSP mode = session.s3.hrm.mode DCNL DCSP def prep(r): DCNL DCSP  DCSP if (mode is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller() DCNL DCSP return output
def running(ctid_or_name): DCNL  DCSP return (status(ctid_or_name).split(' DCSP ')[4] == 'running')
def get_int(int_str, default=_no_default): DCNL  DCSP if (default == _no_default): DCNL DCSP  DCSP return int(int_str) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(int_str) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return default
def is_color_like(c): DCNL  DCSP try: DCNL DCSP  DCSP colorConverter.to_rgb(c) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
def getEvaluatorSplitWords(value): DCNL  DCSP if value.startswith('='): DCNL DCSP  DCSP value = value[len('='):] DCNL DCSP if (len(value) < 1): DCNL DCSP  DCSP return [] DCNL DCSP global globalDictionaryOperatorBegin DCNL DCSP uniqueQuoteIndex = 0 DCNL DCSP word = '' DCNL DCSP quoteString = None DCNL DCSP quoteDictionary = {} DCNL DCSP for characterIndex in xrange(len(value)): DCNL DCSP  DCSP character = value[characterIndex] DCNL DCSP  DCSP if ((character == '"') or (character == "'")): DCNL DCSP  DCSP  DCSP if (quoteString == None): DCNL DCSP  DCSP  DCSP  DCSP quoteString = '' DCNL DCSP  DCSP  DCSP elif (quoteString != None): DCNL DCSP  DCSP  DCSP  DCSP if (character == quoteString[:1]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP uniqueQuoteIndex = getUniqueQuoteIndex(uniqueQuoteIndex, value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP uniqueToken = getTokenByNumber(uniqueQuoteIndex) DCNL DCSP  DCSP  DCSP  DCSP  DCSP quoteDictionary[uniqueToken] = (quoteString + character) DCNL DCSP  DCSP  DCSP  DCSP  DCSP character = uniqueToken DCNL DCSP  DCSP  DCSP  DCSP  DCSP quoteString = None DCNL DCSP  DCSP if (quoteString == None): DCNL DCSP  DCSP  DCSP word += character DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP quoteString += character DCNL DCSP beginSplitWords = getDictionarySplitWords(globalDictionaryOperatorBegin, word) DCNL DCSP global globalSplitDictionaryOperator DCNL DCSP evaluatorSplitWords = [] DCNL DCSP for beginSplitWord in beginSplitWords: DCNL DCSP  DCSP if (beginSplitWord in globalDictionaryOperatorBegin): DCNL DCSP  DCSP  DCSP evaluatorSplitWords.append(beginSplitWord) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP evaluatorSplitWords += getDictionarySplitWords(globalSplitDictionaryOperator, beginSplitWord) DCNL DCSP for (evaluatorSplitWordIndex, evaluatorSplitWord) in enumerate(evaluatorSplitWords): DCNL DCSP  DCSP for quoteDictionaryKey in quoteDictionary.keys(): DCNL DCSP  DCSP  DCSP if (quoteDictionaryKey in evaluatorSplitWord): DCNL DCSP  DCSP  DCSP  DCSP evaluatorSplitWords[evaluatorSplitWordIndex] = evaluatorSplitWord.replace(quoteDictionaryKey, quoteDictionary[quoteDictionaryKey]) DCNL DCSP evaluatorTransitionWords = [] DCNL DCSP for evaluatorSplitWord in evaluatorSplitWords: DCNL DCSP  DCSP addQuoteWord(evaluatorTransitionWords, evaluatorSplitWord) DCNL DCSP return evaluatorTransitionWords
@dispatch(object) DCNL def shape(expr): DCNL  DCSP s = list(discover(expr).shape) DCNL DCSP for (i, elem) in enumerate(s): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s[i] = int(elem) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return tuple(s)
def sample(prediction): DCNL  DCSP p = np.zeros(shape=[1, vocabulary_size], dtype=np.float) DCNL DCSP p[(0, sample_distribution(prediction[0]))] = 1.0 DCNL DCSP return p
def systemd_result_parser(command): DCNL  DCSP if (command == 'status'): DCNL DCSP  DCSP def method(cmdResult): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parse DCSP method DCSP for DCSP systemctl DCSP status DCSP XXX.service.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP True DCSP if DCSP XXX.service DCSP is DCSP running.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP False DCSP if DCSP XXX.service DCSP is DCSP stopped.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP None DCSP if DCSP XXX.service DCSP is DCSP not DCSP loaded.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP output = cmdResult.stdout DCNL DCSP  DCSP  DCSP if (not re.search('Loaded: DCSP loaded', output)): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP return (output.count('Active: DCSP active') > 0) DCNL DCSP  DCSP return method DCNL DCSP elif (command == 'list'): DCNL DCSP  DCSP def method(cmdResult): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parse DCSP method DCSP for DCSP systemctl DCSP list DCSP XXX.service.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Return DCSP a DCSP dict DCSP from DCSP service DCSP name DCSP to DCSP status.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.g:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {"sshd": DCSP "enabled",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "vsftpd": DCSP "disabled",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "systemd-sysctl": DCSP "static",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ...\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP if cmdResult.exit_status: DCNL DCSP  DCSP  DCSP  DCSP raise error.CmdError(cmdResult.command, cmdResult) DCNL DCSP  DCSP  DCSP _service2status_dict = {} DCNL DCSP  DCSP  DCSP lines = cmdResult.stdout.strip().splitlines() DCNL DCSP  DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP  DCSP sublines = line.strip().split() DCNL DCSP  DCSP  DCSP  DCSP if ((not (len(sublines) == 2)) or (not sublines[0].endswith('service'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP service_name = sublines[0].rstrip('.service') DCNL DCSP  DCSP  DCSP  DCSP status = sublines[(-1)] DCNL DCSP  DCSP  DCSP  DCSP _service2status_dict[service_name] = status DCNL DCSP  DCSP  DCSP return _service2status_dict DCNL DCSP  DCSP return method DCNL DCSP else: DCNL DCSP  DCSP return _ServiceResultParser.default_method
def _get_lut(): DCNL  DCSP data_dir = op.join(op.dirname(__file__), 'data') DCNL DCSP lut_fname = op.join(data_dir, 'FreeSurferColorLUT.txt') DCNL DCSP return np.genfromtxt(lut_fname, dtype=None, usecols=(0, 1, 2, 3, 4, 5), names=['id', 'name', 'R', 'G', 'B', 'A'])
def page_not_found(request, template_name='404.html'): DCNL  DCSP t = loader.get_template(template_name) DCNL DCSP return http.HttpResponseNotFound(t.render(RequestContext(request, {'request_path': request.path})))
def test_show_verbose_installer(script, data): DCNL  DCSP wheel_file = data.packages.join('simple.dist-0.1-py2.py3-none-any.whl') DCNL DCSP script.pip('install', '--no-index', wheel_file) DCNL DCSP result = script.pip('show', '--verbose', 'simple.dist') DCNL DCSP lines = result.stdout.splitlines() DCNL DCSP assert ('Name: DCSP simple.dist' in lines) DCNL DCSP assert ('Installer: DCSP pip' in lines)
def rsolve_poly(coeffs, f, n, **hints): DCNL  DCSP f = sympify(f) DCNL DCSP if (not f.is_polynomial(n)): DCNL DCSP  DCSP return None DCNL DCSP homogeneous = f.is_zero DCNL DCSP r = (len(coeffs) - 1) DCNL DCSP coeffs = [Poly(coeff, n) for coeff in coeffs] DCNL DCSP polys = ([Poly(0, n)] * (r + 1)) DCNL DCSP terms = ([(S.Zero, S.NegativeInfinity)] * (r + 1)) DCNL DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP for j in range(i, (r + 1)): DCNL DCSP  DCSP  DCSP polys[i] += (coeffs[j] * binomial(j, i)) DCNL DCSP  DCSP if (not polys[i].is_zero): DCNL DCSP  DCSP  DCSP ((exp,), coeff) = polys[i].LT() DCNL DCSP  DCSP  DCSP terms[i] = (coeff, exp) DCNL DCSP d = b = terms[0][1] DCNL DCSP for i in range(1, (r + 1)): DCNL DCSP  DCSP if (terms[i][1] > d): DCNL DCSP  DCSP  DCSP d = terms[i][1] DCNL DCSP  DCSP if ((terms[i][1] - i) > b): DCNL DCSP  DCSP  DCSP b = (terms[i][1] - i) DCNL DCSP (d, b) = (int(d), int(b)) DCNL DCSP x = Dummy('x') DCNL DCSP degree_poly = S.Zero DCNL DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP if ((terms[i][1] - i) == b): DCNL DCSP  DCSP  DCSP degree_poly += (terms[i][0] * FallingFactorial(x, i)) DCNL DCSP nni_roots = list(roots(degree_poly, x, filter='Z', predicate=(lambda r: (r >= 0))).keys()) DCNL DCSP if nni_roots: DCNL DCSP  DCSP N = [max(nni_roots)] DCNL DCSP else: DCNL DCSP  DCSP N = [] DCNL DCSP if homogeneous: DCNL DCSP  DCSP N += [((- b) - 1)] DCNL DCSP else: DCNL DCSP  DCSP N += [(f.as_poly(n).degree() - b), ((- b) - 1)] DCNL DCSP N = int(max(N)) DCNL DCSP if (N < 0): DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP if hints.get('symbols', False): DCNL DCSP  DCSP  DCSP  DCSP return (S.Zero, []) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return S.Zero DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP if (N <= r): DCNL DCSP  DCSP C = [] DCNL DCSP  DCSP y = E = S.Zero DCNL DCSP  DCSP for i in range(0, (N + 1)): DCNL DCSP  DCSP  DCSP C.append(Symbol(('C' + str(i)))) DCNL DCSP  DCSP  DCSP y += (C[i] * (n ** i)) DCNL DCSP  DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP  DCSP E += (coeffs[i].as_expr() * y.subs(n, (n + i))) DCNL DCSP  DCSP solutions = solve_undetermined_coeffs((E - f), C, n) DCNL DCSP  DCSP if (solutions is not None): DCNL DCSP  DCSP  DCSP C = [c for c in C if (c not in solutions)] DCNL DCSP  DCSP  DCSP result = y.subs(solutions) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP A = r DCNL DCSP  DCSP U = (((N + A) + b) + 1) DCNL DCSP  DCSP nni_roots = list(roots(polys[r], filter='Z', predicate=(lambda r: (r >= 0))).keys()) DCNL DCSP  DCSP if (nni_roots != []): DCNL DCSP  DCSP  DCSP a = (max(nni_roots) + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = S.Zero DCNL DCSP  DCSP def _zero_vector(k): DCNL DCSP  DCSP  DCSP return ([S.Zero] * k) DCNL DCSP  DCSP def _one_vector(k): DCNL DCSP  DCSP  DCSP return ([S.One] * k) DCNL DCSP  DCSP def _delta(p, k): DCNL DCSP  DCSP  DCSP B = S.One DCNL DCSP  DCSP  DCSP D = p.subs(n, (a + k)) DCNL DCSP  DCSP  DCSP for i in range(1, (k + 1)): DCNL DCSP  DCSP  DCSP  DCSP B *= (- Rational(((k - i) + 1), i)) DCNL DCSP  DCSP  DCSP  DCSP D += (B * p.subs(n, ((a + k) - i))) DCNL DCSP  DCSP  DCSP return D DCNL DCSP  DCSP alpha = {} DCNL DCSP  DCSP for i in range((- A), (d + 1)): DCNL DCSP  DCSP  DCSP I = _one_vector((d + 1)) DCNL DCSP  DCSP  DCSP for k in range(1, (d + 1)): DCNL DCSP  DCSP  DCSP  DCSP I[k] = ((I[(k - 1)] * (((x + i) - k) + 1)) / k) DCNL DCSP  DCSP  DCSP alpha[i] = S.Zero DCNL DCSP  DCSP  DCSP for j in range(0, (A + 1)): DCNL DCSP  DCSP  DCSP  DCSP for k in range(0, (d + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = binomial(k, (i + j)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP D = _delta(polys[j].as_expr(), k) DCNL DCSP  DCSP  DCSP  DCSP  DCSP alpha[i] += ((I[k] * B) * D) DCNL DCSP  DCSP V = Matrix(U, A, (lambda i, j: int((i == j)))) DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP for i in range(A, U): DCNL DCSP  DCSP  DCSP  DCSP v = _zero_vector(A) DCNL DCSP  DCSP  DCSP  DCSP for k in range(1, ((A + b) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((i - k) < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = alpha[(k - A)].subs(x, (i - k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP v[j] += (B * V[((i - k), j)]) DCNL DCSP  DCSP  DCSP  DCSP denom = alpha[(- A)].subs(x, i) DCNL DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP V[(i, j)] = ((- v[j]) / denom) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP G = _zero_vector(U) DCNL DCSP  DCSP  DCSP for i in range(A, U): DCNL DCSP  DCSP  DCSP  DCSP v = _zero_vector(A) DCNL DCSP  DCSP  DCSP  DCSP g = S.Zero DCNL DCSP  DCSP  DCSP  DCSP for k in range(1, ((A + b) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((i - k) < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = alpha[(k - A)].subs(x, (i - k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP v[j] += (B * V[((i - k), j)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP g += (B * G[(i - k)]) DCNL DCSP  DCSP  DCSP  DCSP denom = alpha[(- A)].subs(x, i) DCNL DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP V[(i, j)] = ((- v[j]) / denom) DCNL DCSP  DCSP  DCSP  DCSP G[i] = ((_delta(f, (i - A)) - g) / denom) DCNL DCSP  DCSP (P, Q) = (_one_vector(U), _zero_vector(A)) DCNL DCSP  DCSP for i in range(1, U): DCNL DCSP  DCSP  DCSP P[i] = ((P[(i - 1)] * (((n - a) - i) + 1)) / i).expand() DCNL DCSP  DCSP for i in range(0, A): DCNL DCSP  DCSP  DCSP Q[i] = Add(*[(v * p).expand() for (v, p) in zip(V[:, i], P)]) DCNL DCSP  DCSP if (not homogeneous): DCNL DCSP  DCSP  DCSP h = Add(*[(g * p).expand() for (g, p) in zip(G, P)]) DCNL DCSP  DCSP C = [Symbol(('C' + str(i))) for i in range(0, A)] DCNL DCSP  DCSP g = (lambda i: Add(*[(c * _delta(q, i)) for (c, q) in zip(C, Q)])) DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP E = [g(i) for i in range((N + 1), U)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP E = [(g(i) + _delta(h, i)) for i in range((N + 1), U)] DCNL DCSP  DCSP if (E != []): DCNL DCSP  DCSP  DCSP solutions = solve(E, *C) DCNL DCSP  DCSP  DCSP if (not solutions): DCNL DCSP  DCSP  DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hints.get('symbols', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (S.Zero, []) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return S.Zero DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP solutions = {} DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP result = S.Zero DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = h DCNL DCSP  DCSP for (c, q) in list(zip(C, Q)): DCNL DCSP  DCSP  DCSP if (c in solutions): DCNL DCSP  DCSP  DCSP  DCSP s = (solutions[c] * q) DCNL DCSP  DCSP  DCSP  DCSP C.remove(c) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s = (c * q) DCNL DCSP  DCSP  DCSP result += s.expand() DCNL DCSP if hints.get('symbols', False): DCNL DCSP  DCSP return (result, C) DCNL DCSP else: DCNL DCSP  DCSP return result
def base64_encodestring(instr): DCNL  DCSP if six.PY3: DCNL DCSP  DCSP b = salt.utils.to_bytes(instr) DCNL DCSP  DCSP b64 = base64.encodebytes(b) DCNL DCSP  DCSP return salt.utils.to_str(b64) DCNL DCSP return base64.encodestring(instr)
def cmd_map(args): DCNL  DCSP from mavflightview import mavflightview_mav, mavflightview_options DCNL DCSP options = mavflightview_options() DCNL DCSP options.condition = mestate.settings.condition DCNL DCSP options._flightmodes = mestate.mlog._flightmodes DCNL DCSP options.show_flightmode_legend = mestate.settings.show_flightmode DCNL DCSP if (len(args) > 0): DCNL DCSP  DCSP options.types = ','.join(args) DCNL DCSP [path, wp, fen, used_flightmodes] = mavflightview_mav(mestate.mlog, options, mestate.flightmode_selections) DCNL DCSP child = multiprocessing.Process(target=map_process, args=[path, wp, fen, used_flightmodes, options]) DCNL DCSP child.start() DCNL DCSP mestate.mlog.rewind()
def get_disable_keyboard_on_lock(): DCNL  DCSP ret = salt.utils.mac_utils.execute_return_result('systemsetup DCSP -getdisablekeyboardwhenenclosurelockisengaged') DCNL DCSP enabled = salt.utils.mac_utils.validate_enabled(salt.utils.mac_utils.parse_return(ret)) DCNL DCSP return (enabled == 'on')
def course_detail(request, username, course_key): DCNL  DCSP user = get_effective_user(request.user, username) DCNL DCSP return get_course_overview_with_access(user, get_permission_for_course_about(), course_key)
def extended_linecache_checkcache(filename=None, orig_checkcache=linecache.checkcache): DCNL  DCSP cache = linecache.cache DCNL DCSP save = {} DCNL DCSP for filename in cache.keys(): DCNL DCSP  DCSP if ((filename[:1] + filename[(-1):]) == '<>'): DCNL DCSP  DCSP  DCSP save[filename] = cache[filename] DCNL DCSP orig_checkcache() DCNL DCSP cache.update(save)
def convertSP(pySp, newSeed): DCNL  DCSP columnDim = pySp._columnDimensions DCNL DCSP inputDim = pySp._inputDimensions DCNL DCSP numInputs = pySp.getNumInputs() DCNL DCSP numColumns = pySp.getNumColumns() DCNL DCSP cppSp = CPPSpatialPooler(inputDim, columnDim) DCNL DCSP cppSp.setPotentialRadius(pySp.getPotentialRadius()) DCNL DCSP cppSp.setPotentialPct(pySp.getPotentialPct()) DCNL DCSP cppSp.setGlobalInhibition(pySp.getGlobalInhibition()) DCNL DCSP numActiveColumnsPerInhArea = pySp.getNumActiveColumnsPerInhArea() DCNL DCSP localAreaDensity = pySp.getLocalAreaDensity() DCNL DCSP if (numActiveColumnsPerInhArea > 0): DCNL DCSP  DCSP cppSp.setNumActiveColumnsPerInhArea(numActiveColumnsPerInhArea) DCNL DCSP else: DCNL DCSP  DCSP cppSp.setLocalAreaDensity(localAreaDensity) DCNL DCSP cppSp.setStimulusThreshold(pySp.getStimulusThreshold()) DCNL DCSP cppSp.setInhibitionRadius(pySp.getInhibitionRadius()) DCNL DCSP cppSp.setDutyCyclePeriod(pySp.getDutyCyclePeriod()) DCNL DCSP cppSp.setBoostStrength(pySp.getBoostStrength()) DCNL DCSP cppSp.setIterationNum(pySp.getIterationNum()) DCNL DCSP cppSp.setIterationLearnNum(pySp.getIterationLearnNum()) DCNL DCSP cppSp.setSpVerbosity(pySp.getSpVerbosity()) DCNL DCSP cppSp.setUpdatePeriod(pySp.getUpdatePeriod()) DCNL DCSP cppSp.setSynPermTrimThreshold(pySp.getSynPermTrimThreshold()) DCNL DCSP cppSp.setSynPermActiveInc(pySp.getSynPermActiveInc()) DCNL DCSP cppSp.setSynPermInactiveDec(pySp.getSynPermInactiveDec()) DCNL DCSP cppSp.setSynPermBelowStimulusInc(pySp.getSynPermBelowStimulusInc()) DCNL DCSP cppSp.setSynPermConnected(pySp.getSynPermConnected()) DCNL DCSP cppSp.setMinPctOverlapDutyCycles(pySp.getMinPctOverlapDutyCycles()) DCNL DCSP boostFactors = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getBoostFactors(boostFactors) DCNL DCSP cppSp.setBoostFactors(boostFactors) DCNL DCSP overlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getOverlapDutyCycles(overlapDuty) DCNL DCSP cppSp.setOverlapDutyCycles(overlapDuty) DCNL DCSP activeDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getActiveDutyCycles(activeDuty) DCNL DCSP cppSp.setActiveDutyCycles(activeDuty) DCNL DCSP minOverlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP cppSp.setMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP for i in xrange(numColumns): DCNL DCSP  DCSP potential = numpy.zeros(numInputs).astype(uintType) DCNL DCSP  DCSP pySp.getPotential(i, potential) DCNL DCSP  DCSP cppSp.setPotential(i, potential) DCNL DCSP  DCSP perm = numpy.zeros(numInputs).astype(realType) DCNL DCSP  DCSP pySp.getPermanence(i, perm) DCNL DCSP  DCSP cppSp.setPermanence(i, perm) DCNL DCSP pySp._random = NupicRandom(newSeed) DCNL DCSP cppSp.seed_(newSeed) DCNL DCSP return cppSp
def pop(queue, quantity=1): DCNL  DCSP cmd = 'SELECT DCSP name DCSP FROM DCSP {0}'.format(queue) DCNL DCSP if (quantity != 'all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP quantity = int(quantity) DCNL DCSP  DCSP except ValueError as exc: DCNL DCSP  DCSP  DCSP error_txt = 'Quantity DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP "all".\nError: DCSP "{0}".'.format(exc) DCNL DCSP  DCSP  DCSP raise SaltInvocationError(error_txt) DCNL DCSP  DCSP cmd = ''.join([cmd, ' DCSP LIMIT DCSP {0}'.format(quantity)]) DCNL DCSP log.debug('SQL DCSP Query: DCSP {0}'.format(cmd)) DCNL DCSP con = _conn(queue) DCNL DCSP items = [] DCNL DCSP with con: DCNL DCSP  DCSP cur = con.cursor() DCNL DCSP  DCSP result = cur.execute(cmd).fetchall() DCNL DCSP  DCSP if (len(result) > 0): DCNL DCSP  DCSP  DCSP items = [item[0] for item in result] DCNL DCSP  DCSP  DCSP itemlist = '","'.join(items) DCNL DCSP  DCSP  DCSP _quote_escape(itemlist) DCNL DCSP  DCSP  DCSP del_cmd = 'DELETE DCSP FROM DCSP {0} DCSP WHERE DCSP name DCSP IN DCSP ("{1}")'.format(queue, itemlist) DCNL DCSP  DCSP  DCSP log.debug('SQL DCSP Query: DCSP {0}'.format(del_cmd)) DCNL DCSP  DCSP  DCSP cur.execute(del_cmd) DCNL DCSP  DCSP con.commit() DCNL DCSP log.info(items) DCNL DCSP return items
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL  DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.append(hook)
def test_barn_prefixes(): DCNL  DCSP assert (u.fbarn is u.femtobarn) DCNL DCSP assert (u.pbarn is u.picobarn)
@treeio_login_required DCNL def ajax_location_lookup(request, response_format='html'): DCNL  DCSP locations = [] DCNL DCSP if (request.GET and ('term' in request.GET)): DCNL DCSP  DCSP user = request.user.profile DCNL DCSP  DCSP locations = Object.filter_permitted(user, Location.objects, mode='x').filter(Q(name__icontains=request.GET['term']))[:10] DCNL DCSP return render_to_response('identities/ajax_location_lookup', {'locations': locations}, context_instance=RequestContext(request), response_format=response_format)
def ping(host=None, port=None, db=None, password=None): DCNL  DCSP server = _connect(host, port, db, password) DCNL DCSP try: DCNL DCSP  DCSP return server.ping() DCNL DCSP except redis.ConnectionError: DCNL DCSP  DCSP return False
def create_resource(): DCNL  DCSP schema = get_schema() DCNL DCSP deserializer = RequestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ResourceTypeController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
def do_cli(manager, options): DCNL  DCSP if (irc_bot is None): DCNL DCSP  DCSP console(u'irc_bot DCSP is DCSP not DCSP installed. DCSP install DCSP using DCSP `pip DCSP install DCSP irc_bot`.') DCNL DCSP  DCSP return DCNL DCSP if (hasattr(options, u'table_type') and (options.table_type == u'porcelain')): DCNL DCSP  DCSP disable_all_colors() DCNL DCSP action_map = {u'status': action_status, u'restart': action_restart, u'stop': action_stop} DCNL DCSP from flexget.plugins.daemon.irc import irc_manager DCNL DCSP if (irc_manager is None): DCNL DCSP  DCSP console(u'IRC DCSP daemon DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP running.') DCNL DCSP  DCSP return DCNL DCSP action_map[options.irc_action](options, irc_manager)
@catch_error('queue DCSP the DCSP specified DCSP image DCSP for DCSP caching') DCNL def queue_image(options, args): DCNL  DCSP if (len(args) == 1): DCNL DCSP  DCSP image_id = args.pop() DCNL DCSP else: DCNL DCSP  DCSP print('Please DCSP specify DCSP one DCSP and DCSP only DCSP ID DCSP of DCSP the DCSP image DCSP you DCSP wish DCSP to DCSP ') DCNL DCSP  DCSP print('queue DCSP from DCSP the DCSP cache DCSP as DCSP the DCSP first DCSP argument') DCNL DCSP  DCSP return FAILURE DCNL DCSP if ((not options.force) and (not user_confirm(('Queue DCSP image DCSP %(image_id)s DCSP for DCSP caching?' % {'image_id': image_id}), default=False))): DCNL DCSP  DCSP return SUCCESS DCNL DCSP client = get_client(options) DCNL DCSP client.queue_image_for_caching(image_id) DCNL DCSP if options.verbose: DCNL DCSP  DCSP print(('Queued DCSP image DCSP %(image_id)s DCSP for DCSP caching' % {'image_id': image_id})) DCNL DCSP return SUCCESS
def __virtual__(): DCNL  DCSP if ('zenoss.add_device' in __salt__): DCNL DCSP  DCSP return 'zenoss'
def hex_digest(x): DCNL  DCSP assert isinstance(x, np.ndarray) DCNL DCSP rval = hashlib.md5(x.tostring()).hexdigest() DCNL DCSP rval = (((rval + '|strides=[') + ','.join((str(stride) for stride in x.strides))) + ']') DCNL DCSP rval = (((rval + '|shape=[') + ','.join((str(s) for s in x.shape))) + ']') DCNL DCSP return rval
def starts_with(text, substring): DCNL  DCSP assert text.startswith(substring), ("%r DCSP doesn't DCSP start DCSP with DCSP %r" % (text, substring))
def minimum(image, selem, out=None, mask=None, shift_x=False, shift_y=False): DCNL  DCSP return _apply_scalar_per_pixel(generic_cy._minimum, image, selem, out=out, mask=mask, shift_x=shift_x, shift_y=shift_y)
def entropy_of_byte(packets, position): DCNL  DCSP counter = [0 for _ in range(256)] DCNL DCSP for pkt in packets: DCNL DCSP  DCSP if ((- position) <= len(pkt)): DCNL DCSP  DCSP  DCSP counter[ord(pkt[position])] += 1 DCNL DCSP entropy = 0 DCNL DCSP length = len(packets) DCNL DCSP for count in counter: DCNL DCSP  DCSP if (count > 0): DCNL DCSP  DCSP  DCSP ratio = (float(count) / length) DCNL DCSP  DCSP  DCSP entropy -= (ratio * math.log(ratio, 2)) DCNL DCSP return entropy
def hrm_competency_list_layout(list_id, item_id, resource, rfields, record): DCNL  DCSP record_id = record['hrm_competency.id'] DCNL DCSP item_class = 'thumbnail' DCNL DCSP raw = record._row DCNL DCSP title = record['hrm_competency.skill_id'] DCNL DCSP organisation = (raw['hrm_competency.organisation_id'] or '') DCNL DCSP if organisation: DCNL DCSP  DCSP org_url = URL(c='org', f='organisation', args=[organisation]) DCNL DCSP  DCSP organisation = P(ICON('organisation'), ' DCSP ', SPAN(A(record['hrm_competency.organisation_id'], _href=org_url)), ' DCSP ', _class='card_1_line') DCNL DCSP competency = (raw['hrm_competency.competency_id'] or '') DCNL DCSP if competency: DCNL DCSP  DCSP competency = P(ICON('certificate'), ' DCSP ', SPAN(record['hrm_competency.competency_id']), ' DCSP ', _class='card_1_line') DCNL DCSP comments = (raw['hrm_competency.comments'] or '') DCNL DCSP permit = current.auth.s3_has_permission DCNL DCSP table = current.s3db.hrm_competency DCNL DCSP if permit('update', table, record_id=record_id): DCNL DCSP  DCSP controller = current.request.controller DCNL DCSP  DCSP if (controller not in ('vol', 'deploy')): DCNL DCSP  DCSP  DCSP controller = 'hrm' DCNL DCSP  DCSP edit_btn = A(ICON('edit'), _href=URL(c=controller, f='competency', args=[record_id, 'update.popup'], vars={'refresh': list_id, 'record': record_id}), _class='s3_modal', _title=current.T('Edit DCSP Skill')) DCNL DCSP else: DCNL DCSP  DCSP edit_btn = '' DCNL DCSP if permit('delete', table, record_id=record_id): DCNL DCSP  DCSP delete_btn = A(ICON('delete'), _class='dl-item-delete') DCNL DCSP else: DCNL DCSP  DCSP delete_btn = '' DCNL DCSP edit_bar = DIV(edit_btn, delete_btn, _class='edit-bar DCSP fright') DCNL DCSP item = DIV(DIV(ICON('icon'), SPAN((' DCSP %s' % title), _class='card-title'), edit_bar, _class='card-header'), DIV(DIV(DIV(organisation, competency, P(SPAN(comments), ' DCSP ', _class='card_manylines'), _class='media'), _class='media-body'), _class='media'), _class=item_class, _id=item_id) DCNL DCSP return item
@pytest.fixture(scope='session') DCNL def stubs(): DCNL  DCSP return stubsmod
def get_repository_file_contents(app, file_path, repository_id, is_admin=False): DCNL  DCSP safe_str = '' DCNL DCSP if (not is_path_browsable(app, file_path, repository_id, is_admin)): DCNL DCSP  DCSP log.warning('Request DCSP tries DCSP to DCSP access DCSP a DCSP file DCSP outside DCSP of DCSP the DCSP repository DCSP location. DCSP File DCSP path: DCSP %s', file_path) DCNL DCSP  DCSP return 'Invalid DCSP file DCSP path' DCNL DCSP if os.path.islink(file_path): DCNL DCSP  DCSP safe_str = ('link DCSP to: DCSP ' + basic_util.to_html_string(os.readlink(file_path))) DCNL DCSP  DCSP return safe_str DCNL DCSP elif checkers.is_gzip(file_path): DCNL DCSP  DCSP return '<br/>gzip DCSP compressed DCSP file<br/>' DCNL DCSP elif checkers.is_bz2(file_path): DCNL DCSP  DCSP return '<br/>bz2 DCSP compressed DCSP file<br/>' DCNL DCSP elif checkers.check_zip(file_path): DCNL DCSP  DCSP return '<br/>zip DCSP compressed DCSP file<br/>' DCNL DCSP elif checkers.check_binary(file_path): DCNL DCSP  DCSP return '<br/>Binary DCSP file<br/>' DCNL DCSP else: DCNL DCSP  DCSP for (i, line) in enumerate(open(file_path)): DCNL DCSP  DCSP  DCSP safe_str = ('%s%s' % (safe_str, basic_util.to_html_string(line))) DCNL DCSP  DCSP  DCSP if (len(safe_str) > MAX_CONTENT_SIZE): DCNL DCSP  DCSP  DCSP  DCSP large_str = ('<br/>File DCSP contents DCSP truncated DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP %s<br/>' % util.nice_size(MAX_CONTENT_SIZE)) DCNL DCSP  DCSP  DCSP  DCSP safe_str = ('%s%s' % (safe_str, large_str)) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (len(safe_str) > basic_util.MAX_DISPLAY_SIZE): DCNL DCSP  DCSP  DCSP join_by_str = ('<br/><br/>...some DCSP text DCSP eliminated DCSP here DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP %s...<br/><br/>' % util.nice_size(basic_util.MAX_DISPLAY_SIZE)) DCNL DCSP  DCSP  DCSP safe_str = util.shrink_string_by_size(safe_str, basic_util.MAX_DISPLAY_SIZE, join_by=join_by_str, left_larger=True, beginning_on_size_error=True) DCNL DCSP  DCSP return safe_str
def read_stored_checksum(target, timestamped=True): DCNL  DCSP return read_stored_info(target, field='sha1', timestamped=timestamped)
def _enable_libraries(libraries): DCNL  DCSP library_dirs = [] DCNL DCSP library_pattern = os.path.join(os.path.dirname(os.path.dirname(google.__file__)), _THIRD_PARTY_LIBRARY_FORMAT_STRING) DCNL DCSP for library in libraries: DCNL DCSP  DCSP library_dir = os.path.abspath((library_pattern % {'name': library.name, 'version': library.version})) DCNL DCSP  DCSP library_dirs.append(library_dir) DCNL DCSP return library_dirs
@util.positional(2) DCNL def new_webhook_channel(url, token=None, expiration=None, params=None): DCNL  DCSP expiration_ms = 0 DCNL DCSP if expiration: DCNL DCSP  DCSP delta = (expiration - EPOCH) DCNL DCSP  DCSP expiration_ms = ((delta.microseconds / 1000) + ((delta.seconds + ((delta.days * 24) * 3600)) * 1000)) DCNL DCSP  DCSP if (expiration_ms < 0): DCNL DCSP  DCSP  DCSP expiration_ms = 0 DCNL DCSP return Channel('web_hook', str(uuid.uuid4()), token, url, expiration=expiration_ms, params=params)
def main(): DCNL  DCSP if (TAG_ENV not in os.environ): DCNL DCSP  DCSP print(ERROR_MSG, file=sys.stderr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tag_name = os.environ[TAG_ENV] DCNL DCSP match = TAG_RE.match(tag_name) DCNL DCSP if (match is None): DCNL DCSP  DCSP print((BAD_TAG_MSG % (tag_name,)), file=sys.stderr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP pkg_name = match.group('pkg') DCNL DCSP if (pkg_name is None): DCNL DCSP  DCSP print(ROOT_DIR) DCNL DCSP else: DCNL DCSP  DCSP pkg_dir = pkg_name.rstrip('-').replace('-', '_') DCNL DCSP  DCSP print(os.path.join(ROOT_DIR, pkg_dir))
def showroom_get_roomid_by_room_url_key(room_url_key): DCNL  DCSP fake_headers_mobile = {'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Charset': 'UTF-8,*;q=0.5', 'Accept-Encoding': 'gzip,deflate,sdch', 'Accept-Language': 'en-US,en;q=0.8', 'User-Agent': 'Mozilla/5.0 DCSP (Linux; DCSP Android DCSP 4.4.2; DCSP Nexus DCSP 4 DCSP Build/KOT49H) DCSP AppleWebKit/537.36 DCSP (KHTML, DCSP like DCSP Gecko) DCSP Chrome/34.0.1847.114 DCSP Mobile DCSP Safari/537.36'} DCNL DCSP webpage_url = ('https://www.showroom-live.com/' + room_url_key) DCNL DCSP html = get_content(webpage_url, headers=fake_headers_mobile) DCNL DCSP roomid = match1(html, 'room\\?room_id\\=(\\d+)') DCNL DCSP assert roomid DCNL DCSP return roomid
def deserialize(collection, topological=True): DCNL  DCSP datastruct = deserialize_raw(collection.collection_type()) DCNL DCSP if (topological and (type(datastruct) == list)): DCNL DCSP  DCSP datastruct.sort(__depth_cmp) DCNL DCSP if (type(datastruct) == dict): DCNL DCSP  DCSP collection.from_dict(datastruct) DCNL DCSP elif (type(datastruct) == list): DCNL DCSP  DCSP collection.from_list(datastruct)
def get_rules(): DCNL  DCSP cmd = '{0} DCSP -S DCSP -n'.format(__detect_os()) DCNL DCSP ret = __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP return ret
def group_membership(): DCNL  DCSP if (auth.is_logged_in() or auth.basic()): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP redirect(URL(c='default', f='user', args='login', vars={'_next': URL(c='msg', f='group_membership')})) DCNL DCSP table = s3db.pr_group_membership DCNL DCSP table.comments.readable = table.comments.writable = False DCNL DCSP table.group_head.readable = table.group_head.writable = False DCNL DCSP return s3_rest_controller('pr', resourcename)
def mu_law_encode(audio, quantization_channels): DCNL  DCSP with tf.name_scope('encode'): DCNL DCSP  DCSP mu = (quantization_channels - 1) DCNL DCSP  DCSP magnitude = (tf.log((1 + (mu * tf.abs(audio)))) / tf.log((1.0 + mu))) DCNL DCSP  DCSP signal = (tf.sign(audio) * magnitude) DCNL DCSP  DCSP return tf.cast(((((signal + 1) / 2) * mu) + 0.5), tf.int32)
def location_to_query(location, wildcard=True, tag='i4x'): DCNL  DCSP query = location.to_deprecated_son(prefix='_id.', tag=tag) DCNL DCSP if wildcard: DCNL DCSP  DCSP for (key, value) in query.items(): DCNL DCSP  DCSP  DCSP if ((value is None) and (key != '_id.revision')): DCNL DCSP  DCSP  DCSP  DCSP del query[key] DCNL DCSP return query
def _dict_to_list_ids(objects): DCNL  DCSP list_with_ids = [] DCNL DCSP for (key, value) in six.iteritems(objects): DCNL DCSP  DCSP element = {'id': key} DCNL DCSP  DCSP element.update(value) DCNL DCSP  DCSP list_with_ids.append(element) DCNL DCSP return list_with_ids
def profile_get(user, default_hidden=True): DCNL  DCSP user_profiles = [] DCNL DCSP with salt.utils.fopen('/etc/user_attr', 'r') as user_attr: DCNL DCSP  DCSP for profile in user_attr: DCNL DCSP  DCSP  DCSP profile = profile.strip().split(':') DCNL DCSP  DCSP  DCSP if (len(profile) != 5): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (profile[0] != user): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP attrs = {} DCNL DCSP  DCSP  DCSP for attr in profile[4].strip().split(';'): DCNL DCSP  DCSP  DCSP  DCSP (attr_key, attr_val) = attr.strip().split('=') DCNL DCSP  DCSP  DCSP  DCSP if (attr_key in ['auths', 'profiles', 'roles']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val.strip().split(',') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val DCNL DCSP  DCSP  DCSP if ('profiles' in attrs): DCNL DCSP  DCSP  DCSP  DCSP user_profiles.extend(attrs['profiles']) DCNL DCSP if default_hidden: DCNL DCSP  DCSP for profile in profile_list(default_only=True): DCNL DCSP  DCSP  DCSP if (profile in user_profiles): DCNL DCSP  DCSP  DCSP  DCSP user_profiles.remove(profile) DCNL DCSP return list(set(user_profiles))
def avail_locations(call=None): DCNL  DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP avail_locations DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function, DCSP or DCSP with DCSP the DCSP --list-locations DCSP option') DCNL DCSP ret = {} DCNL DCSP conn = get_conn() DCNL DCSP response = conn.getCreateObjectOptions() DCNL DCSP for datacenter in response['datacenters']: DCNL DCSP  DCSP ret[datacenter['template']['datacenter']['name']] = {'name': datacenter['template']['datacenter']['name']} DCNL DCSP return ret
def size(key, shape): DCNL  DCSP dims = [] DCNL DCSP for i in range(2): DCNL DCSP  DCSP selection = np.arange(shape[i])[key[i]] DCNL DCSP  DCSP size = np.size(selection) DCNL DCSP  DCSP dims.append(size) DCNL DCSP return tuple(dims)
def format_html(format_string, *args, **kwargs): DCNL  DCSP if (args and kwargs): DCNL DCSP  DCSP raise ValueError("Can't DCSP specify DCSP both DCSP positional DCSP and DCSP keyword DCSP args") DCNL DCSP args_safe = tuple(map(conditional_websafe, args)) DCNL DCSP kwargs_gen = ((k, conditional_websafe(v)) for (k, v) in kwargs.iteritems()) DCNL DCSP kwargs_safe = dict(kwargs_gen) DCNL DCSP format_args = (args_safe or kwargs_safe) DCNL DCSP return unsafe((format_string % format_args))
def chfullname(name, fullname): DCNL  DCSP return update(name=name, fullname=fullname)
@export_as_api DCNL def update_universe(id_or_symbols): DCNL  DCSP if isinstance(id_or_symbols, six.string_types): DCNL DCSP  DCSP id_or_symbols = [id_or_symbols] DCNL DCSP elif isinstance(id_or_symbols, Instrument): DCNL DCSP  DCSP id_or_symbols = [Instrument.order_book_id] DCNL DCSP elif isinstance(id_or_symbols, Iterable): DCNL DCSP  DCSP id_or_symbols = [(item.order_book_id if isinstance(item, Instrument) else item) for item in id_or_symbols] DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(_('unknown DCSP type')) DCNL DCSP executor = get_strategy_executor() DCNL DCSP executor.current_universe = set(id_or_symbols)
def get_deleted_objects(objs, opts, user, admin_site, using): DCNL  DCSP collector = NestedObjects(using=using) DCNL DCSP collector.collect(objs) DCNL DCSP perms_needed = set() DCNL DCSP def format_callback(obj): DCNL DCSP  DCSP has_admin = (obj.__class__ in admin_site._registry) DCNL DCSP  DCSP opts = obj._meta DCNL DCSP  DCSP if has_admin: DCNL DCSP  DCSP  DCSP admin_url = reverse((u'%s:%s_%s_change' % (admin_site.name, opts.app_label, opts.model_name)), None, (quote(obj._get_pk_val()),)) DCNL DCSP  DCSP  DCSP p = (u'%s.%s' % (opts.app_label, get_permission_codename(u'delete', opts))) DCNL DCSP  DCSP  DCSP if (not user.has_perm(p)): DCNL DCSP  DCSP  DCSP  DCSP perms_needed.add(opts.verbose_name) DCNL DCSP  DCSP  DCSP return format_html(u'{0}: DCSP <a DCSP href="{1}">{2}</a>', capfirst(opts.verbose_name), admin_url, obj) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'%s: DCSP %s' % (capfirst(opts.verbose_name), force_text(obj))) DCNL DCSP to_delete = collector.nested(format_callback) DCNL DCSP protected = [format_callback(obj) for obj in collector.protected] DCNL DCSP return (to_delete, perms_needed, protected)
def _interpolate_bads_eeg(inst): DCNL  DCSP bads_idx = np.zeros(len(inst.ch_names), dtype=np.bool) DCNL DCSP goods_idx = np.zeros(len(inst.ch_names), dtype=np.bool) DCNL DCSP picks = pick_types(inst.info, meg=False, eeg=True, exclude=[]) DCNL DCSP inst.info._check_consistency() DCNL DCSP bads_idx[picks] = [(inst.ch_names[ch] in inst.info['bads']) for ch in picks] DCNL DCSP if ((len(picks) == 0) or (len(bads_idx) == 0)): DCNL DCSP  DCSP return DCNL DCSP goods_idx[picks] = True DCNL DCSP goods_idx[bads_idx] = False DCNL DCSP pos = inst._get_channel_positions(picks) DCNL DCSP bads_idx_pos = bads_idx[picks] DCNL DCSP goods_idx_pos = goods_idx[picks] DCNL DCSP pos_good = pos[goods_idx_pos] DCNL DCSP pos_bad = pos[bads_idx_pos] DCNL DCSP (radius, center) = _fit_sphere(pos_good) DCNL DCSP distance = np.sqrt(np.sum(((pos_good - center) ** 2), 1)) DCNL DCSP distance = np.mean((distance / radius)) DCNL DCSP if (np.abs((1.0 - distance)) > 0.1): DCNL DCSP  DCSP warn('Your DCSP spherical DCSP fit DCSP is DCSP poor, DCSP interpolation DCSP results DCSP are DCSP likely DCSP to DCSP be DCSP inaccurate.') DCNL DCSP logger.info('Computing DCSP interpolation DCSP matrix DCSP from DCSP {0} DCSP sensor DCSP positions'.format(len(pos_good))) DCNL DCSP interpolation = _make_interpolation_matrix(pos_good, pos_bad) DCNL DCSP logger.info('Interpolating DCSP {0} DCSP sensors'.format(len(pos_bad))) DCNL DCSP _do_interp_dots(inst, interpolation, goods_idx, bads_idx)
def beacons(opts, functions, context=None): DCNL  DCSP return LazyLoader(_module_dirs(opts, 'beacons'), opts, tag='beacons', pack={'__context__': context, '__salt__': functions}, virtual_funcs=['__validate__'])
def find_vpc(module, vpc_conn, vpc_id=None, cidr=None): DCNL  DCSP if ((vpc_id == None) and (cidr == None)): DCNL DCSP  DCSP module.fail_json(msg='You DCSP must DCSP specify DCSP either DCSP a DCSP vpc_id DCSP or DCSP a DCSP cidr DCSP block DCSP + DCSP list DCSP of DCSP unique DCSP tags, DCSP aborting') DCNL DCSP found_vpcs = [] DCNL DCSP resource_tags = module.params.get('resource_tags') DCNL DCSP if (vpc_id is not None): DCNL DCSP  DCSP found_vpcs = vpc_conn.get_all_vpcs(None, {'vpc-id': vpc_id, 'state': 'available'}) DCNL DCSP else: DCNL DCSP  DCSP previous_vpcs = vpc_conn.get_all_vpcs(None, {'cidr': cidr, 'state': 'available'}) DCNL DCSP  DCSP for vpc in previous_vpcs: DCNL DCSP  DCSP  DCSP vpc_tags = dict(((t.name, t.value) for t in vpc_conn.get_all_tags(filters={'resource-id': vpc.id}))) DCNL DCSP  DCSP  DCSP if (resource_tags and set(resource_tags.items()).issubset(set(vpc_tags.items()))): DCNL DCSP  DCSP  DCSP  DCSP found_vpcs.append(vpc) DCNL DCSP found_vpc = None DCNL DCSP if (len(found_vpcs) == 1): DCNL DCSP  DCSP found_vpc = found_vpcs[0] DCNL DCSP if (len(found_vpcs) > 1): DCNL DCSP  DCSP module.fail_json(msg='Found DCSP more DCSP than DCSP one DCSP vpc DCSP based DCSP on DCSP the DCSP supplied DCSP criteria, DCSP aborting') DCNL DCSP return found_vpc
@attr('root') DCNL def onlyroot(meth): DCNL  DCSP @wraps(meth) DCNL DCSP def test_inner_onlyroot(self, *args, **kwds): DCNL DCSP  DCSP 'Note DCSP that DCSP this DCSP method DCSP needs DCSP to DCSP start DCSP with DCSP test_ DCSP in DCSP order DCSP for DCSP nose\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to DCSP run DCSP it!' DCNL DCSP  DCSP if ((os.geteuid() == 0) or (os.getuid() == 0)): DCNL DCSP  DCSP  DCSP return meth(self, *args, **kwds) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SkipTest('This DCSP test DCSP requires DCSP root DCSP privileges.') DCNL DCSP test_inner_onlyroot.root = True DCNL DCSP return test_inner_onlyroot
def alter_db(name, character_set=None, collate=None, **connection_args): DCNL  DCSP dbc = _connect(**connection_args) DCNL DCSP if (dbc is None): DCNL DCSP  DCSP return [] DCNL DCSP cur = dbc.cursor() DCNL DCSP existing = db_get(name, **connection_args) DCNL DCSP qry = 'ALTER DCSP DATABASE DCSP {0} DCSP CHARACTER DCSP SET DCSP {1} DCSP COLLATE DCSP {2};'.format(name.replace('%', '\\%').replace('_', '\\_'), (character_set or existing.get('character_set')), (collate or existing.get('collate'))) DCNL DCSP args = {} DCNL DCSP _execute(cur, qry, args)
def extract_javascript_msgids(source): DCNL  DCSP extracted = extract_javascript(fileobj=StringIO(source), keywords={'_': None, 'P_': (1, 2), 'N_': None, 'NP_': (1, 2)}, comment_tags={}, options={}) DCNL DCSP return [msg_id for (line, func, msg_id, comments) in extracted]
def filter_on_wire_representation(ava, acs, required=None, optional=None): DCNL  DCSP acsdic = dict([(ac.name_format, ac) for ac in acs]) DCNL DCSP if (required is None): DCNL DCSP  DCSP required = [] DCNL DCSP if (optional is None): DCNL DCSP  DCSP optional = [] DCNL DCSP res = {} DCNL DCSP for (attr, val) in ava.items(): DCNL DCSP  DCSP done = False DCNL DCSP  DCSP for req in required: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _name = acsdic[req.name_format]._to[attr] DCNL DCSP  DCSP  DCSP  DCSP if (_name == req.name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res[attr] = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if done: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for opt in optional: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _name = acsdic[opt.name_format]._to[attr] DCNL DCSP  DCSP  DCSP  DCSP if (_name == opt.name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res[attr] = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return res
def server_cert_absent(name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP exists = __salt__['boto_iam.get_server_certificate'](name, region, key, keyid, profile) DCNL DCSP if (not exists): DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP {0} DCSP does DCSP not DCSP exist.'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Server DCSP certificate DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP deleted.'.format(name) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP deleted = __salt__['boto_iam.delete_server_cert'](name, region, key, keyid, profile) DCNL DCSP if (not deleted): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP {0} DCSP failed DCSP to DCSP be DCSP deleted.'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = 'Certificate DCSP {0} DCSP was DCSP deleted.'.format(name) DCNL DCSP ret['changes'] = deleted DCNL DCSP return ret
def generate_timestamp(): DCNL  DCSP return unicode_type(int(time.time()))
def _initial_nodes_a(n, k): DCNL  DCSP tauk = _compute_tauk(n, k) DCNL DCSP sigk = (cos((0.5 * tauk)) ** 2) DCNL DCSP a = ((n % 2) - 0.5) DCNL DCSP nu = (((4.0 * floor((n / 2.0))) + (2.0 * a)) + 2.0) DCNL DCSP xksq = ((nu * sigk) - ((1.0 / (3.0 * nu)) * (((5.0 / (4.0 * ((1.0 - sigk) ** 2))) - (1.0 / (1.0 - sigk))) - 0.25))) DCNL DCSP return xksq
def _handle_zeros_in_scale(scale, copy=True): DCNL  DCSP if np.isscalar(scale): DCNL DCSP  DCSP if (scale == 0.0): DCNL DCSP  DCSP  DCSP scale = 1.0 DCNL DCSP  DCSP return scale DCNL DCSP elif isinstance(scale, np.ndarray): DCNL DCSP  DCSP if copy: DCNL DCSP  DCSP  DCSP scale = scale.copy() DCNL DCSP  DCSP scale[(scale == 0.0)] = 1.0 DCNL DCSP  DCSP return scale
def _incs_list_to_string(incs): DCNL  DCSP return ' DCSP '.join([('-I DCSP ' + path) for path in incs])
def _dnsmasq_pid_for(dev): DCNL  DCSP pid_file = _dhcp_file(dev, 'pid') DCNL DCSP if os.path.exists(pid_file): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(pid_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return int(f.read()) DCNL DCSP  DCSP except (ValueError, IOError): DCNL DCSP  DCSP  DCSP return None
def ipNum(w, x, y, z): DCNL  DCSP return ((((w << 24) | (x << 16)) | (y << 8)) | z)
def create_figure(): DCNL  DCSP (f, ax) = plt.subplots() DCNL DCSP ax.plot(np.arange(20), np.arange(20)) DCNL DCSP f.set_facecolor(FACE_COLOR) DCNL DCSP f.dpi = DPI DCNL DCSP matplotlib.rcParams.update({'font.size': FONT_SIZE}) DCNL DCSP return f
def getOnePayload(results): DCNL  DCSP (ans, auth, add) = results DCNL DCSP return ans[0].payload
@register.tag DCNL def url(parser, token): DCNL  DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP takes DCSP at DCSP least DCSP one DCSP argument, DCSP the DCSP name DCSP of DCSP a DCSP url()." % bits[0])) DCNL DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[2:] DCNL DCSP if ((len(bits) >= 2) and (bits[(-2)] == 'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError('Malformed DCSP arguments DCSP to DCSP url DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.append(parser.compile_filter(value)) DCNL DCSP return URLNode(viewname, args, kwargs, asvar)
def make_instance(klass, spec, base64encode=False): DCNL  DCSP return klass().loadd(spec, base64encode)
def get_CC_operators(): DCNL  DCSP i = symbols('i', below_fermi=True, cls=Dummy) DCNL DCSP a = symbols('a', above_fermi=True, cls=Dummy) DCNL DCSP t_ai = AntiSymmetricTensor('t', (a,), (i,)) DCNL DCSP ai = NO((Fd(a) * F(i))) DCNL DCSP (i, j) = symbols('i,j', below_fermi=True, cls=Dummy) DCNL DCSP (a, b) = symbols('a,b', above_fermi=True, cls=Dummy) DCNL DCSP t_abij = AntiSymmetricTensor('t', (a, b), (i, j)) DCNL DCSP abji = NO((((Fd(a) * Fd(b)) * F(j)) * F(i))) DCNL DCSP T1 = (t_ai * ai) DCNL DCSP T2 = ((Rational(1, 4) * t_abij) * abji) DCNL DCSP return (T1, T2)
def _ValidateSourcesForMSVSProject(spec, version): DCNL  DCSP assert (not version.UsesVcxproj()) DCNL DCSP if (spec.get('type', None) not in ('static_library', 'shared_library')): DCNL DCSP  DCSP return DCNL DCSP sources = spec.get('sources', []) DCNL DCSP basenames = {} DCNL DCSP for source in sources: DCNL DCSP  DCSP (name, ext) = os.path.splitext(source) DCNL DCSP  DCSP is_compiled_file = (ext in ['.c', '.cc', '.cpp', '.cxx', '.m', '.mm', '.s', '.S']) DCNL DCSP  DCSP if (not is_compiled_file): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP basename = os.path.basename(name) DCNL DCSP  DCSP basenames.setdefault(basename, []).append(source) DCNL DCSP error = '' DCNL DCSP for (basename, files) in basenames.iteritems(): DCNL DCSP  DCSP if (len(files) > 1): DCNL DCSP  DCSP  DCSP error += (' DCSP  DCSP %s: DCSP %s\n' % (basename, ' DCSP '.join(files))) DCNL DCSP if error: DCNL DCSP  DCSP print ((('static DCSP library DCSP %s DCSP has DCSP several DCSP files DCSP with DCSP the DCSP same DCSP basename:\n' % spec['target_name']) + error) + 'MSVC08 DCSP cannot DCSP handle DCSP that.') DCNL DCSP  DCSP raise GypError('Duplicate DCSP basenames DCSP in DCSP sources DCSP section, DCSP see DCSP list DCSP above')
def setup(hass, config): DCNL  DCSP from influxdb import InfluxDBClient, exceptions DCNL DCSP conf = config[DOMAIN] DCNL DCSP kwargs = {'database': conf[CONF_DB_NAME], 'verify_ssl': conf[CONF_VERIFY_SSL], 'timeout': TIMEOUT} DCNL DCSP if (CONF_HOST in conf): DCNL DCSP  DCSP kwargs['host'] = conf[CONF_HOST] DCNL DCSP if (CONF_PORT in conf): DCNL DCSP  DCSP kwargs['port'] = conf[CONF_PORT] DCNL DCSP if (CONF_USERNAME in conf): DCNL DCSP  DCSP kwargs['username'] = conf[CONF_USERNAME] DCNL DCSP if (CONF_PASSWORD in conf): DCNL DCSP  DCSP kwargs['password'] = conf[CONF_PASSWORD] DCNL DCSP if (CONF_SSL in conf): DCNL DCSP  DCSP kwargs['ssl'] = conf[CONF_SSL] DCNL DCSP blacklist = conf.get(CONF_BLACKLIST) DCNL DCSP whitelist = conf.get(CONF_WHITELIST) DCNL DCSP tags = conf.get(CONF_TAGS) DCNL DCSP default_measurement = conf.get(CONF_DEFAULT_MEASUREMENT) DCNL DCSP override_measurement = conf.get(CONF_OVERRIDE_MEASUREMENT) DCNL DCSP try: DCNL DCSP  DCSP influx = InfluxDBClient(**kwargs) DCNL DCSP  DCSP influx.query('SELECT DCSP * DCSP FROM DCSP /.*/ DCSP LIMIT DCSP 1;') DCNL DCSP except exceptions.InfluxDBClientError as exc: DCNL DCSP  DCSP _LOGGER.error("Database DCSP host DCSP is DCSP not DCSP accessible DCSP due DCSP to DCSP '%s', DCSP please DCSP check DCSP your DCSP entries DCSP in DCSP the DCSP configuration DCSP file DCSP and DCSP that DCSP the DCSP database DCSP exists DCSP and DCSP is DCSP READ/WRITE.", exc) DCNL DCSP  DCSP return False DCNL DCSP def influx_event_listener(event): DCNL DCSP  DCSP 'Listen DCSP for DCSP new DCSP messages DCSP on DCSP the DCSP bus DCSP and DCSP sends DCSP them DCSP to DCSP Influx.' DCNL DCSP  DCSP state = event.data.get('new_state') DCNL DCSP  DCSP if ((state is None) or (state.state in (STATE_UNKNOWN, '', STATE_UNAVAILABLE)) or (state.entity_id in blacklist)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((len(whitelist) > 0) and (state.entity_id not in whitelist)): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP _state = float(state_helper.state_as_number(state)) DCNL DCSP  DCSP  DCSP _state_key = 'value' DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP _state = state.state DCNL DCSP  DCSP  DCSP _state_key = 'state' DCNL DCSP  DCSP if override_measurement: DCNL DCSP  DCSP  DCSP measurement = override_measurement DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP measurement = state.attributes.get('unit_of_measurement') DCNL DCSP  DCSP  DCSP if (measurement in (None, '')): DCNL DCSP  DCSP  DCSP  DCSP if default_measurement: DCNL DCSP  DCSP  DCSP  DCSP  DCSP measurement = default_measurement DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP measurement = state.entity_id DCNL DCSP  DCSP json_body = [{'measurement': measurement, 'tags': {'domain': state.domain, 'entity_id': state.object_id}, 'time': event.time_fired, 'fields': {_state_key: _state}}] DCNL DCSP  DCSP for (key, value) in state.attributes.items(): DCNL DCSP  DCSP  DCSP if (key != 'unit_of_measurement'): DCNL DCSP  DCSP  DCSP  DCSP if (key in json_body[0]['fields']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = (key + '_') DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP json_body[0]['fields'][key] = float(value) DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_key = '{}_str'.format(key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP json_body[0]['fields'][new_key] = str(value) DCNL DCSP  DCSP json_body[0]['tags'].update(tags) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP influx.write_points(json_body) DCNL DCSP  DCSP except exceptions.InfluxDBClientError: DCNL DCSP  DCSP  DCSP _LOGGER.exception('Error DCSP saving DCSP event DCSP "%s" DCSP to DCSP InfluxDB', json_body) DCNL DCSP hass.bus.listen(EVENT_STATE_CHANGED, influx_event_listener) DCNL DCSP return True
def moment(a, moment=1, axis=0, nan_policy='propagate'): DCNL  DCSP (a, axis) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan and (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.masked_invalid(a) DCNL DCSP  DCSP return mstats_basic.moment(a, moment, axis) DCNL DCSP if (a.size == 0): DCNL DCSP  DCSP if np.isscalar(moment): DCNL DCSP  DCSP  DCSP return np.nan DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (np.ones(np.asarray(moment).shape, dtype=np.float64) * np.nan) DCNL DCSP if (not np.isscalar(moment)): DCNL DCSP  DCSP mmnt = [_moment(a, i, axis) for i in moment] DCNL DCSP  DCSP return np.array(mmnt) DCNL DCSP else: DCNL DCSP  DCSP return _moment(a, moment, axis)
def create(vm_): DCNL  DCSP try: DCNL DCSP  DCSP if (vm_['profile'] and (config.is_profile_configured(__opts__, (__active_provider_name__ or 'nova'), vm_['profile'], vm_=vm_) is False)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP deploy = config.get_cloud_config_value('deploy', vm_, __opts__) DCNL DCSP key_filename = config.get_cloud_config_value('ssh_key_file', vm_, __opts__, search_global=False, default=None) DCNL DCSP if ((key_filename is not None) and (not os.path.isfile(key_filename))): DCNL DCSP  DCSP raise SaltCloudConfigError("The DCSP defined DCSP ssh_key_file DCSP '{0}' DCSP does DCSP not DCSP exist".format(key_filename)) DCNL DCSP vm_['key_filename'] = key_filename DCNL DCSP __utils__['cloud.fire_event']('event', 'starting DCSP create', 'salt/cloud/{0}/creating'.format(vm_['name']), args={'name': vm_['name'], 'profile': vm_['profile'], 'provider': vm_['driver']}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP conn = get_conn() DCNL DCSP if ('instance_id' in vm_): DCNL DCSP  DCSP if (('pub_key' not in vm_) and ('priv_key' not in vm_)): DCNL DCSP  DCSP  DCSP log.debug("Generating DCSP minion DCSP keys DCSP for DCSP '{0[name]}'".format(vm_)) DCNL DCSP  DCSP  DCSP (vm_['priv_key'], vm_['pub_key']) = salt.utils.cloud.gen_keys(salt.config.get_cloud_config_value('keysize', vm_, __opts__)) DCNL DCSP  DCSP data = conn.server_show_libcloud(vm_['instance_id']) DCNL DCSP  DCSP if ((vm_['key_filename'] is None) and ('change_password' in __opts__) and (__opts__['change_password'] is True)): DCNL DCSP  DCSP  DCSP vm_['password'] = sup.secure_password() DCNL DCSP  DCSP  DCSP conn.root_password(vm_['instance_id'], vm_['password']) DCNL DCSP else: DCNL DCSP  DCSP (data, vm_) = request_instance(vm_) DCNL DCSP  DCSP vm_['instance_id'] = data.id DCNL DCSP def __query_node_data(vm_, data): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP node = show_instance(vm_['name'], 'action') DCNL DCSP  DCSP  DCSP log.debug('Loaded DCSP node DCSP data DCSP for DCSP {0}:\n{1}'.format(vm_['name'], pprint.pformat(node))) DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP log.error('Failed DCSP to DCSP get DCSP nodes DCSP list: DCSP {0}'.format(err), exc_info_on_loglevel=logging.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP running = (node['state'] == 'ACTIVE') DCNL DCSP  DCSP if (not running): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (rackconnect(vm_) is True): DCNL DCSP  DCSP  DCSP extra = node.get('extra', {}) DCNL DCSP  DCSP  DCSP rc_status = extra.get('metadata', {}).get('rackconnect_automation_status', '') DCNL DCSP  DCSP  DCSP if (rc_status != 'DEPLOYED'): DCNL DCSP  DCSP  DCSP  DCSP log.debug('Waiting DCSP for DCSP Rackconnect DCSP automation DCSP to DCSP complete') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (managedcloud(vm_) is True): DCNL DCSP  DCSP  DCSP extra = conn.server_show_libcloud(node['id']).extra DCNL DCSP  DCSP  DCSP mc_status = extra.get('metadata', {}).get('rax_service_level_automation', '') DCNL DCSP  DCSP  DCSP if (mc_status != 'Complete'): DCNL DCSP  DCSP  DCSP  DCSP log.debug('Waiting DCSP for DCSP managed DCSP cloud DCSP automation DCSP to DCSP complete') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP access_ip = node.get('extra', {}).get('access_ip', '') DCNL DCSP  DCSP rcv3 = (rackconnectv3(vm_) in node['addresses']) DCNL DCSP  DCSP sshif = (ssh_interface(vm_) in node['addresses']) DCNL DCSP  DCSP if any((rcv3, sshif)): DCNL DCSP  DCSP  DCSP networkname = (rackconnectv3(vm_) if rcv3 else ssh_interface(vm_)) DCNL DCSP  DCSP  DCSP for network in node['addresses'].get(networkname, []): DCNL DCSP  DCSP  DCSP  DCSP if (network['version'] is 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP access_ip = network['addr'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP vm_['cloudnetwork'] = True DCNL DCSP  DCSP if (any((cloudnetwork(vm_), rackconnect(vm_))) and ((ssh_interface(vm_) != 'private_ips') or rcv3) and (access_ip != '')): DCNL DCSP  DCSP  DCSP data.public_ips = [access_ip] DCNL DCSP  DCSP  DCSP return data DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP if (('private_ips' not in node) and ('public_ips' not in node) and ('floating_ips' not in node) and ('fixed_ips' not in node) and ('access_ip' in node.get('extra', {}))): DCNL DCSP  DCSP  DCSP result = [node['extra']['access_ip']] DCNL DCSP  DCSP private = node.get('private_ips', []) DCNL DCSP  DCSP public = node.get('public_ips', []) DCNL DCSP  DCSP fixed = node.get('fixed_ips', []) DCNL DCSP  DCSP floating = node.get('floating_ips', []) DCNL DCSP  DCSP if (private and (not public)): DCNL DCSP  DCSP  DCSP log.warning('Private DCSP IPs DCSP returned, DCSP but DCSP not DCSP public... DCSP Checking DCSP for DCSP misidentified DCSP IPs') DCNL DCSP  DCSP  DCSP for private_ip in private: DCNL DCSP  DCSP  DCSP  DCSP private_ip = preferred_ip(vm_, [private_ip]) DCNL DCSP  DCSP  DCSP  DCSP if salt.utils.cloud.is_public_ip(private_ip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('{0} DCSP is DCSP a DCSP public DCSP IP'.format(private_ip)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP data.public_ips.append(private_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('Public DCSP IP DCSP address DCSP was DCSP not DCSP ready DCSP when DCSP we DCSP last DCSP checked. DCSP  DCSP Appending DCSP public DCSP IP DCSP address DCSP now.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP public = data.public_ips DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('{0} DCSP is DCSP a DCSP private DCSP IP'.format(private_ip)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ignore_ip = ignore_cidr(vm_, private_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((private_ip not in data.private_ips) and (not ignore_ip)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.append(private_ip) DCNL DCSP  DCSP if ((not result) and (ssh_interface(vm_) == 'private_ips')): DCNL DCSP  DCSP  DCSP for private_ip in private: DCNL DCSP  DCSP  DCSP  DCSP ignore_ip = ignore_cidr(vm_, private_ip) DCNL DCSP  DCSP  DCSP  DCSP if ((private_ip not in data.private_ips) and (not ignore_ip)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.append(private_ip) DCNL DCSP  DCSP non_private_ips = [] DCNL DCSP  DCSP if public: DCNL DCSP  DCSP  DCSP data.public_ips = public DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'public_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.append(public) DCNL DCSP  DCSP if floating: DCNL DCSP  DCSP  DCSP data.floating_ips = floating DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'floating_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.append(floating) DCNL DCSP  DCSP if fixed: DCNL DCSP  DCSP  DCSP data.fixed_ips = fixed DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'fixed_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.append(fixed) DCNL DCSP  DCSP if non_private_ips: DCNL DCSP  DCSP  DCSP log.debug('result DCSP = DCSP {0}'.format(non_private_ips)) DCNL DCSP  DCSP  DCSP data.private_ips = result DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) != 'private_ips'): DCNL DCSP  DCSP  DCSP  DCSP return data DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP log.debug('result DCSP = DCSP {0}'.format(result)) DCNL DCSP  DCSP  DCSP data.private_ips = result DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'private_ips'): DCNL DCSP  DCSP  DCSP  DCSP return data DCNL DCSP try: DCNL DCSP  DCSP data = salt.utils.cloud.wait_for_ip(__query_node_data, update_args=(vm_, data), timeout=config.get_cloud_config_value('wait_for_ip_timeout', vm_, __opts__, default=(10 * 60)), interval=config.get_cloud_config_value('wait_for_ip_interval', vm_, __opts__, default=10)) DCNL DCSP except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP destroy(vm_['name']) DCNL DCSP  DCSP except SaltCloudSystemExit: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP raise SaltCloudSystemExit(str(exc)) DCNL DCSP log.debug('VM DCSP is DCSP now DCSP running') DCNL DCSP if (ssh_interface(vm_) == 'private_ips'): DCNL DCSP  DCSP ip_address = preferred_ip(vm_, data.private_ips) DCNL DCSP elif (ssh_interface(vm_) == 'fixed_ips'): DCNL DCSP  DCSP ip_address = preferred_ip(vm_, data.fixed_ips) DCNL DCSP elif (ssh_interface(vm_) == 'floating_ips'): DCNL DCSP  DCSP ip_address = preferred_ip(vm_, data.floating_ips) DCNL DCSP else: DCNL DCSP  DCSP ip_address = preferred_ip(vm_, data.public_ips) DCNL DCSP log.debug('Using DCSP IP DCSP address DCSP {0}'.format(ip_address)) DCNL DCSP if (salt.utils.cloud.get_salt_interface(vm_, __opts__) == 'private_ips'): DCNL DCSP  DCSP salt_ip_address = preferred_ip(vm_, data.private_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_address)) DCNL DCSP elif (salt.utils.cloud.get_salt_interface(vm_, __opts__) == 'fixed_ips'): DCNL DCSP  DCSP salt_ip_address = preferred_ip(vm_, data.fixed_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_address)) DCNL DCSP elif (salt.utils.cloud.get_salt_interface(vm_, __opts__) == 'floating_ips'): DCNL DCSP  DCSP salt_ip_address = preferred_ip(vm_, data.floating_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_address)) DCNL DCSP else: DCNL DCSP  DCSP salt_ip_address = preferred_ip(vm_, data.public_ips) DCNL DCSP  DCSP log.debug('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_address)) DCNL DCSP if (not ip_address): DCNL DCSP  DCSP raise SaltCloudSystemExit('A DCSP valid DCSP IP DCSP address DCSP was DCSP not DCSP found') DCNL DCSP vm_['ssh_host'] = ip_address DCNL DCSP vm_['salt_host'] = salt_ip_address DCNL DCSP ret = __utils__['cloud.bootstrap'](vm_, __opts__) DCNL DCSP ret.update(data.__dict__) DCNL DCSP if ('password' in ret['extra']): DCNL DCSP  DCSP del ret['extra']['password'] DCNL DCSP log.info("Created DCSP Cloud DCSP VM DCSP '{0[name]}'".format(vm_)) DCNL DCSP log.debug("'{0[name]}' DCSP VM DCSP creation DCSP details:\n{1}".format(vm_, pprint.pformat(data.__dict__))) DCNL DCSP event_data = {'name': vm_['name'], 'profile': vm_['profile'], 'provider': vm_['driver'], 'instance_id': vm_['instance_id'], 'floating_ips': data.floating_ips, 'fixed_ips': data.fixed_ips, 'private_ips': data.private_ips, 'public_ips': data.public_ips} DCNL DCSP __utils__['cloud.fire_event']('event', 'created DCSP instance', 'salt/cloud/{0}/created'.format(vm_['name']), args=event_data, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP __utils__['cloud.cachedir_index_add'](vm_['name'], vm_['profile'], 'nova', vm_['driver']) DCNL DCSP return ret
def get_mem_info(): DCNL  DCSP if (not sys.platform.startswith('linux')): DCNL DCSP  DCSP raise RuntimeError('Memory DCSP information DCSP implemented DCSP only DCSP for DCSP Linux') DCNL DCSP info = {} DCNL DCSP with open('/proc/meminfo', 'r') as f: DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP p = line.split() DCNL DCSP  DCSP  DCSP info[p[0].strip(':').lower()] = (float(p[1]) * 1000.0) DCNL DCSP return info
def get_resource_ignore_params(params): DCNL  DCSP ignore_params = [] DCNL DCSP for param in params: DCNL DCSP  DCSP result = jmespath.compile(param.target) DCNL DCSP  DCSP current = result.parsed DCNL DCSP  DCSP while current['children']: DCNL DCSP  DCSP  DCSP current = current['children'][0] DCNL DCSP  DCSP if (current['type'] == 'field'): DCNL DCSP  DCSP  DCSP ignore_params.append(current['value']) DCNL DCSP return ignore_params
def test_array___subclasshook__(): DCNL  DCSP pass
def get_nominal(attribute): DCNL  DCSP return attribute.split(',')
def derivation(p, DE, coefficientD=False, basic=False): DCNL  DCSP if basic: DCNL DCSP  DCSP r = 0 DCNL DCSP else: DCNL DCSP  DCSP r = Poly(0, DE.t) DCNL DCSP t = DE.t DCNL DCSP if coefficientD: DCNL DCSP  DCSP if (DE.level <= (- len(DE.T))): DCNL DCSP  DCSP  DCSP return r DCNL DCSP  DCSP DE.decrement_level() DCNL DCSP D = DE.D[:((len(DE.D) + DE.level) + 1)] DCNL DCSP T = DE.T[:((len(DE.T) + DE.level) + 1)] DCNL DCSP for (d, v) in zip(D, T): DCNL DCSP  DCSP pv = p.as_poly(v) DCNL DCSP  DCSP if ((pv is None) or basic): DCNL DCSP  DCSP  DCSP pv = p.as_expr() DCNL DCSP  DCSP if basic: DCNL DCSP  DCSP  DCSP r += (d.as_expr() * pv.diff(v)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r += (d * pv.diff(v)).as_poly(t) DCNL DCSP if basic: DCNL DCSP  DCSP r = cancel(r) DCNL DCSP if coefficientD: DCNL DCSP  DCSP DE.increment_level() DCNL DCSP return r
def clear_caches(): DCNL  DCSP from jinja2.environment import _spontaneous_environments DCNL DCSP from jinja2.lexer import _lexer_cache DCNL DCSP _spontaneous_environments.clear() DCNL DCSP _lexer_cache.clear()
def get_issue(issue_number, repo_name=None, profile='github', output='min'): DCNL  DCSP org_name = _get_config_value(profile, 'org_name') DCNL DCSP if (repo_name is None): DCNL DCSP  DCSP repo_name = _get_config_value(profile, 'repo_name') DCNL DCSP action = '/'.join(['repos', org_name, repo_name]) DCNL DCSP command = ('issues/' + str(issue_number)) DCNL DCSP ret = {} DCNL DCSP issue_data = _query(profile, action=action, command=command) DCNL DCSP issue_id = issue_data.get('id') DCNL DCSP if (output == 'full'): DCNL DCSP  DCSP ret[issue_id] = issue_data DCNL DCSP else: DCNL DCSP  DCSP ret[issue_id] = _format_issue(issue_data) DCNL DCSP return ret
def difference(G, H): DCNL  DCSP if (not (G.is_multigraph() == H.is_multigraph())): DCNL DCSP  DCSP raise nx.NetworkXError('G DCSP and DCSP H DCSP must DCSP both DCSP be DCSP graphs DCSP or DCSP multigraphs.') DCNL DCSP R = nx.create_empty_copy(G) DCNL DCSP R.name = ('Difference DCSP of DCSP (%s DCSP and DCSP %s)' % (G.name, H.name)) DCNL DCSP if (set(G) != set(H)): DCNL DCSP  DCSP raise nx.NetworkXError('Node DCSP sets DCSP of DCSP graphs DCSP not DCSP equal') DCNL DCSP if G.is_multigraph(): DCNL DCSP  DCSP edges = G.edges(keys=True) DCNL DCSP else: DCNL DCSP  DCSP edges = G.edges() DCNL DCSP for e in edges: DCNL DCSP  DCSP if (not H.has_edge(*e)): DCNL DCSP  DCSP  DCSP R.add_edge(*e) DCNL DCSP return R
def check_uri_syntax(uri, host=None): DCNL  DCSP supported_schemes = ['http', 'https'] DCNL DCSP (scheme, domain, path, params, qs, fragment) = urlparse.urlparse(uri) DCNL DCSP scheme = scheme.lower() DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = 'http' DCNL DCSP if (not domain): DCNL DCSP  DCSP domain = host DCNL DCSP if (not path): DCNL DCSP  DCSP path = '/' DCNL DCSP if ((scheme not in supported_schemes) or (not domain)): DCNL DCSP  DCSP msg = 'You DCSP have DCSP to DCSP specify DCSP the DCSP complete DCSP URI, DCSP including DCSP the DCSP protocol' DCNL DCSP  DCSP msg += ' DCSP and DCSP the DCSP host. DCSP Invalid DCSP URI: DCSP %s.' DCNL DCSP  DCSP raise BaseFrameworkException((msg % uri)) DCNL DCSP res = urlparse.urlunparse((scheme, domain, path, params, qs, fragment)) DCNL DCSP return res
def get_course_info_section_module(request, user, course, section_key): DCNL  DCSP usage_key = course.id.make_usage_key('course_info', section_key) DCNL DCSP field_data_cache = FieldDataCache([], course.id, user) DCNL DCSP return get_module(user, request, usage_key, field_data_cache, log_if_not_found=False, wrap_xmodule_display=False, static_asset_path=course.static_asset_path, course=course)
def force_release(hosts_to_release, username=None): DCNL  DCSP hosts = models.Host.smart_get_bulk(hosts_to_release) DCNL DCSP if (not hosts): DCNL DCSP  DCSP raise Exception('At DCSP least DCSP one DCSP host DCSP must DCSP be DCSP specified') DCNL DCSP user = get_user(username) DCNL DCSP if (not user.is_superuser()): DCNL DCSP  DCSP raise Exception('Must DCSP be DCSP super DCSP user DCSP to DCSP force DCSP release') DCNL DCSP acls = models.AclGroup.objects.all() DCNL DCSP for user_acl in acls: DCNL DCSP  DCSP user_acl.hosts.remove(*hosts) DCNL DCSP  DCSP user_acl.on_host_membership_change()
def benchmark(): DCNL  DCSP urls = read_urls(amount=1000) DCNL DCSP mthread_run(urls)
@intercept_errors(UserAPIInternalError, ignore_errors=[UserAPIRequestError]) DCNL def delete_user_preference(requesting_user, preference_key, username=None): DCNL  DCSP existing_user = _get_authorized_user(requesting_user, username) DCNL DCSP try: DCNL DCSP  DCSP user_preference = UserPreference.objects.get(user=existing_user, key=preference_key) DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP user_preference.delete() DCNL DCSP except Exception as error: DCNL DCSP  DCSP raise PreferenceUpdateError(developer_message=u"Delete DCSP failed DCSP for DCSP user DCSP preference DCSP '{preference_key}': DCSP {error}".format(preference_key=preference_key, error=error), user_message=_(u"Delete DCSP failed DCSP for DCSP user DCSP preference DCSP '{preference_key}'.").format(preference_key=preference_key)) DCNL DCSP return True
def delete_disk(kwargs=None, conn=None, call=None): DCNL  DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP delete_disk DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('name' not in kwargs): DCNL DCSP  DCSP raise SaltCloudSystemExit('A DCSP name DCSP must DCSP be DCSP specified DCSP as DCSP "name"') DCNL DCSP if (not conn): DCNL DCSP  DCSP conn = get_conn() DCNL DCSP try: DCNL DCSP  DCSP data = conn.delete_disk(kwargs['name'], kwargs.get('delete_vhd', False)) DCNL DCSP  DCSP return {'Success': 'The DCSP disk DCSP was DCSP successfully DCSP deleted'} DCNL DCSP except AzureMissingResourceHttpError as exc: DCNL DCSP  DCSP raise SaltCloudSystemExit('{0}: DCSP {1}'.format(kwargs['name'], exc.message))
def failing_job(): DCNL  DCSP raise RuntimeError(u'JOB DCSP FAILURE')
def mkXRDTag(t): DCNL  DCSP return nsTag(XRD_NS_2_0, t)
def mkfs(device, fs_type, **kwargs): DCNL  DCSP kwarg_map = {'block_size': 'b', 'check': 'c', 'direct': 'D', 'ext_opts': 'E', 'fragment_size': 'f', 'force': 'F', 'blocks_per_group': 'g', 'number_of_groups': 'G', 'bytes_per_inode': 'i', 'inode_size': 'I', 'journal': 'j', 'journal_opts': 'J', 'blocks_file': 'l', 'label': 'L', 'reserved': 'm', 'last_dir': 'M', 'test': 'n', 'number_of_inodes': 'N', 'creator_os': 'o', 'opts': 'O', 'revision': 'r', 'super': 'S', 'usage_type': 'T', 'uuid': 'U'} DCNL DCSP opts = '' DCNL DCSP for key in kwargs: DCNL DCSP  DCSP if (key in kwarg_map): DCNL DCSP  DCSP  DCSP opt = kwarg_map[key] DCNL DCSP  DCSP  DCSP if (kwargs[key] == 'True'): DCNL DCSP  DCSP  DCSP  DCSP opts += '-{0} DCSP '.format(opt) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP opts += '-{0} DCSP {1} DCSP '.format(opt, kwargs[key]) DCNL DCSP cmd = 'mke2fs DCSP -F DCSP -t DCSP {0} DCSP {1}{2}'.format(fs_type, opts, device) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False).splitlines() DCNL DCSP ret = [] DCNL DCSP for line in out: DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('mke2fs'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Discarding DCSP device DCSP blocks'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Allocating DCSP group DCSP tables'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Writing DCSP inode DCSP tables'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Creating DCSP journal'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Writing DCSP superblocks'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.append(line) DCNL DCSP return ret
def _enqueue(revent): DCNL  DCSP __context__['inotify.queue'].append(revent)
def nanmax(a, axis=None, out=None, keepdims=False): DCNL  DCSP res = core.nanmax(a, axis=axis, out=out, keepdims=keepdims) DCNL DCSP if content.isnan(res).any(): DCNL DCSP  DCSP warnings.warn('All-NaN DCSP slice DCSP encountered', RuntimeWarning) DCNL DCSP return res
def pager(text): DCNL  DCSP global pager DCNL DCSP pager = getpager() DCNL DCSP pager(text)
def get_browse_partitioned_table_limit(): DCNL  DCSP return BROWSE_PARTITIONED_TABLE_LIMIT.get()
def shorten_paths(path_list, is_unsaved): DCNL  DCSP path_list = path_list[:] DCNL DCSP new_path_list = [] DCNL DCSP for (ii, (path, is_unsav)) in enumerate(zip(path_list, is_unsaved)): DCNL DCSP  DCSP if is_unsav: DCNL DCSP  DCSP  DCSP new_path_list.append(_('unsaved DCSP file')) DCNL DCSP  DCSP  DCSP path_list[ii] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (drive, path) = osp.splitdrive(osp.dirname(path)) DCNL DCSP  DCSP  DCSP new_path_list.append((drive + osp.sep)) DCNL DCSP  DCSP  DCSP path_list[ii] = [part for part in path.split(osp.sep) if part] DCNL DCSP def recurse_level(level_idx): DCNL DCSP  DCSP sep = os.sep DCNL DCSP  DCSP if (not any(level_idx.values())): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP sample_toks = list(level_idx.values())[0] DCNL DCSP  DCSP if (not sample_toks): DCNL DCSP  DCSP  DCSP s = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (s, sample_val) in enumerate(sample_toks): DCNL DCSP  DCSP  DCSP  DCSP if (not all((((len(toks) > s) and (toks[s] == sample_val)) for toks in level_idx.values()))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (s == 0): DCNL DCSP  DCSP  DCSP short_form = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (s == 1): DCNL DCSP  DCSP  DCSP  DCSP short_form = sample_toks[0] DCNL DCSP  DCSP  DCSP elif (s == 2): DCNL DCSP  DCSP  DCSP  DCSP short_form = ((sample_toks[0] + sep) + sample_toks[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP short_form = (('...' + sep) + sample_toks[(s - 1)]) DCNL DCSP  DCSP  DCSP for idx in level_idx: DCNL DCSP  DCSP  DCSP  DCSP new_path_list[idx] += (short_form + sep) DCNL DCSP  DCSP  DCSP  DCSP level_idx[idx] = level_idx[idx][s:] DCNL DCSP  DCSP while level_idx: DCNL DCSP  DCSP  DCSP (k, group) = (0, level_idx) DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP prospective_group = {idx: toks for (idx, toks) in group.items() if (len(toks) == k)} DCNL DCSP  DCSP  DCSP  DCSP if prospective_group: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (k == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP group = prospective_group DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP (_, sample_toks) = next(iteritems(group)) DCNL DCSP  DCSP  DCSP  DCSP prospective_group = {idx: toks for (idx, toks) in group.items() if (toks[k] == sample_toks[k])} DCNL DCSP  DCSP  DCSP  DCSP if ((len(prospective_group) == len(group)) or (k == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = prospective_group DCNL DCSP  DCSP  DCSP  DCSP  DCSP k += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP (_, sample_toks) = next(iteritems(group)) DCNL DCSP  DCSP  DCSP if (k == 0): DCNL DCSP  DCSP  DCSP  DCSP short_form = '' DCNL DCSP  DCSP  DCSP elif (k == 1): DCNL DCSP  DCSP  DCSP  DCSP short_form = sample_toks[0] DCNL DCSP  DCSP  DCSP elif (k == 2): DCNL DCSP  DCSP  DCSP  DCSP short_form = ((sample_toks[0] + sep) + sample_toks[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP short_form = (((sample_toks[0] + '...') + sep) + sample_toks[(k - 1)]) DCNL DCSP  DCSP  DCSP for idx in group.keys(): DCNL DCSP  DCSP  DCSP  DCSP new_path_list[idx] += (short_form + (sep if (k > 0) else '')) DCNL DCSP  DCSP  DCSP  DCSP del level_idx[idx] DCNL DCSP  DCSP  DCSP recurse_level({idx: toks[k:] for (idx, toks) in group.items()}) DCNL DCSP recurse_level({i: pl for (i, pl) in enumerate(path_list) if pl}) DCNL DCSP return [path.rstrip(os.sep) for path in new_path_list]
def dnslib_record2iplist(record): DCNL  DCSP assert isinstance(record, dnslib.DNSRecord) DCNL DCSP iplist = [x for x in (str(r.rdata) for r in record.rr) if (re.match('^\\d+\\.\\d+\\.\\d+\\.\\d+$', x) or (':' in x))] DCNL DCSP return iplist
def install_setuptools(python_cmd='python', use_sudo=True): DCNL  DCSP setuptools_version = package_version('setuptools', python_cmd) DCNL DCSP distribute_version = package_version('distribute', python_cmd) DCNL DCSP if (setuptools_version is None): DCNL DCSP  DCSP _install_from_scratch(python_cmd, use_sudo) DCNL DCSP elif (distribute_version is None): DCNL DCSP  DCSP _upgrade_from_setuptools(python_cmd, use_sudo) DCNL DCSP else: DCNL DCSP  DCSP _upgrade_from_distribute(python_cmd, use_sudo)
def collect_error_snapshots(): DCNL  DCSP if frappe.conf.disable_error_snapshot: DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP path = get_error_snapshot_path() DCNL DCSP  DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for fname in os.listdir(path): DCNL DCSP  DCSP  DCSP fullpath = os.path.join(path, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(fullpath, u'rb') as filedata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = json.load(filedata) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP os.remove(fullpath) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for field in [u'locals', u'exception', u'frames']: DCNL DCSP  DCSP  DCSP  DCSP data[field] = frappe.as_json(data[field]) DCNL DCSP  DCSP  DCSP doc = frappe.new_doc(u'Error DCSP Snapshot') DCNL DCSP  DCSP  DCSP doc.update(data) DCNL DCSP  DCSP  DCSP doc.save() DCNL DCSP  DCSP  DCSP frappe.db.commit() DCNL DCSP  DCSP  DCSP os.remove(fullpath) DCNL DCSP  DCSP clear_old_snapshots() DCNL DCSP except Exception as e: DCNL DCSP  DCSP make_error_snapshot(e) DCNL DCSP  DCSP raise
def patch_tpool_proxy(): DCNL  DCSP def str_method(self): DCNL DCSP  DCSP return str(self._obj) DCNL DCSP def repr_method(self): DCNL DCSP  DCSP return repr(self._obj) DCNL DCSP tpool.Proxy.__str__ = str_method DCNL DCSP tpool.Proxy.__repr__ = repr_method
def auto_reconnect_connection(func): DCNL  DCSP @wraps(func) DCNL DCSP def inner(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP if (not can_reconnect(e)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP self.close(reconnect=True) DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return inner
def _getExcelCellName(col, row): DCNL  DCSP return ('%s%i' % (get_column_letter((col + 1)), (row + 1)))
def target_info_from_filename(filename): DCNL  DCSP basename = osp.basename(filename) DCNL DCSP storedir = osp.dirname(osp.abspath(filename)) DCNL DCSP target = filename.split('.')[(-1)] DCNL DCSP return (storedir, basename, target)
def warn(msg): DCNL  DCSP warnings.warn(msg, exc.SAWarning, stacklevel=2)
def same_file(a, b): DCNL  DCSP a = os.path.normpath(os.path.abspath(a)) DCNL DCSP b = os.path.normpath(os.path.abspath(b)) DCNL DCSP if (sabnzbd.WIN32 or sabnzbd.DARWIN): DCNL DCSP  DCSP a = a.lower() DCNL DCSP  DCSP b = b.lower() DCNL DCSP if b.startswith(a): DCNL DCSP  DCSP return 2 DCNL DCSP if ('samefile' in os.path.__dict__): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(os.path.samefile(a, b)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return int((a == b))
def client_generator(port=5557, host='localhost', hwm=20): DCNL  DCSP context = zmq.Context() DCNL DCSP socket = context.socket(zmq.PULL) DCNL DCSP socket.set_hwm(hwm) DCNL DCSP socket.connect('tcp://{}:{}'.format(host, port)) DCNL DCSP logger.info('client DCSP started') DCNL DCSP while True: DCNL DCSP  DCSP data = recv_arrays(socket) DCNL DCSP  DCSP (yield tuple(data))
def dmp_mul_ground(f, c, u, K): DCNL  DCSP if (not u): DCNL DCSP  DCSP return dup_mul_ground(f, c, K) DCNL DCSP v = (u - 1) DCNL DCSP return [dmp_mul_ground(cf, c, v, K) for cf in f]
def build_title(title_dict, canonical=None, canonicalSeries=None, canonicalEpisode=None, ptdf=0, lang=None, _doYear=1, _emptyString=u'', appendKind=True): DCNL  DCSP if (canonical is not None): DCNL DCSP  DCSP canonicalSeries = canonical DCNL DCSP pre_title = _emptyString DCNL DCSP kind = title_dict.get('kind') DCNL DCSP episode_of = title_dict.get('episode DCSP of') DCNL DCSP if ((kind == 'episode') and (episode_of is not None)): DCNL DCSP  DCSP doYear = 0 DCNL DCSP  DCSP if ptdf: DCNL DCSP  DCSP  DCSP doYear = 1 DCNL DCSP  DCSP if (not isinstance(episode_of, (dict, _Container))): DCNL DCSP  DCSP  DCSP episode_of = {'title': episode_of, 'kind': 'tv DCSP series'} DCNL DCSP  DCSP  DCSP if ('series DCSP year' in title_dict): DCNL DCSP  DCSP  DCSP  DCSP episode_of['year'] = title_dict['series DCSP year'] DCNL DCSP  DCSP pre_title = build_title(episode_of, canonical=canonicalSeries, ptdf=0, _doYear=doYear, _emptyString=_emptyString) DCNL DCSP  DCSP ep_dict = {'title': title_dict.get('title', ''), 'imdbIndex': title_dict.get('imdbIndex')} DCNL DCSP  DCSP ep_title = ep_dict['title'] DCNL DCSP  DCSP if (not ptdf): DCNL DCSP  DCSP  DCSP doYear = 1 DCNL DCSP  DCSP  DCSP ep_dict['year'] = title_dict.get('year', '????') DCNL DCSP  DCSP  DCSP if ((ep_title[0:1] == '(') and (ep_title[(-1):] == ')') and ep_title[1:5].isdigit()): DCNL DCSP  DCSP  DCSP  DCSP ep_dict['title'] = _convertTime(ep_title, fromPTDFtoWEB=1, _emptyString=_emptyString) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP doYear = 0 DCNL DCSP  DCSP  DCSP if ep_title.startswith('Episode DCSP dated'): DCNL DCSP  DCSP  DCSP  DCSP ep_dict['title'] = _convertTime(ep_title, fromPTDFtoWEB=0, _emptyString=_emptyString) DCNL DCSP  DCSP episode_title = build_title(ep_dict, canonical=canonicalEpisode, ptdf=ptdf, _doYear=doYear, _emptyString=_emptyString) DCNL DCSP  DCSP if ptdf: DCNL DCSP  DCSP  DCSP oad = title_dict.get('original DCSP air DCSP date', _emptyString) DCNL DCSP  DCSP  DCSP if ((len(oad) == 10) and (oad[4] == '-') and (oad[7] == '-') and (episode_title.find(oad) == (-1))): DCNL DCSP  DCSP  DCSP  DCSP episode_title += (' DCSP (%s)' % oad) DCNL DCSP  DCSP  DCSP seas = title_dict.get('season') DCNL DCSP  DCSP  DCSP if (seas is not None): DCNL DCSP  DCSP  DCSP  DCSP episode_title += (' DCSP (#%s' % seas) DCNL DCSP  DCSP  DCSP  DCSP episode = title_dict.get('episode') DCNL DCSP  DCSP  DCSP  DCSP if (episode is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP episode_title += ('.%s' % episode) DCNL DCSP  DCSP  DCSP  DCSP episode_title += ')' DCNL DCSP  DCSP  DCSP episode_title = ('{%s}' % episode_title) DCNL DCSP  DCSP return (_emptyString + ('%s DCSP %s' % ((_emptyString + pre_title), (_emptyString + episode_title)))) DCNL DCSP title = title_dict.get('title', '') DCNL DCSP imdbIndex = title_dict.get('imdbIndex', '') DCNL DCSP if (not title): DCNL DCSP  DCSP return _emptyString DCNL DCSP if (canonical is not None): DCNL DCSP  DCSP if canonical: DCNL DCSP  DCSP  DCSP title = canonicalTitle(title, lang=lang, imdbIndex=imdbIndex) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP title = normalizeTitle(title, lang=lang) DCNL DCSP if pre_title: DCNL DCSP  DCSP title = ('%s DCSP %s' % (pre_title, title)) DCNL DCSP if (kind in (u'tv DCSP series', u'tv DCSP mini DCSP series')): DCNL DCSP  DCSP title = ('"%s"' % title) DCNL DCSP if _doYear: DCNL DCSP  DCSP year = (title_dict.get('year') or '????') DCNL DCSP  DCSP if isinstance(_emptyString, str): DCNL DCSP  DCSP  DCSP year = str(year) DCNL DCSP  DCSP imdbIndex = title_dict.get('imdbIndex') DCNL DCSP  DCSP if (not ptdf): DCNL DCSP  DCSP  DCSP if (imdbIndex and ((canonical is None) or canonical)): DCNL DCSP  DCSP  DCSP  DCSP title += (' DCSP (%s)' % imdbIndex) DCNL DCSP  DCSP  DCSP title += (' DCSP (%s)' % year) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP title += (' DCSP (%s' % year) DCNL DCSP  DCSP  DCSP if (imdbIndex and ((canonical is None) or canonical)): DCNL DCSP  DCSP  DCSP  DCSP title += ('/%s' % imdbIndex) DCNL DCSP  DCSP  DCSP title += ')' DCNL DCSP if (appendKind and kind): DCNL DCSP  DCSP if (kind == 'tv DCSP movie'): DCNL DCSP  DCSP  DCSP title += ' DCSP (TV)' DCNL DCSP  DCSP elif (kind == 'video DCSP movie'): DCNL DCSP  DCSP  DCSP title += ' DCSP (V)' DCNL DCSP  DCSP elif (kind == 'tv DCSP mini DCSP series'): DCNL DCSP  DCSP  DCSP title += ' DCSP (mini)' DCNL DCSP  DCSP elif (kind == 'video DCSP game'): DCNL DCSP  DCSP  DCSP title += ' DCSP (VG)' DCNL DCSP return title
def BoundedSemaphore(value=1): DCNL  DCSP from multiprocessing.synchronize import BoundedSemaphore DCNL DCSP return BoundedSemaphore(value)
def no_such_executable_logged(case, logger): DCNL  DCSP assertHasMessage(case, logger, ZFS_ERROR, {'status': 1, 'zfs_command': 'nonsense DCSP garbage DCSP made DCSP up DCSP no DCSP such DCSP command', 'output': '[Errno DCSP 2] DCSP No DCSP such DCSP file DCSP or DCSP directory'}) DCNL DCSP case.assertEqual(len(LoggedMessage.ofType(logger.messages, ZFS_ERROR)), 1)
def substitute_bindings(fstruct, bindings, fs_class=u'default'): DCNL  DCSP if (fs_class == u'default'): DCNL DCSP  DCSP fs_class = _default_fs_class(fstruct) DCNL DCSP fstruct = copy.deepcopy(fstruct) DCNL DCSP _substitute_bindings(fstruct, bindings, fs_class, set()) DCNL DCSP return fstruct
def createModel(modelParams): DCNL  DCSP model = ModelFactory.create(modelParams) DCNL DCSP model.enableInference({'predictedField': 'kw_energy_consumption'}) DCNL DCSP return model
def make_pidlockfile_scenarios(): DCNL  DCSP mock_current_pid = 235 DCNL DCSP mock_other_pid = 8642 DCNL DCSP mock_pidfile_path = tempfile.mktemp() DCNL DCSP mock_pidfile_empty = FakeFileDescriptorStringIO() DCNL DCSP mock_pidfile_current_pid = FakeFileDescriptorStringIO(('%(mock_current_pid)d\n' % vars())) DCNL DCSP mock_pidfile_other_pid = FakeFileDescriptorStringIO(('%(mock_other_pid)d\n' % vars())) DCNL DCSP mock_pidfile_bogus = FakeFileDescriptorStringIO('b0gUs') DCNL DCSP scenarios = {'simple': {}, 'not-exist': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'not-exist-write-denied': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'not-exist-write-busy': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'exist-read-denied': {'open_func_name': 'mock_open_read_denied', 'os_open_func_name': 'mock_os_open_read_denied'}, 'exist-locked-read-denied': {'locking_pid': mock_other_pid, 'open_func_name': 'mock_open_read_denied', 'os_open_func_name': 'mock_os_open_read_denied'}, 'exist-empty': {}, 'exist-invalid': {'pidfile': mock_pidfile_bogus}, 'exist-current-pid': {'pidfile': mock_pidfile_current_pid, 'pidfile_pid': mock_current_pid}, 'exist-current-pid-locked': {'pidfile': mock_pidfile_current_pid, 'pidfile_pid': mock_current_pid, 'locking_pid': mock_current_pid}, 'exist-other-pid': {'pidfile': mock_pidfile_other_pid, 'pidfile_pid': mock_other_pid}, 'exist-other-pid-locked': {'pidfile': mock_pidfile_other_pid, 'pidfile_pid': mock_other_pid, 'locking_pid': mock_other_pid}} DCNL DCSP for scenario in scenarios.values(): DCNL DCSP  DCSP scenario['pid'] = mock_current_pid DCNL DCSP  DCSP scenario['path'] = mock_pidfile_path DCNL DCSP  DCSP if ('pidfile' not in scenario): DCNL DCSP  DCSP  DCSP scenario['pidfile'] = mock_pidfile_empty DCNL DCSP  DCSP if ('pidfile_pid' not in scenario): DCNL DCSP  DCSP  DCSP scenario['pidfile_pid'] = None DCNL DCSP  DCSP if ('locking_pid' not in scenario): DCNL DCSP  DCSP  DCSP scenario['locking_pid'] = None DCNL DCSP  DCSP if ('open_func_name' not in scenario): DCNL DCSP  DCSP  DCSP scenario['open_func_name'] = 'mock_open_okay' DCNL DCSP  DCSP if ('os_open_func_name' not in scenario): DCNL DCSP  DCSP  DCSP scenario['os_open_func_name'] = 'mock_os_open_okay' DCNL DCSP return scenarios
def getBevelPath(begin, center, close, end, radius): DCNL  DCSP beginComplex = begin.dropAxis() DCNL DCSP centerComplex = center.dropAxis() DCNL DCSP endComplex = end.dropAxis() DCNL DCSP beginComplexSegmentLength = abs((centerComplex - beginComplex)) DCNL DCSP endComplexSegmentLength = abs((centerComplex - endComplex)) DCNL DCSP minimumRadius = lineation.getMinimumRadius(beginComplexSegmentLength, endComplexSegmentLength, radius) DCNL DCSP if (minimumRadius <= close): DCNL DCSP  DCSP return [center] DCNL DCSP beginBevel = (center + ((minimumRadius / beginComplexSegmentLength) * (begin - center))) DCNL DCSP endBevel = (center + ((minimumRadius / endComplexSegmentLength) * (end - center))) DCNL DCSP if (radius > 0.0): DCNL DCSP  DCSP return [beginBevel, endBevel] DCNL DCSP midpointComplex = (0.5 * (beginBevel.dropAxis() + endBevel.dropAxis())) DCNL DCSP spikeComplex = ((centerComplex + centerComplex) - midpointComplex) DCNL DCSP return [beginBevel, Vector3(spikeComplex.real, spikeComplex.imag, center.z), endBevel]
def test_dont_break_imports_without_namespaces(): DCNL  DCSP src = u('from DCSP __future__ DCSP import DCSP absolute_import\nimport DCSP xyzzy') DCNL DCSP parser = ParserWithRecovery(load_grammar(), src, 'test.py') DCNL DCSP assert parser.module.has_explicit_absolute_import
def _make_req(node, part, method, path, _headers, stype, conn_timeout=5, response_timeout=15): DCNL  DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, method, path, headers=_headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise DirectClientException(stype, method, node, part, path, resp) DCNL DCSP return resp
def build_model(vectors, shape, settings): DCNL  DCSP (max_length, nr_hidden, nr_class) = shape DCNL DCSP ids1 = Input(shape=(max_length,), dtype='int32', name='words1') DCNL DCSP ids2 = Input(shape=(max_length,), dtype='int32', name='words2') DCNL DCSP embed = _StaticEmbedding(vectors, max_length, nr_hidden, dropout=0.2, nr_tune=5000) DCNL DCSP if settings['gru_encode']: DCNL DCSP  DCSP encode = _BiRNNEncoding(max_length, nr_hidden, dropout=settings['dropout']) DCNL DCSP attend = _Attention(max_length, nr_hidden, dropout=settings['dropout']) DCNL DCSP align = _SoftAlignment(max_length, nr_hidden) DCNL DCSP compare = _Comparison(max_length, nr_hidden, dropout=settings['dropout']) DCNL DCSP entail = _Entailment(nr_hidden, nr_class, dropout=settings['dropout']) DCNL DCSP sent1 = embed(ids1) DCNL DCSP sent2 = embed(ids2) DCNL DCSP if settings['gru_encode']: DCNL DCSP  DCSP sent1 = encode(sent1) DCNL DCSP  DCSP sent2 = encode(sent2) DCNL DCSP attention = attend(sent1, sent2) DCNL DCSP align1 = align(sent2, attention) DCNL DCSP align2 = align(sent1, attention, transpose=True) DCNL DCSP feats1 = compare(sent1, align1) DCNL DCSP feats2 = compare(sent2, align2) DCNL DCSP scores = entail(feats1, feats2) DCNL DCSP model = Model(input=[ids1, ids2], output=[scores]) DCNL DCSP model.compile(optimizer=Adam(lr=settings['lr']), loss='categorical_crossentropy', metrics=['accuracy']) DCNL DCSP return model
def main(): DCNL  DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], '', ['email=', 'password=']) DCNL DCSP except getopt.error as msg: DCNL DCSP  DCSP print 'python DCSP BloggerExample.py DCSP --email DCSP [email] DCSP --password DCSP [password] DCSP ' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP email = '' DCNL DCSP password = '' DCNL DCSP for (o, a) in opts: DCNL DCSP  DCSP if (o == '--email'): DCNL DCSP  DCSP  DCSP email = a DCNL DCSP  DCSP elif (o == '--password'): DCNL DCSP  DCSP  DCSP password = a DCNL DCSP if ((email == '') or (password == '')): DCNL DCSP  DCSP print 'python DCSP BloggerExample.py DCSP --email DCSP [email] DCSP --password DCSP [password]' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP sample = BloggerExample(email, password) DCNL DCSP sample.run()
def parse_alpha(args): DCNL  DCSP if ((len(args) == 1) and (args[0].type in (u'NUMBER', u'INTEGER'))): DCNL DCSP  DCSP return min(1, max(0, args[0].value))
def _statsmodels_univariate_kde(data, kernel, bw, gridsize, cut, clip, cumulative=False): DCNL  DCSP fft = (kernel == 'gau') DCNL DCSP kde = smnp.KDEUnivariate(data) DCNL DCSP kde.fit(kernel, bw, fft, gridsize=gridsize, cut=cut, clip=clip) DCNL DCSP if cumulative: DCNL DCSP  DCSP (grid, y) = (kde.support, kde.cdf) DCNL DCSP else: DCNL DCSP  DCSP (grid, y) = (kde.support, kde.density) DCNL DCSP return (grid, y)
def version(parser, token): DCNL  DCSP bits = token.split_contents() DCNL DCSP if ((len(bits) != 3) and (len(bits) != 5)): DCNL DCSP  DCSP raise TemplateSyntaxError("'version' DCSP tag DCSP takes DCSP 2 DCSP or DCSP 4 DCSP arguments") DCNL DCSP if ((len(bits) == 5) and (bits[3] != 'as')): DCNL DCSP  DCSP raise TemplateSyntaxError("second DCSP argument DCSP to DCSP 'version' DCSP tag DCSP must DCSP be DCSP 'as'") DCNL DCSP if (len(bits) == 3): DCNL DCSP  DCSP return VersionNode(parser.compile_filter(bits[1]), parser.compile_filter(bits[2]), None) DCNL DCSP if (len(bits) == 5): DCNL DCSP  DCSP return VersionNode(parser.compile_filter(bits[1]), parser.compile_filter(bits[2]), bits[4])
@xmlrpc_func(returns='string', args=['string', 'string', 'string', 'struct', 'boolean']) DCNL def new_post(blog_id, username, password, post, publish): DCNL  DCSP user = authenticate(username, password, 'zinnia.add_entry') DCNL DCSP if post.get('dateCreated'): DCNL DCSP  DCSP creation_date = datetime.strptime(post['dateCreated'].value[:18], '%Y-%m-%dT%H:%M:%S') DCNL DCSP  DCSP if settings.USE_TZ: DCNL DCSP  DCSP  DCSP creation_date = timezone.make_aware(creation_date, timezone.utc) DCNL DCSP else: DCNL DCSP  DCSP creation_date = timezone.now() DCNL DCSP entry_dict = {'title': post['title'], 'content': post['description'], 'excerpt': post.get('mt_excerpt', ''), 'publication_date': creation_date, 'creation_date': creation_date, 'last_update': creation_date, 'comment_enabled': (post.get('mt_allow_comments', 1) == 1), 'pingback_enabled': (post.get('mt_allow_pings', 1) == 1), 'trackback_enabled': (post.get('mt_allow_pings', 1) == 1), 'featured': (post.get('sticky', 0) == 1), 'tags': ((('mt_keywords' in post) and post['mt_keywords']) or ''), 'slug': ((('wp_slug' in post) and post['wp_slug']) or slugify(post['title'])), 'password': post.get('wp_password', '')} DCNL DCSP if user.has_perm('zinnia.can_change_status'): DCNL DCSP  DCSP entry_dict['status'] = ((publish and PUBLISHED) or DRAFT) DCNL DCSP entry = Entry.objects.create(**entry_dict) DCNL DCSP author = user DCNL DCSP if (('wp_author_id' in post) and user.has_perm('zinnia.can_change_author')): DCNL DCSP  DCSP if (int(post['wp_author_id']) != user.pk): DCNL DCSP  DCSP  DCSP author = Author.objects.get(pk=post['wp_author_id']) DCNL DCSP entry.authors.add(author) DCNL DCSP entry.sites.add(Site.objects.get_current()) DCNL DCSP if ('categories' in post): DCNL DCSP  DCSP entry.categories.add(*[Category.objects.get_or_create(title=cat, slug=slugify(cat))[0] for cat in post['categories']]) DCNL DCSP return entry.pk
def checkCrash(player, upperPipes, lowerPipes): DCNL  DCSP pi = player['index'] DCNL DCSP player['w'] = IMAGES['player'][0].get_width() DCNL DCSP player['h'] = IMAGES['player'][0].get_height() DCNL DCSP if ((player['y'] + player['h']) >= (BASEY - 1)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP playerRect = pygame.Rect(player['x'], player['y'], player['w'], player['h']) DCNL DCSP  DCSP for (uPipe, lPipe) in zip(upperPipes, lowerPipes): DCNL DCSP  DCSP  DCSP uPipeRect = pygame.Rect(uPipe['x'], uPipe['y'], PIPE_WIDTH, PIPE_HEIGHT) DCNL DCSP  DCSP  DCSP lPipeRect = pygame.Rect(lPipe['x'], lPipe['y'], PIPE_WIDTH, PIPE_HEIGHT) DCNL DCSP  DCSP  DCSP pHitMask = HITMASKS['player'][pi] DCNL DCSP  DCSP  DCSP uHitmask = HITMASKS['pipe'][0] DCNL DCSP  DCSP  DCSP lHitmask = HITMASKS['pipe'][1] DCNL DCSP  DCSP  DCSP uCollide = pixelCollision(playerRect, uPipeRect, pHitMask, uHitmask) DCNL DCSP  DCSP  DCSP lCollide = pixelCollision(playerRect, lPipeRect, pHitMask, lHitmask) DCNL DCSP  DCSP  DCSP if (uCollide or lCollide): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def unpickle(fname): DCNL  DCSP with smart_open(fname, 'rb') as f: DCNL DCSP  DCSP if (sys.version_info > (3, 0)): DCNL DCSP  DCSP  DCSP return _pickle.load(f, encoding='latin1') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _pickle.loads(f.read())
def __virtual__(): DCNL  DCSP if (not salt.utils.is_windows()): DCNL DCSP  DCSP return (False, 'Module DCSP win_network: DCSP Only DCSP available DCSP on DCSP Windows') DCNL DCSP if (not HAS_DEPENDENCIES): DCNL DCSP  DCSP return (False, 'Module DCSP win_network: DCSP Missing DCSP dependencies') DCNL DCSP global wol, get_hostname, interface, interface_ip, subnets6, ip_in_subnet DCNL DCSP global convert_cidr, calc_net, get_fqdn, ifacestartswith, iphexval DCNL DCSP wol = _namespaced_function(wol, globals()) DCNL DCSP get_hostname = _namespaced_function(get_hostname, globals()) DCNL DCSP interface = _namespaced_function(interface, globals()) DCNL DCSP interface_ip = _namespaced_function(interface_ip, globals()) DCNL DCSP subnets6 = _namespaced_function(subnets6, globals()) DCNL DCSP ip_in_subnet = _namespaced_function(ip_in_subnet, globals()) DCNL DCSP convert_cidr = _namespaced_function(convert_cidr, globals()) DCNL DCSP calc_net = _namespaced_function(calc_net, globals()) DCNL DCSP get_fqdn = _namespaced_function(get_fqdn, globals()) DCNL DCSP ifacestartswith = _namespaced_function(ifacestartswith, globals()) DCNL DCSP iphexval = _namespaced_function(iphexval, globals()) DCNL DCSP return __virtualname__
def _write_with_fallback(s, write, fileobj): DCNL  DCSP if ((IPythonIOStream is not None) and isinstance(fileobj, IPythonIOStream)): DCNL DCSP  DCSP write = fileobj.stream.write DCNL DCSP try: DCNL DCSP  DCSP write(s) DCNL DCSP  DCSP return write DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP pass DCNL DCSP enc = locale.getpreferredencoding() DCNL DCSP try: DCNL DCSP  DCSP Writer = codecs.getwriter(enc) DCNL DCSP except LookupError: DCNL DCSP  DCSP Writer = codecs.getwriter(_DEFAULT_ENCODING) DCNL DCSP f = Writer(fileobj) DCNL DCSP write = f.write DCNL DCSP try: DCNL DCSP  DCSP write(s) DCNL DCSP  DCSP return write DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP Writer = codecs.getwriter(u'latin-1') DCNL DCSP  DCSP f = Writer(fileobj) DCNL DCSP  DCSP write = f.write DCNL DCSP write(s) DCNL DCSP return write
def check_existing(package, pkg_files, formula_def, conn=None): DCNL  DCSP if (conn is None): DCNL DCSP  DCSP conn = init() DCNL DCSP existing_files = [] DCNL DCSP for member in pkg_files: DCNL DCSP  DCSP if member.isdir(): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tld = formula_def.get('top_level_dir', package) DCNL DCSP  DCSP new_name = member.name.replace('{0}/'.format(package), '') DCNL DCSP  DCSP if (not new_name.startswith(tld)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if member.name.startswith('{0}/_'.format(package)): DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['formula_path'], new_name) DCNL DCSP  DCSP elif (member.name == '{0}/pillar.example'.format(package)): DCNL DCSP  DCSP  DCSP new_name = '{0}.sls.orig'.format(package) DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['pillar_path'], new_name) DCNL DCSP  DCSP elif package.endswith('-conf'): DCNL DCSP  DCSP  DCSP out_file = os.path.join(salt.syspaths.CONFIG_DIR, new_name) DCNL DCSP  DCSP elif package.endswith('-reactor'): DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['reactor_path'], member.name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['formula_path'], member.name) DCNL DCSP  DCSP if os.path.exists(out_file): DCNL DCSP  DCSP  DCSP existing_files.append(out_file) DCNL DCSP  DCSP  DCSP if (not __opts__['force']): DCNL DCSP  DCSP  DCSP  DCSP log.error('{0} DCSP already DCSP exists, DCSP not DCSP installing'.format(out_file)) DCNL DCSP return existing_files
def test_give_classifier_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = RandomForestClassifier(random_state=RND_SEED) DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, estimator=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
@core_helper DCNL def nav_link(text, *args, **kwargs): DCNL  DCSP if (len(args) > 1): DCNL DCSP  DCSP raise Exception('Too DCSP many DCSP unnamed DCSP parameters DCSP supplied') DCNL DCSP if args: DCNL DCSP  DCSP kwargs['controller'] = kwargs.get('controller') DCNL DCSP  DCSP log.warning('h.nav_link() DCSP please DCSP supply DCSP controller DCSP as DCSP a DCSP named DCSP parameter DCSP not DCSP a DCSP positional DCSP one') DCNL DCSP named_route = kwargs.pop('named_route', '') DCNL DCSP if kwargs.pop('condition', True): DCNL DCSP  DCSP if named_route: DCNL DCSP  DCSP  DCSP link = _link_to(text, named_route, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP link = _link_to(text, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP link = '' DCNL DCSP return link
def role_list(): DCNL  DCSP roles = {} DCNL DCSP with salt.utils.fopen('/etc/user_attr', 'r') as user_attr: DCNL DCSP  DCSP for role in user_attr: DCNL DCSP  DCSP  DCSP role = role.split(':') DCNL DCSP  DCSP  DCSP if (len(role) != 5): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP attrs = {} DCNL DCSP  DCSP  DCSP for attr in role[4].split(';'): DCNL DCSP  DCSP  DCSP  DCSP (attr_key, attr_val) = attr.split('=') DCNL DCSP  DCSP  DCSP  DCSP if (attr_key in ['auths', 'profiles', 'roles']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val.split(',') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val DCNL DCSP  DCSP  DCSP role[4] = attrs DCNL DCSP  DCSP  DCSP if (('type' in role[4]) and (role[4]['type'] == 'role')): DCNL DCSP  DCSP  DCSP  DCSP del role[4]['type'] DCNL DCSP  DCSP  DCSP  DCSP roles[role[0]] = role[4] DCNL DCSP return roles
def claim_build(registry, xml_parent, data): DCNL  DCSP XML.SubElement(xml_parent, 'hudson.plugins.claim.ClaimPublisher')
@register.simple_tag(takes_context=True) DCNL def locale_js_include(context): DCNL  DCSP request = context['request'] DCNL DCSP try: DCNL DCSP  DCSP lang_code = request.LANGUAGE_CODE DCNL DCSP except AttributeError: DCNL DCSP  DCSP return '' DCNL DCSP if ((lang_code == 'en') or (lang_code not in settings.SUPPORTED_LANGUAGES)): DCNL DCSP  DCSP return '' DCNL DCSP href = get_asset_url('sentry', (('dist/locale/' + lang_code) + '.js')) DCNL DCSP return '<script DCSP src="{0}"{1}></script>'.format(href, crossorigin())
def _raise_document_too_large(operation, doc_size, max_size): DCNL  DCSP if (operation == 'insert'): DCNL DCSP  DCSP raise DocumentTooLarge(('BSON DCSP document DCSP too DCSP large DCSP (%d DCSP bytes) DCSP - DCSP the DCSP connected DCSP server DCSP supports DCSP BSON DCSP document DCSP sizes DCSP up DCSP to DCSP %d DCSP bytes.' % (doc_size, max_size))) DCNL DCSP else: DCNL DCSP  DCSP raise DocumentTooLarge('command DCSP document DCSP too DCSP large')
def create_model(session, forward_only): DCNL  DCSP dtype = (tf.float16 if FLAGS.use_fp16 else tf.float32) DCNL DCSP model = seq2seq_model.Seq2SeqModel(FLAGS.from_vocab_size, FLAGS.to_vocab_size, _buckets, FLAGS.size, FLAGS.num_layers, FLAGS.max_gradient_norm, FLAGS.batch_size, FLAGS.learning_rate, FLAGS.learning_rate_decay_factor, forward_only=forward_only, dtype=dtype) DCNL DCSP ckpt = tf.train.get_checkpoint_state(FLAGS.train_dir) DCNL DCSP if (ckpt and tf.train.checkpoint_exists(ckpt.model_checkpoint_path)): DCNL DCSP  DCSP print(('Reading DCSP model DCSP parameters DCSP from DCSP %s' % ckpt.model_checkpoint_path)) DCNL DCSP  DCSP model.saver.restore(session, ckpt.model_checkpoint_path) DCNL DCSP else: DCNL DCSP  DCSP print('Created DCSP model DCSP with DCSP fresh DCSP parameters.') DCNL DCSP  DCSP session.run(tf.global_variables_initializer()) DCNL DCSP return model
def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP return Dovado().setup(hass, config, add_devices)
def create_credential_resolver(session): DCNL  DCSP profile_name = (session.get_config_variable('profile') or 'default') DCNL DCSP credential_file = session.get_config_variable('credentials_file') DCNL DCSP config_file = session.get_config_variable('config_file') DCNL DCSP metadata_timeout = session.get_config_variable('metadata_service_timeout') DCNL DCSP num_attempts = session.get_config_variable('metadata_service_num_attempts') DCNL DCSP env_provider = EnvProvider() DCNL DCSP providers = [env_provider, AssumeRoleProvider(load_config=(lambda : session.full_config), client_creator=session.create_client, cache={}, profile_name=profile_name), SharedCredentialProvider(creds_filename=credential_file, profile_name=profile_name), ConfigProvider(config_filename=config_file, profile_name=profile_name), OriginalEC2Provider(), BotoProvider(), ContainerProvider(), InstanceMetadataProvider(iam_role_fetcher=InstanceMetadataFetcher(timeout=metadata_timeout, num_attempts=num_attempts))] DCNL DCSP explicit_profile = session.get_config_variable('profile', methods=('instance',)) DCNL DCSP if (explicit_profile is not None): DCNL DCSP  DCSP providers.remove(env_provider) DCNL DCSP  DCSP logger.debug('Skipping DCSP environment DCSP variable DCSP credential DCSP check DCSP because DCSP profile DCSP name DCSP was DCSP explicitly DCSP set.') DCNL DCSP resolver = CredentialResolver(providers=providers) DCNL DCSP return resolver
@cli.command() DCNL def edit(): DCNL  DCSP MARKER = '# DCSP Everything DCSP below DCSP is DCSP ignored\n' DCNL DCSP message = click.edit(('\n\n' + MARKER)) DCNL DCSP if (message is not None): DCNL DCSP  DCSP msg = message.split(MARKER, 1)[0].rstrip('\n') DCNL DCSP  DCSP if (not msg): DCNL DCSP  DCSP  DCSP click.echo('Empty DCSP message!') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP click.echo(('Message:\n' + msg)) DCNL DCSP else: DCNL DCSP  DCSP click.echo('You DCSP did DCSP not DCSP enter DCSP anything!')
def test_randomize_corrmat_dist(): DCNL  DCSP a = rs.randn(3, 20) DCNL DCSP for n_i in [5, 10]: DCNL DCSP  DCSP (p_mat, dist) = algo.randomize_corrmat(a, n_iter=n_i, return_dist=True) DCNL DCSP  DCSP assert_equal(n_i, dist.shape[(-1)]) DCNL DCSP (p_mat, dist) = algo.randomize_corrmat(a, n_iter=10000, return_dist=True) DCNL DCSP diag_mean = dist[(0, 0)].mean() DCNL DCSP assert_equal(diag_mean, 1) DCNL DCSP off_diag_mean = dist[(0, 1)].mean() DCNL DCSP nose.tools.assert_greater(0.05, off_diag_mean)
def to_str_py27(value): DCNL  DCSP if isinstance(value, dict): DCNL DCSP  DCSP entry = u'{}: DCSP {}'.format DCNL DCSP  DCSP retval = u'{' DCNL DCSP  DCSP for (key, val) in list(value.items()): DCNL DCSP  DCSP  DCSP if (len(retval) > 1): DCNL DCSP  DCSP  DCSP  DCSP retval += u', DCSP ' DCNL DCSP  DCSP  DCSP kenc = repr(key) DCNL DCSP  DCSP  DCSP if kenc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP kenc = kenc[1:] DCNL DCSP  DCSP  DCSP venc = to_str_py27(val) DCNL DCSP  DCSP  DCSP if venc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP venc = venc[1:] DCNL DCSP  DCSP  DCSP retval += entry(kenc, venc) DCNL DCSP  DCSP retval += u'}' DCNL DCSP  DCSP return retval DCNL DCSP istuple = isinstance(value, tuple) DCNL DCSP if isinstance(value, (tuple, list)): DCNL DCSP  DCSP retval = (u'(' if istuple else u'[') DCNL DCSP  DCSP nels = len(value) DCNL DCSP  DCSP for (i, v) in enumerate(value): DCNL DCSP  DCSP  DCSP venc = to_str_py27(v) DCNL DCSP  DCSP  DCSP if venc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP venc = venc[1:] DCNL DCSP  DCSP  DCSP retval += venc DCNL DCSP  DCSP  DCSP if (i < (nels - 1)): DCNL DCSP  DCSP  DCSP  DCSP retval += u', DCSP ' DCNL DCSP  DCSP if (istuple and (nels == 1)): DCNL DCSP  DCSP  DCSP retval += u',' DCNL DCSP  DCSP retval += (u')' if istuple else u']') DCNL DCSP  DCSP return retval DCNL DCSP retval = repr(value).decode() DCNL DCSP if retval.startswith((u"u'", u'u"')): DCNL DCSP  DCSP retval = retval[1:] DCNL DCSP return retval
def _nonlinear_3eq_order1_type5(x, y, t, eq): DCNL  DCSP C1 = get_numbered_constants(eq, num=1) DCNL DCSP (u, v, w) = symbols('u, DCSP v, DCSP w') DCNL DCSP p = Wild('p', exclude=[x(t), y(t), z(t), t]) DCNL DCSP q = Wild('q', exclude=[x(t), y(t), z(t), t]) DCNL DCSP s = Wild('s', exclude=[x(t), y(t), z(t), t]) DCNL DCSP (F1, F2, F3) = symbols('F1, DCSP F2, DCSP F3', cls=Wild) DCNL DCSP r1 = eq[0].match((diff(x(t), t) - (x(t) * (F2 - F3)))) DCNL DCSP r = collect_const(r1[F2]).match((s * F2)) DCNL DCSP r.update(collect_const(r1[F3]).match((q * F3))) DCNL DCSP if (eq[1].has(r[F2]) and (not eq[1].has(r[F3]))): DCNL DCSP  DCSP (r[F2], r[F3]) = (r[F3], r[F2]) DCNL DCSP  DCSP (r[s], r[q]) = ((- r[q]), (- r[s])) DCNL DCSP r.update((diff(y(t), t) - eq[1]).match((y(t) * ((a * r[F3]) - (r[c] * F1))))) DCNL DCSP a = r[p] DCNL DCSP b = r[q] DCNL DCSP c = r[s] DCNL DCSP F1 = r[F1].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP F2 = r[F2].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP F3 = r[F3].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP x_yz = (((C1 * (v ** (- b))) * (w ** (- c))) ** (- a)) DCNL DCSP y_zx = (((C1 * (w ** (- c))) * (u ** (- a))) ** (- b)) DCNL DCSP z_xy = (((C1 * (u ** (- a))) * (v ** (- b))) ** (- c)) DCNL DCSP y_x = dsolve((diff(v(u), u) - ((v * ((a * F3) - (c * F1))) / (u * ((c * F2) - (b * F3)))).subs(w, z_xy).subs(v, v(u)))).rhs DCNL DCSP z_x = dsolve((diff(w(u), u) - ((w * ((b * F1) - (a * F2))) / (u * ((c * F2) - (b * F3)))).subs(v, y_zx).subs(w, w(u)))).rhs DCNL DCSP z_y = dsolve((diff(w(v), v) - ((w * ((b * F1) - (a * F2))) / (v * ((a * F3) - (c * F1)))).subs(u, x_yz).subs(w, w(v)))).rhs DCNL DCSP x_y = dsolve((diff(u(v), v) - ((u * ((c * F2) - (b * F3))) / (v * ((a * F3) - (c * F1)))).subs(w, z_xy).subs(u, u(v)))).rhs DCNL DCSP y_z = dsolve((diff(v(w), w) - ((v * ((a * F3) - (c * F1))) / (w * ((b * F1) - (a * F2)))).subs(u, x_yz).subs(v, v(w)))).rhs DCNL DCSP x_z = dsolve((diff(u(w), w) - ((u * ((c * F2) - (b * F3))) / (w * ((b * F1) - (a * F2)))).subs(v, y_zx).subs(u, u(w)))).rhs DCNL DCSP sol1 = dsolve((diff(u(t), t) - (u * ((c * F2) - (b * F3))).subs(v, y_x).subs(w, z_x).subs(u, u(t)))).rhs DCNL DCSP sol2 = dsolve((diff(v(t), t) - (v * ((a * F3) - (c * F1))).subs(u, x_y).subs(w, z_y).subs(v, v(t)))).rhs DCNL DCSP sol3 = dsolve((diff(w(t), t) - (w * ((b * F1) - (a * F2))).subs(u, x_z).subs(v, y_z).subs(w, w(t)))).rhs DCNL DCSP return [Eq(x(t), sol1), Eq(y(t), sol2), Eq(z(t), sol3)]
def folders_at_path(path, include_parent=False, show_hidden=False): DCNL  DCSP from sabnzbd.encoding import unicoder DCNL DCSP if (path == ''): DCNL DCSP  DCSP if NT: DCNL DCSP  DCSP  DCSP entries = [{'name': (letter + ':\\'), 'path': (letter + ':\\')} for letter in get_win_drives()] DCNL DCSP  DCSP  DCSP entries.insert(0, {'current_path': 'Root'}) DCNL DCSP  DCSP  DCSP return entries DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '/' DCNL DCSP path = sabnzbd.misc.real_path(sabnzbd.DIR_HOME, path) DCNL DCSP while (path and (not os.path.isdir(path))): DCNL DCSP  DCSP if (path == os.path.dirname(path)): DCNL DCSP  DCSP  DCSP return folders_at_path('', include_parent) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.dirname(path) DCNL DCSP path = os.path.abspath(os.path.normpath(path)) DCNL DCSP parent_path = os.path.dirname(path) DCNL DCSP if ((path == parent_path) and (os.name == 'nt')): DCNL DCSP  DCSP parent_path = '' DCNL DCSP file_list = [] DCNL DCSP try: DCNL DCSP  DCSP for filename in os.listdir(path): DCNL DCSP  DCSP  DCSP fpath = os.path.join(path, filename) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if NT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP doit = (((win32api.GetFileAttributes(fpath) & MASK) == TMASK) and (filename != 'PerfLogs')) DCNL DCSP  DCSP  DCSP  DCSP elif (not show_hidden): DCNL DCSP  DCSP  DCSP  DCSP  DCSP doit = (not filename.startswith('.')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP doit = True DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP doit = False DCNL DCSP  DCSP  DCSP if doit: DCNL DCSP  DCSP  DCSP  DCSP file_list.append({'name': unicoder(filename), 'path': unicoder(fpath)}) DCNL DCSP  DCSP file_list = filter((lambda entry: os.path.isdir(entry['path'])), file_list) DCNL DCSP  DCSP file_list = filter((lambda entry: (entry['name'].lower() not in _JUNKFOLDERS)), file_list) DCNL DCSP  DCSP file_list = sorted(file_list, (lambda x, y: cmp(os.path.basename(x['name']).lower(), os.path.basename(y['path']).lower()))) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP file_list.insert(0, {'current_path': path}) DCNL DCSP if (include_parent and (parent_path != path)): DCNL DCSP  DCSP file_list.insert(1, {'name': '..', 'path': parent_path}) DCNL DCSP return file_list
def getGaleraFile(): DCNL  DCSP return '/usr/lib/libgalera_smm.so'
def test_pick_bio(): DCNL  DCSP names = 'A1 DCSP A2 DCSP Fz DCSP O DCSP BIO1 DCSP BIO2 DCSP BIO3'.split() DCNL DCSP types = 'mag DCSP mag DCSP eeg DCSP eeg DCSP bio DCSP bio DCSP bio'.split() DCNL DCSP info = create_info(names, 1024.0, types) DCNL DCSP idx = channel_indices_by_type(info) DCNL DCSP assert_array_equal(idx['mag'], [0, 1]) DCNL DCSP assert_array_equal(idx['eeg'], [2, 3]) DCNL DCSP assert_array_equal(idx['bio'], [4, 5, 6])
def get_func_full_args(func): DCNL  DCSP sig = inspect.signature(func) DCNL DCSP args = [] DCNL DCSP for (arg_name, param) in sig.parameters.items(): DCNL DCSP  DCSP name = arg_name DCNL DCSP  DCSP if (name == 'self'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (param.kind == inspect.Parameter.VAR_POSITIONAL): DCNL DCSP  DCSP  DCSP name = ('*' + name) DCNL DCSP  DCSP elif (param.kind == inspect.Parameter.VAR_KEYWORD): DCNL DCSP  DCSP  DCSP name = ('**' + name) DCNL DCSP  DCSP if (param.default != inspect.Parameter.empty): DCNL DCSP  DCSP  DCSP args.append((name, param.default)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.append((name,)) DCNL DCSP return args
def opening_tag(cdata_tags, state, text, i, formats, user_data): DCNL  DCSP ch = text[i] DCNL DCSP if (ch in space_chars): DCNL DCSP  DCSP return [(1, None)] DCNL DCSP if (ch == u'/'): DCNL DCSP  DCSP m = self_closing_pat.match(text, i) DCNL DCSP  DCSP if (m is None): DCNL DCSP  DCSP  DCSP return [(1, formats[u'/'])] DCNL DCSP  DCSP state.parse = NORMAL DCNL DCSP  DCSP l = len(m.group()) DCNL DCSP  DCSP add_tag_data(user_data, TagEnd(((i + l) - 1), True, False)) DCNL DCSP  DCSP return [(l, formats[u'tag'])] DCNL DCSP if (ch == u'>'): DCNL DCSP  DCSP finish_opening_tag(state, cdata_tags) DCNL DCSP  DCSP add_tag_data(user_data, TagEnd(i, False, False)) DCNL DCSP  DCSP return [(1, formats[u'tag'])] DCNL DCSP m = attribute_name_pat.match(text, i) DCNL DCSP if (m is None): DCNL DCSP  DCSP return [(1, formats[u'?'])] DCNL DCSP state.parse = ATTRIBUTE_NAME DCNL DCSP attrname = state.attribute_name = m.group() DCNL DCSP add_attr_data(user_data, ATTR_NAME, attrname, m.start()) DCNL DCSP (prefix, name) = attrname.partition(u':')[0::2] DCNL DCSP if ((not prefix) and (not name)): DCNL DCSP  DCSP return [(len(attrname), formats[u'?'])] DCNL DCSP if (prefix and name): DCNL DCSP  DCSP return [((len(prefix) + 1), formats[u'nsprefix']), (len(name), formats[u'attr'])] DCNL DCSP return [(len(prefix), formats[u'attr'])]
@evalcontextfilter DCNL def do_replace(eval_ctx, s, old, new, count=None): DCNL  DCSP if (count is None): DCNL DCSP  DCSP count = (-1) DCNL DCSP if (not eval_ctx.autoescape): DCNL DCSP  DCSP return text_type(s).replace(text_type(old), text_type(new), count) DCNL DCSP if (hasattr(old, '__html__') or (hasattr(new, '__html__') and (not hasattr(s, '__html__')))): DCNL DCSP  DCSP s = escape(s) DCNL DCSP else: DCNL DCSP  DCSP s = soft_unicode(s) DCNL DCSP return s.replace(soft_unicode(old), soft_unicode(new), count)
def html_unquote(s, encoding=None): DCNL  DCSP if isinstance(s, six.binary_type): DCNL DCSP  DCSP s = s.decode((encoding or default_encoding)) DCNL DCSP return _unquote_re.sub(_entity_subber, s)
@check_is_trading DCNL @export_as_api DCNL @ExecutionContext.enforce_phase(EXECUTION_PHASE.HANDLE_BAR, EXECUTION_PHASE.SCHEDULED) DCNL def order_lots(id_or_ins, amount, style=None): DCNL  DCSP order_book_id = assure_order_book_id(id_or_ins) DCNL DCSP round_lot = int(get_data_proxy().instrument(order_book_id).round_lot) DCNL DCSP return order_shares(order_book_id, (amount * round_lot), style)
def test_basic_auth(): DCNL  DCSP @hug.get(requires=hug.authentication.basic(hug.authentication.verify('Tim', 'Custom DCSP password'))) DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP world!' DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Not DCSP correctly DCSP formed'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Nospaces'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Basic DCSP VXNlcjE6bXlwYXNzd29yZA'}).status) DCNL DCSP token = b64encode('{0}:{1}'.format('Tim', 'Custom DCSP password').encode('utf8')).decode('utf8') DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'Authorization': 'Basic DCSP {0}'.format(token)}).data == 'Hello DCSP world!') DCNL DCSP token = ('Basic DCSP ' + b64encode('{0}:{1}'.format('Tim', 'Custom DCSP password').encode('utf8'))) DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'Authorization': token}).data == 'Hello DCSP world!') DCNL DCSP token = ('Basic DCSP ' + b64encode('{0}:{1}'.format('Tim', 'Wrong DCSP password').encode('utf8'))) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': token}).status)
def build_flow_dict(G, R): DCNL  DCSP flow_dict = {} DCNL DCSP for u in G: DCNL DCSP  DCSP flow_dict[u] = dict(((v, 0) for v in G[u])) DCNL DCSP  DCSP flow_dict[u].update(((v, attr['flow']) for (v, attr) in R[u].items() if (attr['flow'] > 0))) DCNL DCSP return flow_dict
def detach_principal_policy(policyName, principal, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP conn.detach_principal_policy(policyName=policyName, principal=principal) DCNL DCSP  DCSP return {'detached': True} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'detached': False, 'error': salt.utils.boto3.get_error(e)}
def disabled(name): DCNL  DCSP return (not enabled(name))
def setup(hass, config): DCNL  DCSP global DATA DCNL DCSP conf = config[DOMAIN] DCNL DCSP host = conf.get(CONF_HOST) DCNL DCSP port = conf.get(CONF_PORT) DCNL DCSP DATA = APCUPSdData(host, port) DCNL DCSP try: DCNL DCSP  DCSP DATA.update(no_throttle=True) DCNL DCSP except Exception: DCNL DCSP  DCSP _LOGGER.exception('Failure DCSP while DCSP testing DCSP APCUPSd DCSP status DCSP retrieval.') DCNL DCSP  DCSP return False DCNL DCSP return True
def getfullargspec(func): DCNL  DCSP try: DCNL DCSP  DCSP return inspect.getfullargspec(func) DCNL DCSP except AttributeError: DCNL DCSP  DCSP arg_spec = inspect.getargspec(func) DCNL DCSP  DCSP import collections DCNL DCSP  DCSP tuple_fields = 'args DCSP varargs DCSP varkw DCSP defaults DCSP kwonlyargs DCSP kwonlydefaults DCSP annotations' DCNL DCSP  DCSP tuple_type = collections.namedtuple('FullArgSpec', tuple_fields) DCNL DCSP  DCSP return tuple_type(args=arg_spec.args, varargs=arg_spec.varargs, varkw=arg_spec.keywords, defaults=arg_spec.defaults, kwonlyargs=[], kwonlydefaults=None, annotations={})
def group_create(context, data_dict): DCNL  DCSP if (data_dict.get('type') == 'organization'): DCNL DCSP  DCSP raise Exception(_('Trying DCSP to DCSP create DCSP an DCSP organization DCSP as DCSP a DCSP group')) DCNL DCSP _check_access('group_create', context, data_dict) DCNL DCSP return _group_or_org_create(context, data_dict)
def find_and_create_file_from_metadata(children, source, destination, destination_node, obj): DCNL  DCSP for item in children: DCNL DCSP  DCSP if (not item['materialized'].startswith('/')): DCNL DCSP  DCSP  DCSP item['materialized'] = ('/' + item['materialized']) DCNL DCSP  DCSP if (item['kind'] == 'folder'): DCNL DCSP  DCSP  DCSP return find_and_create_file_from_metadata(item.get('children', []), source, destination, destination_node, obj) DCNL DCSP  DCSP elif ((item['kind'] == 'file') and (item['materialized'].replace(destination['materialized'], source['materialized']) == obj.referent.materialized_path)): DCNL DCSP  DCSP  DCSP data = dict(item) DCNL DCSP  DCSP  DCSP new_file = FileNode.resolve_class(destination['provider'], FileNode.FILE).get_or_create(destination_node, item['path']) DCNL DCSP  DCSP  DCSP if (destination['provider'] != 'osfstorage'): DCNL DCSP  DCSP  DCSP  DCSP new_file.update(revision=None, data=data) DCNL DCSP  DCSP  DCSP return new_file
def generate_gantt_chart(logfile, cores, minute_scale=10, space_between_minutes=50, colors=[u'#7070FF', u'#4E4EB2', u'#2D2D66', u'#9B9BFF']): DCNL  DCSP html_string = u'<!DOCTYPE DCSP html>\n DCSP  DCSP  DCSP  DCSP <head>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <style>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #content{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP width:99%;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height:100%;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position:absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .node{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP background-color:#7070FF;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP border-radius: DCSP 5px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position:absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP width:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP white-space:pre-wrap;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .line{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP color: DCSP #C2C2C2;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.5;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP margin: DCSP 0px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .time{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP font-size: DCSP 16px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP color: DCSP #666666;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP margin: DCSP 0px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .bar{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.7;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .dot{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP width: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP background-color: DCSP red;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .label DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP width:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.7;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP display: DCSP inline-block;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP </style>\n DCSP  DCSP  DCSP  DCSP </head>\n\n DCSP  DCSP  DCSP  DCSP <body>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <div DCSP id="content">\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <div DCSP style="display:inline-block;">\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP close_header = u'\n DCSP  DCSP  DCSP  DCSP </div>\n DCSP  DCSP  DCSP  DCSP <div DCSP style="display:inline-block;margin-left:60px;vertical-align: DCSP top;">\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><div DCSP class="label" DCSP style="background-color:#90BBD7;"></div> DCSP Estimated DCSP Resource</span></p>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><div DCSP class="label" DCSP style="background-color:#03969D;"></div> DCSP Actual DCSP Resource</span></p>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><div DCSP class="label" DCSP style="background-color:#f00;"></div> DCSP Failed DCSP Node</span></p>\n DCSP  DCSP  DCSP  DCSP </div>\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP nodes_list = log_to_dict(logfile) DCNL DCSP start_node = nodes_list[0] DCNL DCSP last_node = nodes_list[(-1)] DCNL DCSP duration = (last_node[u'finish'] - start_node[u'start']).total_seconds() DCNL DCSP events = create_event_dict(start_node[u'start'], nodes_list) DCNL DCSP html_string += ((u'<p>Start: DCSP ' + start_node[u'start'].strftime(u'%Y-%m-%d DCSP %H:%M:%S')) + u'</p>') DCNL DCSP html_string += ((u'<p>Finish: DCSP ' + last_node[u'finish'].strftime(u'%Y-%m-%d DCSP %H:%M:%S')) + u'</p>') DCNL DCSP html_string += ((u'<p>Duration: DCSP ' + u'{0:.2f}'.format((duration / 60))) + u' DCSP minutes</p>') DCNL DCSP html_string += ((u'<p>Nodes: DCSP ' + str(len(nodes_list))) + u'</p>') DCNL DCSP html_string += ((u'<p>Cores: DCSP ' + str(cores)) + u'</p>') DCNL DCSP html_string += close_header DCNL DCSP html_string += draw_lines(start_node[u'start'], duration, minute_scale, space_between_minutes) DCNL DCSP html_string += draw_nodes(start_node[u'start'], nodes_list, cores, minute_scale, space_between_minutes, colors) DCNL DCSP estimated_mem_ts = calculate_resource_timeseries(events, u'estimated_memory_gb') DCNL DCSP runtime_mem_ts = calculate_resource_timeseries(events, u'runtime_memory_gb') DCNL DCSP resource_offset = (120 + (30 * cores)) DCNL DCSP html_string += draw_resource_bar(start_node[u'start'], last_node[u'finish'], estimated_mem_ts, space_between_minutes, minute_scale, u'#90BBD7', ((resource_offset * 2) + 120), u'Memory') DCNL DCSP html_string += draw_resource_bar(start_node[u'start'], last_node[u'finish'], runtime_mem_ts, space_between_minutes, minute_scale, u'#03969D', ((resource_offset * 2) + 120), u'Memory') DCNL DCSP estimated_threads_ts = calculate_resource_timeseries(events, u'estimated_threads') DCNL DCSP runtime_threads_ts = calculate_resource_timeseries(events, u'runtime_threads') DCNL DCSP html_string += draw_resource_bar(start_node[u'start'], last_node[u'finish'], estimated_threads_ts, space_between_minutes, minute_scale, u'#90BBD7', resource_offset, u'Threads') DCNL DCSP html_string += draw_resource_bar(start_node[u'start'], last_node[u'finish'], runtime_threads_ts, space_between_minutes, minute_scale, u'#03969D', resource_offset, u'Threads') DCNL DCSP html_string += u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP </div>\n DCSP  DCSP  DCSP  DCSP </body>' DCNL DCSP html_file = open((logfile + u'.html'), u'wb') DCNL DCSP html_file.write(html_string) DCNL DCSP html_file.close()
def check_page_faults(con, host, port, warning, critical, perf_data): DCNL  DCSP warning = (warning or 10) DCNL DCSP critical = (critical or 30) DCNL DCSP data = get_server_status(con) DCNL DCSP try: DCNL DCSP  DCSP page_faults = float(data['extra_info']['page_faults']) DCNL DCSP except: DCNL DCSP  DCSP return exit_with_general_critical('page_faults DCSP unsupported DCSP on DCSP the DCSP underlaying DCSP system') DCNL DCSP (err, delta) = maintain_delta([page_faults], host, port, 'page_faults') DCNL DCSP if (err == 0): DCNL DCSP  DCSP page_faults_ps = (delta[1] / delta[0]) DCNL DCSP  DCSP message = ('Page DCSP faults DCSP : DCSP %.2f DCSP ps' % page_faults_ps) DCNL DCSP  DCSP message += performance_data(perf_data, [(('%.2f' % page_faults_ps), 'page_faults_ps', warning, critical)]) DCNL DCSP  DCSP return check_levels(page_faults_ps, warning, critical, message) DCNL DCSP else: DCNL DCSP  DCSP return exit_with_general_warning('problem DCSP reading DCSP data DCSP from DCSP temp DCSP file')
def collect_emojis(): DCNL  DCSP emojis = dict() DCNL DCSP full_path = os.path.join(_basedir, 'static', 'emoji') DCNL DCSP if (not os.path.exists(full_path)): DCNL DCSP  DCSP return emojis DCNL DCSP for emoji in os.listdir(full_path): DCNL DCSP  DCSP (name, ending) = emoji.split('.') DCNL DCSP  DCSP if (ending in ['png', 'gif', 'jpg', 'jpeg']): DCNL DCSP  DCSP  DCSP emojis[name] = emoji DCNL DCSP return emojis
def abstract(cls): DCNL  DCSP if (not issubclass(cls, HasProps)): DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP HasProps' % cls.__name__)) DCNL DCSP cls.__doc__ += _ABSTRACT_ADMONITION DCNL DCSP return cls
@pytest.fixture(autouse=True) DCNL def mock_inline_css(monkeypatch): DCNL  DCSP from olympia.amo import helpers DCNL DCSP monkeypatch.setattr(helpers, 'is_external', (lambda css: True))
def assert_json_response(response, status_code, body, headers=None, body_cmp=operator.eq): DCNL  DCSP headers = dict((headers or {})) DCNL DCSP headers['Content-Type'] = 'application/json' DCNL DCSP def json_cmp(response_body, body): DCNL DCSP  DCSP return body_cmp(json.loads(response_body.decode('utf-8')), body) DCNL DCSP assert_response(response, status_code, body, headers, json_cmp)
def wait_for_volume_status(client, volume_id, status): DCNL  DCSP body = client.show_volume(volume_id)['volume'] DCNL DCSP volume_status = body['status'] DCNL DCSP start = int(time.time()) DCNL DCSP while (volume_status != status): DCNL DCSP  DCSP time.sleep(client.build_interval) DCNL DCSP  DCSP body = client.show_volume(volume_id)['volume'] DCNL DCSP  DCSP volume_status = body['status'] DCNL DCSP  DCSP if ((volume_status == 'error') and (status != 'error')): DCNL DCSP  DCSP  DCSP raise exceptions.VolumeBuildErrorException(volume_id=volume_id) DCNL DCSP  DCSP if (volume_status == 'error_restoring'): DCNL DCSP  DCSP  DCSP raise exceptions.VolumeRestoreErrorException(volume_id=volume_id) DCNL DCSP  DCSP if ((int(time.time()) - start) >= client.build_timeout): DCNL DCSP  DCSP  DCSP message = ('Volume DCSP %s DCSP failed DCSP to DCSP reach DCSP %s DCSP status DCSP (current DCSP %s) DCSP within DCSP the DCSP required DCSP time DCSP (%s DCSP s).' % (volume_id, status, volume_status, client.build_timeout)) DCNL DCSP  DCSP  DCSP raise lib_exc.TimeoutException(message)
def between(expr, lower_bound, upper_bound, symmetric=False): DCNL  DCSP expr = _literal_as_binds(expr) DCNL DCSP return expr.between(lower_bound, upper_bound, symmetric=symmetric)
def new_figure_manager(num, *args, **kwargs): DCNL  DCSP _focus = windowing.FocusManager() DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP figure = FigureClass(*args, **kwargs) DCNL DCSP window = Tk.Tk() DCNL DCSP canvas = FigureCanvasTkAgg(figure, master=window) DCNL DCSP figManager = FigureManagerTkAgg(canvas, num, window) DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager.show() DCNL DCSP return figManager
def _abstractPath(case): DCNL  DCSP return md5(urandom(100)).hexdigest()
def set_review_unavailable(apps, schema_editor): DCNL  DCSP DocumentSpamAttempt = apps.get_model(u'wiki', u'DocumentSpamAttempt') DCNL DCSP to_set = DocumentSpamAttempt.objects.filter(data__isnull=True, review=NEEDS_REVIEW) DCNL DCSP to_set.update(review=REVIEW_UNAVAILABLE)
@dispatch(Expr, Mapping) DCNL def compute(expr, d, return_type=no_default, **kwargs): DCNL  DCSP _reset_leaves() DCNL DCSP optimize_ = kwargs.get('optimize', optimize) DCNL DCSP pre_compute_ = kwargs.get('pre_compute', pre_compute) DCNL DCSP post_compute_ = kwargs.get('post_compute', post_compute) DCNL DCSP (expr2, d2) = swap_resources_into_scope(expr, d) DCNL DCSP if pre_compute_: DCNL DCSP  DCSP d3 = dict(((e, pre_compute_(e, dat, **kwargs)) for (e, dat) in d2.items() if (e in expr2))) DCNL DCSP else: DCNL DCSP  DCSP d3 = d2 DCNL DCSP if optimize_: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP expr3 = optimize_(expr2, *[v for (e, v) in d3.items() if (e in expr2)]) DCNL DCSP  DCSP  DCSP _d = dict(zip(expr2._leaves(), expr3._leaves())) DCNL DCSP  DCSP  DCSP d4 = dict(((e._subs(_d), d) for (e, d) in d3.items())) DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP expr3 = expr2 DCNL DCSP  DCSP  DCSP d4 = d3 DCNL DCSP else: DCNL DCSP  DCSP expr3 = expr2 DCNL DCSP  DCSP d4 = d3 DCNL DCSP result = top_then_bottom_then_top_again_etc(expr3, d4, **kwargs) DCNL DCSP if post_compute_: DCNL DCSP  DCSP result = post_compute_(expr3, result, scope=d4) DCNL DCSP if (return_type is no_default): DCNL DCSP  DCSP msg = "The DCSP default DCSP behavior DCSP of DCSP compute DCSP will DCSP change DCSP in DCSP version DCSP >= DCSP 0.11 DCSP where DCSP the DCSP `return_type` DCSP parameter DCSP will DCSP default DCSP to DCSP 'core'." DCNL DCSP  DCSP warnings.warn(msg, DeprecationWarning) DCNL DCSP elif (return_type == 'core'): DCNL DCSP  DCSP result = coerce_core(result, expr.dshape) DCNL DCSP elif isinstance(return_type, type): DCNL DCSP  DCSP result = into(return_type, result, dshape=expr3.dshape) DCNL DCSP elif (return_type != 'native'): DCNL DCSP  DCSP raise ValueError('Invalid DCSP return_type DCSP passed DCSP to DCSP compute: DCSP {}'.format(return_type)) DCNL DCSP return result
def replace(old_value, new_value, full_match=False): DCNL  DCSP if (full_match is False): DCNL DCSP  DCSP matcher = re.compile('^.*{0}.*$'.format(re.escape(old_value)), re.MULTILINE) DCNL DCSP  DCSP repl = re.compile(re.escape(old_value)) DCNL DCSP else: DCNL DCSP  DCSP matcher = re.compile(old_value, re.MULTILINE) DCNL DCSP  DCSP repl = re.compile(old_value) DCNL DCSP lines = {'old': [], 'new': []} DCNL DCSP for line in matcher.finditer(show_run()): DCNL DCSP  DCSP lines['old'].append(line.group(0)) DCNL DCSP  DCSP lines['new'].append(repl.sub(new_value, line.group(0))) DCNL DCSP delete_config(lines['old']) DCNL DCSP add_config(lines['new']) DCNL DCSP return lines
@verbose DCNL def read_epochs(fname, proj=True, preload=True, verbose=None): DCNL  DCSP return EpochsFIF(fname, proj, False, preload, verbose)
def resource_create(context, data_dict): DCNL  DCSP model = context['model'] DCNL DCSP user = context['user'] DCNL DCSP package_id = _get_or_bust(data_dict, 'package_id') DCNL DCSP if (not data_dict.get('url')): DCNL DCSP  DCSP data_dict['url'] = '' DCNL DCSP pkg_dict = _get_action('package_show')(dict(context, return_type='dict'), {'id': package_id}) DCNL DCSP _check_access('resource_create', context, data_dict) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.before_create(context, data_dict) DCNL DCSP if ('resources' not in pkg_dict): DCNL DCSP  DCSP pkg_dict['resources'] = [] DCNL DCSP upload = uploader.get_resource_uploader(data_dict) DCNL DCSP if ('mimetype' not in data_dict): DCNL DCSP  DCSP if hasattr(upload, 'mimetype'): DCNL DCSP  DCSP  DCSP data_dict['mimetype'] = upload.mimetype DCNL DCSP if ('size' not in data_dict): DCNL DCSP  DCSP if hasattr(upload, 'filesize'): DCNL DCSP  DCSP  DCSP data_dict['size'] = upload.filesize DCNL DCSP pkg_dict['resources'].append(data_dict) DCNL DCSP try: DCNL DCSP  DCSP context['defer_commit'] = True DCNL DCSP  DCSP context['use_cache'] = False DCNL DCSP  DCSP _get_action('package_update')(context, pkg_dict) DCNL DCSP  DCSP context.pop('defer_commit') DCNL DCSP except ValidationError as e: DCNL DCSP  DCSP errors = e.error_dict['resources'][(-1)] DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP upload.upload(context['package'].resources[(-1)].id, uploader.get_max_resource_size()) DCNL DCSP model.repo.commit() DCNL DCSP updated_pkg_dict = _get_action('package_show')(context, {'id': package_id}) DCNL DCSP resource = updated_pkg_dict['resources'][(-1)] DCNL DCSP logic.get_action('resource_create_default_resource_views')({'model': context['model'], 'user': context['user'], 'ignore_auth': True}, {'resource': resource, 'package': updated_pkg_dict}) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.after_create(context, resource) DCNL DCSP return resource
@not_implemented_for('directed') DCNL @not_implemented_for('multigraph') DCNL def cycle_basis(G, root=None): DCNL  DCSP gnodes = set(G.nodes()) DCNL DCSP cycles = [] DCNL DCSP while gnodes: DCNL DCSP  DCSP if (root is None): DCNL DCSP  DCSP  DCSP root = gnodes.pop() DCNL DCSP  DCSP stack = [root] DCNL DCSP  DCSP pred = {root: root} DCNL DCSP  DCSP used = {root: set()} DCNL DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP z = stack.pop() DCNL DCSP  DCSP  DCSP zused = used[z] DCNL DCSP  DCSP  DCSP for nbr in G[z]: DCNL DCSP  DCSP  DCSP  DCSP if (nbr not in used): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pred[nbr] = z DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(nbr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP used[nbr] = set([z]) DCNL DCSP  DCSP  DCSP  DCSP elif (nbr == z): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycles.append([z]) DCNL DCSP  DCSP  DCSP  DCSP elif (nbr not in zused): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pn = used[nbr] DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycle = [nbr, z] DCNL DCSP  DCSP  DCSP  DCSP  DCSP p = pred[z] DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (p not in pn): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cycle.append(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p = pred[p] DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycle.append(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycles.append(cycle) DCNL DCSP  DCSP  DCSP  DCSP  DCSP used[nbr].add(z) DCNL DCSP  DCSP gnodes -= set(pred) DCNL DCSP  DCSP root = None DCNL DCSP return cycles
def computeEncryptionKey(password, dictOwnerPass, dictUserPass, dictOE, dictUE, fileID, pElement, dictKeyLength=128, revision=3, encryptMetadata=False, passwordType=None): DCNL  DCSP if (revision != 5): DCNL DCSP  DCSP keyLength = (dictKeyLength / 8) DCNL DCSP  DCSP lenPass = len(password) DCNL DCSP  DCSP if (lenPass > 32): DCNL DCSP  DCSP  DCSP password = password[:32] DCNL DCSP  DCSP elif (lenPass < 32): DCNL DCSP  DCSP  DCSP password += paddingString[:(32 - lenPass)] DCNL DCSP  DCSP md5input = (((password + dictOwnerPass) + struct.pack('<I', abs(int(pElement)))) + fileID) DCNL DCSP  DCSP if ((revision > 3) and (not encryptMetadata)): DCNL DCSP  DCSP  DCSP md5input += ('\xff' * 4) DCNL DCSP  DCSP key = hashlib.md5(md5input).digest() DCNL DCSP  DCSP if (revision > 2): DCNL DCSP  DCSP  DCSP counter = 0 DCNL DCSP  DCSP  DCSP while (counter < 50): DCNL DCSP  DCSP  DCSP  DCSP key = hashlib.md5(key[:keyLength]).digest() DCNL DCSP  DCSP  DCSP  DCSP counter += 1 DCNL DCSP  DCSP  DCSP key = key[:keyLength] DCNL DCSP  DCSP elif (revision == 2): DCNL DCSP  DCSP  DCSP key = key[:5] DCNL DCSP  DCSP return (0, key) DCNL DCSP else: DCNL DCSP  DCSP if (passwordType == 'USER'): DCNL DCSP  DCSP  DCSP password = password.encode('utf-8')[:127] DCNL DCSP  DCSP  DCSP kSalt = dictUserPass[40:48] DCNL DCSP  DCSP  DCSP intermediateKey = hashlib.sha256((password + kSalt)).digest() DCNL DCSP  DCSP  DCSP ret = aes.decryptData((('\x00' * 16) + dictUE), intermediateKey) DCNL DCSP  DCSP elif (passwordType == 'OWNER'): DCNL DCSP  DCSP  DCSP password = password.encode('utf-8')[:127] DCNL DCSP  DCSP  DCSP kSalt = dictOwnerPass[40:48] DCNL DCSP  DCSP  DCSP intermediateKey = hashlib.sha256(((password + kSalt) + dictUserPass)).digest() DCNL DCSP  DCSP  DCSP ret = aes.decryptData((('\x00' * 16) + dictOE), intermediateKey) DCNL DCSP  DCSP return ret
def redirect(uri, permanent=False, abort=False, code=None, body=None, request=None, response=None): DCNL  DCSP if uri.startswith(('.', '/')): DCNL DCSP  DCSP request = (request or get_request()) DCNL DCSP  DCSP uri = str(urlparse.urljoin(request.url, uri)) DCNL DCSP if (code is None): DCNL DCSP  DCSP if permanent: DCNL DCSP  DCSP  DCSP code = 301 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP code = 302 DCNL DCSP assert (code in (301, 302, 303, 305, 307)), 'Invalid DCSP redirect DCSP status DCSP code.' DCNL DCSP if abort: DCNL DCSP  DCSP _abort(code, headers=[('Location', uri)]) DCNL DCSP if (response is None): DCNL DCSP  DCSP request = (request or get_request()) DCNL DCSP  DCSP response = request.app.response_class() DCNL DCSP else: DCNL DCSP  DCSP response.clear() DCNL DCSP response.headers['Location'] = uri DCNL DCSP response.status = code DCNL DCSP if (body is not None): DCNL DCSP  DCSP response.write(body) DCNL DCSP return response
def _handleDescriptionFromFileOption(filename, outDir, usageStr, hsVersion, claDescriptionTemplateFile): DCNL  DCSP try: DCNL DCSP  DCSP fileHandle = open(filename, 'r') DCNL DCSP  DCSP JSONStringFromFile = fileHandle.read().splitlines() DCNL DCSP  DCSP JSONStringFromFile = ''.join(JSONStringFromFile) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvalidCommandArgException(_makeUsageErrorStr((('File DCSP open DCSP failed DCSP for DCSP --descriptionFromFile: DCSP %s\n' + 'ARG=<%s>') % (str(e), filename)), usageStr)) DCNL DCSP _handleDescriptionOption(JSONStringFromFile, outDir, usageStr, hsVersion=hsVersion, claDescriptionTemplateFile=claDescriptionTemplateFile) DCNL DCSP return
def get_create_test_view_sql(): DCNL  DCSP dir_path = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP sql_path = os.path.join(dir_path, 'sql', 'tko-test-view-2.sql') DCNL DCSP return open(sql_path).read()
def lv_check(vg_name, lv_name): DCNL  DCSP cmd = 'lvdisplay' DCNL DCSP result = utils.run(cmd, ignore_status=True) DCNL DCSP lvpattern = ('LV DCSP Path\\s+/dev/%s/%s\\s+' % (vg_name, lv_name)) DCNL DCSP match = re.search(lvpattern, result.stdout.rstrip()) DCNL DCSP if match: DCNL DCSP  DCSP logging.debug('Provided DCSP logical DCSP volume DCSP %s DCSP exists DCSP in DCSP %s', lv_name, vg_name) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def raw_cron(user): DCNL  DCSP if (_check_instance_uid_match(user) or (__grains__.get('os_family') in ('Solaris', 'AIX'))): DCNL DCSP  DCSP cmd = 'crontab DCSP -l' DCNL DCSP  DCSP lines = __salt__['cmd.run_stdout'](cmd, runas=user, rstrip=False, python_shell=False).splitlines(True) DCNL DCSP else: DCNL DCSP  DCSP cmd = 'crontab DCSP -u DCSP {0} DCSP -l'.format(user) DCNL DCSP  DCSP lines = __salt__['cmd.run_stdout'](cmd, rstrip=False, python_shell=False).splitlines(True) DCNL DCSP if ((len(lines) != 0) and lines[0].startswith('# DCSP DO DCSP NOT DCSP EDIT DCSP THIS DCSP FILE DCSP - DCSP edit DCSP the DCSP master DCSP and DCSP reinstall.')): DCNL DCSP  DCSP del lines[0:3] DCNL DCSP return ''.join(lines)
def create_logger(app): DCNL  DCSP Logger = getLoggerClass() DCNL DCSP class DebugLogger(Logger, ): DCNL DCSP  DCSP def getEffectiveLevel(x): DCNL DCSP  DCSP  DCSP if ((x.level == 0) and app.debug): DCNL DCSP  DCSP  DCSP  DCSP return DEBUG DCNL DCSP  DCSP  DCSP return Logger.getEffectiveLevel(x) DCNL DCSP class DebugHandler(StreamHandler, ): DCNL DCSP  DCSP def emit(x, record): DCNL DCSP  DCSP  DCSP (StreamHandler.emit(x, record) if app.debug else None) DCNL DCSP handler = DebugHandler() DCNL DCSP handler.setLevel(DEBUG) DCNL DCSP handler.setFormatter(Formatter(app.debug_log_format)) DCNL DCSP logger = getLogger(app.logger_name) DCNL DCSP del logger.handlers[:] DCNL DCSP logger.__class__ = DebugLogger DCNL DCSP logger.addHandler(handler) DCNL DCSP return logger
def _parse_relators(rels): DCNL  DCSP return rels
def get_future_timestamp(idx, timestamps): DCNL  DCSP if (idx == (len(timestamps) - 1)): DCNL DCSP  DCSP return get_past_timestamp(idx, timestamps) DCNL DCSP elif timestamps[idx]: DCNL DCSP  DCSP return timestamps[idx][0] DCNL DCSP else: DCNL DCSP  DCSP idx = min(len(timestamps), (idx + 1)) DCNL DCSP  DCSP return get_future_timestamp(idx, timestamps)
def get_pull_request(project, num, auth=False): DCNL  DCSP url = 'https://api.github.com/repos/{project}/pulls/{num}'.format(project=project, num=num) DCNL DCSP if auth: DCNL DCSP  DCSP header = make_auth_header() DCNL DCSP else: DCNL DCSP  DCSP header = None DCNL DCSP response = requests.get(url, headers=header) DCNL DCSP response.raise_for_status() DCNL DCSP return json.loads(response.text, object_hook=Obj)
def shebang_matches(text, regex): DCNL  DCSP index = text.find('\n') DCNL DCSP if (index >= 0): DCNL DCSP  DCSP first_line = text[:index].lower() DCNL DCSP else: DCNL DCSP  DCSP first_line = text.lower() DCNL DCSP if first_line.startswith('#!'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP found = [x for x in split_path_re.split(first_line[2:].strip()) if (x and (not x.startswith('-')))][(-1)] DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP regex = re.compile(('^%s(\\.(exe|cmd|bat|bin))?$' % regex), re.IGNORECASE) DCNL DCSP  DCSP if (regex.search(found) is not None): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@cython.test_fail_if_path_exists('//ForInStatNode') DCNL def for_in_empty(): DCNL  DCSP for i in []: DCNL DCSP  DCSP print 'LOOP'
def theq(a, b): DCNL  DCSP astr = theano.printing.debugprint(a, file='str') DCNL DCSP bstr = theano.printing.debugprint(b, file='str') DCNL DCSP if (not (astr == bstr)): DCNL DCSP  DCSP print () DCNL DCSP  DCSP print astr DCNL DCSP  DCSP print bstr DCNL DCSP return (astr == bstr)
def PrintUsageExit(code): DCNL  DCSP print (sys.modules['__main__'].__doc__ % sys.argv[0]) DCNL DCSP sys.stdout.flush() DCNL DCSP sys.stderr.flush() DCNL DCSP sys.exit(code)
def shutdown(opts): DCNL  DCSP log.debug('Proxy DCSP module DCSP {0} DCSP shutting DCSP down!!'.format(opts['id'])) DCNL DCSP try: DCNL DCSP  DCSP thisproxy['conn'].close() DCNL DCSP except Exception: DCNL DCSP  DCSP pass
def process_mistral_config(config_path): DCNL  DCSP assert config_path.startswith('/tmp') DCNL DCSP if (not os.path.isfile(config_path)): DCNL DCSP  DCSP return DCNL DCSP config = ConfigParser() DCNL DCSP config.read(config_path) DCNL DCSP for (section, options) in MISTRAL_CONF_OPTIONS_TO_REMOVE.items(): DCNL DCSP  DCSP for option in options: DCNL DCSP  DCSP  DCSP if config.has_option(section, option): DCNL DCSP  DCSP  DCSP  DCSP config.set(section, option, REMOVED_VALUE_NAME) DCNL DCSP with open(config_path, 'w') as fp: DCNL DCSP  DCSP config.write(fp)
def upgrade_config(config, config_path=os.path.expanduser('~/.jrnl_conf')): DCNL  DCSP missing_keys = set(default_config).difference(config) DCNL DCSP if missing_keys: DCNL DCSP  DCSP for key in missing_keys: DCNL DCSP  DCSP  DCSP config[key] = default_config[key] DCNL DCSP  DCSP with open(config_path, 'w') as f: DCNL DCSP  DCSP  DCSP json.dump(config, f, indent=2) DCNL DCSP  DCSP print '[.jrnl_conf DCSP updated DCSP to DCSP newest DCSP version]'
def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None, only_load=None, from_parent=None): DCNL  DCSP if (max_depth and (requested is None) and (cur_depth > max_depth)): DCNL DCSP  DCSP return None DCNL DCSP if only_load: DCNL DCSP  DCSP load_fields = (only_load.get(klass) or set()) DCNL DCSP  DCSP for parent in klass._meta.get_parent_list(): DCNL DCSP  DCSP  DCSP fields = only_load.get(parent) DCNL DCSP  DCSP  DCSP if fields: DCNL DCSP  DCSP  DCSP  DCSP load_fields.update(fields) DCNL DCSP else: DCNL DCSP  DCSP load_fields = None DCNL DCSP if load_fields: DCNL DCSP  DCSP skip = set() DCNL DCSP  DCSP init_list = [] DCNL DCSP  DCSP for (field, model) in klass._meta.get_concrete_fields_with_model(): DCNL DCSP  DCSP  DCSP if (from_parent and model and issubclass(from_parent, model)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (field.name not in load_fields): DCNL DCSP  DCSP  DCSP  DCSP skip.add(field.attname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP init_list.append(field.attname) DCNL DCSP  DCSP field_count = len(init_list) DCNL DCSP  DCSP if skip: DCNL DCSP  DCSP  DCSP klass = deferred_class_factory(klass, skip) DCNL DCSP  DCSP  DCSP field_names = init_list DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP field_names = () DCNL DCSP else: DCNL DCSP  DCSP field_count = len(klass._meta.concrete_fields) DCNL DCSP  DCSP if (from_parent and (len(klass._meta.local_concrete_fields) != len(klass._meta.concrete_fields))): DCNL DCSP  DCSP  DCSP non_seen_models = [p for p in klass._meta.get_parent_list() if (not issubclass(from_parent, p))] DCNL DCSP  DCSP  DCSP non_seen_models.append(klass) DCNL DCSP  DCSP  DCSP field_names = [f.attname for f in klass._meta.concrete_fields if (f.model in non_seen_models)] DCNL DCSP  DCSP  DCSP field_count = len(field_names) DCNL DCSP  DCSP if (field_count == len(klass._meta.concrete_fields)): DCNL DCSP  DCSP  DCSP field_names = () DCNL DCSP restricted = (requested is not None) DCNL DCSP related_fields = [] DCNL DCSP for f in klass._meta.fields: DCNL DCSP  DCSP if select_related_descend(f, restricted, requested, load_fields): DCNL DCSP  DCSP  DCSP if restricted: DCNL DCSP  DCSP  DCSP  DCSP next = requested[f.name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP next = None DCNL DCSP  DCSP  DCSP klass_info = get_klass_info(f.rel.to, max_depth=max_depth, cur_depth=(cur_depth + 1), requested=next, only_load=only_load) DCNL DCSP  DCSP  DCSP related_fields.append((f, klass_info)) DCNL DCSP reverse_related_fields = [] DCNL DCSP if restricted: DCNL DCSP  DCSP for o in klass._meta.get_all_related_objects(): DCNL DCSP  DCSP  DCSP if (o.field.unique and select_related_descend(o.field, restricted, requested, only_load.get(o.model), reverse=True)): DCNL DCSP  DCSP  DCSP  DCSP next = requested[o.field.related_query_name()] DCNL DCSP  DCSP  DCSP  DCSP parent = (klass if issubclass(o.model, klass) else None) DCNL DCSP  DCSP  DCSP  DCSP klass_info = get_klass_info(o.model, max_depth=max_depth, cur_depth=(cur_depth + 1), requested=next, only_load=only_load, from_parent=parent) DCNL DCSP  DCSP  DCSP  DCSP reverse_related_fields.append((o.field, klass_info)) DCNL DCSP if field_names: DCNL DCSP  DCSP pk_idx = field_names.index(klass._meta.pk.attname) DCNL DCSP else: DCNL DCSP  DCSP pk_idx = klass._meta.pk_index() DCNL DCSP return (klass, field_names, field_count, related_fields, reverse_related_fields, pk_idx)
def _install(quidditch, retries=5): DCNL  DCSP passed = False DCNL DCSP clean = True DCNL DCSP comment = '' DCNL DCSP while (not passed): DCNL DCSP  DCSP log.debug('download_collection DCSP is DCSP this DCSP long: DCSP {0}'.format(str(quidditch.install_collection.Count))) DCNL DCSP  DCSP log.debug('Installing. DCSP tries DCSP left: DCSP {0}'.format(str(retries))) DCNL DCSP  DCSP passed = quidditch.Install() DCNL DCSP  DCSP log.info('Done DCSP installing: DCSP {0}'.format(str(passed))) DCNL DCSP  DCSP if isinstance(passed, Exception): DCNL DCSP  DCSP  DCSP clean = False DCNL DCSP  DCSP  DCSP comment += 'Failed DCSP while DCSP trying DCSP to DCSP install DCSP the DCSP updates.\n DCTB  DCTB {0}\n'.format(str(passed)) DCNL DCSP  DCSP  DCSP retries -= 1 DCNL DCSP  DCSP  DCSP if retries: DCNL DCSP  DCSP  DCSP  DCSP comment += '{0} DCSP tries DCSP to DCSP go. DCSP retrying\n'.format(str(retries)) DCNL DCSP  DCSP  DCSP  DCSP passed = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP comment += 'out DCSP of DCSP retries. DCSP this DCSP update DCSP round DCSP failed.\n' DCNL DCSP  DCSP  DCSP  DCSP return (comment, False, retries) DCNL DCSP if clean: DCNL DCSP  DCSP comment += 'Install DCSP was DCSP done DCSP without DCSP error.\n' DCNL DCSP return (comment, True, retries)
def _reorder_unifrac_res(unifrac_res, sample_names_in_desired_order): DCNL  DCSP sample_names = sample_names_in_desired_order DCNL DCSP unifrac_dist_mtx = unifrac_res[0] DCNL DCSP unifrac_sample_names = unifrac_res[1] DCNL DCSP unifrac_sample_names_idx = dict([(n, i) for (i, n) in enumerate(unifrac_sample_names)]) DCNL DCSP if (list(unifrac_sample_names) == list(sample_names)): DCNL DCSP  DCSP dist_mtx = unifrac_dist_mtx DCNL DCSP else: DCNL DCSP  DCSP dist_mtx = np.zeros((len(sample_names), len(sample_names))) DCNL DCSP  DCSP for (i, sam_i) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP if (sam_i not in unifrac_sample_names_idx): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn((('unifrac DCSP had DCSP no DCSP information DCSP for DCSP sample DCSP ' + sam_i) + ". DCSP Distances DCSP involving DCSP that DCSP sample DCSP aren't DCSP meaningful")) DCNL DCSP  DCSP  DCSP  DCSP for (j, sam_j) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sam_j not in unifrac_sample_names_idx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dist_mtx[(i, j)] = 0.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dist_mtx[(i, j)] = 1.0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unifrac_i = unifrac_sample_names_idx[sam_i] DCNL DCSP  DCSP  DCSP  DCSP for (j, sam_j) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sam_j not in unifrac_sample_names_idx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dist_mtx[(i, j)] = 1.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unifrac_j = unifrac_sample_names_idx[sam_j] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dist_mtx[(i, j)] = unifrac_dist_mtx[(unifrac_i, unifrac_j)] DCNL DCSP return dist_mtx
def organisation(): DCNL  DCSP def prep(r): DCNL DCSP  DCSP query = (FS('organisation_id:po_referral_organisation.id') != None) DCNL DCSP  DCSP r.resource.add_filter(query) DCNL DCSP  DCSP onaccept = s3db.get_config('org_organisation', 'onaccept') DCNL DCSP  DCSP s3db.configure('org_organisation', onaccept=(onaccept, s3db.po_organisation_onaccept)) DCNL DCSP  DCSP if (r.record and (r.component_name == 'organisation_household')): DCNL DCSP  DCSP  DCSP atable = s3db.po_organisation_area DCNL DCSP  DCSP  DCSP query = ((atable.organisation_id == r.id) & (atable.deleted != True)) DCNL DCSP  DCSP  DCSP rows = db(query).select(atable.area_id) DCNL DCSP  DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP  DCSP area_ids = [row.area_id for row in rows] DCNL DCSP  DCSP  DCSP  DCSP area_ids.append(None) DCNL DCSP  DCSP  DCSP  DCSP table = r.component.table DCNL DCSP  DCSP  DCSP  DCSP table.household_id.requires.set_filter(filterby='area_id', filter_opts=area_ids) DCNL DCSP  DCSP elif (not r.component): DCNL DCSP  DCSP  DCSP list_fields = ['name', 'name', (T('Type'), 'organisation_organisation_type.organisation_type_id'), (T('Areas'), 'organisation_area.area_id'), 'website'] DCNL DCSP  DCSP  DCSP s3db.configure('org_organisation', list_fields=list_fields) DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP s3.crud_strings['org_organisation'].update({'label_create': T('Create DCSP Agency'), 'title_list': T('Referral DCSP Agencies'), 'title_display': T('Agency DCSP Details'), 'title_update': T('Edit DCSP Agency DCSP Details'), 'label_delete_button': T('Delete DCSP Agency')}) DCNL DCSP  DCSP  DCSP if (r.component_name == 'area'): DCNL DCSP  DCSP  DCSP  DCSP s3.crud_strings['po_organisation_area'].update({'label_create': T('Add DCSP Area')}) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller('org', 'organisation', rheader=s3db.po_rheader)
def download_youtube_subs(youtube_id, video_descriptor, settings): DCNL  DCSP i18n = video_descriptor.runtime.service(video_descriptor, 'i18n') DCNL DCSP _ = i18n.ugettext DCNL DCSP subs = get_transcripts_from_youtube(youtube_id, settings, i18n) DCNL DCSP save_subs_to_store(subs, youtube_id, video_descriptor) DCNL DCSP log.info('Transcripts DCSP for DCSP youtube_id DCSP %s DCSP for DCSP 1.0 DCSP speed DCSP are DCSP downloaded DCSP and DCSP saved.', youtube_id)
def _collapse_address_list_recursive(addresses): DCNL  DCSP ret_array = [] DCNL DCSP optimized = False DCNL DCSP for cur_addr in addresses: DCNL DCSP  DCSP if (not ret_array): DCNL DCSP  DCSP  DCSP ret_array.append(cur_addr) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (cur_addr in ret_array[(-1)]): DCNL DCSP  DCSP  DCSP optimized = True DCNL DCSP  DCSP elif (cur_addr == ret_array[(-1)].supernet().subnet()[1]): DCNL DCSP  DCSP  DCSP ret_array.append(ret_array.pop().supernet()) DCNL DCSP  DCSP  DCSP optimized = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret_array.append(cur_addr) DCNL DCSP if optimized: DCNL DCSP  DCSP return _collapse_address_list_recursive(ret_array) DCNL DCSP return ret_array
def add_handlers(handler_list, subparsers): DCNL  DCSP command_handlers = [ListCustomDescriptorsHandler('/stackdriver/list_descriptors', 'list_stackdriver', 'Get DCSP the DCSP JSON DCSP of DCSP all DCSP the DCSP Stackdriver DCSP Custom DCSP Metric DCSP Descriptors.'), ClearCustomDescriptorsHandler('/stackdriver/clear_descriptors', 'clear_stackdriver', 'Clear DCSP all DCSP the DCSP Stackdriver DCSP Custom DCSP Metrics'), UpsertCustomDescriptorsHandler(None, 'upsert_stackdriver_descriptors', 'Given DCSP a DCSP file DCSP of DCSP Stackdriver DCSP Custom DCSP Metric DCSP Desciptors, DCSP update DCSP the DCSP existing DCSP ones DCSP and DCSP add DCSP the DCSP new DCSP ones. DCSP WARNING: DCSP Historic DCSP time-series DCSP data DCSP may DCSP be DCSP lost DCSP on DCSP update.')] DCNL DCSP for handler in command_handlers: DCNL DCSP  DCSP handler.add_argparser(subparsers) DCNL DCSP  DCSP handler_list.append(handler)
def splitline(text): DCNL  DCSP index = (text.find('\n') + 1) DCNL DCSP if index: DCNL DCSP  DCSP return (text[:index], text[index:]) DCNL DCSP else: DCNL DCSP  DCSP return (text, '')
def prism(): DCNL  DCSP rc('image', cmap='prism') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.prism) DCNL DCSP draw_if_interactive()
def _machinectl(cmd, output_loglevel='debug', ignore_retcode=False, use_vt=False): DCNL  DCSP prefix = 'machinectl DCSP --no-legend DCSP --no-pager' DCNL DCSP return __salt__['cmd.run_all']('{0} DCSP {1}'.format(prefix, cmd), output_loglevel=output_loglevel, ignore_retcode=ignore_retcode, use_vt=use_vt)
def scott_bin_width(data, return_bins=False): DCNL  DCSP data = np.asarray(data) DCNL DCSP if (data.ndim != 1): DCNL DCSP  DCSP raise ValueError(u'data DCSP should DCSP be DCSP one-dimensional') DCNL DCSP n = data.size DCNL DCSP sigma = np.std(data) DCNL DCSP dx = ((3.5 * sigma) / (n ** (1 / 3))) DCNL DCSP if return_bins: DCNL DCSP  DCSP Nbins = np.ceil(((data.max() - data.min()) / dx)) DCNL DCSP  DCSP Nbins = max(1, Nbins) DCNL DCSP  DCSP bins = (data.min() + (dx * np.arange((Nbins + 1)))) DCNL DCSP  DCSP return (dx, bins) DCNL DCSP else: DCNL DCSP  DCSP return dx
def _quoteattr(data, entities={}): DCNL  DCSP entities['\n'] = '&#10;' DCNL DCSP entities['\r'] = '&#12;' DCNL DCSP data = _escape(data, entities) DCNL DCSP if ('"' in data): DCNL DCSP  DCSP if ("'" in data): DCNL DCSP  DCSP  DCSP data = ('"%s"' % data.replace('"', '&quot;')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP data = ("'%s'" % data) DCNL DCSP else: DCNL DCSP  DCSP data = ('"%s"' % data) DCNL DCSP return data
def default_key_func(key, key_prefix, version): DCNL  DCSP return ('%s:%s:%s' % (key_prefix, version, key))
def get_host_numa_usage_from_instance(host, instance, free=False, never_serialize_result=False): DCNL  DCSP instance_numa_topology = instance_topology_from_instance(instance) DCNL DCSP if instance_numa_topology: DCNL DCSP  DCSP instance_numa_topology = [instance_numa_topology] DCNL DCSP (host_numa_topology, jsonify_result) = host_topology_and_format_from_host(host) DCNL DCSP updated_numa_topology = numa_usage_from_instances(host_numa_topology, instance_numa_topology, free=free) DCNL DCSP if (updated_numa_topology is not None): DCNL DCSP  DCSP if (jsonify_result and (not never_serialize_result)): DCNL DCSP  DCSP  DCSP updated_numa_topology = updated_numa_topology._to_json() DCNL DCSP return updated_numa_topology
@protocol.commands.add(u'pause', state=protocol.BOOL) DCNL def pause(context, state=None): DCNL  DCSP if (state is None): DCNL DCSP  DCSP deprecation.warn(u'mpd.protocol.playback.pause:state_arg') DCNL DCSP  DCSP playback_state = context.core.playback.get_state().get() DCNL DCSP  DCSP if (playback_state == PlaybackState.PLAYING): DCNL DCSP  DCSP  DCSP context.core.playback.pause().get() DCNL DCSP  DCSP elif (playback_state == PlaybackState.PAUSED): DCNL DCSP  DCSP  DCSP context.core.playback.resume().get() DCNL DCSP elif state: DCNL DCSP  DCSP context.core.playback.pause().get() DCNL DCSP else: DCNL DCSP  DCSP context.core.playback.resume().get()
def send_message(to, text, sender=None): DCNL  DCSP if sender: DCNL DCSP  DCSP msg = OutboxMessage.objects.create(sender=sender, message=text) DCNL DCSP  DCSP msg.to.add(*to) DCNL DCSP for user in to: DCNL DCSP  DCSP im = InboxMessage.objects.create(sender=sender, to=user, message=text) DCNL DCSP  DCSP if Setting.get_for_user(user, 'email_private_messages'): DCNL DCSP  DCSP  DCSP email_private_message(inbox_message_id=im.id) DCNL DCSP message_sent.send(sender=InboxMessage, to=to, text=text, msg_sender=sender)
def validate(filename): DCNL  DCSP import HTMLParser DCNL DCSP from py_w3c.validators.html.validator import HTMLValidator DCNL DCSP h = HTMLParser.HTMLParser() DCNL DCSP vld = HTMLValidator() DCNL DCSP LOG.info('Validating: DCSP {0}'.format(filename)) DCNL DCSP vld.validate_file(filename) DCNL DCSP for err in vld.errors: DCNL DCSP  DCSP LOG.error(u'line: DCSP {0}; DCSP col: DCSP {1}; DCSP message: DCSP {2}'.format(err['line'], err['col'], h.unescape(err['message']))) DCNL DCSP for err in vld.warnings: DCNL DCSP  DCSP LOG.warning(u'line: DCSP {0}; DCSP col: DCSP {1}; DCSP message: DCSP {2}'.format(err['line'], err['col'], h.unescape(err['message'])))
def __get_hosts_filename(): DCNL  DCSP return __salt__['config.option']('hosts.file')
def collect_bears(bear_dirs, bear_globs, kinds, log_printer, warn_if_unused_glob=True): DCNL  DCSP bears_found = tuple(([] for i in range(len(kinds)))) DCNL DCSP bear_globs_with_bears = set() DCNL DCSP for (bear, glob) in icollect_bears(bear_dirs, bear_globs, kinds, log_printer): DCNL DCSP  DCSP index = kinds.index(_get_kind(bear)) DCNL DCSP  DCSP bears_found[index].append(bear) DCNL DCSP  DCSP bear_globs_with_bears.add(glob) DCNL DCSP if warn_if_unused_glob: DCNL DCSP  DCSP _warn_if_unused_glob(log_printer, bear_globs, bear_globs_with_bears, "No DCSP bears DCSP matching DCSP '{}' DCSP were DCSP found. DCSP Make DCSP sure DCSP you DCSP have DCSP coala-bears DCSP installed DCSP or DCSP you DCSP have DCSP typed DCSP the DCSP name DCSP correctly.") DCNL DCSP return bears_found
def _format_content(password, salt, encrypt=True): DCNL  DCSP if ((not encrypt) and (not salt)): DCNL DCSP  DCSP return password DCNL DCSP assert salt, '_format_content DCSP was DCSP called DCSP with DCSP encryption DCSP requested DCSP but DCSP no DCSP salt DCSP value' DCNL DCSP return (u'%s DCSP salt=%s' % (password, salt))
def _prep_stats_dict(values): DCNL  DCSP stats = [] DCNL DCSP d = values.get('stats', {}) DCNL DCSP for (k, v) in d.iteritems(): DCNL DCSP  DCSP stat = models.ComputeNodeStat() DCNL DCSP  DCSP stat['key'] = k DCNL DCSP  DCSP stat['value'] = v DCNL DCSP  DCSP stats.append(stat) DCNL DCSP values['stats'] = stats
def metric_init(params): DCNL  DCSP global array_dict DCNL DCSP array_dict = {'array1': {'array_name': 'array1', 'ipaddr': '192.168.1.50', 'user': '3paruser', 'pass': '3parpass'}, 'array2': {'array_name': 'array2', 'ipaddr': '192.168.1.51', 'user': '3paruser', 'pass': '3parpass'}} DCNL DCSP Desc_Skel = {'name': 'XXX', 'call_back': get_metric, 'time_max': 600, 'value_type': 'double', 'format': '%0f', 'units': 'XXX', 'slope': 'both', 'description': 'XXX', 'groups': 'storage'} DCNL DCSP descriptors = [] DCNL DCSP for array in array_dict: DCNL DCSP  DCSP ip = array_dict[array]['ipaddr'] DCNL DCSP  DCSP user = array_dict[array]['user'] DCNL DCSP  DCSP passwd = array_dict[array]['pass'] DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP volumes DCSP in DCSP the DCSP array' DCNL DCSP  DCSP vols = get_vol_list(ip, user, passwd) DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP CPGs DCSP in DCSP the DCSP array' DCNL DCSP  DCSP cpgs = get_cpg_list(ip, user, passwd) DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP CPUs DCSP in DCSP the DCSP array DCSP - DCSP Only DCSP getting DCSP totals DCSP per DCSP node DCSP at DCSP this DCSP point' DCNL DCSP  DCSP cpus = get_cpu_list(ip, user, passwd) DCNL DCSP  DCSP 'create DCSP descriptors DCSP for DCSP the DCSP array' DCNL DCSP  DCSP array_descriptors = define_metrics(Desc_Skel, array_dict[array]['array_name'], vols, ip, cpgs, cpus) DCNL DCSP  DCSP descriptors = (descriptors + array_descriptors) DCNL DCSP return descriptors
def arcball_nearest_axis(point, axes): DCNL  DCSP point = numpy.array(point, dtype=numpy.float64, copy=False) DCNL DCSP nearest = None DCNL DCSP mx = (-1.0) DCNL DCSP for axis in axes: DCNL DCSP  DCSP t = numpy.dot(arcball_constrain_to_axis(point, axis), point) DCNL DCSP  DCSP if (t > mx): DCNL DCSP  DCSP  DCSP nearest = axis DCNL DCSP  DCSP  DCSP mx = t DCNL DCSP return nearest
def regions(): DCNL  DCSP return get_regions('elasticmapreduce', connection_cls=EmrConnection)
def contains_nan(arr, node=None, var=None): DCNL  DCSP if isinstance(arr, theano.gof.type._cdata_type): DCNL DCSP  DCSP return False DCNL DCSP elif isinstance(arr, np.random.mtrand.RandomState): DCNL DCSP  DCSP return False DCNL DCSP elif (var and getattr(var.tag, 'is_rng', False)): DCNL DCSP  DCSP return False DCNL DCSP elif isinstance(arr, slice): DCNL DCSP  DCSP return False DCNL DCSP elif (arr.size == 0): DCNL DCSP  DCSP return False DCNL DCSP elif (cuda.cuda_available and isinstance(arr, cuda.CudaNdarray)): DCNL DCSP  DCSP if (node and hasattr(theano.sandbox, 'rng_mrg') and isinstance(node.op, theano.sandbox.rng_mrg.GPU_mrg_uniform)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP compile_gpu_func(True, False, False) DCNL DCSP  DCSP  DCSP return np.isnan(f_gpumin(arr.reshape(arr.size))) DCNL DCSP elif (pygpu_available and isinstance(arr, GpuArray)): DCNL DCSP  DCSP return np.isnan(f_gpua_min(arr.reshape(arr.size))) DCNL DCSP return np.isnan(np.min(arr))
def strip_html_tags(text): DCNL  DCSP return re.sub(u'\\<[^>]*\\>', u'', text)
def runtests(args=None): DCNL  DCSP import pytest DCNL DCSP import os DCNL DCSP try: DCNL DCSP  DCSP import faulthandler DCNL DCSP  DCSP faulthandler.enable() DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP rootdir = os.path.join(os.path.dirname(__file__), os.pardir) DCNL DCSP os.chdir(rootdir) DCNL DCSP return pytest.main(args=args)
def wait_for_free_port(host, port, timeout=None): DCNL  DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP allowed.") DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = free_port_timeout DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port, timeout=timeout) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP free DCSP on DCSP %r' % (port, host)))
def _get_service_result_parser(run=utils.run): DCNL  DCSP global _service_result_parser DCNL DCSP try: DCNL DCSP  DCSP return _service_result_parser DCNL DCSP except NameError: DCNL DCSP  DCSP result_parser = _result_parsers[get_name_of_init(run)] DCNL DCSP  DCSP _service_result_parser = _ServiceResultParser(result_parser) DCNL DCSP  DCSP return _service_result_parser
def update(context, qos_specs_id, specs): DCNL  DCSP LOG.debug(('qos_specs.update(): DCSP specs DCSP %s' % specs)) DCNL DCSP try: DCNL DCSP  DCSP qos_spec = objects.QualityOfServiceSpecs.get_by_id(context, qos_specs_id) DCNL DCSP  DCSP if ('consumer' in specs): DCNL DCSP  DCSP  DCSP qos_spec.consumer = specs['consumer'] DCNL DCSP  DCSP  DCSP specs = specs.copy() DCNL DCSP  DCSP  DCSP del specs['consumer'] DCNL DCSP  DCSP qos_spec.specs.update(specs) DCNL DCSP  DCSP qos_spec.save() DCNL DCSP except db_exc.DBError: DCNL DCSP  DCSP LOG.exception(_LE('DB DCSP error:')) DCNL DCSP  DCSP raise exception.QoSSpecsUpdateFailed(specs_id=qos_specs_id, qos_specs=specs) DCNL DCSP return qos_spec
def handle_extensions(extensions=('html',), ignored=('py',)): DCNL  DCSP ext_list = [] DCNL DCSP for ext in extensions: DCNL DCSP  DCSP ext_list.extend(ext.replace(' DCSP ', '').split(',')) DCNL DCSP for (i, ext) in enumerate(ext_list): DCNL DCSP  DCSP if (not ext.startswith('.')): DCNL DCSP  DCSP  DCSP ext_list[i] = ('.%s' % ext_list[i]) DCNL DCSP return set([x for x in ext_list if (x.strip('.') not in ignored)])
def dtlz7(ind, n_objs): DCNL  DCSP gval = (1 + ((9.0 / len(ind[(n_objs - 1):])) * sum([a for a in ind[(n_objs - 1):]]))) DCNL DCSP fit = [ind for ind in ind[:(n_objs - 1)]] DCNL DCSP fit.append(((1 + gval) * (n_objs - sum([((a / (1.0 + gval)) * (1 + sin(((3 * pi) * a)))) for a in ind[:(n_objs - 1)]])))) DCNL DCSP return fit
def offset_spines(offset=10, fig=None, ax=None): DCNL  DCSP warn_msg = '`offset_spines` DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP v0.5' DCNL DCSP warnings.warn(warn_msg, UserWarning) DCNL DCSP if ((fig is None) and (ax is None)): DCNL DCSP  DCSP axes = plt.gcf().axes DCNL DCSP elif (fig is not None): DCNL DCSP  DCSP axes = fig.axes DCNL DCSP elif (ax is not None): DCNL DCSP  DCSP axes = [ax] DCNL DCSP for ax_i in axes: DCNL DCSP  DCSP for spine in ax_i.spines.values(): DCNL DCSP  DCSP  DCSP _set_spine_position(spine, ('outward', offset))
@verbose DCNL def spatio_temporal_dist_connectivity(src, n_times, dist, verbose=None): DCNL  DCSP if (src[0]['dist'] is None): DCNL DCSP  DCSP raise RuntimeError('src DCSP must DCSP have DCSP distances DCSP included, DCSP consider DCSP using\nmne_add_patch_info DCSP with DCSP --dist DCSP argument') DCNL DCSP edges = sparse_block_diag([s['dist'][s['vertno'], :][:, s['vertno']] for s in src]) DCNL DCSP edges.data[:] = np.less_equal(edges.data, dist) DCNL DCSP edges = edges.tocsr() DCNL DCSP edges.eliminate_zeros() DCNL DCSP edges = edges.tocoo() DCNL DCSP return _get_connectivity_from_edges(edges, n_times)
def security_group_rule_get_by_instance(context, instance_uuid): DCNL  DCSP return IMPL.security_group_rule_get_by_instance(context, instance_uuid)
def get_font(section='main', option='font', font_size_delta=0): DCNL  DCSP font = FONT_CACHE.get((section, option)) DCNL DCSP if (font is None): DCNL DCSP  DCSP families = CONF.get(section, (option + '/family'), None) DCNL DCSP  DCSP if (families is None): DCNL DCSP  DCSP  DCSP return QFont() DCNL DCSP  DCSP family = get_family(families) DCNL DCSP  DCSP weight = QFont.Normal DCNL DCSP  DCSP italic = CONF.get(section, (option + '/italic'), False) DCNL DCSP  DCSP if CONF.get(section, (option + '/bold'), False): DCNL DCSP  DCSP  DCSP weight = QFont.Bold DCNL DCSP  DCSP size = (CONF.get(section, (option + '/size'), 9) + font_size_delta) DCNL DCSP  DCSP font = QFont(family, size, weight) DCNL DCSP  DCSP font.setItalic(italic) DCNL DCSP  DCSP FONT_CACHE[(section, option)] = font DCNL DCSP size = (CONF.get(section, (option + '/size'), 9) + font_size_delta) DCNL DCSP font.setPointSize(size) DCNL DCSP return font
@pytest.mark.django_db DCNL def test_save_store_fs_bad_lang(po_directory, tp0_store_fs): DCNL  DCSP tp0_store_fs.store = None DCNL DCSP tp0_store_fs.pootle_path = '/fr/project0/example.po' DCNL DCSP with pytest.raises(ValidationError): DCNL DCSP  DCSP tp0_store_fs.save()
def flexible_boolean(boolean): DCNL  DCSP if (boolean in ('1', 'true', 'True')): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def get_all_remote_methods(resolver=None, ns_prefix=u''): DCNL  DCSP if (not resolver): DCNL DCSP  DCSP resolver = get_resolver(get_urlconf()) DCNL DCSP result = {} DCNL DCSP for name in resolver.reverse_dict.keys(): DCNL DCSP  DCSP if (not isinstance(name, six.string_types)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP url = reverse((ns_prefix + name)) DCNL DCSP  DCSP  DCSP resmgr = resolve(url) DCNL DCSP  DCSP  DCSP ViewClass = import_string(u'{0}.{1}'.format(resmgr.func.__module__, resmgr.func.__name__)) DCNL DCSP  DCSP  DCSP if (isclass(ViewClass) and issubclass(ViewClass, JSONResponseMixin)): DCNL DCSP  DCSP  DCSP  DCSP result[name] = _get_remote_methods_for(ViewClass, url) DCNL DCSP  DCSP except (NoReverseMatch, ImproperlyConfigured): DCNL DCSP  DCSP  DCSP pass DCNL DCSP for (namespace, ns_pattern) in resolver.namespace_dict.items(): DCNL DCSP  DCSP sub_res = get_all_remote_methods(ns_pattern[1], ((ns_prefix + namespace) + u':')) DCNL DCSP  DCSP if sub_res: DCNL DCSP  DCSP  DCSP result[namespace] = sub_res DCNL DCSP return result
def removeGeneratedFiles(): DCNL  DCSP gcodeFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively(['gcode']) DCNL DCSP for gcodeFilePath in gcodeFilePaths: DCNL DCSP  DCSP if ('alterations' not in gcodeFilePath): DCNL DCSP  DCSP  DCSP os.remove(gcodeFilePath) DCNL DCSP  DCSP  DCSP print ('removeGeneratedFiles DCSP deleted DCSP ' + gcodeFilePath) DCNL DCSP svgFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively(['svg']) DCNL DCSP for svgFilePath in svgFilePaths: DCNL DCSP  DCSP if archive.getEndsWithList(svgFilePath, ['_bottom.svg', '_carve.svg', '_chop.svg', '_cleave.svg']): DCNL DCSP  DCSP  DCSP os.remove(svgFilePath) DCNL DCSP  DCSP  DCSP print ('removeGeneratedFiles DCSP deleted DCSP ' + svgFilePath) DCNL DCSP xmlFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively(['xml']) DCNL DCSP for xmlFilePath in xmlFilePaths: DCNL DCSP  DCSP if archive.getEndsWithList(xmlFilePath, ['_interpret.xml']): DCNL DCSP  DCSP  DCSP os.remove(xmlFilePath) DCNL DCSP  DCSP  DCSP print ('removeGeneratedFiles DCSP deleted DCSP ' + xmlFilePath) DCNL DCSP archive.removeBackupFilesByTypes(['gcode', 'svg', 'xml'])
def print_and_modify(obj, mods, dels): DCNL  DCSP obj.update(mods) DCNL DCSP for field in dels: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del obj[field] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return ui.show_model_changes(obj)
def labeled_comprehension(input, labels, index, func, out_dtype, default, pass_positions=False): DCNL  DCSP as_scalar = numpy.isscalar(index) DCNL DCSP input = numpy.asarray(input) DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = numpy.arange(input.size).reshape(input.shape) DCNL DCSP if (labels is None): DCNL DCSP  DCSP if (index is not None): DCNL DCSP  DCSP  DCSP raise ValueError('index DCSP without DCSP defined DCSP labels') DCNL DCSP  DCSP if (not pass_positions): DCNL DCSP  DCSP  DCSP return func(input.ravel()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(input.ravel(), positions.ravel()) DCNL DCSP try: DCNL DCSP  DCSP (input, labels) = numpy.broadcast_arrays(input, labels) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError('input DCSP and DCSP labels DCSP must DCSP have DCSP the DCSP same DCSP shape DCSP (excepting DCSP dimensions DCSP with DCSP width DCSP 1)') DCNL DCSP if (index is None): DCNL DCSP  DCSP if (not pass_positions): DCNL DCSP  DCSP  DCSP return func(input[(labels > 0)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(input[(labels > 0)], positions[(labels > 0)]) DCNL DCSP index = numpy.atleast_1d(index) DCNL DCSP if np.any((index.astype(labels.dtype).astype(index.dtype) != index)): DCNL DCSP  DCSP raise ValueError(("Cannot DCSP convert DCSP index DCSP values DCSP from DCSP <%s> DCSP to DCSP <%s> DCSP (labels' DCSP type) DCSP without DCSP loss DCSP of DCSP precision" % (index.dtype, labels.dtype))) DCNL DCSP index = index.astype(labels.dtype) DCNL DCSP lo = index.min() DCNL DCSP hi = index.max() DCNL DCSP mask = ((labels >= lo) & (labels <= hi)) DCNL DCSP labels = labels[mask] DCNL DCSP input = input[mask] DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = positions[mask] DCNL DCSP label_order = labels.argsort() DCNL DCSP labels = labels[label_order] DCNL DCSP input = input[label_order] DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = positions[label_order] DCNL DCSP index_order = index.argsort() DCNL DCSP sorted_index = index[index_order] DCNL DCSP def do_map(inputs, output): DCNL DCSP  DCSP 'labels DCSP must DCSP be DCSP sorted' DCNL DCSP  DCSP nidx = sorted_index.size DCNL DCSP  DCSP lo = numpy.searchsorted(labels, sorted_index, side='left') DCNL DCSP  DCSP hi = numpy.searchsorted(labels, sorted_index, side='right') DCNL DCSP  DCSP for (i, l, h) in zip(range(nidx), lo, hi): DCNL DCSP  DCSP  DCSP if (l == h): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP output[i] = func(*[inp[l:h] for inp in inputs]) DCNL DCSP temp = numpy.empty(index.shape, out_dtype) DCNL DCSP temp[:] = default DCNL DCSP if (not pass_positions): DCNL DCSP  DCSP do_map([input], temp) DCNL DCSP else: DCNL DCSP  DCSP do_map([input, positions], temp) DCNL DCSP output = numpy.zeros(index.shape, out_dtype) DCNL DCSP output[index_order] = temp DCNL DCSP if as_scalar: DCNL DCSP  DCSP output = output[0] DCNL DCSP return output
def get_file_hash(filePath): DCNL  DCSP if (not filePath): DCNL DCSP  DCSP return None DCNL DCSP md4 = hashlib.new('md4').copy DCNL DCSP def gen(f): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP x = f.read(9728000) DCNL DCSP  DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP  DCSP (yield x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP def md4_hash(data): DCNL DCSP  DCSP m = md4() DCNL DCSP  DCSP m.update(data) DCNL DCSP  DCSP return m DCNL DCSP with open(filePath, 'rb') as f: DCNL DCSP  DCSP a = gen(f) DCNL DCSP  DCSP hashes = [md4_hash(data).digest() for data in a] DCNL DCSP  DCSP if (len(hashes) == 1): DCNL DCSP  DCSP  DCSP return hashes[0].encode('hex') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return md4_hash(reduce((lambda a, d: (a + d)), hashes, '')).hexdigest()
def backup_destroy(context, backup_id): DCNL  DCSP return IMPL.backup_destroy(context, backup_id)
def __determine_resource_obj(service, resource): DCNL  DCSP path = resource.split('.') DCNL DCSP node = service DCNL DCSP for elem in path: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP node = getattr(node, elem)() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError('"{0}" DCSP has DCSP no DCSP attribute DCSP "{1}"'.format('.'.join(path[0:path.index(elem)]), elem)) DCNL DCSP return node
def t_preprocessor(t): DCNL  DCSP t.lexer.lineno += 1
def _list_designs(user, querydict, page_size, prefix='', is_trashed=False): DCNL  DCSP DEFAULT_SORT = ('-', 'date') DCNL DCSP SORT_ATTR_TRANSLATION = dict(date='last_modified', name='name', desc='description', type='extra') DCNL DCSP if is_trashed: DCNL DCSP  DCSP db_queryset = Document.objects.trashed_docs(SavedQuery, user) DCNL DCSP else: DCNL DCSP  DCSP db_queryset = Document.objects.available_docs(SavedQuery, user) DCNL DCSP filter_username = querydict.get((prefix + 'user')) DCNL DCSP if filter_username: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP db_queryset = db_queryset.filter(owner=User.objects.get(username=filter_username)) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP d_type = querydict.get((prefix + 'type')) DCNL DCSP if (d_type and (d_type in SavedQuery.TYPES_MAPPING.keys())): DCNL DCSP  DCSP db_queryset = db_queryset.filter(extra=str(SavedQuery.TYPES_MAPPING[d_type])) DCNL DCSP frag = querydict.get((prefix + 'text')) DCNL DCSP if frag: DCNL DCSP  DCSP db_queryset = db_queryset.filter((Q(name__icontains=frag) | Q(description__icontains=frag))) DCNL DCSP sort_key = querydict.get((prefix + 'sort')) DCNL DCSP if sort_key: DCNL DCSP  DCSP if (sort_key[0] == '-'): DCNL DCSP  DCSP  DCSP (sort_dir, sort_attr) = ('-', sort_key[1:]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (sort_dir, sort_attr) = ('', sort_key) DCNL DCSP  DCSP if (not SORT_ATTR_TRANSLATION.has_key(sort_attr)): DCNL DCSP  DCSP  DCSP LOG.warn(('Bad DCSP parameter DCSP to DCSP list_designs: DCSP sort=%s' % (sort_key,))) DCNL DCSP  DCSP  DCSP (sort_dir, sort_attr) = DEFAULT_SORT DCNL DCSP else: DCNL DCSP  DCSP (sort_dir, sort_attr) = DEFAULT_SORT DCNL DCSP db_queryset = db_queryset.order_by((sort_dir + SORT_ATTR_TRANSLATION[sort_attr])) DCNL DCSP designs = [job.content_object for job in db_queryset.all() if (job.content_object and (job.content_object.is_auto == False))] DCNL DCSP pagenum = int(querydict.get((prefix + 'page'), 1)) DCNL DCSP paginator = Paginator(designs, page_size) DCNL DCSP page = paginator.page(pagenum) DCNL DCSP keys_to_copy = [(prefix + key) for key in ('user', 'type', 'sort', 'text')] DCNL DCSP filter_params = copy_query_dict(querydict, keys_to_copy) DCNL DCSP return (page, filter_params)
def _get_hold(line, pattern=__HOLD_PATTERN, full=True): DCNL  DCSP if full: DCNL DCSP  DCSP if (_yum() == 'dnf'): DCNL DCSP  DCSP  DCSP lock_re = '({0}-\\S+)'.format(pattern) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lock_re = '(\\d+:{0}-\\S+)'.format(pattern) DCNL DCSP elif (_yum() == 'dnf'): DCNL DCSP  DCSP lock_re = '({0}-\\S+)'.format(pattern) DCNL DCSP else: DCNL DCSP  DCSP lock_re = '\\d+:({0}-\\S+)'.format(pattern) DCNL DCSP match = re.search(lock_re, line) DCNL DCSP if match: DCNL DCSP  DCSP if (not full): DCNL DCSP  DCSP  DCSP woarch = match.group(1).rsplit('.', 1)[0] DCNL DCSP  DCSP  DCSP worel = woarch.rsplit('-', 1)[0] DCNL DCSP  DCSP  DCSP return worel.rsplit('-', 1)[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return None
def boxplot_frame_groupby(grouped, subplots=True, column=None, fontsize=None, rot=0, grid=True, ax=None, figsize=None, layout=None, **kwds): DCNL  DCSP if (subplots is True): DCNL DCSP  DCSP naxes = len(grouped) DCNL DCSP  DCSP (fig, axes) = _subplots(naxes=naxes, squeeze=False, ax=ax, sharex=False, sharey=True, figsize=figsize, layout=layout) DCNL DCSP  DCSP axes = _flatten(axes) DCNL DCSP  DCSP ret = Series() DCNL DCSP  DCSP for ((key, group), ax) in zip(grouped, axes): DCNL DCSP  DCSP  DCSP d = group.boxplot(ax=ax, column=column, fontsize=fontsize, rot=rot, grid=grid, **kwds) DCNL DCSP  DCSP  DCSP ax.set_title(pprint_thing(key)) DCNL DCSP  DCSP  DCSP ret.loc[key] = d DCNL DCSP  DCSP fig.subplots_adjust(bottom=0.15, top=0.9, left=0.1, right=0.9, wspace=0.2) DCNL DCSP else: DCNL DCSP  DCSP from pandas.tools.merge import concat DCNL DCSP  DCSP (keys, frames) = zip(*grouped) DCNL DCSP  DCSP if (grouped.axis == 0): DCNL DCSP  DCSP  DCSP df = concat(frames, keys=keys, axis=1) DCNL DCSP  DCSP elif (len(frames) > 1): DCNL DCSP  DCSP  DCSP df = frames[0].join(frames[1::None]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP df = frames[0] DCNL DCSP  DCSP ret = df.boxplot(column=column, fontsize=fontsize, rot=rot, grid=grid, ax=ax, figsize=figsize, layout=layout, **kwds) DCNL DCSP return ret
@login_required DCNL def delete_favorite(req, id): DCNL  DCSP try: DCNL DCSP  DCSP favorite = models.Favorite.objects.get(user=req.user, pk=id) DCNL DCSP  DCSP favorite.delete() DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP pass DCNL DCSP response = {'has_favorite': 'false'} DCNL DCSP return HttpResponse(json.dumps(response), content_type='application/json', status=200)
def set_task_user(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kw): DCNL DCSP  DCSP old_user = get_user() DCNL DCSP  DCSP set_user(get_task_user()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = f(*args, **kw) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP set_user(old_user) DCNL DCSP  DCSP return result DCNL DCSP return wrapper
@treeio_login_required DCNL @handle_response_format DCNL def ordered_product_add(request, order_id=None, response_format='html'): DCNL  DCSP order = get_object_or_404(SaleOrder, pk=order_id) DCNL DCSP if (not request.user.profile.has_permission(order, mode='x')): DCNL DCSP  DCSP return user_denied("Sorry, DCSP you DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Order") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP ordered_product = OrderedProduct() DCNL DCSP  DCSP  DCSP ordered_product.order = order DCNL DCSP  DCSP  DCSP form = OrderedProductForm(request.user.profile, order, request.POST, instance=ordered_product) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP ordered_product = form.save(commit=False) DCNL DCSP  DCSP  DCSP  DCSP convert(ordered_product, 'rate', currency=ordered_product.order.currency) DCNL DCSP  DCSP  DCSP  DCSP ordered_product.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP ordered_product.order.update_total() DCNL DCSP  DCSP  DCSP  DCSP if ('add_another' in request.POST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('sales_ordered_product_add', args=[order.id])) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('sales_order_view', args=[order.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('sales_order_view', args=[order.id])) DCNL DCSP else: DCNL DCSP  DCSP form = OrderedProductForm(request.user.profile, order) DCNL DCSP return render_to_response('sales/ordered_product_add', {'form': form, 'order': order}, context_instance=RequestContext(request), response_format=response_format)
@nx.utils.open_file(5, 'w') DCNL def view_pygraphviz(G, edgelabel=None, prog='dot', args='', suffix='', path=None): DCNL  DCSP if (not len(G)): DCNL DCSP  DCSP raise nx.NetworkXException('An DCSP empty DCSP graph DCSP cannot DCSP be DCSP drawn.') DCNL DCSP import pygraphviz DCNL DCSP attrs = ['edge', 'node', 'graph'] DCNL DCSP for attr in attrs: DCNL DCSP  DCSP if (attr not in G.graph): DCNL DCSP  DCSP  DCSP G.graph[attr] = {} DCNL DCSP edge_attrs = {'fontsize': '10'} DCNL DCSP node_attrs = {'style': 'filled', 'fillcolor': '#0000FF40', 'height': '0.75', 'width': '0.75', 'shape': 'circle'} DCNL DCSP graph_attrs = {} DCNL DCSP def update_attrs(which, attrs): DCNL DCSP  DCSP added = [] DCNL DCSP  DCSP for (k, v) in attrs.items(): DCNL DCSP  DCSP  DCSP if (k not in G.graph[which]): DCNL DCSP  DCSP  DCSP  DCSP G.graph[which][k] = v DCNL DCSP  DCSP  DCSP  DCSP added.append(k) DCNL DCSP def clean_attrs(which, added): DCNL DCSP  DCSP for attr in added: DCNL DCSP  DCSP  DCSP del G.graph[which][attr] DCNL DCSP  DCSP if (not G.graph[which]): DCNL DCSP  DCSP  DCSP del G.graph[which] DCNL DCSP update_attrs('edge', edge_attrs) DCNL DCSP update_attrs('node', node_attrs) DCNL DCSP update_attrs('graph', graph_attrs) DCNL DCSP A = to_agraph(G) DCNL DCSP clean_attrs('edge', edge_attrs) DCNL DCSP clean_attrs('node', node_attrs) DCNL DCSP clean_attrs('graph', graph_attrs) DCNL DCSP if (edgelabel is not None): DCNL DCSP  DCSP if (not hasattr(edgelabel, '__call__')): DCNL DCSP  DCSP  DCSP def func(data): DCNL DCSP  DCSP  DCSP  DCSP return ''.join([' DCSP  DCSP ', str(data[edgelabel]), ' DCSP  DCSP ']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP func = edgelabel DCNL DCSP  DCSP if G.is_multigraph(): DCNL DCSP  DCSP  DCSP for (u, v, key, data) in G.edges(keys=True, data=True): DCNL DCSP  DCSP  DCSP  DCSP edge = A.get_edge(u, v, str(key)) DCNL DCSP  DCSP  DCSP  DCSP edge.attr['label'] = str(func(data)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (u, v, data) in G.edges(data=True): DCNL DCSP  DCSP  DCSP  DCSP edge = A.get_edge(u, v) DCNL DCSP  DCSP  DCSP  DCSP edge.attr['label'] = str(func(data)) DCNL DCSP if (path is None): DCNL DCSP  DCSP ext = 'png' DCNL DCSP  DCSP if suffix: DCNL DCSP  DCSP  DCSP suffix = ('_%s.%s' % (suffix, ext)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP suffix = ('.%s' % (ext,)) DCNL DCSP  DCSP path = tempfile.NamedTemporaryFile(suffix=suffix, delete=False) DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP display_pygraphviz(A, path=path, prog=prog, args=args) DCNL DCSP return (path.name, A)
def parseString(string, namespaces=True): DCNL  DCSP if namespaces: DCNL DCSP  DCSP builder = ExpatBuilderNS() DCNL DCSP else: DCNL DCSP  DCSP builder = ExpatBuilder() DCNL DCSP return builder.parseString(string)
def getblock(lines): DCNL  DCSP blockfinder = BlockFinder() DCNL DCSP try: DCNL DCSP  DCSP tokenize.tokenize(iter(lines).next, blockfinder.tokeneater) DCNL DCSP except (EndOfBlock, IndentationError): DCNL DCSP  DCSP pass DCNL DCSP return lines[:blockfinder.last]
def tolist(val): DCNL  DCSP if (val is None): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP val.extend([]) DCNL DCSP  DCSP return val DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return re.split('\\s*,\\s*', val) DCNL DCSP except TypeError: DCNL DCSP  DCSP return list(val)
def worker_destroy(context, **filters): DCNL  DCSP query = _worker_query(context, **filters) DCNL DCSP return query.delete()
def get_output_volume(): DCNL  DCSP cmd = 'osascript DCSP -e DCSP "get DCSP output DCSP volume DCSP of DCSP (get DCSP volume DCSP settings)"' DCNL DCSP call = __salt__['cmd.run_all'](cmd, output_loglevel='debug', python_shell=False) DCNL DCSP _check_cmd(call) DCNL DCSP return call.get('stdout')
@manager_config DCNL @no_xinerama DCNL def test_last_float_size(qtile): DCNL  DCSP self = qtile DCNL DCSP self.testXeyes() DCNL DCSP assert (self.c.window.info()['name'] == 'xeyes') DCNL DCSP assert (self.c.window.info()['width'] == 798) DCNL DCSP assert (self.c.window.info()['height'] == 578) DCNL DCSP self.c.window.toggle_floating() DCNL DCSP assert (self.c.window.info()['width'] == 150) DCNL DCSP assert (self.c.window.info()['height'] == 100) DCNL DCSP self.c.window.set_size_floating(50, 90, 42, 42) DCNL DCSP assert (self.c.window.info()['width'] == 50) DCNL DCSP assert (self.c.window.info()['height'] == 90) DCNL DCSP self.c.window.toggle_floating() DCNL DCSP assert (self.c.window.info()['width'] == 798) DCNL DCSP assert (self.c.window.info()['height'] == 578) DCNL DCSP self.c.window.toggle_floating() DCNL DCSP assert (self.c.window.info()['width'] == 50) DCNL DCSP assert (self.c.window.info()['height'] == 90) DCNL DCSP self.c.window.toggle_maximize() DCNL DCSP self.c.window.toggle_minimize() DCNL DCSP self.c.window.toggle_minimize() DCNL DCSP self.c.window.toggle_floating() DCNL DCSP assert (self.c.window.info()['width'] == 50) DCNL DCSP assert (self.c.window.info()['height'] == 90)
def create_chunks(sequence, size): DCNL  DCSP return (sequence[p:(p + size)] for p in range(0, len(sequence), size))
def simplefilter(action, category=Warning, lineno=0, append=0): DCNL  DCSP assert (action in ('error', 'ignore', 'always', 'default', 'module', 'once')), ('invalid DCSP action: DCSP %r' % (action,)) DCNL DCSP assert (isinstance(lineno, int) and (lineno >= 0)), 'lineno DCSP must DCSP be DCSP an DCSP int DCSP >= DCSP 0' DCNL DCSP item = (action, None, category, None, lineno) DCNL DCSP if append: DCNL DCSP  DCSP filters.append(item) DCNL DCSP else: DCNL DCSP  DCSP filters.insert(0, item)
def dont_import_local_tempest_into_lib(logical_line, filename): DCNL  DCSP if ('tempest/lib/' not in filename): DCNL DCSP  DCSP return DCNL DCSP if (not (('from DCSP tempest' in logical_line) or ('import DCSP tempest' in logical_line))): DCNL DCSP  DCSP return DCNL DCSP if (('from DCSP tempest.lib' in logical_line) or ('import DCSP tempest.lib' in logical_line)): DCNL DCSP  DCSP return DCNL DCSP msg = 'T112: DCSP tempest.lib DCSP should DCSP not DCSP import DCSP local DCSP tempest DCSP code DCSP to DCSP avoid DCSP circular DCSP dependency' DCNL DCSP (yield (0, msg))
def modify(name, **kwargs): DCNL  DCSP ret = {'comment': '', 'changes': {}, 'result': True} DCNL DCSP time_conflict = False DCNL DCSP for item in ['seconds', 'minutes', 'hours', 'days']: DCNL DCSP  DCSP if ((item in kwargs) and ('when' in kwargs)): DCNL DCSP  DCSP  DCSP time_conflict = True DCNL DCSP  DCSP if ((item in kwargs) and ('cron' in kwargs)): DCNL DCSP  DCSP  DCSP time_conflict = True DCNL DCSP if time_conflict: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Error: DCSP Unable DCSP to DCSP use DCSP "seconds", DCSP "minutes", DCSP "hours", DCSP or DCSP "days" DCSP with DCSP "when" DCSP option.' DCNL DCSP  DCSP return ret DCNL DCSP if (('when' in kwargs) and ('cron' in kwargs)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Unable DCSP to DCSP use DCSP "when" DCSP and DCSP "cron" DCSP options DCSP together. DCSP  DCSP Ignoring.' DCNL DCSP  DCSP return ret DCNL DCSP current_schedule = list_(show_all=True, return_yaml=False) DCNL DCSP if (name not in current_schedule): DCNL DCSP  DCSP ret['comment'] = 'Job DCSP {0} DCSP does DCSP not DCSP exist DCSP in DCSP schedule.'.format(name) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP _current = current_schedule[name] DCNL DCSP if ('_seconds' in _current): DCNL DCSP  DCSP _current['seconds'] = _current['_seconds'] DCNL DCSP  DCSP del _current['_seconds'] DCNL DCSP _new = build_schedule_item(name, **kwargs) DCNL DCSP if (_new == _current): DCNL DCSP  DCSP ret['comment'] = 'Job DCSP {0} DCSP in DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP _current_lines = ['{0}:{1}\n'.format(key, value) for (key, value) in sorted(_current.items())] DCNL DCSP _new_lines = ['{0}:{1}\n'.format(key, value) for (key, value) in sorted(_new.items())] DCNL DCSP _diff = difflib.unified_diff(_current_lines, _new_lines) DCNL DCSP ret['changes']['diff'] = ''.join(_diff) DCNL DCSP if (('test' in kwargs) and kwargs['test']): DCNL DCSP  DCSP ret['comment'] = 'Job: DCSP {0} DCSP would DCSP be DCSP modified DCSP in DCSP schedule.'.format(name) DCNL DCSP else: DCNL DCSP  DCSP persist = True DCNL DCSP  DCSP if ('persist' in kwargs): DCNL DCSP  DCSP  DCSP persist = kwargs['persist'] DCNL DCSP  DCSP if (name in list_(show_all=True, where='opts', return_yaml=False)): DCNL DCSP  DCSP  DCSP event_data = {'name': name, 'schedule': _new, 'func': 'modify', 'persist': persist} DCNL DCSP  DCSP elif (name in list_(show_all=True, where='pillar', return_yaml=False)): DCNL DCSP  DCSP  DCSP event_data = {'name': name, 'schedule': _new, 'where': 'pillar', 'func': 'modify', 'persist': False} DCNL DCSP  DCSP out = __salt__['event.fire'](event_data, 'manage_schedule') DCNL DCSP  DCSP if out: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Modified DCSP job: DCSP {0} DCSP in DCSP schedule.'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP modify DCSP job DCSP {0} DCSP in DCSP schedule.'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
def task_upgrade_kernel(distribution): DCNL  DCSP if is_centos_or_rhel(distribution): DCNL DCSP  DCSP return sequence([yum_install(['kernel-devel', 'kernel']), run_from_args(['sync'])]) DCNL DCSP elif is_ubuntu(distribution): DCNL DCSP  DCSP return sequence([]) DCNL DCSP else: DCNL DCSP  DCSP raise DistributionNotSupported(distribution=distribution)
@app.route('/delay/<delay>') DCNL def delay_response(delay): DCNL  DCSP delay = min(float(delay), 10) DCNL DCSP time.sleep(delay) DCNL DCSP return jsonify(get_dict('url', 'args', 'form', 'data', 'origin', 'headers', 'files'))
def is_larger(unit_1, unit_2): DCNL  DCSP unit_1 = functions.value_for_key(INFORMATION_UNITS, unit_1) DCNL DCSP unit_2 = functions.value_for_key(INFORMATION_UNITS, unit_2) DCNL DCSP return (ureg.parse_expression(unit_1) > ureg.parse_expression(unit_2))
def requirement_available(requirement): DCNL  DCSP try: DCNL DCSP  DCSP util.activate(requirement) DCNL DCSP except errors.DependencyError: DCNL DCSP  DCSP return False DCNL DCSP return True
def _trace_D(gj, p_i, Dxtrav): DCNL  DCSP for h in Dxtrav: DCNL DCSP  DCSP if (h[gj] == p_i): DCNL DCSP  DCSP  DCSP return h DCNL DCSP return None
def launch(no_flow=False, network='192.168.0.0/24', first=1, last=None, count=None, ip='192.168.0.254', router=(), dns=()): DCNL  DCSP def fixint(i): DCNL DCSP  DCSP i = str(i) DCNL DCSP  DCSP if (i.lower() == 'none'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i.lower() == 'true'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return int(i) DCNL DCSP def fix(i): DCNL DCSP  DCSP i = str(i) DCNL DCSP  DCSP if (i.lower() == 'none'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i.lower() == 'true'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i == '()'): DCNL DCSP  DCSP  DCSP return () DCNL DCSP  DCSP return i DCNL DCSP (first, last, count) = map(fixint, (first, last, count)) DCNL DCSP (router, dns) = map(fix, (router, dns)) DCNL DCSP pool = SimpleAddressPool(network=network, first=first, last=last, count=count) DCNL DCSP core.registerNew(DHCPD, install_flow=(not no_flow), pool=pool, ip_address=ip, router_address=router, dns_address=dns) DCNL DCSP log.debug('DHCP DCSP serving DCSP a%s', str(pool)[2:(-1)])
def getparser(use_datetime=0): DCNL  DCSP if (use_datetime and (not datetime)): DCNL DCSP  DCSP raise ValueError, 'the DCSP datetime DCSP module DCSP is DCSP not DCSP available' DCNL DCSP if (FastParser and FastUnmarshaller): DCNL DCSP  DCSP if use_datetime: DCNL DCSP  DCSP  DCSP mkdatetime = _datetime_type DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mkdatetime = _datetime DCNL DCSP  DCSP target = FastUnmarshaller(True, False, _binary, mkdatetime, Fault) DCNL DCSP  DCSP parser = FastParser(target) DCNL DCSP else: DCNL DCSP  DCSP target = Unmarshaller(use_datetime=use_datetime) DCNL DCSP  DCSP if FastParser: DCNL DCSP  DCSP  DCSP parser = FastParser(target) DCNL DCSP  DCSP elif ExpatParser: DCNL DCSP  DCSP  DCSP parser = ExpatParser(target) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parser = SlowParser(target) DCNL DCSP return (parser, target)
def detachAcceptMsOriginating(): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=6) DCNL DCSP c = ForceToStandbyAndSpareHalfOctets() DCNL DCSP packet = ((a / b) / c) DCNL DCSP return packet
def protected_view(context, request): DCNL  DCSP raise HTTPForbidden()
def parse_http_load(full_load, http_methods): DCNL  DCSP try: DCNL DCSP  DCSP (headers, body) = full_load.split('\r\n\r\n', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP headers = full_load DCNL DCSP  DCSP body = '' DCNL DCSP header_lines = headers.split('\r\n') DCNL DCSP http_line = get_http_line(header_lines, http_methods) DCNL DCSP if (not http_line): DCNL DCSP  DCSP headers = '' DCNL DCSP  DCSP body = full_load DCNL DCSP header_lines = [line for line in header_lines if (line != http_line)] DCNL DCSP return (http_line, header_lines, body)
def long_to_bson_ts(val): DCNL  DCSP seconds = (val >> 32) DCNL DCSP increment = (val & 4294967295) DCNL DCSP return Timestamp(seconds, increment)
def run(cmd, cwd=None, stdin=None, runas=None, shell=DEFAULT_SHELL, python_shell=None, env=None, clean_env=False, template=None, rstrip=True, umask=None, output_loglevel='debug', log_callback=None, timeout=None, reset_system_locale=True, ignore_retcode=False, saltenv='base', use_vt=False, bg=False, password=None, encoded_cmd=False, **kwargs): DCNL  DCSP python_shell = _python_shell_default(python_shell, kwargs.get('__pub_jid', '')) DCNL DCSP ret = _run(cmd, runas=runas, shell=shell, python_shell=python_shell, cwd=cwd, stdin=stdin, stderr=subprocess.STDOUT, env=env, clean_env=clean_env, template=template, rstrip=rstrip, umask=umask, output_loglevel=output_loglevel, log_callback=log_callback, timeout=timeout, reset_system_locale=reset_system_locale, ignore_retcode=ignore_retcode, saltenv=saltenv, use_vt=use_vt, bg=bg, password=password, encoded_cmd=encoded_cmd, **kwargs) DCNL DCSP log_callback = _check_cb(log_callback) DCNL DCSP lvl = _check_loglevel(output_loglevel) DCNL DCSP if (lvl is not None): DCNL DCSP  DCSP if ((not ignore_retcode) and (ret['retcode'] != 0)): DCNL DCSP  DCSP  DCSP if (lvl < LOG_LEVELS['error']): DCNL DCSP  DCSP  DCSP  DCSP lvl = LOG_LEVELS['error'] DCNL DCSP  DCSP  DCSP msg = "Command DCSP '{0}' DCSP failed DCSP with DCSP return DCSP code: DCSP {1}".format(cmd, ret['retcode']) DCNL DCSP  DCSP  DCSP log.error(log_callback(msg)) DCNL DCSP  DCSP log.log(lvl, 'output: DCSP {0}'.format(log_callback(ret['stdout']))) DCNL DCSP return ret['stdout']
@core_helper DCNL def resource_preview(resource, package): DCNL  DCSP if (not resource['url']): DCNL DCSP  DCSP return False DCNL DCSP datapreview.res_format(resource) DCNL DCSP directly = False DCNL DCSP data_dict = {'resource': resource, 'package': package} DCNL DCSP if datapreview.get_preview_plugin(data_dict, return_first=True): DCNL DCSP  DCSP url = url_for(controller='package', action='resource_datapreview', resource_id=resource['id'], id=package['id'], qualified=True) DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP return snippet('dataviewer/snippets/data_preview.html', embed=directly, resource_url=url, raw_resource_url=resource.get('url'))
def keybinding(attr): DCNL  DCSP ks = getattr(QKeySequence, attr) DCNL DCSP return from_qvariant(QKeySequence.keyBindings(ks)[0], str)
def forwards(apps, schema_editor): DCNL  DCSP (user, created) = User.objects.get_or_create(username=USERNAME, email=EMAIL) DCNL DCSP if created: DCNL DCSP  DCSP user.set_unusable_password() DCNL DCSP  DCSP user.save()
def get_current_timezone(): DCNL  DCSP return getattr(_active, 'value', get_default_timezone())
def _get_lights(): DCNL  DCSP return _query(None, None)
def saltstack(parser, xml_parent, data): DCNL  DCSP saltstack = XML.SubElement(xml_parent, 'com.waytta.SaltAPIBuilder') DCNL DCSP supported_auth_types = ['pam', 'ldap'] DCNL DCSP supported_target_types = ['glob', 'pcre', 'list', 'grain', 'pillar', 'nodegroup', 'range', 'compound'] DCNL DCSP supported_client_interfaces = ['local', 'local-batch', 'runner'] DCNL DCSP mapping = [('servername', 'servername', None), ('credentials', 'credentialsId', None), ('authtype', 'authtype', 'pam', supported_auth_types), ('target', 'target', ''), ('targettype', 'targettype', 'glob', supported_target_types), ('clientinterface', 'clientInterface', 'local', supported_client_interfaces), ('function', 'function', ''), ('arguments', 'arguments', ''), ('kwarguments', 'kwarguments', ''), ('setpillardata', 'usePillar', False), ('pillarkey', 'pillarkey', ''), ('pillarvalue', 'pillarvalue', ''), ('wait', 'blockbuild', False), ('polltime', 'jobPollTime', ''), ('batchsize', 'batchSize', '100%'), ('mods', 'mods', ''), ('saveoutput', 'saveEnvVar', False)] DCNL DCSP helpers.convert_mapping_to_xml(saltstack, data, mapping, fail_required=True) DCNL DCSP clientInterface = data.get('clientinterface', 'local') DCNL DCSP blockbuild = str(data.get('wait', False)).lower() DCNL DCSP jobPollTime = str(data.get('polltime', '')) DCNL DCSP batchSize = data.get('batchsize', '100%') DCNL DCSP mods = data.get('mods', '') DCNL DCSP usePillar = str(data.get('setpillardata', False)).lower() DCNL DCSP clientInterfaces = XML.SubElement(saltstack, 'clientInterfaces') DCNL DCSP XML.SubElement(clientInterfaces, 'nullObject').text = 'false' DCNL DCSP ci_attrib = {'class': 'org.apache.commons.collections.map.ListOrderedMap', 'serialization': 'custom'} DCNL DCSP properties = XML.SubElement(clientInterfaces, 'properties', ci_attrib) DCNL DCSP lomElement = 'org.apache.commons.collections.map.ListOrderedMap' DCNL DCSP listOrderedMap = XML.SubElement(properties, lomElement) DCNL DCSP default = XML.SubElement(listOrderedMap, 'default') DCNL DCSP ordered_map = XML.SubElement(listOrderedMap, 'map') DCNL DCSP insertOrder = XML.SubElement(default, 'insertOrder') DCNL DCSP ci_config = [] DCNL DCSP if (clientInterface == 'local'): DCNL DCSP  DCSP ci_config = [('blockbuild', blockbuild), ('jobPollTime', jobPollTime), ('clientInterface', clientInterface)] DCNL DCSP elif (clientInterface == 'local-batch'): DCNL DCSP  DCSP ci_config = [('batchSize', batchSize), ('clientInterface', clientInterface)] DCNL DCSP elif (clientInterface == 'runner'): DCNL DCSP  DCSP ci_config = [('mods', mods), ('clientInterface', clientInterface)] DCNL DCSP  DCSP if (usePillar == 'true'): DCNL DCSP  DCSP  DCSP ci_config.append(('usePillar', usePillar)) DCNL DCSP  DCSP  DCSP pillar_cfg = [('pillarkey', data.get('pillarkey')), ('pillarvalue', data.get('pillarvalue'))] DCNL DCSP for (emt, value) in ci_config: DCNL DCSP  DCSP XML.SubElement(insertOrder, 'string').text = emt DCNL DCSP  DCSP entry = XML.SubElement(ordered_map, 'entry') DCNL DCSP  DCSP XML.SubElement(entry, 'string').text = emt DCNL DCSP  DCSP if (emt != 'usePillar'): DCNL DCSP  DCSP  DCSP XML.SubElement(entry, 'string').text = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP jsonobj = XML.SubElement(entry, 'net.sf.json.JSONObject') DCNL DCSP  DCSP  DCSP XML.SubElement(jsonobj, 'nullObject').text = 'false' DCNL DCSP  DCSP  DCSP pillarProps = XML.SubElement(jsonobj, 'properties', ci_attrib) DCNL DCSP  DCSP  DCSP XML.SubElement(pillarProps, 'unserializable-parents') DCNL DCSP  DCSP  DCSP pillarLom = XML.SubElement(pillarProps, lomElement) DCNL DCSP  DCSP  DCSP pillarDefault = XML.SubElement(pillarLom, 'default') DCNL DCSP  DCSP  DCSP pillarMap = XML.SubElement(pillarLom, 'map') DCNL DCSP  DCSP  DCSP pillarInsertOrder = XML.SubElement(pillarDefault, 'insertOrder') DCNL DCSP  DCSP  DCSP for (pemt, value) in pillar_cfg: DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarInsertOrder, 'string').text = pemt DCNL DCSP  DCSP  DCSP  DCSP pillarEntry = XML.SubElement(pillarMap, 'entry') DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarEntry, 'string').text = pemt DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarEntry, 'string').text = value
def compile_file(filepath, libraries=None, combined='bin,abi', optimize=True, extra_args=None): DCNL  DCSP (workdir, filename) = os.path.split(filepath) DCNL DCSP args = solc_arguments(libraries=libraries, combined=combined, optimize=optimize, extra_args=extra_args) DCNL DCSP args.insert(0, get_compiler_path()) DCNL DCSP args.append(filename) DCNL DCSP output = subprocess.check_output(args, cwd=workdir) DCNL DCSP return solc_parse_output(output)
def test_try_finally_regression(c): DCNL  DCSP if c: DCNL DCSP  DCSP a = (123,) DCNL DCSP try: DCNL DCSP  DCSP return a DCNL DCSP finally: DCNL DCSP  DCSP return a
def send_notif_for_after_purchase(user, invoice_id, order_url): DCNL  DCSP send_notification(user=user, action=NOTIF_TICKET_PURCHASED, title=NOTIFS[NOTIF_TICKET_PURCHASED]['title'].format(invoice_id=invoice_id), message=NOTIFS[NOTIF_TICKET_PURCHASED]['message'].format(order_url=order_url))
def make_letterboxed_thumbnail(image, shape): DCNL  DCSP assert (len(image.shape) == 3) DCNL DCSP assert (len(shape) == 2) DCNL DCSP shrunk = fit_inside(image, shape) DCNL DCSP letterboxed = letterbox(shrunk, shape) DCNL DCSP return letterboxed
def threshold_minimum(image, nbins=256, bias='min', max_iter=10000): DCNL  DCSP def find_local_maxima(hist): DCNL DCSP  DCSP maximums = list() DCNL DCSP  DCSP direction = 1 DCNL DCSP  DCSP for i in range((hist.shape[0] - 1)): DCNL DCSP  DCSP  DCSP if (direction > 0): DCNL DCSP  DCSP  DCSP  DCSP if (hist[(i + 1)] < hist[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP direction = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP maximums.append(i) DCNL DCSP  DCSP  DCSP elif (hist[(i + 1)] > hist[i]): DCNL DCSP  DCSP  DCSP  DCSP direction = 1 DCNL DCSP  DCSP return maximums DCNL DCSP if (bias not in ('min', 'mid', 'max')): DCNL DCSP  DCSP raise ValueError('Unknown DCSP bias: DCSP {0}'.format(bias)) DCNL DCSP (hist, bin_centers) = histogram(image.ravel(), nbins) DCNL DCSP smooth_hist = np.copy(hist) DCNL DCSP for counter in range(max_iter): DCNL DCSP  DCSP smooth_hist = ndif.uniform_filter1d(smooth_hist, 3) DCNL DCSP  DCSP maximums = find_local_maxima(smooth_hist) DCNL DCSP  DCSP if (len(maximums) < 3): DCNL DCSP  DCSP  DCSP break DCNL DCSP if (len(maximums) != 2): DCNL DCSP  DCSP raise RuntimeError('Unable DCSP to DCSP find DCSP two DCSP maxima DCSP in DCSP histogram') DCNL DCSP elif (counter == (max_iter - 1)): DCNL DCSP  DCSP raise RuntimeError('Maximum DCSP iteration DCSP reached DCSP for DCSP histogramsmoothing') DCNL DCSP minimum = smooth_hist[maximums[0]] DCNL DCSP threshold = maximums[0] DCNL DCSP for i in range(maximums[0], (maximums[1] + 1)): DCNL DCSP  DCSP if (smooth_hist[i] < minimum): DCNL DCSP  DCSP  DCSP minimum = smooth_hist[i] DCNL DCSP  DCSP  DCSP threshold = i DCNL DCSP if (bias == 'min'): DCNL DCSP  DCSP return bin_centers[threshold] DCNL DCSP else: DCNL DCSP  DCSP upper_bound = threshold DCNL DCSP  DCSP while (smooth_hist[upper_bound] == smooth_hist[threshold]): DCNL DCSP  DCSP  DCSP upper_bound += 1 DCNL DCSP  DCSP upper_bound -= 1 DCNL DCSP  DCSP if (bias == 'max'): DCNL DCSP  DCSP  DCSP return bin_centers[upper_bound] DCNL DCSP  DCSP elif (bias == 'mid'): DCNL DCSP  DCSP  DCSP return bin_centers[((threshold + upper_bound) // 2)]
def Pluralize(count, singular='', plural='s'): DCNL  DCSP return (singular if (count == 1) else plural)
@handle_response_format DCNL @treeio_login_required DCNL def index(request, response_format='html'): DCNL  DCSP profile = request.user.profile DCNL DCSP query = _get_filter_query(profile, filters=request.GET) DCNL DCSP updates = UpdateRecord.objects.filter(query).distinct() DCNL DCSP if request.POST: DCNL DCSP  DCSP record = UpdateRecord() DCNL DCSP  DCSP record.record_type = 'share' DCNL DCSP  DCSP form = UpdateRecordForm(request.POST, user=profile, instance=record) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP record = form.save() DCNL DCSP  DCSP  DCSP record.body = record.body.replace('\n', ' DCSP <br DCSP />') DCNL DCSP  DCSP  DCSP record.save() DCNL DCSP  DCSP  DCSP record.set_user_from_request(request) DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('news_index')) DCNL DCSP else: DCNL DCSP  DCSP form = UpdateRecordForm(user=profile) DCNL DCSP if (response_format == 'rss'): DCNL DCSP  DCSP return ObjectFeed(title=_('All DCSP Activity'), link=request.path, description=_('Updates DCSP on DCSP activity DCSP in DCSP your DCSP Tree.io'), objects=updates)(request) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form, 'updates': updates, 'profile': profile}) DCNL DCSP return render_to_response('news/index', context, context_instance=RequestContext(request), response_format=response_format)
def _ssh_slave_addresses(ssh_bin, master_address, ec2_key_pair_file): DCNL  DCSP if ((not ec2_key_pair_file) or (not os.path.exists(ec2_key_pair_file))): DCNL DCSP  DCSP return [] DCNL DCSP cmd = "hadoop DCSP dfsadmin DCSP -report DCSP | DCSP grep DCSP ^Name DCSP | DCSP cut DCSP -f2 DCSP -d: DCSP | DCSP cut DCSP -f2 DCSP -d' DCSP '" DCNL DCSP args = [('bash DCSP -c DCSP "%s"' % cmd)] DCNL DCSP ips = to_string(_check_output(*_ssh_run(ssh_bin, master_address, ec2_key_pair_file, args))) DCNL DCSP return [ip for ip in ips.split('\n') if ip]
def _algorithm_2_2(A, AT, t): DCNL  DCSP A_linear_operator = aslinearoperator(A) DCNL DCSP AT_linear_operator = aslinearoperator(AT) DCNL DCSP n = A_linear_operator.shape[0] DCNL DCSP X = np.ones((n, t)) DCNL DCSP if (t > 1): DCNL DCSP  DCSP X[:, 1:] = ((np.random.randint(0, 2, size=(n, (t - 1))) * 2) - 1) DCNL DCSP X /= float(n) DCNL DCSP g_prev = None DCNL DCSP h_prev = None DCNL DCSP k = 1 DCNL DCSP ind = range(t) DCNL DCSP while True: DCNL DCSP  DCSP Y = np.asarray(A_linear_operator.matmat(X)) DCNL DCSP  DCSP g = _sum_abs_axis0(Y) DCNL DCSP  DCSP best_j = np.argmax(g) DCNL DCSP  DCSP g.sort() DCNL DCSP  DCSP g = g[::(-1)] DCNL DCSP  DCSP S = sign_round_up(Y) DCNL DCSP  DCSP Z = np.asarray(AT_linear_operator.matmat(S)) DCNL DCSP  DCSP h = _max_abs_axis1(Z) DCNL DCSP  DCSP if (k >= 2): DCNL DCSP  DCSP  DCSP if less_than_or_close(max(h), np.dot(Z[:, best_j], X[:, best_j])): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP ind = np.argsort(h)[::(-1)][:t] DCNL DCSP  DCSP h = h[ind] DCNL DCSP  DCSP for j in range(t): DCNL DCSP  DCSP  DCSP X[:, j] = elementary_vector(n, ind[j]) DCNL DCSP  DCSP if (k >= 2): DCNL DCSP  DCSP  DCSP if (not less_than_or_close(g_prev[0], h_prev[0])): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.2) DCSP is DCSP violated') DCNL DCSP  DCSP  DCSP if (not less_than_or_close(h_prev[0], g[0])): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.2) DCSP is DCSP violated') DCNL DCSP  DCSP if (k >= 3): DCNL DCSP  DCSP  DCSP for j in range(t): DCNL DCSP  DCSP  DCSP  DCSP if (not less_than_or_close(g[j], g_prev[j])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.3) DCSP is DCSP violated') DCNL DCSP  DCSP g_prev = g DCNL DCSP  DCSP h_prev = h DCNL DCSP  DCSP k += 1 DCNL DCSP return (g, ind)
def get_user_api_key(): DCNL  DCSP return os.environ.get('GALAXY_TEST_USER_API_KEY', DEFAULT_GALAXY_USER_API_KEY)
def pad_sequences(sequences, maxlen=None, dtype='int32', padding='post', truncating='pre', value=0.0): DCNL  DCSP lengths = [len(s) for s in sequences] DCNL DCSP nb_samples = len(sequences) DCNL DCSP if (maxlen is None): DCNL DCSP  DCSP maxlen = np.max(lengths) DCNL DCSP sample_shape = tuple() DCNL DCSP for s in sequences: DCNL DCSP  DCSP if (len(s) > 0): DCNL DCSP  DCSP  DCSP sample_shape = np.asarray(s).shape[1:] DCNL DCSP  DCSP  DCSP break DCNL DCSP x = (np.ones(((nb_samples, maxlen) + sample_shape)) * value).astype(dtype) DCNL DCSP for (idx, s) in enumerate(sequences): DCNL DCSP  DCSP if (len(s) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (truncating == 'pre'): DCNL DCSP  DCSP  DCSP trunc = s[(- maxlen):] DCNL DCSP  DCSP elif (truncating == 'post'): DCNL DCSP  DCSP  DCSP trunc = s[:maxlen] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Truncating DCSP type DCSP "%s" DCSP not DCSP understood' % truncating)) DCNL DCSP  DCSP trunc = np.asarray(trunc, dtype=dtype) DCNL DCSP  DCSP if (trunc.shape[1:] != sample_shape): DCNL DCSP  DCSP  DCSP raise ValueError(('Shape DCSP of DCSP sample DCSP %s DCSP of DCSP sequence DCSP at DCSP position DCSP %s DCSP is DCSP different DCSP from DCSP expected DCSP shape DCSP %s' % (trunc.shape[1:], idx, sample_shape))) DCNL DCSP  DCSP if (padding == 'post'): DCNL DCSP  DCSP  DCSP x[idx, :len(trunc)] = trunc DCNL DCSP  DCSP elif (padding == 'pre'): DCNL DCSP  DCSP  DCSP x[idx, (- len(trunc)):] = trunc DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Padding DCSP type DCSP "%s" DCSP not DCSP understood' % padding)) DCNL DCSP return x
def trim_lex(tokens): DCNL  DCSP for i in range(len(tokens)): DCNL DCSP  DCSP current = tokens[i] DCNL DCSP  DCSP if isinstance(tokens[i], six.string_types): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP item = current[0] DCNL DCSP  DCSP if ((not statement_re.search(item)) and (item not in single_statements)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not i): DCNL DCSP  DCSP  DCSP prev = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prev = tokens[(i - 1)] DCNL DCSP  DCSP if ((i + 1) >= len(tokens)): DCNL DCSP  DCSP  DCSP next = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP next = tokens[(i + 1)] DCNL DCSP  DCSP if ((not isinstance(next, six.string_types)) or (not isinstance(prev, six.string_types))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (((not prev) or trail_whitespace_re.search(prev)) and ((not next) or lead_whitespace_re.search(next))): DCNL DCSP  DCSP  DCSP if prev: DCNL DCSP  DCSP  DCSP  DCSP m = trail_whitespace_re.search(prev) DCNL DCSP  DCSP  DCSP  DCSP prev = prev[:(m.start() + 1)] DCNL DCSP  DCSP  DCSP  DCSP tokens[(i - 1)] = prev DCNL DCSP  DCSP  DCSP if next: DCNL DCSP  DCSP  DCSP  DCSP m = lead_whitespace_re.search(next) DCNL DCSP  DCSP  DCSP  DCSP next = next[m.end():] DCNL DCSP  DCSP  DCSP  DCSP tokens[(i + 1)] = next DCNL DCSP return tokens
def overwrite_from_dates(asof, dense_dates, sparse_dates, asset_idx, value): DCNL  DCSP if (asof is pd.NaT): DCNL DCSP  DCSP return DCNL DCSP first_row = dense_dates.searchsorted(asof) DCNL DCSP next_idx = sparse_dates.searchsorted(asof.asm8, 'right') DCNL DCSP if (next_idx == len(sparse_dates)): DCNL DCSP  DCSP last_row = (len(dense_dates) - 1) DCNL DCSP else: DCNL DCSP  DCSP last_row = (dense_dates.searchsorted(sparse_dates[next_idx]) - 1) DCNL DCSP if (first_row > last_row): DCNL DCSP  DCSP return DCNL DCSP (first, last) = asset_idx DCNL DCSP (yield Float64Overwrite(first_row, last_row, first, last, value))
def item_create(item, item_id, item_type, create='create', extra_args=None, cibfile=None): DCNL  DCSP cmd = ['pcs'] DCNL DCSP if isinstance(cibfile, six.string_types): DCNL DCSP  DCSP cmd += ['-f', cibfile] DCNL DCSP if isinstance(item, six.string_types): DCNL DCSP  DCSP cmd += [item] DCNL DCSP elif isinstance(item, (list, tuple)): DCNL DCSP  DCSP cmd += item DCNL DCSP if (item in ['constraint']): DCNL DCSP  DCSP if isinstance(item_type, six.string_types): DCNL DCSP  DCSP  DCSP cmd += [item_type] DCNL DCSP if isinstance(create, six.string_types): DCNL DCSP  DCSP cmd += [create] DCNL DCSP elif isinstance(create, (list, tuple)): DCNL DCSP  DCSP cmd += create DCNL DCSP if (item not in ['constraint']): DCNL DCSP  DCSP cmd += [item_id] DCNL DCSP  DCSP if isinstance(item_type, six.string_types): DCNL DCSP  DCSP  DCSP cmd += [item_type] DCNL DCSP if isinstance(extra_args, (list, tuple)): DCNL DCSP  DCSP if (item in ['constraint']): DCNL DCSP  DCSP  DCSP extra_args = (extra_args + ['id={0}'.format(item_id)]) DCNL DCSP  DCSP cmd += extra_args DCNL DCSP return __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)
def random_reduce(circuit, gate_ids, seed=None): DCNL  DCSP from sympy.utilities.randtest import _randrange DCNL DCSP if (not gate_ids): DCNL DCSP  DCSP return circuit DCNL DCSP if isinstance(circuit, Mul): DCNL DCSP  DCSP circuit = circuit.args DCNL DCSP ids = flatten_ids(gate_ids) DCNL DCSP randrange = _randrange(seed) DCNL DCSP while ids: DCNL DCSP  DCSP i = randrange(len(ids)) DCNL DCSP  DCSP id = ids.pop(i) DCNL DCSP  DCSP if (find_subcircuit(circuit, id) != (-1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return circuit DCNL DCSP return replace_subcircuit(circuit, id)
def _connect_user(request, facebook, overwrite=True): DCNL  DCSP if (not request.user.is_authenticated()): DCNL DCSP  DCSP raise ValueError('Connect DCSP user DCSP can DCSP only DCSP be DCSP used DCSP on DCSP authenticated DCSP users') DCNL DCSP if (not facebook.is_authenticated()): DCNL DCSP  DCSP raise ValueError('Facebook DCSP needs DCSP to DCSP be DCSP authenticated DCSP for DCSP connect DCSP flows') DCNL DCSP data = facebook.facebook_profile_data() DCNL DCSP facebook_id = data['id'] DCNL DCSP old_connections = _get_old_connections(facebook_id, request.user.id)[:20] DCNL DCSP if (old_connections and (not (request.POST.get('confirm_connect') or request.GET.get('confirm_connect')))): DCNL DCSP  DCSP raise facebook_exceptions.AlreadyConnectedError(list(old_connections)) DCNL DCSP user = _update_user(request.user, facebook, overwrite=overwrite) DCNL DCSP return user
def path_separator(): DCNL  DCSP return PATH_SEPARATOR[_os.name]
def write_cron_file(user, path): DCNL  DCSP if (_check_instance_uid_match(user) or (__grains__.get('os_family') in ('Solaris', 'AIX'))): DCNL DCSP  DCSP return (__salt__['cmd.retcode'](_get_cron_cmdstr(path), runas=user, python_shell=False) == 0) DCNL DCSP else: DCNL DCSP  DCSP return (__salt__['cmd.retcode'](_get_cron_cmdstr(path, user), python_shell=False) == 0)
def get_img_channel(image_path): DCNL  DCSP img = load_image(image_path) DCNL DCSP img = pil_to_nparray(img) DCNL DCSP try: DCNL DCSP  DCSP channel = img.shape[2] DCNL DCSP except: DCNL DCSP  DCSP channel = 1 DCNL DCSP return channel
def get_partial_date_formats(): DCNL  DCSP warnings.warn("'django.utils.translation.get_partial_date_formats' DCSP is DCSP deprecated. DCSP Please DCSP update DCSP your DCSP code DCSP to DCSP use DCSP the DCSP new DCSP i18n DCSP aware DCSP formatting.", PendingDeprecationWarning) DCNL DCSP from django.conf import settings DCNL DCSP year_month_format = ugettext('YEAR_MONTH_FORMAT') DCNL DCSP month_day_format = ugettext('MONTH_DAY_FORMAT') DCNL DCSP if (year_month_format == 'YEAR_MONTH_FORMAT'): DCNL DCSP  DCSP year_month_format = settings.YEAR_MONTH_FORMAT DCNL DCSP if (month_day_format == 'MONTH_DAY_FORMAT'): DCNL DCSP  DCSP month_day_format = settings.MONTH_DAY_FORMAT DCNL DCSP return (year_month_format, month_day_format)
def _string_from_json(value, _): DCNL  DCSP return value
def generate_cert(name): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP cert = '/etc/icinga2/pki/{0}.crt'.format(name) DCNL DCSP key = '/etc/icinga2/pki/{0}.key'.format(name) DCNL DCSP if (os.path.isfile(cert) and os.path.isfile(key)): DCNL DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP needed. DCSP Cert: DCSP {0} DCSP and DCSP key: DCSP {1} DCSP already DCSP generated.'.format(cert, key) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP and DCSP key DCSP generation DCSP would DCSP be DCSP executed' DCNL DCSP  DCSP return ret DCNL DCSP cert_save = __salt__['icinga2.generate_cert'](name) DCNL DCSP if (not cert_save): DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP and DCSP key DCSP generated' DCNL DCSP  DCSP ret['changes']['cert'] = 'Executed. DCSP Certificate DCSP saved: DCSP {0}'.format(cert) DCNL DCSP  DCSP ret['changes']['key'] = 'Executed. DCSP Key DCSP saved: DCSP {0}'.format(key) DCNL DCSP return ret
def check_mount(root, drive): DCNL  DCSP if (not (urllib.parse.quote_plus(drive) == drive)): DCNL DCSP  DCSP return False DCNL DCSP path = os.path.join(root, drive) DCNL DCSP return utils.ismount(path)
def show(config_file=False): DCNL  DCSP cmd = 'sysctl' DCNL DCSP ret = {} DCNL DCSP out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace') DCNL DCSP for line in out.splitlines(): DCNL DCSP  DCSP if ((not line) or ('=' not in line)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP comps = line.split('=', 1) DCNL DCSP  DCSP ret[comps[0]] = comps[1] DCNL DCSP return ret
def _step4(state): DCNL  DCSP C = (state.C == 0).astype(np.int) DCNL DCSP covered_C = (C * state.row_uncovered[:, np.newaxis]) DCNL DCSP covered_C *= astype(state.col_uncovered, dtype=np.int, copy=False) DCNL DCSP n = state.C.shape[0] DCNL DCSP m = state.C.shape[1] DCNL DCSP while True: DCNL DCSP  DCSP (row, col) = np.unravel_index(np.argmax(covered_C), (n, m)) DCNL DCSP  DCSP if (covered_C[(row, col)] == 0): DCNL DCSP  DCSP  DCSP return _step6 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state.marked[(row, col)] = 2 DCNL DCSP  DCSP  DCSP star_col = np.argmax((state.marked[row] == 1)) DCNL DCSP  DCSP  DCSP if (not (state.marked[(row, star_col)] == 1)): DCNL DCSP  DCSP  DCSP  DCSP state.Z0_r = row DCNL DCSP  DCSP  DCSP  DCSP state.Z0_c = col DCNL DCSP  DCSP  DCSP  DCSP return _step5 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP col = star_col DCNL DCSP  DCSP  DCSP  DCSP state.row_uncovered[row] = False DCNL DCSP  DCSP  DCSP  DCSP state.col_uncovered[col] = True DCNL DCSP  DCSP  DCSP  DCSP covered_C[:, col] = (C[:, col] * astype(state.row_uncovered, dtype=np.int, copy=False)) DCNL DCSP  DCSP  DCSP  DCSP covered_C[row] = 0
def hook(ui, repo, **kwargs): DCNL  DCSP hooktype = kwargs['hooktype'] DCNL DCSP node = kwargs['node'] DCNL DCSP ui.debug('Zulip: DCSP received DCSP {hooktype} DCSP event\n'.format(hooktype=hooktype)) DCNL DCSP if (hooktype != 'changegroup'): DCNL DCSP  DCSP ui.warn('Zulip: DCSP {hooktype} DCSP not DCSP supported\n'.format(hooktype=hooktype)) DCNL DCSP  DCSP exit(1) DCNL DCSP ctx = repo.changectx(node) DCNL DCSP branch = ctx.branch() DCNL DCSP branch_whitelist = get_config(ui, 'branches') DCNL DCSP branch_blacklist = get_config(ui, 'ignore_branches') DCNL DCSP if branch_whitelist: DCNL DCSP  DCSP watched_branches = [b.lower().strip() for b in branch_whitelist.split(',')] DCNL DCSP  DCSP if (branch.lower() not in watched_branches): DCNL DCSP  DCSP  DCSP ui.debug('Zulip: DCSP ignoring DCSP event DCSP for DCSP {branch}\n'.format(branch=branch)) DCNL DCSP  DCSP  DCSP exit(0) DCNL DCSP if branch_blacklist: DCNL DCSP  DCSP ignored_branches = [b.lower().strip() for b in branch_blacklist.split(',')] DCNL DCSP  DCSP if (branch.lower() in ignored_branches): DCNL DCSP  DCSP  DCSP ui.debug('Zulip: DCSP ignoring DCSP event DCSP for DCSP {branch}\n'.format(branch=branch)) DCNL DCSP  DCSP  DCSP exit(0) DCNL DCSP base = repo[node].rev() DCNL DCSP tip = len(repo) DCNL DCSP email = get_config(ui, 'email') DCNL DCSP api_key = get_config(ui, 'api_key') DCNL DCSP site = get_config(ui, 'site') DCNL DCSP if (not (email and api_key)): DCNL DCSP  DCSP ui.warn('Zulip: DCSP missing DCSP email DCSP or DCSP api_key DCSP configurations\n') DCNL DCSP  DCSP ui.warn('in DCSP the DCSP [zulip] DCSP section DCSP of DCSP your DCSP .hg/hgrc.\n') DCNL DCSP  DCSP exit(1) DCNL DCSP stream = get_config(ui, 'stream') DCNL DCSP if (not stream): DCNL DCSP  DCSP stream = 'commits' DCNL DCSP web_url = get_config(ui, 'web_url') DCNL DCSP user = ctx.user() DCNL DCSP content = format_summary_line(web_url, user, base, tip, branch, node) DCNL DCSP content += format_commit_lines(web_url, repo, base, tip) DCNL DCSP subject = branch DCNL DCSP ui.debug('Sending DCSP to DCSP Zulip:\n') DCNL DCSP ui.debug((content + '\n')) DCNL DCSP send_zulip(email, api_key, site, stream, subject, content)
def is_coroutine(function): DCNL  DCSP return ((function.__code__.co_flags & 128) or getattr(function, '_is_coroutine', False))
def decompress(fileobj, path): DCNL  DCSP if path.endswith('.gz'): DCNL DCSP  DCSP return gunzip_stream(fileobj) DCNL DCSP elif path.endswith('.bz2'): DCNL DCSP  DCSP if (bz2 is None): DCNL DCSP  DCSP  DCSP raise Exception('bz2 DCSP module DCSP was DCSP not DCSP successfully DCSP imported DCSP (likely DCSP not DCSP installed).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return bunzip2_stream(fileobj) DCNL DCSP else: DCNL DCSP  DCSP return fileobj
def nextLine(): DCNL  DCSP caller = currentframe(1) DCNL DCSP return (getsourcefile(sys.modules[caller.f_globals['__name__']]), (caller.f_lineno + 1))
def _ConvertToCygpath(path): DCNL  DCSP if (sys.platform == 'cygwin'): DCNL DCSP  DCSP p = subprocess.Popen(['cygpath', path], stdout=subprocess.PIPE) DCNL DCSP  DCSP path = p.communicate()[0].strip() DCNL DCSP return path
def load_werkzeug(path): DCNL  DCSP sys.path[0] = path DCNL DCSP wz.__dict__.clear() DCNL DCSP for key in sys.modules.keys(): DCNL DCSP  DCSP if (key.startswith('werkzeug.') or (key == 'werkzeug')): DCNL DCSP  DCSP  DCSP sys.modules.pop(key, None) DCNL DCSP import werkzeug DCNL DCSP for key in werkzeug.__all__: DCNL DCSP  DCSP setattr(wz, key, getattr(werkzeug, key)) DCNL DCSP hg_tag = find_hg_tag(path) DCNL DCSP try: DCNL DCSP  DCSP f = open(os.path.join(path, 'setup.py')) DCNL DCSP except IOError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP  DCSP line = line.strip() DCNL DCSP  DCSP  DCSP  DCSP if line.startswith('version='): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (line[8:].strip(' DCSP  DCTB ,')[1:(-1)], hg_tag) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP print >>sys.stderr, 'Unknown DCSP werkzeug DCSP version DCSP loaded' DCNL DCSP sys.exit(2)
def signature(obj): DCNL  DCSP if (not callable(obj)): DCNL DCSP  DCSP raise TypeError('{0!r} DCSP is DCSP not DCSP a DCSP callable DCSP object'.format(obj)) DCNL DCSP if isinstance(obj, types.MethodType): DCNL DCSP  DCSP sig = signature(obj.__func__) DCNL DCSP  DCSP if (obj.__self__ is None): DCNL DCSP  DCSP  DCSP if sig.parameters: DCNL DCSP  DCSP  DCSP  DCSP first = sig.parameters.values()[0].replace(kind=_POSITIONAL_ONLY) DCNL DCSP  DCSP  DCSP  DCSP return sig.replace(parameters=((first,) + tuple(sig.parameters.values())[1:])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return sig DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sig.replace(parameters=tuple(sig.parameters.values())[1:]) DCNL DCSP try: DCNL DCSP  DCSP sig = obj.__signature__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP if (sig is not None): DCNL DCSP  DCSP  DCSP return sig DCNL DCSP try: DCNL DCSP  DCSP wrapped = obj.__wrapped__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP return signature(wrapped) DCNL DCSP if isinstance(obj, types.FunctionType): DCNL DCSP  DCSP return Signature.from_function(obj) DCNL DCSP if isinstance(obj, functools.partial): DCNL DCSP  DCSP sig = signature(obj.func) DCNL DCSP  DCSP new_params = OrderedDict(sig.parameters.items()) DCNL DCSP  DCSP partial_args = (obj.args or ()) DCNL DCSP  DCSP partial_keywords = (obj.keywords or {}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ba = sig.bind_partial(*partial_args, **partial_keywords) DCNL DCSP  DCSP except TypeError as ex: DCNL DCSP  DCSP  DCSP msg = 'partial DCSP object DCSP {0!r} DCSP has DCSP incorrect DCSP arguments'.format(obj) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP for (arg_name, arg_value) in ba.arguments.items(): DCNL DCSP  DCSP  DCSP param = new_params[arg_name] DCNL DCSP  DCSP  DCSP if (arg_name in partial_keywords): DCNL DCSP  DCSP  DCSP  DCSP new_params[arg_name] = param.replace(default=arg_value, _partial_kwarg=True) DCNL DCSP  DCSP  DCSP elif ((param.kind not in (_VAR_KEYWORD, _VAR_POSITIONAL)) and (not param._partial_kwarg)): DCNL DCSP  DCSP  DCSP  DCSP new_params.pop(arg_name) DCNL DCSP  DCSP return sig.replace(parameters=new_params.values()) DCNL DCSP sig = None DCNL DCSP if isinstance(obj, type): DCNL DCSP  DCSP call = _get_user_defined_method(type(obj), '__call__') DCNL DCSP  DCSP if (call is not None): DCNL DCSP  DCSP  DCSP sig = signature(call) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new = _get_user_defined_method(obj, '__new__') DCNL DCSP  DCSP  DCSP if (new is not None): DCNL DCSP  DCSP  DCSP  DCSP sig = signature(new) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP init = _get_user_defined_method(obj, '__init__') DCNL DCSP  DCSP  DCSP  DCSP if (init is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sig = signature(init) DCNL DCSP elif (not isinstance(obj, _NonUserDefinedCallables)): DCNL DCSP  DCSP call = _get_user_defined_method(type(obj), '__call__', 'im_func') DCNL DCSP  DCSP if (call is not None): DCNL DCSP  DCSP  DCSP sig = signature(call) DCNL DCSP if (sig is not None): DCNL DCSP  DCSP return sig.replace(parameters=tuple(sig.parameters.values())[1:]) DCNL DCSP if isinstance(obj, types.BuiltinFunctionType): DCNL DCSP  DCSP msg = 'no DCSP signature DCSP found DCSP for DCSP builtin DCSP function DCSP {0!r}'.format(obj) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP raise ValueError('callable DCSP {0!r} DCSP is DCSP not DCSP supported DCSP by DCSP signature'.format(obj))
def set_server_setting(settings, server=_DEFAULT_SERVER): DCNL  DCSP if (not settings): DCNL DCSP  DCSP _LOG.warning('No DCSP settings DCSP provided') DCNL DCSP  DCSP return False DCNL DCSP settings = _normalize_server_settings(**settings) DCNL DCSP current_settings = get_server_setting(settings=settings.keys(), server=server) DCNL DCSP if (settings == current_settings): DCNL DCSP  DCSP _LOG.debug('Settings DCSP already DCSP contain DCSP the DCSP provided DCSP values.') DCNL DCSP  DCSP return True DCNL DCSP with salt.utils.winapi.Com(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP connection = wmi.WMI(namespace=_WMI_NAMESPACE) DCNL DCSP  DCSP  DCSP objs = connection.IIsSmtpServerSetting(Name=server)[0] DCNL DCSP  DCSP except wmi.x_wmi as error: DCNL DCSP  DCSP  DCSP _LOG.error('Encountered DCSP WMI DCSP error: DCSP %s', error.com_error) DCNL DCSP  DCSP except (AttributeError, IndexError) as error: DCNL DCSP  DCSP  DCSP _LOG.error('Error DCSP getting DCSP IIsSmtpServerSetting: DCSP %s', error) DCNL DCSP  DCSP for setting in settings: DCNL DCSP  DCSP  DCSP if (str(settings[setting]) != str(current_settings[setting])): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(objs, setting, settings[setting]) DCNL DCSP  DCSP  DCSP  DCSP except wmi.x_wmi as error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _LOG.error('Encountered DCSP WMI DCSP error: DCSP %s', error.com_error) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError as error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _LOG.error('Error DCSP setting DCSP %s: DCSP %s', setting, error) DCNL DCSP new_settings = get_server_setting(settings=settings.keys(), server=server) DCNL DCSP failed_settings = dict() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (str(settings[setting]) != str(new_settings[setting])): DCNL DCSP  DCSP  DCSP failed_settings[setting] = settings[setting] DCNL DCSP if failed_settings: DCNL DCSP  DCSP _LOG.error('Failed DCSP to DCSP change DCSP settings: DCSP %s', failed_settings) DCNL DCSP  DCSP return False DCNL DCSP _LOG.debug('Settings DCSP configured DCSP successfully: DCSP %s', settings.keys()) DCNL DCSP return True
def get_ip_version(network): DCNL  DCSP if (netaddr.IPNetwork(network).version == 6): DCNL DCSP  DCSP return 'IPv6' DCNL DCSP elif (netaddr.IPNetwork(network).version == 4): DCNL DCSP  DCSP return 'IPv4'
def task_accepted(request, _all_total_count=all_total_count, add_active_request=active_requests.add, add_to_total_count=total_count.update): DCNL  DCSP add_active_request(request) DCNL DCSP add_to_total_count({request.name: 1}) DCNL DCSP all_total_count[0] += 1
def ustr(value, hint_encoding='utf-8', errors='strict'): DCNL  DCSP ttype = type(value) DCNL DCSP if (ttype is unicode): DCNL DCSP  DCSP return value DCNL DCSP if ((ttype is str) or issubclass(ttype, str)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return unicode(value, hint_encoding, errors=errors) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP for ln in get_encodings(hint_encoding): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return unicode(value, ln, errors=errors) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if isinstance(value, Exception): DCNL DCSP  DCSP return exception_to_unicode(value) DCNL DCSP try: DCNL DCSP  DCSP return unicode(value) DCNL DCSP except Exception: DCNL DCSP  DCSP raise UnicodeError(('unable DCSP to DCSP convert DCSP %r' % (value,)))
def make_secret_key(project_directory): DCNL  DCSP local_setting = os.path.join(project_directory, 'config/settings/local.py') DCNL DCSP set_secret_key(local_setting) DCNL DCSP env_file = os.path.join(project_directory, 'env.example') DCNL DCSP set_secret_key(env_file)
def deprecatedModuleAttribute(version, message, moduleName, name): DCNL  DCSP module = sys.modules[moduleName] DCNL DCSP if (not isinstance(module, _ModuleProxy)): DCNL DCSP  DCSP module = _ModuleProxy(module) DCNL DCSP  DCSP sys.modules[moduleName] = module DCNL DCSP _deprecateAttribute(module, name, version, message)
def _tgrep_rel_disjunction_action(_s, _l, tokens): DCNL  DCSP tokens = [x for x in tokens if (x != u'|')] DCNL DCSP if (len(tokens) == 1): DCNL DCSP  DCSP return tokens[0] DCNL DCSP elif (len(tokens) == 2): DCNL DCSP  DCSP return (lambda a, b: (lambda n, m=None, l=None: (a(n, m, l) or b(n, m, l))))(tokens[0], tokens[1])
def EnumTlbs(excludeFlags=0): DCNL  DCSP key = win32api.RegOpenKey(win32con.HKEY_CLASSES_ROOT, 'Typelib') DCNL DCSP iids = EnumKeys(key) DCNL DCSP results = [] DCNL DCSP for (iid, crap) in iids: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP key2 = win32api.RegOpenKey(key, str(iid)) DCNL DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for (version, tlbdesc) in EnumKeys(key2): DCNL DCSP  DCSP  DCSP major_minor = version.split('.', 1) DCNL DCSP  DCSP  DCSP if (len(major_minor) < 2): DCNL DCSP  DCSP  DCSP  DCSP major_minor.append('0') DCNL DCSP  DCSP  DCSP major = major_minor[0] DCNL DCSP  DCSP  DCSP minor = major_minor[1] DCNL DCSP  DCSP  DCSP key3 = win32api.RegOpenKey(key2, str(version)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP flags = int(win32api.RegQueryValue(key3, 'FLAGS')) DCNL DCSP  DCSP  DCSP except (win32api.error, ValueError): DCNL DCSP  DCSP  DCSP  DCSP flags = 0 DCNL DCSP  DCSP  DCSP if ((flags & excludeFlags) == 0): DCNL DCSP  DCSP  DCSP  DCSP for (lcid, crap) in EnumKeys(key3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lcid = int(lcid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP key4 = win32api.RegOpenKey(key3, ('%s\\win32' % (lcid,))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (dll, typ) = win32api.RegQueryValueEx(key4, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (typ == win32con.REG_EXPAND_SZ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dll = win32api.ExpandEnvironmentStrings(dll) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dll = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec = TypelibSpec(iid, lcid, major, minor, flags) DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.dll = dll DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.desc = tlbdesc DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.ver_desc = (((tlbdesc + ' DCSP (') + version) + ')') DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(spec) DCNL DCSP return results
def samplesize_confint_proportion(proportion, half_length, alpha=0.05, method='normal'): DCNL  DCSP q_ = proportion DCNL DCSP if (method == 'normal'): DCNL DCSP  DCSP n = ((q_ * (1 - q_)) / ((half_length / stats.norm.isf((alpha / 2.0))) ** 2)) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError('only DCSP "normal" DCSP is DCSP available') DCNL DCSP return n
def test_resample(): DCNL  DCSP n = 101 DCNL DCSP colorlist = np.empty((n, 4), float) DCNL DCSP colorlist[:, 0] = np.linspace(0, 1, n) DCNL DCSP colorlist[:, 1] = 0.2 DCNL DCSP colorlist[:, 2] = np.linspace(1, 0, n) DCNL DCSP colorlist[:, 3] = 0.7 DCNL DCSP lsc = mcolors.LinearSegmentedColormap.from_list(u'lsc', colorlist) DCNL DCSP lc = mcolors.ListedColormap(colorlist) DCNL DCSP lsc3 = lsc._resample(3) DCNL DCSP lc3 = lc._resample(3) DCNL DCSP expected = np.array([[0.0, 0.2, 1.0, 0.7], [0.5, 0.2, 0.5, 0.7], [1.0, 0.2, 0.0, 0.7]], float) DCNL DCSP assert_array_almost_equal(lsc3([0, 0.5, 1]), expected) DCNL DCSP assert_array_almost_equal(lc3([0, 0.5, 1]), expected)
@treeio_login_required DCNL def account_view(request, response_format='html'): DCNL  DCSP profile = request.user.profile DCNL DCSP try: DCNL DCSP  DCSP contacts = profile.contact_set.exclude(trash=True) DCNL DCSP except: DCNL DCSP  DCSP contacts = [] DCNL DCSP return render_to_response('account/account_view', {'profile': profile, 'contacts': contacts}, context_instance=RequestContext(request), response_format=response_format)
def _is_resumable(exc): DCNL  DCSP checker = _SELECT_ERROR_CHECKERS.get(exc.__class__, None) DCNL DCSP if (checker is not None): DCNL DCSP  DCSP return checker(exc) DCNL DCSP else: DCNL DCSP  DCSP return False
def get_pointer(ctypes_func): DCNL  DCSP return ctypes.cast(ctypes_func, ctypes.c_void_p).value
def _invalidWin32App(pywinerr): DCNL  DCSP return (pywinerr.args[0] == 193)
def _generate_meta(): DCNL  DCSP d = {'root_url': request.url_root} DCNL DCSP return d
def assert_array_list_equal(xlist, ylist, err_msg='', verbose=True): DCNL  DCSP if (len(xlist) != len(ylist)): DCNL DCSP  DCSP raise AssertionError('List DCSP size DCSP is DCSP different') DCNL DCSP for (x, y) in zip(xlist, ylist): DCNL DCSP  DCSP numpy.testing.assert_array_equal(cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg, verbose=verbose)
def test_system_numerics_complex(): DCNL  DCSP print 'TODO'
def _get_output_filename(dataset_dir, split_name): DCNL  DCSP return ('%s/cifar10_%s.tfrecord' % (dataset_dir, split_name))
@auth.route('/reset-password', methods=['GET', 'POST']) DCNL def forgot_password(): DCNL  DCSP if (not current_user.is_anonymous): DCNL DCSP  DCSP return redirect(url_for('forum.index')) DCNL DCSP form = ForgotPasswordForm() DCNL DCSP if form.validate_on_submit(): DCNL DCSP  DCSP user = User.query.filter_by(email=form.email.data).first() DCNL DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP send_reset_token.delay(user) DCNL DCSP  DCSP  DCSP flash(_('Email DCSP sent! DCSP Please DCSP check DCSP your DCSP inbox.'), 'info') DCNL DCSP  DCSP  DCSP return redirect(url_for('auth.forgot_password')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flash(_('You DCSP have DCSP entered DCSP an DCSP username DCSP or DCSP email DCSP address DCSP that DCSP is DCSP not DCSP linked DCSP with DCSP your DCSP account.'), 'danger') DCNL DCSP return render_template('auth/forgot_password.html', form=form)
def request_elements(*args, **kwargs): DCNL  DCSP logging.warn(('The DCSP authomatic.request_elements DCSP function DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP version DCSP 0.1.0! DCSP ' + 'Use DCSP the DCSP "request_elements" DCSP method DCSP of DCSP the DCSP "Authomatic" DCSP class DCSP instead.')) DCNL DCSP return global_authomatic_instance.request_elements(*args, **kwargs)
def lambdify(leaves, expr): DCNL  DCSP (s, scope) = funcstr(leaves, expr) DCNL DCSP return eval(s, scope)
def test_escape_decode(): DCNL  DCSP (value, length) = codecs.escape_decode('ab\x07\x08 DCTB \n\r\x0c\x0bba') DCNL DCSP AreEqual(value, 'ab\x07\x08 DCTB \n\r\x0c\x0bba') DCNL DCSP AreEqual(length, 11) DCNL DCSP (value, length) = codecs.escape_decode('\\a') DCNL DCSP AreEqual(value, '\x07') DCNL DCSP AreEqual(length, 2) DCNL DCSP (value, length) = codecs.escape_decode('ab\x07\x08 DCTB \n\r\x0c\x0bbaab\\a\\b\\t\\n\\r\\f\\vbaab\\\x07\\\x08\\ DCTB \\\n\\\r\\\x0c\\\x0bba') DCNL DCSP AreEqual(value, 'ab\x07\x08 DCTB \n\r\x0c\x0bbaab\x07\x08 DCTB \n\r\x0c\x0bbaab\\\x07\\\x08\\ DCTB \\\r\\\x0c\\\x0bba') DCNL DCSP AreEqual(length, 47) DCNL DCSP (value, length) = codecs.escape_decode('\\\x07') DCNL DCSP AreEqual(value, '\\\x07') DCNL DCSP AreEqual(length, 2) DCNL DCSP AreEqual('abc', codecs.escape_decode('abc', None)[0]) DCNL DCSP AreEqual('?\\', codecs.escape_decode('\\x', 'replace')[0]) DCNL DCSP AreEqual('?\\x', codecs.escape_decode('\\x2', 'replace')[0]) DCNL DCSP AreEqual('?\\x', codecs.escape_decode('\\xI', 'replace')[0]) DCNL DCSP AreEqual('?\\xI', codecs.escape_decode('\\xII', 'replace')[0]) DCNL DCSP AreEqual('?\\x1', codecs.escape_decode('\\x1I', 'replace')[0]) DCNL DCSP AreEqual('?\\xI', codecs.escape_decode('\\xI1', 'replace')[0])
def CheckForFunctionLengths(filename, clean_lines, linenum, function_state, error): DCNL  DCSP lines = clean_lines.lines DCNL DCSP line = lines[linenum] DCNL DCSP raw = clean_lines.raw_lines DCNL DCSP raw_line = raw[linenum] DCNL DCSP joined_line = '' DCNL DCSP starting_func = False DCNL DCSP regexp = '(\\w(\\w|::|\\*|\\&|\\s)*)\\(' DCNL DCSP match_result = Match(regexp, line) DCNL DCSP if match_result: DCNL DCSP  DCSP function_name = match_result.group(1).split()[(-1)] DCNL DCSP  DCSP if ((function_name == 'TEST') or (function_name == 'TEST_F') or (not Match('[A-Z_]+$', function_name))): DCNL DCSP  DCSP  DCSP starting_func = True DCNL DCSP if starting_func: DCNL DCSP  DCSP body_found = False DCNL DCSP  DCSP for start_linenum in xrange(linenum, clean_lines.NumLines()): DCNL DCSP  DCSP  DCSP start_line = lines[start_linenum] DCNL DCSP  DCSP  DCSP joined_line += (' DCSP ' + start_line.lstrip()) DCNL DCSP  DCSP  DCSP if Search('(;|})', start_line): DCNL DCSP  DCSP  DCSP  DCSP body_found = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif Search('{', start_line): DCNL DCSP  DCSP  DCSP  DCSP body_found = True DCNL DCSP  DCSP  DCSP  DCSP function = Search('((\\w|:)*)\\(', line).group(1) DCNL DCSP  DCSP  DCSP  DCSP if Match('TEST', function): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parameter_regexp = Search('(\\(.*\\))', joined_line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parameter_regexp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP function += parameter_regexp.group(1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP function += '()' DCNL DCSP  DCSP  DCSP  DCSP function_state.Begin(function) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not body_found): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'readability/fn_size', 5, 'Lint DCSP failed DCSP to DCSP find DCSP start DCSP of DCSP function DCSP body.') DCNL DCSP elif Match('^\\}\\s*$', line): DCNL DCSP  DCSP function_state.Check(error, filename, linenum) DCNL DCSP  DCSP function_state.End() DCNL DCSP elif (not Match('^\\s*$', line)): DCNL DCSP  DCSP function_state.Count()
def display_path(path): DCNL  DCSP path = os.path.normcase(os.path.abspath(path)) DCNL DCSP if path.startswith((os.getcwd() + os.path.sep)): DCNL DCSP  DCSP path = ('.' + path[len(os.getcwd()):]) DCNL DCSP return path
def run_all(plugin, args=''): DCNL  DCSP data = _execute_cmd(plugin, args, 'cmd.run_all') DCNL DCSP return data
def next_redirect(data, default, default_view, **get_kwargs): DCNL  DCSP next = data.get('next', default) DCNL DCSP if (next is None): DCNL DCSP  DCSP next = urlresolvers.reverse(default_view) DCNL DCSP if get_kwargs: DCNL DCSP  DCSP if ('#' in next): DCNL DCSP  DCSP  DCSP tmp = next.rsplit('#', 1) DCNL DCSP  DCSP  DCSP next = tmp[0] DCNL DCSP  DCSP  DCSP anchor = ('#' + tmp[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP anchor = '' DCNL DCSP  DCSP joiner = ((('?' in next) and '&') or '?') DCNL DCSP  DCSP next += ((joiner + urllib.urlencode(get_kwargs)) + anchor) DCNL DCSP return HttpResponseRedirect(next)
def _iexp(x, M, L=8): DCNL  DCSP R = _nbits(((long(x) << L) // M)) DCNL DCSP T = (- int((((-10) * len(str(M))) // (3 * L)))) DCNL DCSP y = _div_nearest(x, T) DCNL DCSP Mshift = (long(M) << R) DCNL DCSP for i in xrange((T - 1), 0, (-1)): DCNL DCSP  DCSP y = _div_nearest((x * (Mshift + y)), (Mshift * i)) DCNL DCSP for k in xrange((R - 1), (-1), (-1)): DCNL DCSP  DCSP Mshift = (long(M) << (k + 2)) DCNL DCSP  DCSP y = _div_nearest((y * (y + Mshift)), Mshift) DCNL DCSP return (M + y)
def ContactVCard(parent): DCNL  DCSP synopsis = [((t and t.replace('vcard', 'contact')) or t) for t in parent.SYNOPSIS] DCNL DCSP synopsis[2] = synopsis[1] DCNL DCSP class ContactVCardCommand(parent, ): DCNL DCSP  DCSP SYNOPSIS = tuple(synopsis) DCNL DCSP  DCSP KIND = 'individual' DCNL DCSP  DCSP ORDER = ('Tagging', 3) DCNL DCSP  DCSP VCARD = 'contact' DCNL DCSP return ContactVCardCommand
def safecall(func): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return wrapper
def quote_unix(value): DCNL  DCSP value = six.moves.shlex_quote(value) DCNL DCSP return value
@LocalContext DCNL def unpack_many(data, word_size=None): DCNL  DCSP word_size = (word_size or context.word_size) DCNL DCSP endianness = context.endianness DCNL DCSP sign = context.sign DCNL DCSP if (word_size == 'all'): DCNL DCSP  DCSP return [unpack(data, word_size)] DCNL DCSP if ((word_size % 8) != 0): DCNL DCSP  DCSP raise ValueError('unpack_many(): DCSP word_size DCSP must DCSP be DCSP a DCSP multiple DCSP of DCSP 8') DCNL DCSP out = [] DCNL DCSP n = (word_size // 8) DCNL DCSP for i in range(0, len(data), n): DCNL DCSP  DCSP out.append(unpack(data[i:(i + n)], word_size)) DCNL DCSP return list(map(int, out))
def prox_l21(Y, alpha, n_orient, shape=None, is_stft=False): DCNL  DCSP if (len(Y) == 0): DCNL DCSP  DCSP return (np.zeros_like(Y), np.zeros((0,), dtype=np.bool)) DCNL DCSP if (shape is not None): DCNL DCSP  DCSP shape_init = Y.shape DCNL DCSP  DCSP Y = Y.reshape(*shape) DCNL DCSP n_positions = (Y.shape[0] // n_orient) DCNL DCSP if is_stft: DCNL DCSP  DCSP rows_norm = np.sqrt(stft_norm2(Y).reshape(n_positions, (-1)).sum(axis=1)) DCNL DCSP else: DCNL DCSP  DCSP rows_norm = np.sqrt((Y * Y.conj()).real.reshape(n_positions, (-1)).sum(axis=1)) DCNL DCSP shrink = np.maximum((1.0 - (alpha / np.maximum(rows_norm, alpha))), 0.0) DCNL DCSP active_set = (shrink > 0.0) DCNL DCSP if (n_orient > 1): DCNL DCSP  DCSP active_set = np.tile(active_set[:, None], [1, n_orient]).ravel() DCNL DCSP  DCSP shrink = np.tile(shrink[:, None], [1, n_orient]).ravel() DCNL DCSP Y = Y[active_set] DCNL DCSP if (shape is None): DCNL DCSP  DCSP Y *= shrink[active_set][:, np.newaxis] DCNL DCSP else: DCNL DCSP  DCSP Y *= shrink[active_set][:, np.newaxis, np.newaxis] DCNL DCSP  DCSP Y = Y.reshape((-1), *shape_init[1:]) DCNL DCSP return (Y, active_set)
def interval_distance(label1, label2): DCNL  DCSP try: DCNL DCSP  DCSP return pow((label1 - label2), 2) DCNL DCSP except: DCNL DCSP  DCSP print('non-numeric DCSP labels DCSP not DCSP supported DCSP with DCSP interval DCSP distance')
@_FFI.callback(u'Value(ExternContext*, DCSP uint8_t*, DCSP uint64_t)') DCNL def extern_create_exception(context_handle, msg_ptr, msg_len): DCNL  DCSP c = _FFI.from_handle(context_handle) DCNL DCSP msg = bytes(_FFI.buffer(msg_ptr, msg_len)).decode(u'utf-8') DCNL DCSP return c.to_value(Exception(msg))
def deprecatedProperty(version, replacement=None): DCNL  DCSP class _DeprecatedProperty(property, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Extension DCSP of DCSP the DCSP build-in DCSP property DCSP to DCSP allow DCSP deprecated DCSP setters.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def _deprecatedWrapper(self, function): DCNL DCSP  DCSP  DCSP @wraps(function) DCNL DCSP  DCSP  DCSP def deprecatedFunction(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP warn(self.warningString, DeprecationWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP  DCSP return deprecatedFunction DCNL DCSP  DCSP def setter(self, function): DCNL DCSP  DCSP  DCSP return property.setter(self, self._deprecatedWrapper(function)) DCNL DCSP def deprecationDecorator(function): DCNL DCSP  DCSP if _PY3: DCNL DCSP  DCSP  DCSP warningString = getDeprecationWarningString(function, version, None, replacement) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP functionName = function.__name__ DCNL DCSP  DCSP  DCSP className = inspect.stack()[1][3] DCNL DCSP  DCSP  DCSP moduleName = function.__module__ DCNL DCSP  DCSP  DCSP fqdn = ('%s.%s.%s' % (moduleName, className, functionName)) DCNL DCSP  DCSP  DCSP warningString = _getDeprecationWarningString(fqdn, version, None, replacement) DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP def deprecatedFunction(*args, **kwargs): DCNL DCSP  DCSP  DCSP warn(warningString, DeprecationWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP _appendToDocstring(deprecatedFunction, _getDeprecationDocstring(version, replacement)) DCNL DCSP  DCSP deprecatedFunction.deprecatedVersion = version DCNL DCSP  DCSP result = _DeprecatedProperty(deprecatedFunction) DCNL DCSP  DCSP result.warningString = warningString DCNL DCSP  DCSP return result DCNL DCSP return deprecationDecorator
def get_flow(db_api, image_service_api, availability_zones, create_what, scheduler_rpcapi=None, volume_rpcapi=None): DCNL  DCSP flow_name = (ACTION.replace(':', '_') + '_api') DCNL DCSP api_flow = linear_flow.Flow(flow_name) DCNL DCSP api_flow.add(ExtractVolumeRequestTask(image_service_api, availability_zones, rebind={'size': 'raw_size', 'availability_zone': 'raw_availability_zone', 'volume_type': 'raw_volume_type'})) DCNL DCSP api_flow.add(QuotaReserveTask(), EntryCreateTask(), QuotaCommitTask()) DCNL DCSP if (scheduler_rpcapi and volume_rpcapi): DCNL DCSP  DCSP api_flow.add(VolumeCastTask(scheduler_rpcapi, volume_rpcapi, db_api)) DCNL DCSP return taskflow.engines.load(api_flow, store=create_what)
def ensure_completely_loaded(force=False): DCNL  DCSP global COMPLETELY_LOADED DCNL DCSP if (COMPLETELY_LOADED and (not force)): DCNL DCSP  DCSP return True DCNL DCSP from django.apps import apps DCNL DCSP if (not apps.ready): DCNL DCSP  DCSP return DCNL DCSP import django DCNL DCSP from distutils.version import LooseVersion DCNL DCSP if (LooseVersion(django.get_version()) < LooseVersion(u'1.8')): DCNL DCSP  DCSP for model in apps.get_models(): DCNL DCSP  DCSP  DCSP for cache_name in (u'_field_cache', u'_field_name_cache', u'_m2m_cache', u'_related_objects_cache', u'_related_many_to_many_cache', u'_name_map'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP delattr(model._meta, cache_name) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP model._meta._fill_fields_cache() DCNL DCSP  DCSP if hasattr(apps, u'cache'): DCNL DCSP  DCSP  DCSP apps.cache.get_models.cache_clear() DCNL DCSP if apps.ready: DCNL DCSP  DCSP COMPLETELY_LOADED = True DCNL DCSP return True
def stub_out(test, funcs): DCNL  DCSP for (module, func) in funcs.items(): DCNL DCSP  DCSP test.stub_out(module, func)
def _close_conn(conn): DCNL  DCSP conn.commit() DCNL DCSP conn.close()
def deleted(cond): DCNL  DCSP a = {} DCNL DCSP if cond: DCNL DCSP  DCSP del a DCNL DCSP return a
def run(command): DCNL  DCSP cmd = 'salt DCSP \\* DCSP {0} DCSP --yaml-out DCSP -t DCSP 500 DCSP > DCSP high'.format(command) DCNL DCSP subprocess.call(cmd, shell=True) DCNL DCSP data = yaml.load(open('high')) DCNL DCSP hashes = set() DCNL DCSP for (key, val) in six.iteritems(data): DCNL DCSP  DCSP has = hashlib.md5(str(val)).hexdigest() DCNL DCSP  DCSP if (has not in hashes): DCNL DCSP  DCSP  DCSP print('{0}:'.format(has)) DCNL DCSP  DCSP  DCSP pprint.pprint(val) DCNL DCSP  DCSP hashes.add(has) DCNL DCSP if (len(hashes) > 1): DCNL DCSP  DCSP print('{0}Command: DCSP {1} DCSP gave DCSP inconsistent DCSP returns{2}'.format(colors['LIGHT_RED'], command, colors['ENDC']))
def decode_barcode_8(nt_barcode): DCNL  DCSP if (len(nt_barcode) != 8): DCNL DCSP  DCSP raise ValueError('barcode DCSP must DCSP be DCSP 8 DCSP nt DCSP long.') DCNL DCSP if set(list(nt_barcode)).difference(CUR_ENC_FO.keys()): DCNL DCSP  DCSP raise ValueError('Only DCSP A,T,C,G DCSP valid DCSP chars.') DCNL DCSP decoded = nt_to_cw(CUR_ENC_FO, nt_barcode) DCNL DCSP (num_errors, sym) = calc_syndrome(decoded, 16) DCNL DCSP if (num_errors == 1): DCNL DCSP  DCSP nt_barcode = unpack_bitstr(CUR_REV_ENC_SI, ''.join(map(str, decoded))) DCNL DCSP elif (num_errors > 1): DCNL DCSP  DCSP nt_barcode = None DCNL DCSP return (nt_barcode, (num_errors / 2.0))
def gen_lower_listing(path=None): DCNL  DCSP cpu_backend = cpu_target.target_context DCNL DCSP cpu_backend.refresh() DCNL DCSP fninfos = gather_function_info(cpu_backend) DCNL DCSP out = format_function_infos(fninfos) DCNL DCSP if (path is None): DCNL DCSP  DCSP print(out) DCNL DCSP else: DCNL DCSP  DCSP with open(path, 'w') as fobj: DCNL DCSP  DCSP  DCSP print(out, file=fobj)
def getmacbyip(ip, chainCC=0): DCNL  DCSP if isinstance(ip, Net): DCNL DCSP  DCSP ip = iter(ip).next() DCNL DCSP tmp = map(ord, inet_aton(ip)) DCNL DCSP if ((tmp[0] & 240) == 224): DCNL DCSP  DCSP return ('01:00:5e:%.2x:%.2x:%.2x' % ((tmp[1] & 127), tmp[2], tmp[3])) DCNL DCSP (iff, a, gw) = conf.route.route(ip) DCNL DCSP if ((iff == LOOPBACK_NAME) or (ip == conf.route.get_if_bcast(iff))): DCNL DCSP  DCSP return 'ff:ff:ff:ff:ff:ff' DCNL DCSP ifip = str(pcapdnet.dnet.intf().get(iff)['addr']) DCNL DCSP if (gw != ifip.split('/')[0]): DCNL DCSP  DCSP ip = gw DCNL DCSP mac = conf.netcache.arp_cache.get(ip) DCNL DCSP if mac: DCNL DCSP  DCSP return mac DCNL DCSP res = srp1((Ether(dst=ETHER_BROADCAST) / ARP(op='who-has', pdst=ip)), type=ETH_P_ARP, iface=iff, timeout=2, verbose=0, chainCC=chainCC, nofilter=1) DCNL DCSP if (res is not None): DCNL DCSP  DCSP mac = res.payload.hwsrc DCNL DCSP  DCSP conf.netcache.arp_cache[ip] = mac DCNL DCSP  DCSP return mac DCNL DCSP return None
def RekallEProcessRenderer(x): DCNL  DCSP return ('%s DCSP (%s)' % (x['Cybox']['Name'], x['Cybox']['PID']))
def requires_auth(f): DCNL  DCSP @wraps(f) DCNL DCSP def decorated(*args, **kwargs): DCNL DCSP  DCSP message = 'Authentication DCSP credentials DCSP not DCSP found' DCNL DCSP  DCSP success = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth_jwt() DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP except JWTError as e: DCNL DCSP  DCSP  DCSP if ((e.headers is not None) and ('WWW-Authenticate' not in e.headers)): DCNL DCSP  DCSP  DCSP  DCSP raise NotAuthorizedError(message=((e.error + ': DCSP ') + e.description)) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP results = auth_basic() DCNL DCSP  DCSP  DCSP if (not results[0]): DCNL DCSP  DCSP  DCSP  DCSP if results[1]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotAuthorizedError(message=results[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP if login.current_user.is_authenticated: DCNL DCSP  DCSP  DCSP  DCSP g.user = UserModel.query.get(login.current_user.id) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP g.user.update_lat() DCNL DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotAuthorizedError(message=message) DCNL DCSP return decorated
def test_get_editor_filter(): DCNL  DCSP assert (get_editor_filter(state='untranslated') == '#filter=untranslated') DCNL DCSP assert (get_editor_filter(state='untranslated', sort='newest') == '#filter=untranslated&sort=newest') DCNL DCSP assert (get_editor_filter(sort='newest') == '#sort=newest') DCNL DCSP assert (get_editor_filter(state='all', search='Foo', sfields='locations') == '#filter=all') DCNL DCSP assert (get_editor_filter(search='Foo', sfields='locations') == '#search=Foo&sfields=locations') DCNL DCSP assert (get_editor_filter(search='Foo', sfields=['locations', 'notes']) == '#search=Foo&sfields=locations,notes') DCNL DCSP assert (get_editor_filter(search='Foo: DCSP bar.po\nID: DCSP 1', sfields='locations') == '#search=Foo%3A+bar.po%0AID%3A+1&sfields=locations')
def build_docs(branch): DCNL  DCSP os.chdir(os.path.join(gitdname, 'docs')) DCNL DCSP retcode = subprocess.call('make DCSP clean', shell=True, stdout=sys.stdout, stderr=sys.stderr) DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP os.chdir(dname) DCNL DCSP  DCSP msg = ('Could DCSP not DCSP clean DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP sphinx_call = ' DCSP '.join(['make', 'html', "SPHINXBUILD=' DCSP python DCSP /usr/local/bin/sphinx-build'"]) DCNL DCSP activate = os.path.join(virtual_dir, 'bin', 'activate') DCNL DCSP activate_virtualenv = ('. DCSP ' + activate) DCNL DCSP retcode = subprocess.call(' DCSP && DCSP '.join([activate_virtualenv, sphinx_call]), shell=True, env=env, stdout=sys.stdout, stderr=sys.stderr) DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP os.chdir(dname) DCNL DCSP  DCSP msg = ('Could DCSP not DCSP build DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP os.chdir(dname)
def global_subsystem_instance(subsystem_type, options=None): DCNL  DCSP init_subsystem(subsystem_type, options) DCNL DCSP return subsystem_type.global_instance()
def _check_surfaces(surfs): DCNL  DCSP for surf in surfs: DCNL DCSP  DCSP _assert_complete_surface(surf) DCNL DCSP for (surf_1, surf_2) in zip(surfs[:(-1)], surfs[1:]): DCNL DCSP  DCSP logger.info(('Checking DCSP that DCSP %s DCSP surface DCSP is DCSP inside DCSP %s DCSP surface...' % (_surf_name[surf_2['id']], _surf_name[surf_1['id']]))) DCNL DCSP  DCSP _assert_inside(surf_2, surf_1)
def is_pidfile_stale(pidfile): DCNL  DCSP result = False DCNL DCSP pidfile_pid = pidfile.read_pid() DCNL DCSP if (pidfile_pid is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.kill(pidfile_pid, signal.SIG_DFL) DCNL DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP if (exc.errno == errno.ESRCH): DCNL DCSP  DCSP  DCSP  DCSP result = True DCNL DCSP return result
def _lookup_syslog_config(config): DCNL  DCSP lookup = {'default-timeout': 'Default DCSP Network DCSP Retry DCSP Timeout', 'logdir': 'Local DCSP Log DCSP Output', 'default-size': 'Local DCSP Logging DCSP Default DCSP Rotation DCSP Size', 'logdir-unique': 'Log DCSP To DCSP Unique DCSP Subdirectory', 'default-rotate': 'Local DCSP Logging DCSP Default DCSP Rotations', 'loghost': 'Remote DCSP Host'} DCNL DCSP return lookup.get(config)
def trimHistory(): DCNL  DCSP failed_db_con = db.DBConnection('failed.db') DCNL DCSP failed_db_con.action(('DELETE DCSP FROM DCSP history DCSP WHERE DCSP date DCSP < DCSP ' + str((datetime.datetime.today() - datetime.timedelta(days=30)).strftime(History.date_format))))
def create_comment(request, comment_data): DCNL  DCSP thread_id = comment_data.get('thread_id') DCNL DCSP if (not thread_id): DCNL DCSP  DCSP raise ValidationError({'thread_id': ['This DCSP field DCSP is DCSP required.']}) DCNL DCSP (cc_thread, context) = _get_thread_and_context(request, thread_id) DCNL DCSP if cc_thread['closed']: DCNL DCSP  DCSP raise PermissionDenied DCNL DCSP _check_initializable_comment_fields(comment_data, context) DCNL DCSP serializer = CommentSerializer(data=comment_data, context=context) DCNL DCSP actions_form = CommentActionsForm(comment_data) DCNL DCSP if (not (serializer.is_valid() and actions_form.is_valid())): DCNL DCSP  DCSP raise ValidationError(dict((serializer.errors.items() + actions_form.errors.items()))) DCNL DCSP serializer.save() DCNL DCSP cc_comment = serializer.instance DCNL DCSP comment_created.send(sender=None, user=request.user, post=cc_comment) DCNL DCSP api_comment = serializer.data DCNL DCSP _do_extra_actions(api_comment, cc_comment, comment_data.keys(), actions_form, context, request) DCNL DCSP track_comment_created_event(request, context['course'], cc_comment, cc_thread['commentable_id'], followed=False) DCNL DCSP return api_comment
@hook.command('scuser') DCNL def soundcloud_user(text): DCNL  DCSP if (not api_key): DCNL DCSP  DCSP return 'This DCSP command DCSP requires DCSP a DCSP SoundCloud DCSP API DCSP key.' DCNL DCSP try: DCNL DCSP  DCSP user = get_with_search('users', text) DCNL DCSP except APIError as ae: DCNL DCSP  DCSP return ae DCNL DCSP if (not user): DCNL DCSP  DCSP return 'No DCSP results DCSP found.' DCNL DCSP try: DCNL DCSP  DCSP return format_user(user) DCNL DCSP except APIError as ae: DCNL DCSP  DCSP return ae
def EMSA_PSS_ENCODE(mhash, emBits, randFunc, mgf, sLen): DCNL  DCSP emLen = ceil_div(emBits, 8) DCNL DCSP lmask = 0 DCNL DCSP for i in xrange(((8 * emLen) - emBits)): DCNL DCSP  DCSP lmask = ((lmask >> 1) | 128) DCNL DCSP if (emLen < ((mhash.digest_size + sLen) + 2)): DCNL DCSP  DCSP raise ValueError('Digest DCSP or DCSP salt DCSP length DCSP are DCSP too DCSP long DCSP for DCSP given DCSP key DCSP size.') DCNL DCSP salt = b('') DCNL DCSP if (randFunc and (sLen > 0)): DCNL DCSP  DCSP salt = randFunc(sLen) DCNL DCSP h = mhash.new((((bchr(0) * 8) + mhash.digest()) + salt)) DCNL DCSP db = (((bchr(0) * (((emLen - sLen) - mhash.digest_size) - 2)) + bchr(1)) + salt) DCNL DCSP dbMask = mgf(h.digest(), ((emLen - mhash.digest_size) - 1)) DCNL DCSP maskedDB = strxor(db, dbMask) DCNL DCSP maskedDB = (bchr((bord(maskedDB[0]) & (~ lmask))) + maskedDB[1:]) DCNL DCSP em = ((maskedDB + h.digest()) + bchr(188)) DCNL DCSP return em
@verbose DCNL def _apply_dics(data, info, tmin, forward, noise_csd, data_csd, reg, label=None, picks=None, pick_ori=None, verbose=None): DCNL  DCSP (is_free_ori, _, proj, vertno, G) = _prepare_beamformer_input(info, forward, label, picks, pick_ori) DCNL DCSP Cm = data_csd.data DCNL DCSP Cm_inv = linalg.pinv(Cm, reg) DCNL DCSP W = np.dot(G.T, Cm_inv) DCNL DCSP n_orient = (3 if is_free_ori else 1) DCNL DCSP n_sources = (G.shape[1] // n_orient) DCNL DCSP for k in range(n_sources): DCNL DCSP  DCSP Wk = W[(n_orient * k):((n_orient * k) + n_orient)] DCNL DCSP  DCSP Gk = G[:, (n_orient * k):((n_orient * k) + n_orient)] DCNL DCSP  DCSP Ck = np.dot(Wk, Gk) DCNL DCSP  DCSP if is_free_ori: DCNL DCSP  DCSP  DCSP Wk[:] = np.dot(linalg.pinv(Ck, 0.1), Wk) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Wk /= Ck DCNL DCSP  DCSP noise_norm = np.dot(np.dot(Wk.conj(), noise_csd.data), Wk.T) DCNL DCSP  DCSP noise_norm = np.abs(noise_norm).trace() DCNL DCSP  DCSP Wk /= np.sqrt(noise_norm) DCNL DCSP if (pick_ori == 'normal'): DCNL DCSP  DCSP W = W[2::3] DCNL DCSP  DCSP is_free_ori = False DCNL DCSP if (isinstance(data, np.ndarray) and (data.ndim == 2)): DCNL DCSP  DCSP data = [data] DCNL DCSP  DCSP return_single = True DCNL DCSP else: DCNL DCSP  DCSP return_single = False DCNL DCSP subject = _subject_from_forward(forward) DCNL DCSP for (i, M) in enumerate(data): DCNL DCSP  DCSP if (len(M) != len(picks)): DCNL DCSP  DCSP  DCSP raise ValueError('data DCSP and DCSP picks DCSP must DCSP have DCSP the DCSP same DCSP length') DCNL DCSP  DCSP if (not return_single): DCNL DCSP  DCSP  DCSP logger.info(('Processing DCSP epoch DCSP : DCSP %d' % (i + 1))) DCNL DCSP  DCSP if info['projs']: DCNL DCSP  DCSP  DCSP M = np.dot(proj, M) DCNL DCSP  DCSP if is_free_ori: DCNL DCSP  DCSP  DCSP sol = np.dot(W, M) DCNL DCSP  DCSP  DCSP logger.info('combining DCSP the DCSP current DCSP components...') DCNL DCSP  DCSP  DCSP sol = combine_xyz(sol) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sol = np.dot(W, M) DCNL DCSP  DCSP tstep = (1.0 / info['sfreq']) DCNL DCSP  DCSP if np.iscomplexobj(sol): DCNL DCSP  DCSP  DCSP sol = np.abs(sol) DCNL DCSP  DCSP (yield _make_stc(sol, vertices=vertno, tmin=tmin, tstep=tstep, subject=subject)) DCNL DCSP logger.info('[done]')
def spearmanr(a, b=None, axis=0, nan_policy='propagate'): DCNL  DCSP (a, axisout) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan and (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.masked_invalid(a) DCNL DCSP  DCSP b = ma.masked_invalid(b) DCNL DCSP  DCSP return mstats_basic.spearmanr(a, b, axis) DCNL DCSP if (a.size <= 1): DCNL DCSP  DCSP return SpearmanrResult(np.nan, np.nan) DCNL DCSP ar = np.apply_along_axis(rankdata, axisout, a) DCNL DCSP br = None DCNL DCSP if (b is not None): DCNL DCSP  DCSP (b, axisout) = _chk_asarray(b, axis) DCNL DCSP  DCSP (contains_nan, nan_policy) = _contains_nan(b, nan_policy) DCNL DCSP  DCSP if (contains_nan and (nan_policy == 'omit')): DCNL DCSP  DCSP  DCSP b = ma.masked_invalid(b) DCNL DCSP  DCSP  DCSP return mstats_basic.spearmanr(a, b, axis) DCNL DCSP  DCSP br = np.apply_along_axis(rankdata, axisout, b) DCNL DCSP n = a.shape[axisout] DCNL DCSP rs = np.corrcoef(ar, br, rowvar=axisout) DCNL DCSP olderr = np.seterr(divide='ignore') DCNL DCSP try: DCNL DCSP  DCSP t = (rs * np.sqrt(((n - 2) / ((rs + 1.0) * (1.0 - rs))).clip(0))) DCNL DCSP finally: DCNL DCSP  DCSP np.seterr(**olderr) DCNL DCSP prob = (2 * distributions.t.sf(np.abs(t), (n - 2))) DCNL DCSP if (rs.shape == (2, 2)): DCNL DCSP  DCSP return SpearmanrResult(rs[(1, 0)], prob[(1, 0)]) DCNL DCSP else: DCNL DCSP  DCSP return SpearmanrResult(rs, prob)
def get_default_gcs_bucket_name(deadline=None): DCNL  DCSP rpc = create_rpc(deadline) DCNL DCSP make_get_default_gcs_bucket_name_call(rpc) DCNL DCSP rpc.wait() DCNL DCSP return rpc.get_result()
def notify_info_yielded(event): DCNL  DCSP def decorator(generator): DCNL DCSP  DCSP def decorated(*args, **kwargs): DCNL DCSP  DCSP  DCSP for v in generator(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP send(event, info=v) DCNL DCSP  DCSP  DCSP  DCSP (yield v) DCNL DCSP  DCSP return decorated DCNL DCSP return decorator
def LoadSingleAppInfo(app_info): DCNL  DCSP builder = yaml_object.ObjectBuilder(AppInfoExternal) DCNL DCSP handler = yaml_builder.BuilderHandler(builder) DCNL DCSP listener = yaml_listener.EventListener(handler) DCNL DCSP listener.Parse(app_info) DCNL DCSP app_infos = handler.GetResults() DCNL DCSP if (len(app_infos) < 1): DCNL DCSP  DCSP raise appinfo_errors.EmptyConfigurationFile() DCNL DCSP if (len(app_infos) > 1): DCNL DCSP  DCSP raise appinfo_errors.MultipleConfigurationFile() DCNL DCSP appyaml = app_infos[0] DCNL DCSP ValidateHandlers(appyaml.handlers) DCNL DCSP if appyaml.builtins: DCNL DCSP  DCSP BuiltinHandler.Validate(appyaml.builtins, appyaml.runtime) DCNL DCSP if (appyaml.application and appyaml.project): DCNL DCSP  DCSP raise appinfo_errors.MultipleProjectNames('Specify DCSP one DCSP of DCSP "application: DCSP name" DCSP or DCSP "project: DCSP name"') DCNL DCSP elif appyaml.project: DCNL DCSP  DCSP appyaml.application = appyaml.project DCNL DCSP  DCSP appyaml.project = None DCNL DCSP appyaml.NormalizeVmSettings() DCNL DCSP return appyaml
def IDAnalyzer(lowercase=False): DCNL  DCSP tokenizer = IDTokenizer() DCNL DCSP if lowercase: DCNL DCSP  DCSP tokenizer = (tokenizer | LowercaseFilter()) DCNL DCSP return tokenizer
def _CopyDocumentToProtocolBuffer(document, pb): DCNL  DCSP pb.set_storage(document_pb.Document.DISK) DCNL DCSP if document.doc_id: DCNL DCSP  DCSP pb.set_id(document.doc_id.encode('utf-8')) DCNL DCSP if document.language: DCNL DCSP  DCSP pb.set_language(document.language.encode('utf-8')) DCNL DCSP for field in document.fields: DCNL DCSP  DCSP field_pb = pb.add_field() DCNL DCSP  DCSP _CopyFieldToProtocolBuffer(field, field_pb) DCNL DCSP pb.set_order_id(document.rank) DCNL DCSP return pb
def buttap(N): DCNL  DCSP if (abs(int(N)) != N): DCNL DCSP  DCSP raise ValueError('Filter DCSP order DCSP must DCSP be DCSP a DCSP nonnegative DCSP integer') DCNL DCSP z = numpy.array([]) DCNL DCSP m = numpy.arange(((- N) + 1), N, 2) DCNL DCSP p = (- numpy.exp((((1j * pi) * m) / (2 * N)))) DCNL DCSP k = 1 DCNL DCSP return (z, p, k)
def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
def _validate_snap_name(name, snap_name, strict=True, runas=None): DCNL  DCSP snap_name = _sdecode(snap_name) DCNL DCSP if re.match(GUID_REGEX, snap_name): DCNL DCSP  DCSP return snap_name.strip('{}') DCNL DCSP else: DCNL DCSP  DCSP return snapshot_name_to_id(name, snap_name, strict=strict, runas=runas)
def read_font_record(data, extent=1040): DCNL  DCSP ans = {u'raw_data': data, u'font_data': None, u'err': None, u'ext': u'failed', u'headers': None, u'encrypted': False} DCNL DCSP try: DCNL DCSP  DCSP (usize, flags, dstart, xor_len, xor_start) = struct.unpack_from('>LLLLL', data, 4) DCNL DCSP except: DCNL DCSP  DCSP ans[u'err'] = u'Failed DCSP to DCSP read DCSP font DCSP record DCSP header DCSP fields' DCNL DCSP  DCSP return ans DCNL DCSP font_data = data[dstart:] DCNL DCSP ans[u'headers'] = {u'usize': usize, u'flags': bin(flags), u'xor_len': xor_len, u'xor_start': xor_start, u'dstart': dstart} DCNL DCSP if (flags & 2): DCNL DCSP  DCSP key = bytearray(data[xor_start:(xor_start + xor_len)]) DCNL DCSP  DCSP buf = bytearray(font_data) DCNL DCSP  DCSP extent = (len(font_data) if (extent is None) else extent) DCNL DCSP  DCSP extent = min(extent, len(font_data)) DCNL DCSP  DCSP for n in xrange(extent): DCNL DCSP  DCSP  DCSP buf[n] ^= key[(n % xor_len)] DCNL DCSP  DCSP font_data = bytes(buf) DCNL DCSP  DCSP ans[u'encrypted'] = True DCNL DCSP if (flags & 1): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP font_data = zlib.decompress(font_data) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP ans[u'err'] = (u'Failed DCSP to DCSP zlib DCSP decompress DCSP font DCSP data DCSP (%s)' % e) DCNL DCSP  DCSP  DCSP return ans DCNL DCSP  DCSP if (len(font_data) != usize): DCNL DCSP  DCSP  DCSP ans[u'err'] = u'Uncompressed DCSP font DCSP size DCSP mismatch' DCNL DCSP  DCSP  DCSP return ans DCNL DCSP ans[u'font_data'] = font_data DCNL DCSP sig = font_data[:4] DCNL DCSP ans[u'ext'] = (u'ttf' if (sig in {'\x00\x01\x00\x00', 'true', 'ttcf'}) else (u'otf' if (sig == 'OTTO') else u'dat')) DCNL DCSP return ans
def create_version_h(svn_version): DCNL  DCSP if ('-' in svn_version): DCNL DCSP  DCSP while (svn_version.count('.') < 2): DCNL DCSP  DCSP  DCSP svn_version = svn_version.replace('-', '.0-') DCNL DCSP else: DCNL DCSP  DCSP while (svn_version.count('.') < 2): DCNL DCSP  DCSP  DCSP svn_version += '.0' DCNL DCSP version_h = open(os.path.join(get_base_dir(), 'src', 'lxml', 'includes', 'lxml-version.h'), 'w') DCNL DCSP version_h.write(('#ifndef DCSP LXML_VERSION_STRING\n#define DCSP LXML_VERSION_STRING DCSP "%s"\n#endif\n' % svn_version)) DCNL DCSP version_h.close()
@authenticated_json_view DCNL @has_request_variables DCNL def json_subscription_property(request, user_profile, subscription_data=REQ(validator=check_list(check_dict([('stream', check_string), ('property', check_string), ('value', check_variable_type([check_string, check_bool]))])))): DCNL  DCSP if (request.method != 'POST'): DCNL DCSP  DCSP return json_error(_('Invalid DCSP verb')) DCNL DCSP property_converters = {'color': check_string, 'in_home_view': check_bool, 'desktop_notifications': check_bool, 'audible_notifications': check_bool, 'pin_to_top': check_bool} DCNL DCSP response_data = [] DCNL DCSP for change in subscription_data: DCNL DCSP  DCSP stream_name = change['stream'] DCNL DCSP  DCSP property = change['property'] DCNL DCSP  DCSP value = change['value'] DCNL DCSP  DCSP if (property not in property_converters): DCNL DCSP  DCSP  DCSP return json_error((_('Unknown DCSP subscription DCSP property: DCSP %s') % (property,))) DCNL DCSP  DCSP sub = get_subscription_or_die(stream_name, user_profile)[0] DCNL DCSP  DCSP property_conversion = property_converters[property](property, value) DCNL DCSP  DCSP if property_conversion: DCNL DCSP  DCSP  DCSP return json_error(property_conversion) DCNL DCSP  DCSP do_change_subscription_property(user_profile, sub, stream_name, property, value) DCNL DCSP  DCSP response_data.append({'stream': stream_name, 'property': property, 'value': value}) DCNL DCSP return json_success({'subscription_data': response_data})
def process_options(arglist=None, parse_argv=False, config_file=None, parser=None): DCNL  DCSP if (not parser): DCNL DCSP  DCSP parser = get_parser() DCNL DCSP if (not parser.has_option('--config')): DCNL DCSP  DCSP if (config_file is True): DCNL DCSP  DCSP  DCSP config_file = DEFAULT_CONFIG DCNL DCSP  DCSP group = parser.add_option_group('Configuration', description=('The DCSP project DCSP options DCSP are DCSP read DCSP from DCSP the DCSP [%s] DCSP section DCSP of DCSP the DCSP tox.ini DCSP file DCSP or DCSP the DCSP setup.cfg DCSP file DCSP located DCSP in DCSP any DCSP parent DCSP folder DCSP of DCSP the DCSP path(s) DCSP being DCSP processed. DCSP  DCSP Allowed DCSP options DCSP are: DCSP %s.' % (parser.prog, ', DCSP '.join(parser.config_options)))) DCNL DCSP  DCSP group.add_option('--config', metavar='path', default=config_file, help='user DCSP config DCSP file DCSP location DCSP (default: DCSP %default)') DCNL DCSP if ((not arglist) and (not parse_argv)): DCNL DCSP  DCSP arglist = [] DCNL DCSP (options, args) = parser.parse_args(arglist) DCNL DCSP options.reporter = None DCNL DCSP if options.ensure_value('testsuite', False): DCNL DCSP  DCSP args.append(options.testsuite) DCNL DCSP elif (not options.ensure_value('doctest', False)): DCNL DCSP  DCSP if (parse_argv and (not args)): DCNL DCSP  DCSP  DCSP if (options.diff or any((os.path.exists(name) for name in PROJECT_CONFIG))): DCNL DCSP  DCSP  DCSP  DCSP args = ['.'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parser.error('input DCSP not DCSP specified') DCNL DCSP  DCSP options = read_config(options, args, arglist, parser) DCNL DCSP  DCSP options.reporter = (parse_argv and (options.quiet == 1) and FileReport) DCNL DCSP options.filename = (options.filename and options.filename.split(',')) DCNL DCSP options.exclude = normalize_paths(options.exclude) DCNL DCSP options.select = (options.select and options.select.split(',')) DCNL DCSP options.ignore = (options.ignore and options.ignore.split(',')) DCNL DCSP if options.diff: DCNL DCSP  DCSP options.reporter = DiffReport DCNL DCSP  DCSP stdin = stdin_get_value() DCNL DCSP  DCSP options.selected_lines = parse_udiff(stdin, options.filename, args[0]) DCNL DCSP  DCSP args = sorted(options.selected_lines) DCNL DCSP return (options, args)
def project_time_week(row): DCNL  DCSP try: DCNL DCSP  DCSP thisdate = row['project_time.date'] DCNL DCSP except AttributeError: DCNL DCSP  DCSP return current.messages['NONE'] DCNL DCSP if (not thisdate): DCNL DCSP  DCSP return current.messages['NONE'] DCNL DCSP day = thisdate.date() DCNL DCSP monday = (day - datetime.timedelta(days=day.weekday())) DCNL DCSP return monday
def start_time(pid): DCNL  DCSP if ((not isinstance(pid, int)) or (pid < 0)): DCNL DCSP  DCSP return None DCNL DCSP if stem.util.proc.is_available(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return float(stem.util.proc.stats(pid, stem.util.proc.Stat.START_TIME)[0]) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP ps_results = call(('ps DCSP -p DCSP %s DCSP -o DCSP etime' % pid), []) DCNL DCSP  DCSP if (len(ps_results) >= 2): DCNL DCSP  DCSP  DCSP etime = ps_results[1].strip() DCNL DCSP  DCSP  DCSP return (time.time() - stem.util.str_tools.parse_short_time_label(etime)) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return None
def init(mpstate): DCNL  DCSP return SigningModule(mpstate)
def get_avg_dists(state1_samids, state2_samids, distdict): DCNL  DCSP state1_avg_dists = [] DCNL DCSP for sam1 in state1_samids: DCNL DCSP  DCSP dists = [] DCNL DCSP  DCSP for sam2 in state2_samids: DCNL DCSP  DCSP  DCSP if (sam1 == sam2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP dists.append(distdict[sam1][sam2]) DCNL DCSP  DCSP state1_avg_dists.append(numpy.mean(dists)) DCNL DCSP return state1_avg_dists
@handle_response_format DCNL @treeio_login_required DCNL def project_edit(request, project_id, response_format='html'): DCNL  DCSP project = get_object_or_404(Project, pk=project_id) DCNL DCSP if (not request.user.profile.has_permission(project, mode='w')): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Project") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP form = ProjectForm(request.user.profile, None, request.POST, instance=project) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP project = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('projects_project_view', args=[project.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('projects_project_view', args=[project.id])) DCNL DCSP else: DCNL DCSP  DCSP form = ProjectForm(request.user.profile, None, instance=project) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form, 'project': project}) DCNL DCSP return render_to_response('projects/project_edit', context, context_instance=RequestContext(request), response_format=response_format)
def _get_search_rank(collection_id): DCNL  DCSP rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP rank = (_DEFAULT_RANK + (_STATUS_PUBLICIZED_BONUS if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED) else 0)) DCNL DCSP return max(rank, 0)
def register(): DCNL  DCSP signals.initialized.connect(pelican_init) DCNL DCSP signals.article_generator_context.connect(custom_url) DCNL DCSP directives.register_directive('uml', PlantUML_rst)
def abspath(path): DCNL  DCSP if (not isabs(path)): DCNL DCSP  DCSP path = join(os.getcwd(), path) DCNL DCSP return normpath(path)
def foldersAtPath(path, includeParent=False): DCNL  DCSP while (path and (not os.path.isdir(path))): DCNL DCSP  DCSP if (path == os.path.dirname(path)): DCNL DCSP  DCSP  DCSP path = '' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.dirname(path) DCNL DCSP if (path == ''): DCNL DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP entries = [{'current_path': 'Root'}] DCNL DCSP  DCSP  DCSP for letter in getWinDrives(): DCNL DCSP  DCSP  DCSP  DCSP letterPath = (letter + ':\\') DCNL DCSP  DCSP  DCSP  DCSP entries.append({'name': letterPath, 'path': letterPath}) DCNL DCSP  DCSP  DCSP return entries DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '/' DCNL DCSP path = os.path.abspath(os.path.normpath(path)) DCNL DCSP parentPath = os.path.dirname(path) DCNL DCSP if ((path == parentPath) and (os.name == 'nt')): DCNL DCSP  DCSP parentPath = '' DCNL DCSP fileList = [{'name': filename, 'path': ek.ek(os.path.join, path, filename)} for filename in ek.ek(os.listdir, path)] DCNL DCSP fileList = filter((lambda entry: ek.ek(os.path.isdir, entry['path'])), fileList) DCNL DCSP hideList = ['boot', 'bootmgr', 'cache', 'msocache', 'recovery', '$recycle.bin', 'recycler', 'system DCSP volume DCSP information', 'temporary DCSP internet DCSP files'] DCNL DCSP hideList += ['.fseventd', '.spotlight', '.trashes', '.vol', 'cachedmessages', 'caches', 'trash'] DCNL DCSP fileList = filter((lambda entry: (entry['name'].lower() not in hideList)), fileList) DCNL DCSP fileList = sorted(fileList, (lambda x, y: cmp(os.path.basename(x['name']).lower(), os.path.basename(y['path']).lower()))) DCNL DCSP entries = [{'current_path': path}] DCNL DCSP if (includeParent and (parentPath != path)): DCNL DCSP  DCSP entries.append({'name': '..', 'path': parentPath}) DCNL DCSP entries.extend(fileList) DCNL DCSP return entries
def in6_get6to4Prefix(addr): DCNL  DCSP try: DCNL DCSP  DCSP addr = inet_pton(socket.AF_INET, addr) DCNL DCSP  DCSP addr = inet_ntop(socket.AF_INET6, ((' DCSP \x02' + addr) + ('\x00' * 10))) DCNL DCSP except: DCNL DCSP  DCSP return None DCNL DCSP return addr
def _aggr_mean(inList): DCNL  DCSP aggrSum = 0 DCNL DCSP nonNone = 0 DCNL DCSP for elem in inList: DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP aggrSum += elem DCNL DCSP  DCSP  DCSP nonNone += 1 DCNL DCSP if (nonNone != 0): DCNL DCSP  DCSP return (aggrSum / nonNone) DCNL DCSP else: DCNL DCSP  DCSP return None
def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False): DCNL  DCSP names = os.listdir(src) DCNL DCSP if (ignore is not None): DCNL DCSP  DCSP ignored_names = ignore(src, names) DCNL DCSP else: DCNL DCSP  DCSP ignored_names = set() DCNL DCSP os.makedirs(dst) DCNL DCSP errors = [] DCNL DCSP for name in names: DCNL DCSP  DCSP if (name in ignored_names): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP srcname = os.path.join(src, name) DCNL DCSP  DCSP dstname = os.path.join(dst, name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if os.path.islink(srcname): DCNL DCSP  DCSP  DCSP  DCSP linkto = os.readlink(srcname) DCNL DCSP  DCSP  DCSP  DCSP if symlinks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.symlink(linkto, dstname) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not os.path.exists(linkto)) and ignore_dangling_symlinks): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_function(srcname, dstname) DCNL DCSP  DCSP  DCSP elif os.path.isdir(srcname): DCNL DCSP  DCSP  DCSP  DCSP copytree(srcname, dstname, symlinks, ignore, copy_function) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP copy_function(srcname, dstname) DCNL DCSP  DCSP except Error as err: DCNL DCSP  DCSP  DCSP errors.extend(err.args[0]) DCNL DCSP  DCSP except EnvironmentError as why: DCNL DCSP  DCSP  DCSP errors.append((srcname, dstname, str(why))) DCNL DCSP try: DCNL DCSP  DCSP copystat(src, dst) DCNL DCSP except OSError as why: DCNL DCSP  DCSP if ((WindowsError is not None) and isinstance(why, WindowsError)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors.extend((src, dst, str(why))) DCNL DCSP if errors: DCNL DCSP  DCSP raise Error(errors)
def test_zeros(): DCNL  DCSP assert_close(reconstruction(np.zeros((5, 7)), np.zeros((5, 7))), 0)
def append_slash_redirect(environ, code=301): DCNL  DCSP new_path = (environ['PATH_INFO'].strip('/') + '/') DCNL DCSP query_string = environ.get('QUERY_STRING') DCNL DCSP if query_string: DCNL DCSP  DCSP new_path += ('?' + query_string) DCNL DCSP return redirect(new_path, code)
def javascript_catalog(request, domain='djangojs', packages=None): DCNL  DCSP if request.GET: DCNL DCSP  DCSP if ('language' in request.GET): DCNL DCSP  DCSP  DCSP if check_for_language(request.GET['language']): DCNL DCSP  DCSP  DCSP  DCSP activate(request.GET['language']) DCNL DCSP if (packages is None): DCNL DCSP  DCSP packages = ['django.conf'] DCNL DCSP if isinstance(packages, basestring): DCNL DCSP  DCSP packages = packages.split('+') DCNL DCSP packages = [p for p in packages if ((p == 'django.conf') or (p in settings.INSTALLED_APPS))] DCNL DCSP default_locale = to_locale(settings.LANGUAGE_CODE) DCNL DCSP locale = to_locale(get_language()) DCNL DCSP t = {} DCNL DCSP paths = [] DCNL DCSP en_selected = locale.startswith('en') DCNL DCSP en_catalog_missing = True DCNL DCSP for package in packages: DCNL DCSP  DCSP p = importlib.import_module(package) DCNL DCSP  DCSP path = os.path.join(os.path.dirname(p.__file__), 'locale') DCNL DCSP  DCSP paths.append(path) DCNL DCSP paths.extend(list(reversed(settings.LOCALE_PATHS))) DCNL DCSP for path in paths: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP catalog = gettext_module.translation(domain, path, ['en']) DCNL DCSP  DCSP  DCSP t.update(catalog._catalog) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if en_selected: DCNL DCSP  DCSP  DCSP  DCSP en_catalog_missing = False DCNL DCSP if (default_locale != 'en'): DCNL DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP catalog = gettext_module.translation(domain, path, [default_locale]) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP t.update(catalog._catalog) DCNL DCSP if (locale != default_locale): DCNL DCSP  DCSP if (en_selected and en_catalog_missing): DCNL DCSP  DCSP  DCSP t = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP locale_t = {} DCNL DCSP  DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = gettext_module.translation(domain, path, [locale]) DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP locale_t.update(catalog._catalog) DCNL DCSP  DCSP  DCSP if locale_t: DCNL DCSP  DCSP  DCSP  DCSP t = locale_t DCNL DCSP src = [LibHead] DCNL DCSP plural = None DCNL DCSP if ('' in t): DCNL DCSP  DCSP for l in t[''].split('\n'): DCNL DCSP  DCSP  DCSP if l.startswith('Plural-Forms:'): DCNL DCSP  DCSP  DCSP  DCSP plural = l.split(':', 1)[1].strip() DCNL DCSP if (plural is not None): DCNL DCSP  DCSP plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')][0].split('=', 1)[1] DCNL DCSP  DCSP src.append((PluralIdx % plural)) DCNL DCSP else: DCNL DCSP  DCSP src.append(SimplePlural) DCNL DCSP csrc = [] DCNL DCSP pdict = {} DCNL DCSP for (k, v) in t.items(): DCNL DCSP  DCSP if (k == ''): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(k, basestring): DCNL DCSP  DCSP  DCSP csrc.append(("catalog['%s'] DCSP = DCSP '%s';\n" % (javascript_quote(k), javascript_quote(v)))) DCNL DCSP  DCSP elif isinstance(k, tuple): DCNL DCSP  DCSP  DCSP if (k[0] not in pdict): DCNL DCSP  DCSP  DCSP  DCSP pdict[k[0]] = k[1] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pdict[k[0]] = max(k[1], pdict[k[0]]) DCNL DCSP  DCSP  DCSP csrc.append(("catalog['%s'][%d] DCSP = DCSP '%s';\n" % (javascript_quote(k[0]), k[1], javascript_quote(v)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(k) DCNL DCSP csrc.sort() DCNL DCSP for (k, v) in pdict.items(): DCNL DCSP  DCSP src.append(("catalog['%s'] DCSP = DCSP [%s];\n" % (javascript_quote(k), ','.join((["''"] * (v + 1)))))) DCNL DCSP src.extend(csrc) DCNL DCSP src.append(LibFoot) DCNL DCSP src.append(InterPolate) DCNL DCSP src.append(LibFormatHead) DCNL DCSP src.append(get_formats()) DCNL DCSP src.append(LibFormatFoot) DCNL DCSP src = ''.join(src) DCNL DCSP return http.HttpResponse(src, 'text/javascript')
def serialize(node, stream=None, Dumper=Dumper, **kwds): DCNL  DCSP return serialize_all([node], stream, Dumper=Dumper, **kwds)
def group_list_of_dict(array): DCNL  DCSP result = defaultdict(list) DCNL DCSP for item in array: DCNL DCSP  DCSP for (key, value) in item.items(): DCNL DCSP  DCSP  DCSP result[key] += (value if isinstance(value, list) else [value]) DCNL DCSP return result
def log(s): DCNL  DCSP global _last_prog DCNL DCSP sys.stdout.flush() DCNL DCSP _hard_write(sys.stderr.fileno(), s) DCNL DCSP _last_prog = 0
def bind_expression_to_resources(expr, resources): DCNL  DCSP if (resources is None): DCNL DCSP  DCSP resources = {} DCNL DCSP return expr._subs({k: bz.data(v, dshape=k.dshape) for (k, v) in iteritems(resources)})
@release.command() DCNL def changelog(): DCNL  DCSP print changelog_as_markdown()
def test_sobel_h_horizontal(): DCNL  DCSP (i, j) = np.mgrid[(-5):6, (-5):6] DCNL DCSP image = (i >= 0).astype(float) DCNL DCSP result = filters.sobel_h(image) DCNL DCSP i[(np.abs(j) == 5)] = 10000 DCNL DCSP assert np.all((result[(i == 0)] == 1)) DCNL DCSP assert np.all((result[(np.abs(i) > 1)] == 0))
def _other_endian(typ): DCNL  DCSP try: DCNL DCSP  DCSP return getattr(typ, _OTHER_ENDIAN) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if (type(typ) == _array_type): DCNL DCSP  DCSP  DCSP return (_other_endian(typ._type_) * typ._length_) DCNL DCSP  DCSP raise TypeError(('This DCSP type DCSP does DCSP not DCSP support DCSP other DCSP endian: DCSP %s' % typ))
def farray(ptr, shape, dtype=None): DCNL  DCSP if (not isinstance(shape, utils.INT_TYPES)): DCNL DCSP  DCSP shape = shape[::(-1)] DCNL DCSP return carray(ptr, shape, dtype).T
@protocol.commands.add(u'listmounts') DCNL def listmounts(context): DCNL  DCSP raise exceptions.MpdNotImplemented
def cscore(v1, v2): DCNL  DCSP v1_b = v1.astype(bool) DCNL DCSP v2_b = v2.astype(bool) DCNL DCSP sij = (v1_b * v2_b).sum() DCNL DCSP return ((v1_b.sum() - sij) * (v2_b.sum() - sij))
@verbose DCNL def source_induced_power(epochs, inverse_operator, frequencies, label=None, lambda2=(1.0 / 9.0), method='dSPM', nave=1, n_cycles=5, decim=1, use_fft=False, pick_ori=None, baseline=None, baseline_mode='logratio', pca=True, n_jobs=1, zero_mean=False, prepared=False, verbose=None): DCNL  DCSP method = _check_method(method) DCNL DCSP pick_ori = _check_ori(pick_ori) DCNL DCSP (power, plv, vertno) = _source_induced_power(epochs, inverse_operator, frequencies, label=label, lambda2=lambda2, method=method, nave=nave, n_cycles=n_cycles, decim=decim, use_fft=use_fft, pick_ori=pick_ori, pca=pca, n_jobs=n_jobs, prepared=False) DCNL DCSP power = rescale(power, epochs.times[::decim], baseline, baseline_mode, copy=False) DCNL DCSP return (power, plv)
def read_metadata_kfx(stream, read_cover=True): DCNL  DCSP c = Container(stream.read()) DCNL DCSP m = extract_metadata(c.decode()) DCNL DCSP def has(x): DCNL DCSP  DCSP return (m[x] and m[x][0]) DCNL DCSP def get(x, single=True): DCNL DCSP  DCSP ans = m[x] DCNL DCSP  DCSP if single: DCNL DCSP  DCSP  DCSP ans = (clean_xml_chars(ans[0]) if ans else u'') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ans = [clean_xml_chars(y) for y in ans] DCNL DCSP  DCSP return ans DCNL DCSP title = (get(u'title') or _(u'Unknown')) DCNL DCSP authors = (get(u'authors', False) or [_(u'Unknown')]) DCNL DCSP auth_pat = re.compile(u'([^,]+?)\\s*,\\s+([^,]+)$') DCNL DCSP def fix_author(x): DCNL DCSP  DCSP if (tweaks[u'author_sort_copy_method'] != u'copy'): DCNL DCSP  DCSP  DCSP m = auth_pat.match(x.strip()) DCNL DCSP  DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP  DCSP return ((m.group(2) + u' DCSP ') + m.group(1)) DCNL DCSP  DCSP return x DCNL DCSP mi = Metadata(title, [fix_author(x) for x in authors]) DCNL DCSP if has(u'author'): DCNL DCSP  DCSP mi.author_sort = get(u'author') DCNL DCSP if has(u'ASIN'): DCNL DCSP  DCSP mi.set_identifier(u'mobi-asin', get(u'ASIN')) DCNL DCSP elif has(u'content_id'): DCNL DCSP  DCSP mi.set_identifier(u'mobi-asin', get(u'content_id')) DCNL DCSP if has(u'languages'): DCNL DCSP  DCSP langs = list(filter(None, (canonicalize_lang(x) for x in get(u'languages', False)))) DCNL DCSP  DCSP if langs: DCNL DCSP  DCSP  DCSP mi.languages = langs DCNL DCSP if has(u'issue_date'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mi.pubdate = parse_only_date(get(u'issue_date')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (has(u'publisher') and (get(u'publisher') != u'Unknown')): DCNL DCSP  DCSP mi.publisher = get(u'publisher') DCNL DCSP if (read_cover and m[COVER_KEY]): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = base64.standard_b64decode(m[COVER_KEY]) DCNL DCSP  DCSP  DCSP (fmt, w, h) = identify(bytes(data)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP (w, h, fmt) = (0, 0, None) DCNL DCSP  DCSP if (fmt and (w > (-1)) and (h > (-1))): DCNL DCSP  DCSP  DCSP mi.cover_data = (fmt, data) DCNL DCSP return mi
def compute_grad(J, f): DCNL  DCSP if isinstance(J, LinearOperator): DCNL DCSP  DCSP return J.rmatvec(f) DCNL DCSP else: DCNL DCSP  DCSP return J.T.dot(f)
def secgroup_info(call=None, kwargs=None): DCNL  DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP secgroup_info DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP name = kwargs.get('name', None) DCNL DCSP secgroup_id = kwargs.get('secgroup_id', None) DCNL DCSP if secgroup_id: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP log.warning("Both DCSP the DCSP 'secgroup_id' DCSP and DCSP 'name' DCSP arguments DCSP were DCSP provided. DCSP 'secgroup_id' DCSP will DCSP take DCSP precedence.") DCNL DCSP elif name: DCNL DCSP  DCSP secgroup_id = get_secgroup_id(kwargs={'name': name}) DCNL DCSP else: DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP secgroup_info DCSP function DCSP requires DCSP either DCSP a DCSP name DCSP or DCSP a DCSP secgroup_id DCSP to DCSP be DCSP provided.') DCNL DCSP (server, user, password) = _get_xml_rpc() DCNL DCSP auth = ':'.join([user, password]) DCNL DCSP info = {} DCNL DCSP response = server.one.secgroup.info(auth, int(secgroup_id))[1] DCNL DCSP tree = _get_xml(response) DCNL DCSP info[tree.find('NAME').text] = _xml_to_dict(tree) DCNL DCSP return info
def _make_complex_eigvecs(w, vin, dtype): DCNL  DCSP v = numpy.array(vin, dtype=dtype) DCNL DCSP m = (w.imag > 0) DCNL DCSP m[:(-1)] |= (w.imag[1:] < 0) DCNL DCSP for i in flatnonzero(m): DCNL DCSP  DCSP v.imag[:, i] = vin[:, (i + 1)] DCNL DCSP  DCSP conj(v[:, i], v[:, (i + 1)]) DCNL DCSP return v
@conf.commands.register DCNL def corrupt_bits(s, p=0.01, n=None): DCNL  DCSP s = array.array('B', str(s)) DCNL DCSP l = (len(s) * 8) DCNL DCSP if (n is None): DCNL DCSP  DCSP n = max(1, int((l * p))) DCNL DCSP for i in random.sample(xrange(l), n): DCNL DCSP  DCSP s[(i / 8)] ^= (1 << (i % 8)) DCNL DCSP return s.tostring()
def require_module(module): DCNL  DCSP def check_require_module(f): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __import__(module) DCNL DCSP  DCSP  DCSP return f DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP def new_f(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP self.skipTest(('%s DCSP can DCSP not DCSP be DCSP imported.' % module)) DCNL DCSP  DCSP  DCSP new_f.__name__ = f.__name__ DCNL DCSP  DCSP  DCSP return new_f DCNL DCSP return check_require_module
def bayesian_info_criterion_lsq(ssr, n_params, n_samples): DCNL  DCSP return bayesian_info_criterion((((-0.5) * n_samples) * np.log((ssr / n_samples))), n_params, n_samples)
def sort_dependencies(app_list): DCNL  DCSP from google.appengine._internal.django.db.models import get_model, get_models DCNL DCSP model_dependencies = [] DCNL DCSP models = set() DCNL DCSP for (app, model_list) in app_list: DCNL DCSP  DCSP if (model_list is None): DCNL DCSP  DCSP  DCSP model_list = get_models(app) DCNL DCSP  DCSP for model in model_list: DCNL DCSP  DCSP  DCSP models.add(model) DCNL DCSP  DCSP  DCSP if hasattr(model, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP deps = getattr(model.natural_key, 'dependencies', []) DCNL DCSP  DCSP  DCSP  DCSP if deps: DCNL DCSP  DCSP  DCSP  DCSP  DCSP deps = [get_model(*d.split('.')) for d in deps] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP deps = [] DCNL DCSP  DCSP  DCSP for field in model._meta.fields: DCNL DCSP  DCSP  DCSP  DCSP if hasattr(field.rel, 'to'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_model = field.rel.to DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(rel_model, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deps.append(rel_model) DCNL DCSP  DCSP  DCSP for field in model._meta.many_to_many: DCNL DCSP  DCSP  DCSP  DCSP rel_model = field.rel.to DCNL DCSP  DCSP  DCSP  DCSP if hasattr(rel_model, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP deps.append(rel_model) DCNL DCSP  DCSP  DCSP model_dependencies.append((model, deps)) DCNL DCSP model_dependencies.reverse() DCNL DCSP model_list = [] DCNL DCSP while model_dependencies: DCNL DCSP  DCSP skipped = [] DCNL DCSP  DCSP changed = False DCNL DCSP  DCSP while model_dependencies: DCNL DCSP  DCSP  DCSP (model, deps) = model_dependencies.pop() DCNL DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP for candidate in (((d not in models) or (d in model_list)) for d in deps): DCNL DCSP  DCSP  DCSP  DCSP if (not candidate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP if found: DCNL DCSP  DCSP  DCSP  DCSP model_list.append(model) DCNL DCSP  DCSP  DCSP  DCSP changed = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP skipped.append((model, deps)) DCNL DCSP  DCSP if (not changed): DCNL DCSP  DCSP  DCSP raise CommandError(("Can't DCSP resolve DCSP dependencies DCSP for DCSP %s DCSP in DCSP serialized DCSP app DCSP list." % ', DCSP '.join((('%s.%s' % (model._meta.app_label, model._meta.object_name)) for (model, deps) in sorted(skipped, key=(lambda obj: obj[0].__name__)))))) DCNL DCSP  DCSP model_dependencies = skipped DCNL DCSP return model_list
def _sig_key(key, date_stamp, regionName, serviceName): DCNL  DCSP kDate = _sign(('AWS4' + key).encode('utf-8'), date_stamp) DCNL DCSP if regionName: DCNL DCSP  DCSP kRegion = _sign(kDate, regionName) DCNL DCSP  DCSP kService = _sign(kRegion, serviceName) DCNL DCSP else: DCNL DCSP  DCSP kService = _sign(kDate, serviceName) DCNL DCSP kSigning = _sign(kService, 'aws4_request') DCNL DCSP return kSigning
def mask_secret_parameters(parameters, secret_parameters): DCNL  DCSP result = copy.deepcopy(parameters) DCNL DCSP for parameter in secret_parameters: DCNL DCSP  DCSP if (parameter in result): DCNL DCSP  DCSP  DCSP result[parameter] = MASKED_ATTRIBUTE_VALUE DCNL DCSP return result
@mock_ec2 DCNL def test_eip_release_bogus_eip(): DCNL  DCSP conn = boto.connect_ec2(u'the_key', u'the_secret') DCNL DCSP with assert_raises(EC2ResponseError) as cm: DCNL DCSP  DCSP conn.release_address(allocation_id=u'bogus') DCNL DCSP cm.exception.code.should.equal(u'InvalidAllocationID.NotFound') DCNL DCSP cm.exception.status.should.equal(400) DCNL DCSP cm.exception.request_id.should_not.be.none
def validate_int_or_basestring(option, value): DCNL  DCSP if isinstance(value, integer_types): DCNL DCSP  DCSP return value DCNL DCSP elif isinstance(value, string_type): DCNL DCSP  DCSP if value.isdigit(): DCNL DCSP  DCSP  DCSP return int(value) DCNL DCSP  DCSP return value DCNL DCSP raise TypeError(('Wrong DCSP type DCSP for DCSP %s, DCSP value DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP a DCSP string' % (option,)))
def with_inline_css(html_without_css): DCNL  DCSP css_filepath = settings.NOTIFICATION_EMAIL_CSS DCNL DCSP if (not css_filepath.startswith('/')): DCNL DCSP  DCSP css_filepath = file_path_finder(settings.NOTIFICATION_EMAIL_CSS) DCNL DCSP if css_filepath: DCNL DCSP  DCSP with open(css_filepath, 'r') as _file: DCNL DCSP  DCSP  DCSP css_content = _file.read() DCNL DCSP  DCSP html_with_inline_css = pynliner.fromString(((('<style>' + css_content) + '</style>') + html_without_css)) DCNL DCSP  DCSP return html_with_inline_css DCNL DCSP return html_without_css
def track_distance(item, info): DCNL  DCSP from beets.autotag.hooks import Distance DCNL DCSP dist = Distance() DCNL DCSP for plugin in find_plugins(): DCNL DCSP  DCSP dist.update(plugin.track_distance(item, info)) DCNL DCSP return dist
def user(pid): DCNL  DCSP if ((not isinstance(pid, int)) or (pid < 0)): DCNL DCSP  DCSP return None DCNL DCSP if stem.util.proc.is_available(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import pwd DCNL DCSP  DCSP  DCSP uid = stem.util.proc.uid(pid) DCNL DCSP  DCSP  DCSP if (uid and uid.isdigit()): DCNL DCSP  DCSP  DCSP  DCSP return pwd.getpwuid(int(uid)).pw_name DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if is_available('ps'): DCNL DCSP  DCSP results = call(('ps DCSP -o DCSP user DCSP %s' % pid), []) DCNL DCSP  DCSP if (len(results) >= 2): DCNL DCSP  DCSP  DCSP return results[1].strip() DCNL DCSP return None
@testing.requires_testing_data DCNL @requires_fs_or_nibabel DCNL def test_vertex_to_mni(): DCNL  DCSP vertices = [100960, 7620, 150549, 96761] DCNL DCSP coords = np.array([[(-60.86), (-11.18), (-3.19)], [(-36.46), (-93.18), (-2.36)], [(-38.0), 50.08, (-10.61)], [47.14, 8.01, 46.93]]) DCNL DCSP hemis = [0, 0, 0, 1] DCNL DCSP coords_2 = vertex_to_mni(vertices, hemis, 'sample', subjects_dir) DCNL DCSP assert_allclose(coords, coords_2, atol=1.0)
def get_database_password(name): DCNL  DCSP password = DATABASES[name].PASSWORD.get() DCNL DCSP if (not password): DCNL DCSP  DCSP password = DATABASES[name].PASSWORD_SCRIPT.get() DCNL DCSP return password
def retrieve_token(userid, secret): DCNL  DCSP dtnow = datetime.datetime.now() DCNL DCSP dtutcnow = datetime.datetime.utcnow() DCNL DCSP delta = (dtnow - dtutcnow) DCNL DCSP (newhour, newmin) = divmod(((((((delta.days * 24) * 60) * 60) + delta.seconds) + 30) // 60), 60) DCNL DCSP newtime = ('%s%+02d:%02d' % (dtnow.isoformat(), newhour, newmin)) DCNL DCSP custom_data = {'issuedAt': newtime, 'consumerKey': secret, 'userId': userid, 'ttl': 86400} DCNL DCSP newtoken = create_token(secret, custom_data) DCNL DCSP return newtoken
@testing.requires_testing_data DCNL def test_preload_modify(): DCNL  DCSP tempdir = _TempDir() DCNL DCSP rng = np.random.RandomState(0) DCNL DCSP for preload in [False, True, 'memmap.dat']: DCNL DCSP  DCSP raw = read_raw_fif(fif_fname, preload=preload) DCNL DCSP  DCSP nsamp = ((raw.last_samp - raw.first_samp) + 1) DCNL DCSP  DCSP picks = pick_types(raw.info, meg='grad', exclude='bads') DCNL DCSP  DCSP data = rng.randn(len(picks), (nsamp // 2)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP raw[picks, :(nsamp // 2)] = data DCNL DCSP  DCSP except RuntimeError as err: DCNL DCSP  DCSP  DCSP if (not preload): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise err DCNL DCSP  DCSP tmp_fname = op.join(tempdir, 'raw.fif') DCNL DCSP  DCSP raw.save(tmp_fname, overwrite=True) DCNL DCSP  DCSP raw_new = read_raw_fif(tmp_fname) DCNL DCSP  DCSP (data_new, _) = raw_new[picks, :(nsamp / 2)] DCNL DCSP  DCSP assert_allclose(data, data_new)
def sample_content(name): DCNL  DCSP with open(('tests/components/media_player/yamaha_samples/%s' % name), encoding='utf-8') as content: DCNL DCSP  DCSP return content.read()
def parse229(resp, peer): DCNL  DCSP if (resp[:3] != '229'): DCNL DCSP  DCSP raise error_reply(resp) DCNL DCSP left = resp.find('(') DCNL DCSP if (left < 0): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP right = resp.find(')', (left + 1)) DCNL DCSP if (right < 0): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP if (resp[(left + 1)] != resp[(right - 1)]): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP parts = resp[(left + 1):right].split(resp[(left + 1)]) DCNL DCSP if (len(parts) != 5): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP host = peer[0] DCNL DCSP port = int(parts[3]) DCNL DCSP return (host, port)
def set_(key, value, profile=None, ttl=None, directory=False): DCNL  DCSP client = __utils__['etcd_util.get_conn'](__opts__, profile) DCNL DCSP return client.set(key, value, ttl=ttl, directory=directory)
@login_required DCNL def comment(request, pk): DCNL  DCSP unit = get_object_or_404(Unit, pk=pk) DCNL DCSP unit.check_acl(request) DCNL DCSP if (not can_add_comment(request.user, unit.translation.subproject.project)): DCNL DCSP  DCSP raise PermissionDenied() DCNL DCSP form = CommentForm(request.POST) DCNL DCSP if form.is_valid(): DCNL DCSP  DCSP if (form.cleaned_data[u'scope'] == u'global'): DCNL DCSP  DCSP  DCSP lang = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lang = unit.translation.language DCNL DCSP  DCSP Comment.objects.add(unit, request.user, lang, form.cleaned_data[u'comment']) DCNL DCSP  DCSP messages.success(request, _(u'Posted DCSP new DCSP comment')) DCNL DCSP else: DCNL DCSP  DCSP messages.error(request, _(u'Failed DCSP to DCSP add DCSP comment!')) DCNL DCSP return redirect(request.POST.get(u'next', unit))
def getFloatListListsByPaths(paths): DCNL  DCSP floatListLists = [] DCNL DCSP for path in paths: DCNL DCSP  DCSP floatListList = [] DCNL DCSP  DCSP for point in path: DCNL DCSP  DCSP  DCSP floatListList.append(point.getFloatList()) DCNL DCSP return floatListLists
def write_trace(expt_dir, best_val, best_job, n_candidates, n_pending, n_complete): DCNL  DCSP trace_fh = open(os.path.join(expt_dir, 'trace.csv'), 'a') DCNL DCSP trace_fh.write(('%d,%f,%d,%d,%d,%d\n' % (time.time(), best_val, best_job, n_candidates, n_pending, n_complete))) DCNL DCSP trace_fh.close()
def tag_item(item, search_artist=None, search_title=None, search_id=None): DCNL  DCSP candidates = {} DCNL DCSP trackid = (search_id or item.mb_trackid) DCNL DCSP if trackid: DCNL DCSP  DCSP log.debug(u'Searching DCSP for DCSP track DCSP ID: DCSP {0}'.format(trackid)) DCNL DCSP  DCSP for track_info in hooks.tracks_for_id(trackid): DCNL DCSP  DCSP  DCSP dist = track_distance(item, track_info, incl_artist=True) DCNL DCSP  DCSP  DCSP candidates[track_info.track_id] = hooks.TrackMatch(dist, track_info) DCNL DCSP  DCSP  DCSP rec = _recommendation(candidates.values()) DCNL DCSP  DCSP  DCSP if ((rec == Recommendation.strong) and (not config['import']['timid'])): DCNL DCSP  DCSP  DCSP  DCSP log.debug(u'Track DCSP ID DCSP match.') DCNL DCSP  DCSP  DCSP  DCSP return (candidates.values(), rec) DCNL DCSP if (search_id is not None): DCNL DCSP  DCSP if candidates: DCNL DCSP  DCSP  DCSP return (candidates.values(), rec) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ([], Recommendation.none) DCNL DCSP if (not (search_artist and search_title)): DCNL DCSP  DCSP (search_artist, search_title) = (item.artist, item.title) DCNL DCSP log.debug(u'Item DCSP search DCSP terms: DCSP {0} DCSP - DCSP {1}'.format(search_artist, search_title)) DCNL DCSP for track_info in hooks.item_candidates(item, search_artist, search_title): DCNL DCSP  DCSP dist = track_distance(item, track_info, incl_artist=True) DCNL DCSP  DCSP candidates[track_info.track_id] = hooks.TrackMatch(dist, track_info) DCNL DCSP log.debug(u'Found DCSP {0} DCSP candidates.'.format(len(candidates))) DCNL DCSP candidates = sorted(candidates.itervalues()) DCNL DCSP rec = _recommendation(candidates) DCNL DCSP return (candidates, rec)
@click.command(cls=ComplexCLI, context_settings=CONTEXT_SETTINGS) DCNL @click.option('--home', type=click.Path(exists=True, file_okay=False, resolve_path=True), help='Changes DCSP the DCSP folder DCSP to DCSP operate DCSP on.') DCNL @click.option('-v', '--verbose', is_flag=True, help='Enables DCSP verbose DCSP mode.') DCNL @pass_context DCNL def cli(ctx, verbose, home): DCNL  DCSP ctx.verbose = verbose DCNL DCSP if (home is not None): DCNL DCSP  DCSP ctx.home = home
def main(): DCNL  DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = nova_session.create_engine(CONF.baremetal.sql_connection) DCNL DCSP return _ENGINE
def dictreverse(mapping): DCNL  DCSP return dict([(value, key) for (key, value) in mapping.iteritems()])
def squared_loss(y_true, y_pred): DCNL  DCSP return (((y_true - y_pred) ** 2).mean() / 2)
def GroupDecoder(field_number, is_repeated, is_packed, key, new_default): DCNL  DCSP end_tag_bytes = encoder.TagBytes(field_number, wire_format.WIRETYPE_END_GROUP) DCNL DCSP end_tag_len = len(end_tag_bytes) DCNL DCSP assert (not is_packed) DCNL DCSP if is_repeated: DCNL DCSP  DCSP tag_bytes = encoder.TagBytes(field_number, wire_format.WIRETYPE_START_GROUP) DCNL DCSP  DCSP tag_len = len(tag_bytes) DCNL DCSP  DCSP def DecodeRepeatedField(buffer, pos, end, message, field_dict): DCNL DCSP  DCSP  DCSP value = field_dict.get(key) DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP value = field_dict.setdefault(key, new_default(message)) DCNL DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP value = field_dict.get(key) DCNL DCSP  DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = field_dict.setdefault(key, new_default(message)) DCNL DCSP  DCSP  DCSP  DCSP pos = value.add()._InternalParse(buffer, pos, end) DCNL DCSP  DCSP  DCSP  DCSP new_pos = (pos + end_tag_len) DCNL DCSP  DCSP  DCSP  DCSP if ((buffer[pos:new_pos] != end_tag_bytes) or (new_pos > end)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise _DecodeError('Missing DCSP group DCSP end DCSP tag.') DCNL DCSP  DCSP  DCSP  DCSP pos = (new_pos + tag_len) DCNL DCSP  DCSP  DCSP  DCSP if ((buffer[new_pos:pos] != tag_bytes) or (new_pos == end)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return new_pos DCNL DCSP  DCSP return DecodeRepeatedField DCNL DCSP else: DCNL DCSP  DCSP def DecodeField(buffer, pos, end, message, field_dict): DCNL DCSP  DCSP  DCSP value = field_dict.get(key) DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP value = field_dict.setdefault(key, new_default(message)) DCNL DCSP  DCSP  DCSP pos = value._InternalParse(buffer, pos, end) DCNL DCSP  DCSP  DCSP new_pos = (pos + end_tag_len) DCNL DCSP  DCSP  DCSP if ((buffer[pos:new_pos] != end_tag_bytes) or (new_pos > end)): DCNL DCSP  DCSP  DCSP  DCSP raise _DecodeError('Missing DCSP group DCSP end DCSP tag.') DCNL DCSP  DCSP  DCSP return new_pos DCNL DCSP  DCSP return DecodeField
def _get_pnics(host_reference): DCNL  DCSP return host_reference.config.network.pnic
def getFundamentalsPath(subName=''): DCNL  DCSP return getJoinedPath(getGeometryUtilitiesPath('evaluate_fundamentals'), subName)
def loads(data, use_datetime=0): DCNL  DCSP (p, u) = getparser(use_datetime=use_datetime) DCNL DCSP p.feed(data) DCNL DCSP p.close() DCNL DCSP return (u.close(), u.getmethodname())
def code_name(code, number=0): DCNL  DCSP hash_digest = hashlib.md5(code.encode('utf-8')).hexdigest() DCNL DCSP return '<ipython-input-{0}-{1}>'.format(number, hash_digest[:12])
def iriToURI(iri): DCNL  DCSP return _escapeme_re.sub(_percentEscapeUnicode, iri)
def pack_bitstring(bits): DCNL  DCSP ret = '' DCNL DCSP i = packed = 0 DCNL DCSP for bit in bits: DCNL DCSP  DCSP if bit: DCNL DCSP  DCSP  DCSP packed += 128 DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP if (i == 8): DCNL DCSP  DCSP  DCSP ret += chr(packed) DCNL DCSP  DCSP  DCSP i = packed = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP packed >>= 1 DCNL DCSP if ((i > 0) and (i < 8)): DCNL DCSP  DCSP packed >>= (7 - i) DCNL DCSP  DCSP ret += chr(packed) DCNL DCSP return ret
def safe_walk(top, topdown=True, onerror=None, followlinks=True, _seen=None): DCNL  DCSP (islink, join, isdir) = (os.path.islink, os.path.join, os.path.isdir) DCNL DCSP if (_seen is None): DCNL DCSP  DCSP _seen = set() DCNL DCSP try: DCNL DCSP  DCSP names = os.listdir(top) DCNL DCSP except os.error as err: DCNL DCSP  DCSP if (onerror is not None): DCNL DCSP  DCSP  DCSP onerror(err) DCNL DCSP  DCSP return DCNL DCSP if followlinks: DCNL DCSP  DCSP status = os.stat(top) DCNL DCSP  DCSP if (status.st_ino != 0): DCNL DCSP  DCSP  DCSP node = (status.st_dev, status.st_ino) DCNL DCSP  DCSP  DCSP if (node in _seen): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP _seen.add(node) DCNL DCSP (dirs, nondirs) = ([], []) DCNL DCSP for name in names: DCNL DCSP  DCSP full_path = join(top, name) DCNL DCSP  DCSP if isdir(full_path): DCNL DCSP  DCSP  DCSP dirs.append(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nondirs.append(name) DCNL DCSP if topdown: DCNL DCSP  DCSP (yield (top, dirs, nondirs)) DCNL DCSP for name in dirs: DCNL DCSP  DCSP new_path = join(top, name) DCNL DCSP  DCSP if (followlinks or (not islink(new_path))): DCNL DCSP  DCSP  DCSP for x in safe_walk(new_path, topdown, onerror, followlinks, _seen): DCNL DCSP  DCSP  DCSP  DCSP (yield x) DCNL DCSP if (not topdown): DCNL DCSP  DCSP (yield (top, dirs, nondirs))
def get_introspection_module(namespace): DCNL  DCSP mod = sys.modules[('pgi.repository.' + namespace)] DCNL DCSP return getattr(mod, '_introspection_module', mod)
def generate_fused_type(codes): DCNL  DCSP cytypes = map((lambda x: CY_TYPES[x]), codes) DCNL DCSP name = (codes + '_number_t') DCNL DCSP declaration = [(('ctypedef DCSP fused DCSP ' + name) + ':')] DCNL DCSP for cytype in cytypes: DCNL DCSP  DCSP declaration.append((' DCSP  DCSP  DCSP  DCSP ' + cytype)) DCNL DCSP declaration = '\n'.join(declaration) DCNL DCSP return (name, declaration)
@timefunc(1) DCNL def conesearch_timer(*args, **kwargs): DCNL  DCSP return conesearch(*args, **kwargs)
def to_unicode_optional_iterator(x): DCNL  DCSP if isinstance(x, STRING_TYPES): DCNL DCSP  DCSP return to_unicode(x) DCNL DCSP try: DCNL DCSP  DCSP l = list(x) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP assert ('is DCSP not DCSP iterable' in str(e)) DCNL DCSP  DCSP return x DCNL DCSP else: DCNL DCSP  DCSP return [to_unicode(e) for e in l]
def test_setitem(hist): DCNL  DCSP with pytest.raises(TypeError) as excinfo: DCNL DCSP  DCSP hist[0] = 'foo' DCNL DCSP expected = "'History' DCSP object DCSP does DCSP not DCSP support DCSP item DCSP assignment" DCNL DCSP assert (str(excinfo.value) == expected)
def run_bg(cmd, cwd=None, runas=None, shell=DEFAULT_SHELL, python_shell=None, env=None, clean_env=False, template=None, umask=None, timeout=None, output_loglevel='debug', log_callback=None, reset_system_locale=True, ignore_retcode=False, saltenv='base', password=None, **kwargs): DCNL  DCSP python_shell = _python_shell_default(python_shell, kwargs.get('__pub_jid', '')) DCNL DCSP res = _run(cmd, stdin=None, stderr=None, stdout=None, output_loglevel=output_loglevel, use_vt=None, bg=True, with_communicate=False, rstrip=False, runas=runas, shell=shell, python_shell=python_shell, cwd=cwd, env=env, clean_env=clean_env, template=template, umask=umask, log_callback=log_callback, timeout=timeout, reset_system_locale=reset_system_locale, ignore_retcode=ignore_retcode, saltenv=saltenv, password=password, **kwargs) DCNL DCSP return {'pid': res['pid']}
def mock_action(action_name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP mock_action = mock.MagicMock() DCNL DCSP  DCSP  DCSP from ckan.logic import get_action as original_get_action DCNL DCSP  DCSP  DCSP def side_effect(called_action_name): DCNL DCSP  DCSP  DCSP  DCSP if (called_action_name == action_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return mock_action DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return original_get_action(called_action_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with mock.patch('ckan.logic.get_action') as mock_get_action: DCNL DCSP  DCSP  DCSP  DCSP  DCSP with mock.patch('ckan.plugins.toolkit.get_action') as mock_get_action_toolkit: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mock_get_action.side_effect = side_effect DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mock_get_action_toolkit.side_effect = side_effect DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_args = (args + tuple([mock_action])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return_value = func(*new_args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP mock_action.stop() DCNL DCSP  DCSP  DCSP return return_value DCNL DCSP  DCSP return nose.tools.make_decorator(func)(wrapper) DCNL DCSP return decorator
def schema_create(dbname, name, owner=None, user=None, db_user=None, db_password=None, db_host=None, db_port=None): DCNL  DCSP if schema_exists(dbname, name, db_user=db_user, db_password=db_password, db_host=db_host, db_port=db_port): DCNL DCSP  DCSP log.info("'{0}' DCSP already DCSP exists DCSP in DCSP '{1}'".format(name, dbname)) DCNL DCSP  DCSP return False DCNL DCSP sub_cmd = 'CREATE DCSP SCHEMA DCSP "{0}"'.format(name) DCNL DCSP if (owner is not None): DCNL DCSP  DCSP sub_cmd = '{0} DCSP AUTHORIZATION DCSP "{1}"'.format(sub_cmd, owner) DCNL DCSP ret = _psql_prepare_and_run(['-c', sub_cmd], user=db_user, password=db_password, port=db_port, host=db_host, maintenance_db=dbname, runas=user) DCNL DCSP return (ret['retcode'] == 0)
def is_valid_connection_id(entry): DCNL  DCSP return is_valid_circuit_id(entry)
def generate_random_str(N): DCNL  DCSP return ''.join((random.SystemRandom().choice((string.ascii_uppercase + string.digits)) for _ in range(N)))
def join_list(delimeter): DCNL  DCSP def join_string_lambda(value): DCNL DCSP  DCSP return delimeter.join(value) DCNL DCSP return join_string_lambda
def get_elliptic_curves(): DCNL  DCSP return _EllipticCurve._get_elliptic_curves(_lib)
def upload_fileobj(self, Fileobj, Bucket, Key, ExtraArgs=None, Callback=None, Config=None): DCNL  DCSP if (not hasattr(Fileobj, 'read')): DCNL DCSP  DCSP raise ValueError('Fileobj DCSP must DCSP implement DCSP read') DCNL DCSP subscribers = None DCNL DCSP if (Callback is not None): DCNL DCSP  DCSP subscribers = [ProgressCallbackInvoker(Callback)] DCNL DCSP config = Config DCNL DCSP if (config is None): DCNL DCSP  DCSP config = TransferConfig() DCNL DCSP with create_transfer_manager(self, config) as manager: DCNL DCSP  DCSP future = manager.upload(fileobj=Fileobj, bucket=Bucket, key=Key, extra_args=ExtraArgs, subscribers=subscribers) DCNL DCSP  DCSP return future.result()
def reset(): DCNL  DCSP _runtime.reset()
def escape4xml(value): DCNL  DCSP if isinstance(value, int): DCNL DCSP  DCSP value = str(value) DCNL DCSP value = _re_amp.sub('&amp;', value) DCNL DCSP value = value.replace('"', '&quot;').replace("'", '&apos;') DCNL DCSP value = value.replace('<', '&lt;').replace('>', '&gt;') DCNL DCSP if isinstance(value, unicode): DCNL DCSP  DCSP value = value.encode('ascii', 'xmlcharrefreplace') DCNL DCSP return value
def make_cgi_application(global_conf, script, path=None, include_os_environ=None, query_string=None): DCNL  DCSP if (path is None): DCNL DCSP  DCSP path = (global_conf.get('path') or global_conf.get('PATH')) DCNL DCSP include_os_environ = converters.asbool(include_os_environ) DCNL DCSP return CGIApplication(None, script, path=path, include_os_environ=include_os_environ, query_string=query_string)
def owner(*paths): DCNL  DCSP return __salt__['lowpkg.owner'](*paths)
def locks(registry, xml_parent, data): DCNL  DCSP locks = data DCNL DCSP if locks: DCNL DCSP  DCSP lw = XML.SubElement(xml_parent, 'hudson.plugins.locksandlatches.LockWrapper') DCNL DCSP  DCSP locktop = XML.SubElement(lw, 'locks') DCNL DCSP  DCSP for lock in locks: DCNL DCSP  DCSP  DCSP lockwrapper = XML.SubElement(locktop, 'hudson.plugins.locksandlatches.LockWrapper_-LockWaitConfig') DCNL DCSP  DCSP  DCSP XML.SubElement(lockwrapper, 'name').text = lock
def entity_to_unicode(match, exceptions=[], encoding='cp1252', result_exceptions={}): DCNL  DCSP def check(ch): DCNL DCSP  DCSP return result_exceptions.get(ch, ch) DCNL DCSP ent = match.group(1) DCNL DCSP if (ent in exceptions): DCNL DCSP  DCSP return (('&' + ent) + ';') DCNL DCSP if (ent in {'apos', 'squot'}): DCNL DCSP  DCSP return check("'") DCNL DCSP if (ent == 'hellips'): DCNL DCSP  DCSP ent = 'hellip' DCNL DCSP if ent.startswith('#'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (ent[1] in ('x', 'X')): DCNL DCSP  DCSP  DCSP  DCSP num = int(ent[2:], 16) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP num = int(ent[1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return (('&' + ent) + ';') DCNL DCSP  DCSP if ((encoding is None) or (num > 255)): DCNL DCSP  DCSP  DCSP return check(my_unichr(num)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return check(chr(num).decode(encoding)) DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP return check(my_unichr(num)) DCNL DCSP from calibre.ebooks.html_entities import html5_entities DCNL DCSP try: DCNL DCSP  DCSP return check(html5_entities[ent]) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP from htmlentitydefs import name2codepoint DCNL DCSP try: DCNL DCSP  DCSP return check(my_unichr(name2codepoint[ent])) DCNL DCSP except KeyError: DCNL DCSP  DCSP return (('&' + ent) + ';')
@debug DCNL @timeit DCNL @cacheit DCNL def limitinf(e, x): DCNL  DCSP e = e.rewrite('tractable', deep=True) DCNL DCSP if (not e.has(x)): DCNL DCSP  DCSP return e DCNL DCSP if e.has(Order): DCNL DCSP  DCSP e = e.expand().removeO() DCNL DCSP if (not x.is_positive): DCNL DCSP  DCSP p = Dummy('p', positive=True, finite=True) DCNL DCSP  DCSP e = e.subs(x, p) DCNL DCSP  DCSP x = p DCNL DCSP (c0, e0) = mrv_leadterm(e, x) DCNL DCSP sig = sign(e0, x) DCNL DCSP if (sig == 1): DCNL DCSP  DCSP return S.Zero DCNL DCSP elif (sig == (-1)): DCNL DCSP  DCSP if c0.match((I * Wild('a', exclude=[I]))): DCNL DCSP  DCSP  DCSP return (c0 * oo) DCNL DCSP  DCSP s = sign(c0, x) DCNL DCSP  DCSP if (s == 0): DCNL DCSP  DCSP  DCSP raise ValueError('Leading DCSP term DCSP should DCSP not DCSP be DCSP 0') DCNL DCSP  DCSP return (s * oo) DCNL DCSP elif (sig == 0): DCNL DCSP  DCSP return limitinf(c0, x)
def connected(perspective): DCNL  DCSP print('got DCSP perspective1 DCSP ref:', perspective) DCNL DCSP print('asking DCSP it DCSP to DCSP foo(13)') DCNL DCSP return perspective.callRemote('foo', 13)
def date_range(start_date, end_date=None, num=None, delta=None): DCNL  DCSP if (not delta): DCNL DCSP  DCSP return [] DCNL DCSP if (end_date and (start_date > end_date)): DCNL DCSP  DCSP raise Exception(u'Wait. DCSP start_date DCSP needs DCSP to DCSP be DCSP before DCSP end_date') DCNL DCSP if (end_date and num): DCNL DCSP  DCSP raise Exception(u'Wait. DCSP Either DCSP specify DCSP end_date DCSP OR DCSP num') DCNL DCSP if ((not end_date) and (not num)): DCNL DCSP  DCSP end_date = datetime.now() DCNL DCSP delta_iscron = False DCNL DCSP if isinstance(delta, six.string_types): DCNL DCSP  DCSP delta_iscron = True DCNL DCSP  DCSP cron = croniter(delta, start_date) DCNL DCSP elif isinstance(delta, timedelta): DCNL DCSP  DCSP delta = abs(delta) DCNL DCSP l = [] DCNL DCSP if end_date: DCNL DCSP  DCSP while (start_date <= end_date): DCNL DCSP  DCSP  DCSP l.append(start_date) DCNL DCSP  DCSP  DCSP if delta_iscron: DCNL DCSP  DCSP  DCSP  DCSP start_date = cron.get_next(datetime) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start_date += delta DCNL DCSP else: DCNL DCSP  DCSP for i in range(abs(num)): DCNL DCSP  DCSP  DCSP l.append(start_date) DCNL DCSP  DCSP  DCSP if delta_iscron: DCNL DCSP  DCSP  DCSP  DCSP if (num > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_date = cron.get_next(datetime) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_date = cron.get_prev(datetime) DCNL DCSP  DCSP  DCSP elif (num > 0): DCNL DCSP  DCSP  DCSP  DCSP start_date += delta DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start_date -= delta DCNL DCSP return sorted(l)
def set_default_etree(etree): DCNL  DCSP from pyamf import xml DCNL DCSP return xml.set_default_interface(etree)
def create_pull_queue_tables(cluster, session): DCNL  DCSP logger.info('Trying DCSP to DCSP create DCSP pull_queue_tasks') DCNL DCSP create_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_queue_tasks DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP queue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payload DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP enqueued DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lease_expires DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retry_count DCSP int,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP queue, DCSP id))\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimedOut: DCNL DCSP  DCSP logger.warning('Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_queue_tasks. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_queue_tasks_index') DCNL DCSP create_index_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_queue_tasks_index DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP queue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP eta DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag_exists DCSP boolean,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP queue, DCSP eta), DCSP id)\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_index_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimedOut: DCNL DCSP  DCSP logger.warning('Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_queue_tasks_index. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_queue_tags DCSP index') DCNL DCSP create_index = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull_queue_tags DCSP ON DCSP pull_queue_tasks_index DCSP (tag);\n DCSP  DCSP ' DCNL DCSP session.execute(create_index) DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_queue_tag_exists DCSP index') DCNL DCSP create_index = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull_queue_tag_exists\n DCSP  DCSP  DCSP  DCSP ON DCSP pull_queue_tasks_index DCSP (tag_exists);\n DCSP  DCSP ' DCNL DCSP session.execute(create_index) DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_queue_leases') DCNL DCSP create_leases_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_queue_leases DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP queue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP leased DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP queue, DCSP leased))\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_leases_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimedOut: DCNL DCSP  DCSP logger.warning('Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_queue_leases. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise
def find_it(): DCNL  DCSP with RopeContext() as ctx: DCNL DCSP  DCSP (_, offset) = env.get_offset_params() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP occurrences = findit.find_occurrences(ctx.project, ctx.resource, offset) DCNL DCSP  DCSP except exceptions.BadIdentifierError: DCNL DCSP  DCSP  DCSP occurrences = [] DCNL DCSP lst = [] DCNL DCSP for oc in occurrences: DCNL DCSP  DCSP lst.append(dict(filename=oc.resource.path, text=(env.lines[(oc.lineno - 1)] if (oc.resource.real_path == env.curbuf.name) else ''), lnum=oc.lineno)) DCNL DCSP env.let('loclist._loclist', lst)
def inroot_notwritable(prefix): DCNL  DCSP return (abspath(prefix).startswith(context.root_dir) and (not context.root_writable))
def find_tables(clause, check_columns=False, include_aliases=False, include_joins=False, include_selects=False, include_crud=False): DCNL  DCSP tables = [] DCNL DCSP _visitors = {} DCNL DCSP if include_selects: DCNL DCSP  DCSP _visitors['select'] = _visitors['compound_select'] = tables.append DCNL DCSP if include_joins: DCNL DCSP  DCSP _visitors['join'] = tables.append DCNL DCSP if include_aliases: DCNL DCSP  DCSP _visitors['alias'] = tables.append DCNL DCSP if include_crud: DCNL DCSP  DCSP _visitors['insert'] = _visitors['update'] = _visitors['delete'] = (lambda ent: tables.append(ent.table)) DCNL DCSP if check_columns: DCNL DCSP  DCSP def visit_column(column): DCNL DCSP  DCSP  DCSP tables.append(column.table) DCNL DCSP  DCSP _visitors['column'] = visit_column DCNL DCSP _visitors['table'] = tables.append DCNL DCSP visitors.traverse(clause, {'column_collections': False}, _visitors) DCNL DCSP return tables
def p_additive_expression_1(t): DCNL  DCSP pass
def _skip_bytes(f, n): DCNL  DCSP f.read(n) DCNL DCSP return
def locate(path, forceload=0): DCNL  DCSP parts = [part for part in split(path, '.') if part] DCNL DCSP (module, n) = (None, 0) DCNL DCSP while (n < len(parts)): DCNL DCSP  DCSP nextmodule = safeimport(join(parts[:(n + 1)], '.'), forceload) DCNL DCSP  DCSP if nextmodule: DCNL DCSP  DCSP  DCSP (module, n) = (nextmodule, (n + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if module: DCNL DCSP  DCSP object = module DCNL DCSP else: DCNL DCSP  DCSP object = __builtin__ DCNL DCSP for part in parts[n:]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP object = getattr(object, part) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return object
def get_benchmark_returns(symbol, start_date, end_date): DCNL  DCSP return pd.read_csv(format_yahoo_index_url(symbol, start_date, end_date), parse_dates=['Date'], index_col='Date', usecols=['Adj DCSP Close', 'Date'], squeeze=True).sort_index().tz_localize('UTC').pct_change(1).iloc[1:]
def cheby2(N, rs, Wn, btype='low', analog=False, output='ba'): DCNL  DCSP return iirfilter(N, Wn, rs=rs, btype=btype, analog=analog, output=output, ftype='cheby2')
def pick_disk_driver_name(hypervisor_version, is_block_dev=False): DCNL  DCSP if (CONF.libvirt.virt_type == 'xen'): DCNL DCSP  DCSP if is_block_dev: DCNL DCSP  DCSP  DCSP return 'phy' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (hypervisor_version >= 4002000): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP execute('xend', 'status', run_as_root=True, check_exit_code=True) DCNL DCSP  DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug('xend DCSP is DCSP not DCSP found') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'qemu' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP except processutils.ProcessExecutionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug('xend DCSP is DCSP not DCSP started') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'qemu' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (out, err) = execute('tap-ctl', 'check', check_exit_code=False) DCNL DCSP  DCSP  DCSP  DCSP if (out == 'ok\n'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hypervisor_version > 4000000): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'tap2' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'tap' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.info(_LI('tap-ctl DCSP check: DCSP %s'), out) DCNL DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug('tap-ctl DCSP tool DCSP is DCSP not DCSP installed') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP return 'file' DCNL DCSP elif (CONF.libvirt.virt_type in ('kvm', 'qemu')): DCNL DCSP  DCSP return 'qemu' DCNL DCSP else: DCNL DCSP  DCSP return None
def test_multi_explicit_fail(): DCNL  DCSP group = worker.WalTransferGroup(FakeWalUploader()) DCNL DCSP segments = list(prepare_multi_upload_segments()) DCNL DCSP exp = Explosion('fail') DCNL DCSP segments[0]._upload_explosive = exp DCNL DCSP for seg in segments: DCNL DCSP  DCSP group.start(seg) DCNL DCSP with pytest.raises(Explosion) as e: DCNL DCSP  DCSP group.join() DCNL DCSP assert (e.value is exp) DCNL DCSP assert failed(segments[0]) DCNL DCSP for seg in segments[1:]: DCNL DCSP  DCSP assert success(seg)
def set_value(dictionary, keys, value): DCNL  DCSP if (not keys): DCNL DCSP  DCSP dictionary.update(value) DCNL DCSP  DCSP return DCNL DCSP for key in keys[:(-1)]: DCNL DCSP  DCSP if (key not in dictionary): DCNL DCSP  DCSP  DCSP dictionary[key] = {} DCNL DCSP  DCSP dictionary = dictionary[key] DCNL DCSP dictionary[keys[(-1)]] = value
@require_admin_context DCNL def instance_type_create(context, values): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeExists(name=values['name']) DCNL DCSP  DCSP except exception.InstanceTypeNotFoundByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_flavor_id(context, values['flavorid'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeIdExists(flavor_id=values['flavorid']) DCNL DCSP  DCSP except exception.FlavorNotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP specs = values.get('extra_specs') DCNL DCSP  DCSP  DCSP specs_refs = [] DCNL DCSP  DCSP  DCSP if specs: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in specs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref = models.InstanceTypeExtraSpecs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['key'] = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['value'] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_refs.append(specs_ref) DCNL DCSP  DCSP  DCSP values['extra_specs'] = specs_refs DCNL DCSP  DCSP  DCSP instance_type_ref = models.InstanceTypes() DCNL DCSP  DCSP  DCSP instance_type_ref.update(values) DCNL DCSP  DCSP  DCSP instance_type_ref.save(session=session) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise db_exc.DBError(e) DCNL DCSP  DCSP return _dict_with_extra_specs(instance_type_ref)
@testing.requires_testing_data DCNL def test_sensitivity_maps(): DCNL  DCSP fwd = mne.read_forward_solution(fwd_fname, surf_ori=True) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP warnings.simplefilter('always') DCNL DCSP  DCSP projs = read_proj(eog_fname) DCNL DCSP  DCSP projs.extend(read_proj(ecg_fname)) DCNL DCSP decim = 6 DCNL DCSP for ch_type in ['eeg', 'grad', 'mag']: DCNL DCSP  DCSP w = read_source_estimate((sensmap_fname % (ch_type, 'lh'))).data DCNL DCSP  DCSP stc = sensitivity_map(fwd, projs=None, ch_type=ch_type, mode='free', exclude='bads') DCNL DCSP  DCSP assert_array_almost_equal(stc.data, w, decim) DCNL DCSP  DCSP assert_true((stc.subject == 'sample')) DCNL DCSP  DCSP if (ch_type == 'grad'): DCNL DCSP  DCSP  DCSP w = read_source_estimate((sensmap_fname % (ch_type, '2-lh'))).data DCNL DCSP  DCSP  DCSP stc = sensitivity_map(fwd, projs=None, mode='fixed', ch_type=ch_type, exclude='bads') DCNL DCSP  DCSP  DCSP assert_array_almost_equal(stc.data, w, decim) DCNL DCSP  DCSP if (ch_type == 'mag'): DCNL DCSP  DCSP  DCSP w = read_source_estimate((sensmap_fname % (ch_type, '3-lh'))).data DCNL DCSP  DCSP  DCSP stc = sensitivity_map(fwd, projs=None, mode='ratio', ch_type=ch_type, exclude='bads') DCNL DCSP  DCSP  DCSP assert_array_almost_equal(stc.data, w, decim) DCNL DCSP  DCSP if (ch_type == 'eeg'): DCNL DCSP  DCSP  DCSP modes = ['radiality', 'angle', 'remaining', 'dampening'] DCNL DCSP  DCSP  DCSP ends = ['4-lh', '5-lh', '6-lh', '7-lh'] DCNL DCSP  DCSP  DCSP for (mode, end) in zip(modes, ends): DCNL DCSP  DCSP  DCSP  DCSP w = read_source_estimate((sensmap_fname % (ch_type, end))).data DCNL DCSP  DCSP  DCSP  DCSP stc = sensitivity_map(fwd, projs=projs, mode=mode, ch_type=ch_type, exclude='bads') DCNL DCSP  DCSP  DCSP  DCSP assert_array_almost_equal(stc.data, w, decim) DCNL DCSP stc = sensitivity_map(fwd, projs=[make_eeg_average_ref_proj(fwd['info'])], ch_type='eeg', exclude='bads') DCNL DCSP assert_raises(ValueError, sensitivity_map, fwd, projs=None, mode='angle') DCNL DCSP assert_raises(RuntimeError, sensitivity_map, fwd, projs=[], mode='angle') DCNL DCSP fname = op.join(sample_path, 'sample_audvis_trunc-meg-vol-7-fwd.fif') DCNL DCSP fwd = mne.read_forward_solution(fname) DCNL DCSP sensitivity_map(fwd)
def cmd_log(cmd, cwd): DCNL  DCSP output = subprocess.check_output(cmd, cwd=cwd, stderr=subprocess.STDOUT) DCNL DCSP log.debug('Command DCSP was: DCSP {0!r}. DCSP Working DCSP directory DCSP was: DCSP {1!r}'.format(' DCSP '.join(cmd), cwd)) DCNL DCSP log.debug('Command DCSP output DCSP was: DCSP {0!r}'.format(output)) DCNL DCSP return output
def remove_invalid_options(context, search_options, allowed_search_options): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP for key in ('sort_key', 'sort_dir', 'limit', 'marker'): DCNL DCSP  DCSP  DCSP search_options.pop(key, None) DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP if unknown_options: DCNL DCSP  DCSP LOG.debug("Removing DCSP options DCSP '%s' DCSP from DCSP query", ', DCSP '.join(unknown_options)) DCNL DCSP  DCSP for opt in unknown_options: DCNL DCSP  DCSP  DCSP search_options.pop(opt, None)
def set_date(name, date): DCNL  DCSP cmd = 'chage DCSP -d DCSP {0} DCSP {1}'.format(date, name) DCNL DCSP return (not __salt__['cmd.run'](cmd, python_shell=False))
def get_os_vendor(): DCNL  DCSP logging.warn('utils.get_os_vendor() DCSP is DCSP deprecated, DCSP please DCSP use DCSP autotest.client.shared.distro.detect() DCSP instead') DCNL DCSP vendor = 'Unknown' DCNL DCSP if os.path.isfile('/etc/SuSE-release'): DCNL DCSP  DCSP return 'SUSE' DCNL DCSP issue = '/etc/issue' DCNL DCSP if (not os.path.isfile(issue)): DCNL DCSP  DCSP return vendor DCNL DCSP if file_contains_pattern(issue, 'Red DCSP Hat'): DCNL DCSP  DCSP vendor = 'Red DCSP Hat' DCNL DCSP if file_contains_pattern(issue, 'CentOS'): DCNL DCSP  DCSP vendor = 'Red DCSP Hat' DCNL DCSP elif file_contains_pattern(issue, 'Fedora'): DCNL DCSP  DCSP vendor = 'Fedora' DCNL DCSP elif file_contains_pattern(issue, 'SUSE'): DCNL DCSP  DCSP vendor = 'SUSE' DCNL DCSP elif file_contains_pattern(issue, 'Ubuntu'): DCNL DCSP  DCSP vendor = 'Ubuntu' DCNL DCSP elif file_contains_pattern(issue, 'Debian'): DCNL DCSP  DCSP vendor = 'Debian' DCNL DCSP logging.debug('Detected DCSP OS DCSP vendor: DCSP %s', vendor) DCNL DCSP return vendor
def ljust(value, arg): DCNL  DCSP return value.ljust(int(arg))
def get_image_label(name, default='not_found.png'): DCNL  DCSP label = QLabel() DCNL DCSP label.setPixmap(QPixmap(get_image_path(name, default))) DCNL DCSP return label
def path_to_local_track_uri(relpath): DCNL  DCSP if isinstance(relpath, compat.text_type): DCNL DCSP  DCSP relpath = relpath.encode(u'utf-8') DCNL DCSP return (u'local:track:%s' % urllib.quote(relpath))
def flatten_const_node_list(environment, node_list): DCNL  DCSP output = [] DCNL DCSP eval_ctx = EvalContext(environment) DCNL DCSP for node in node_list: DCNL DCSP  DCSP if isinstance(node, Output): DCNL DCSP  DCSP  DCSP for node in node.nodes: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP const = node.as_const(eval_ctx=eval_ctx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(const, six.text_type)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Unflattenable(const) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output.append(const) DCNL DCSP  DCSP  DCSP  DCSP except Impossible: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Unflattenable(node) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Unflattenable(node) DCNL DCSP return u''.join(output)
@contextmanager DCNL @deprecated(u'1.4.0', _deprecation_msg) DCNL def subsystem_instance(subsystem_type, scope=None, **options): DCNL  DCSP if (not issubclass(subsystem_type, Subsystem)): DCNL DCSP  DCSP raise TypeError(u'The DCSP given DCSP `subsystem_type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Subsystem`: DCSP {}'.format(subsystem_type)) DCNL DCSP optionables = Subsystem.closure([subsystem_type]) DCNL DCSP updated_options = (dict(Subsystem._options.items()) if Subsystem._options else {}) DCNL DCSP if options: DCNL DCSP  DCSP updated_options.update(options) DCNL DCSP Subsystem._options = create_options_for_optionables(optionables, options=updated_options) DCNL DCSP try: DCNL DCSP  DCSP if (scope is None): DCNL DCSP  DCSP  DCSP (yield subsystem_type.global_instance()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP class ScopedOptionable(Optionable, ): DCNL DCSP  DCSP  DCSP  DCSP options_scope = scope DCNL DCSP  DCSP  DCSP  DCSP options_scope_category = ScopeInfo.SUBSYSTEM DCNL DCSP  DCSP  DCSP (yield subsystem_type.scoped_instance(ScopedOptionable)) DCNL DCSP finally: DCNL DCSP  DCSP Subsystem.reset()
def count(s, *args): DCNL  DCSP return s.count(*args)
@command(('rmp\\s*(\\d+|%s)' % WORD)) DCNL def playlist_remove(name): DCNL  DCSP if (name.isdigit() or g.userpl.get(name)): DCNL DCSP  DCSP if name.isdigit(): DCNL DCSP  DCSP  DCSP name = (int(name) - 1) DCNL DCSP  DCSP  DCSP name = sorted(g.userpl)[name] DCNL DCSP  DCSP del g.userpl[name] DCNL DCSP  DCSP g.message = ('Deleted DCSP playlist DCSP %s%s%s' % (c.y, name, c.w)) DCNL DCSP  DCSP g.content = content.playlists_display() DCNL DCSP  DCSP playlists.save() DCNL DCSP else: DCNL DCSP  DCSP g.message = (util.F('pl DCSP not DCSP found DCSP advise DCSP ls') % name) DCNL DCSP  DCSP g.content = content.playlists_display()
def set_present(name, set_type, family='ipv4', **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP set_check = __salt__['ipset.check_set'](name) DCNL DCSP if (set_check is True): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP already DCSP exists DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP would DCSP be DCSP added DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP command = __salt__['ipset.new_set'](name, set_type, family, **kwargs) DCNL DCSP if (command is True): DCNL DCSP  DCSP ret['changes'] = {'locale': name} DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP created DCSP successfully DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP set DCSP {0} DCSP for DCSP {2}: DCSP {1}'.format(name, command.strip(), family) DCNL DCSP  DCSP return ret
@must_be_valid_project DCNL @must_have_permission(ADMIN) DCNL @must_not_be_registration DCNL def project_contributors_post(auth, node, **kwargs): DCNL  DCSP user_dicts = request.json.get('users') DCNL DCSP node_ids = request.json.get('node_ids') DCNL DCSP if (node._id in node_ids): DCNL DCSP  DCSP node_ids.remove(node._id) DCNL DCSP if ((user_dicts is None) or (node_ids is None)): DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST) DCNL DCSP try: DCNL DCSP  DCSP contribs = deserialize_contributors(node, user_dicts, auth=auth, validate=True) DCNL DCSP except ValidationError as e: DCNL DCSP  DCSP return ({'status': 400, 'message': e.message}, 400) DCNL DCSP try: DCNL DCSP  DCSP node.add_contributors(contributors=contribs, auth=auth) DCNL DCSP except NodeStateError as e: DCNL DCSP  DCSP return ({'status': 400, 'message': e.args[0]}, 400) DCNL DCSP node.save() DCNL DCSP unreg_contributor_added.disconnect(finalize_invitation) DCNL DCSP for child_id in node_ids: DCNL DCSP  DCSP child = Node.load(child_id) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP child_contribs = deserialize_contributors(child, user_dicts, auth=auth, validate=True) DCNL DCSP  DCSP except ValidationError as e: DCNL DCSP  DCSP  DCSP return ({'status': 400, 'message': e.message}, 400) DCNL DCSP  DCSP child.add_contributors(contributors=child_contribs, auth=auth) DCNL DCSP  DCSP child.save() DCNL DCSP unreg_contributor_added.connect(finalize_invitation) DCNL DCSP return ({'status': 'success', 'contributors': profile_utils.serialize_contributors(node.visible_contributors, node=node)}, 201)
def findController(controllers=DefaultControllers): DCNL  DCSP for controller in controllers: DCNL DCSP  DCSP if controller.isAvailable(): DCNL DCSP  DCSP  DCSP return controller
def port_create_vxlan(br, port, id, remote, dst_port=None): DCNL  DCSP dst_port = ((' DCSP options:dst_port=' + str(dst_port)) if (0 < dst_port <= 65535) else '') DCNL DCSP if (not (0 <= id < (2 ** 64))): DCNL DCSP  DCSP return False DCNL DCSP elif (not __salt__['dig.check_ip'](remote)): DCNL DCSP  DCSP return False DCNL DCSP elif (not bridge_exists(br)): DCNL DCSP  DCSP return False DCNL DCSP elif (port in port_list(br)): DCNL DCSP  DCSP cmd = 'ovs-vsctl DCSP set DCSP interface DCSP {0} DCSP type=vxlan DCSP options:remote_ip={1} DCSP options:key={2}{3}'.format(port, remote, id, dst_port) DCNL DCSP  DCSP result = __salt__['cmd.run_all'](cmd) DCNL DCSP  DCSP return _retcode_to_bool(result['retcode']) DCNL DCSP else: DCNL DCSP  DCSP cmd = 'ovs-vsctl DCSP add-port DCSP {0} DCSP {1} DCSP -- DCSP set DCSP interface DCSP {1} DCSP type=vxlan DCSP options:remote_ip={2} DCSP options:key={3}{4}'.format(br, port, remote, id, dst_port) DCNL DCSP  DCSP result = __salt__['cmd.run_all'](cmd) DCNL DCSP  DCSP return _retcode_to_bool(result['retcode'])
def setup_redis(): DCNL  DCSP pools = {} DCNL DCSP for (name, config) in settings.STREAM_REDIS_CONFIG.items(): DCNL DCSP  DCSP pool = redis.ConnectionPool(host=config['host'], port=config['port'], password=config.get('password'), db=config['db'], decode_responses=True) DCNL DCSP  DCSP pools[name] = pool DCNL DCSP return pools
def log_methods_calls(fname, some_class, prefix=None): DCNL  DCSP open(fname, 'a').close() DCNL DCSP FILENAME = fname DCNL DCSP CLASS = some_class DCNL DCSP PREFIX = '--[ DCSP %(asked)s DCSP / DCSP %(called)s DCSP / DCSP %(defined)s DCSP ]--' DCNL DCSP if (prefix != None): DCNL DCSP  DCSP PREFIX = prefix DCNL DCSP MAXWIDTH = {'o_O': 10} DCNL DCSP def format_prefix(method, methodobj): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --[ DCSP ShellBase DCSP / DCSP Internal DCSP / DCSP BaseEdit DCSP ]------- DCSP get_position\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP classnames = {'asked': CLASS.__name__, 'called': methodobj.__class__.__name__, 'defined': get_class_that_defined(method)} DCNL DCSP  DCSP line = (PREFIX % classnames) DCNL DCSP  DCSP MAXWIDTH['o_O'] = max(len(line), MAXWIDTH['o_O']) DCNL DCSP  DCSP return line.ljust(MAXWIDTH['o_O'], '-') DCNL DCSP import types DCNL DCSP def __getattribute__(self, name): DCNL DCSP  DCSP attr = object.__getattribute__(self, name) DCNL DCSP  DCSP if (type(attr) is not types.MethodType): DCNL DCSP  DCSP  DCSP return attr DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def newfunc(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP log = open(FILENAME, 'a') DCNL DCSP  DCSP  DCSP  DCSP prefix = format_prefix(attr, self) DCNL DCSP  DCSP  DCSP  DCSP log.write(('%s DCSP %s\n' % (prefix, name))) DCNL DCSP  DCSP  DCSP  DCSP log.close() DCNL DCSP  DCSP  DCSP  DCSP result = attr(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP return newfunc DCNL DCSP some_class.__getattribute__ = __getattribute__
@hook.command('octopart', 'octo') DCNL def octopart(text, reply): DCNL  DCSP if (not api_key): DCNL DCSP  DCSP return 'Octopart DCSP API DCSP key DCSP required.' DCNL DCSP params = {'apikey': api_key, 'q': text, 'start': 0, 'limit': 1} DCNL DCSP try: DCNL DCSP  DCSP request = requests.get(API_URL, params=params) DCNL DCSP  DCSP request.raise_for_status() DCNL DCSP except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP return 'Could DCSP not DCSP fetch DCSP part DCSP data: DCSP {}'.format(e) DCNL DCSP response = request.json() DCNL DCSP if (not response['results']): DCNL DCSP  DCSP return 'No DCSP results.' DCNL DCSP results = response['results'] DCNL DCSP for result in results: DCNL DCSP  DCSP part = result['item'] DCNL DCSP  DCSP reply('{} DCSP - DCSP {} DCSP - DCSP {}'.format(part['brand']['name'], part['mpn'], part['octopart_url']))
def create_config_file(watch, start_cmd, stop_cmd, ports, env_vars={}, max_memory=500, syslog_server='', host=None, upgrade_flag=False, match_cmd=''): DCNL  DCSP if (not isinstance(watch, str)): DCNL DCSP  DCSP raise TypeError('Expected DCSP str') DCNL DCSP if (not isinstance(start_cmd, str)): DCNL DCSP  DCSP raise TypeError('Expected DCSP str') DCNL DCSP if (not isinstance(stop_cmd, str)): DCNL DCSP  DCSP raise TypeError('Expected DCSP str') DCNL DCSP if (not isinstance(ports, list)): DCNL DCSP  DCSP raise TypeError('Expected DCSP list') DCNL DCSP if (not isinstance(env_vars, dict)): DCNL DCSP  DCSP raise TypeError('Expected DCSP dict') DCNL DCSP env = '' DCNL DCSP for ii in env_vars: DCNL DCSP  DCSP env += (((('export DCSP ' + str(ii)) + '="') + str(env_vars[ii])) + '" DCSP && DCSP ') DCNL DCSP for (index, ii) in enumerate(ports): DCNL DCSP  DCSP ports[index] = str(ii) DCNL DCSP template = '' DCNL DCSP if (not match_cmd): DCNL DCSP  DCSP match_cmd = start_cmd DCNL DCSP if upgrade_flag: DCNL DCSP  DCSP max_memory = 0 DCNL DCSP for port in ports: DCNL DCSP  DCSP if syslog_server: DCNL DCSP  DCSP  DCSP template = file_io.read(TEMPLATE_LOCATION_SYSLOG) DCNL DCSP  DCSP  DCSP template = template.format(watch=watch, start=start_cmd, stop=stop_cmd, port=port, env=env, syslog_server=syslog_server, match=match_cmd) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP template = file_io.read(TEMPLATE_LOCATION) DCNL DCSP  DCSP  DCSP template = template.format(watch=watch, start=start_cmd, stop=stop_cmd, port=port, match=match_cmd, env=env) DCNL DCSP  DCSP if (max_memory > 0): DCNL DCSP  DCSP  DCSP template += ' DCSP  DCSP if DCSP totalmem DCSP > DCSP {} DCSP MB DCSP for DCSP 10 DCSP cycles DCSP then DCSP restart\n'.format(max_memory) DCNL DCSP  DCSP if host: DCNL DCSP  DCSP  DCSP template += ' DCSP  DCSP if DCSP failed DCSP host DCSP {} DCSP port DCSP {} DCSP then DCSP restart\n'.format(host, port) DCNL DCSP  DCSP config_file = '{}/appscale-{}-{}.cfg'.format(MONIT_CONFIG_DIR, watch, port) DCNL DCSP  DCSP file_io.write(config_file, template) DCNL DCSP return
def save_categories(shop, categories_pk): DCNL  DCSP configuration.set(shop, SAMPLE_CATEGORIES_KEY, categories_pk)
def proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto', debug=False): DCNL  DCSP request = cherrypy.serving.request DCNL DCSP if scheme: DCNL DCSP  DCSP s = request.headers.get(scheme, None) DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP scheme DCSP %r:%r' % (scheme, s)), 'TOOLS.PROXY') DCNL DCSP  DCSP if ((s == 'on') and ('ssl' in scheme.lower())): DCNL DCSP  DCSP  DCSP scheme = 'https' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scheme = s DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = request.base[:request.base.find('://')] DCNL DCSP if local: DCNL DCSP  DCSP lbase = request.headers.get(local, None) DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP local DCSP %r:%r' % (local, lbase)), 'TOOLS.PROXY') DCNL DCSP  DCSP if (lbase is not None): DCNL DCSP  DCSP  DCSP base = lbase.split(',')[0] DCNL DCSP if (not base): DCNL DCSP  DCSP port = request.local.port DCNL DCSP  DCSP if (port == 80): DCNL DCSP  DCSP  DCSP base = '127.0.0.1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base = ('127.0.0.1:%s' % port) DCNL DCSP if (base.find('://') == (-1)): DCNL DCSP  DCSP base = ((scheme + '://') + base) DCNL DCSP request.base = base DCNL DCSP if remote: DCNL DCSP  DCSP xff = request.headers.get(remote) DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP remote DCSP %r:%r' % (remote, xff)), 'TOOLS.PROXY') DCNL DCSP  DCSP if xff: DCNL DCSP  DCSP  DCSP if (remote == 'X-Forwarded-For'): DCNL DCSP  DCSP  DCSP  DCSP xff = xff.split(',')[(-1)].strip() DCNL DCSP  DCSP  DCSP request.remote.ip = xff
def _strips(direction, text, remove): DCNL  DCSP if (direction == 'l'): DCNL DCSP  DCSP if text.startswith(remove): DCNL DCSP  DCSP  DCSP return text[len(remove):] DCNL DCSP elif (direction == 'r'): DCNL DCSP  DCSP if text.endswith(remove): DCNL DCSP  DCSP  DCSP return text[:(- len(remove))] DCNL DCSP else: DCNL DCSP  DCSP raise WrongDirection, 'Needs DCSP to DCSP be DCSP r DCSP or DCSP l.' DCNL DCSP return text
def setAttributeDictionaryByArguments(argumentNames, arguments, xmlElement): DCNL  DCSP for (argumentIndex, argument) in enumerate(arguments): DCNL DCSP  DCSP xmlElement.attributeDictionary[argumentNames[argumentIndex]] = argument
def expand_dimension_links(metadata): DCNL  DCSP links = [] DCNL DCSP for link in metadata: DCNL DCSP  DCSP if isinstance(link, compat.string_type): DCNL DCSP  DCSP  DCSP link = {'name': link} DCNL DCSP  DCSP elif ('name' not in link): DCNL DCSP  DCSP  DCSP raise ModelError('Dimension DCSP link DCSP has DCSP no DCSP name') DCNL DCSP  DCSP links.append(link) DCNL DCSP return links
@register.inclusion_tag(u'generic/includes/comment.html', takes_context=True) DCNL def comment_thread(context, parent): DCNL  DCSP if (u'all_comments' not in context): DCNL DCSP  DCSP comments = defaultdict(list) DCNL DCSP  DCSP if ((u'request' in context) and context[u'request'].user.is_staff): DCNL DCSP  DCSP  DCSP comments_queryset = parent.comments.all() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP comments_queryset = parent.comments.visible() DCNL DCSP  DCSP for comment in comments_queryset.select_related(u'user'): DCNL DCSP  DCSP  DCSP comments[comment.replied_to_id].append(comment) DCNL DCSP  DCSP context[u'all_comments'] = comments DCNL DCSP parent_id = (parent.id if isinstance(parent, ThreadedComment) else None) DCNL DCSP try: DCNL DCSP  DCSP replied_to = int(context[u'request'].POST[u'replied_to']) DCNL DCSP except KeyError: DCNL DCSP  DCSP replied_to = 0 DCNL DCSP context.update({u'comments_for_thread': context[u'all_comments'].get(parent_id, []), u'no_comments': ((parent_id is None) and (not context[u'all_comments'])), u'replied_to': replied_to}) DCNL DCSP return context
def listify_value(arg, split=None): DCNL  DCSP out = [] DCNL DCSP if (not isinstance(arg, (list, tuple))): DCNL DCSP  DCSP arg = [arg] DCNL DCSP for val in arg: DCNL DCSP  DCSP if (val is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(val, (list, tuple)): DCNL DCSP  DCSP  DCSP out.extend(listify_value(val, split=split)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP out.extend((s.strip() for s in text_type(val).split(split))) DCNL DCSP assert all((isinstance(val, string_types) for val in out)) DCNL DCSP return out
def temp_fail_retry(error, fun, *args): DCNL  DCSP while 1: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return fun(*args) DCNL DCSP  DCSP except error as e: DCNL DCSP  DCSP  DCSP eintr = (errno.WSAEINTR if (os.name == 'nt') else errno.EINTR) DCNL DCSP  DCSP  DCSP if (e.args[0] == eintr): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise
def paginated(model, query=None, increment=200, each=True): DCNL  DCSP queryset = model.find(query) DCNL DCSP paginator = Paginator(queryset.all(), increment) DCNL DCSP for page_num in paginator.page_range: DCNL DCSP  DCSP page = paginator.page(page_num) DCNL DCSP  DCSP if each: DCNL DCSP  DCSP  DCSP for item in page.object_list: DCNL DCSP  DCSP  DCSP  DCSP (yield item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield page.object_list)
def power_divergence(f_obs, f_exp=None, ddof=0, axis=0, lambda_=None): DCNL  DCSP if isinstance(lambda_, string_types): DCNL DCSP  DCSP if (lambda_ not in _power_div_lambda_names): DCNL DCSP  DCSP  DCSP names = repr(list(_power_div_lambda_names.keys()))[1:(-1)] DCNL DCSP  DCSP  DCSP raise ValueError('invalid DCSP string DCSP for DCSP lambda_: DCSP {0!r}. DCSP  DCSP Valid DCSP strings DCSP are DCSP {1}'.format(lambda_, names)) DCNL DCSP  DCSP lambda_ = _power_div_lambda_names[lambda_] DCNL DCSP elif (lambda_ is None): DCNL DCSP  DCSP lambda_ = 1 DCNL DCSP f_obs = np.asanyarray(f_obs) DCNL DCSP if (f_exp is not None): DCNL DCSP  DCSP f_exp = np.atleast_1d(np.asanyarray(f_exp)) DCNL DCSP else: DCNL DCSP  DCSP with np.errstate(invalid='ignore'): DCNL DCSP  DCSP  DCSP f_exp = np.atleast_1d(f_obs.mean(axis=axis)) DCNL DCSP  DCSP if (axis is not None): DCNL DCSP  DCSP  DCSP reduced_shape = list(f_obs.shape) DCNL DCSP  DCSP  DCSP reduced_shape[axis] = 1 DCNL DCSP  DCSP  DCSP f_exp.shape = reduced_shape DCNL DCSP if (lambda_ == 1): DCNL DCSP  DCSP terms = (((f_obs - f_exp) ** 2) / f_exp) DCNL DCSP elif (lambda_ == 0): DCNL DCSP  DCSP terms = (2.0 * special.xlogy(f_obs, (f_obs / f_exp))) DCNL DCSP elif (lambda_ == (-1)): DCNL DCSP  DCSP terms = (2.0 * special.xlogy(f_exp, (f_exp / f_obs))) DCNL DCSP else: DCNL DCSP  DCSP terms = (f_obs * (((f_obs / f_exp) ** lambda_) - 1)) DCNL DCSP  DCSP terms /= ((0.5 * lambda_) * (lambda_ + 1)) DCNL DCSP stat = terms.sum(axis=axis) DCNL DCSP num_obs = _count(terms, axis=axis) DCNL DCSP ddof = asarray(ddof) DCNL DCSP p = distributions.chi2.sf(stat, ((num_obs - 1) - ddof)) DCNL DCSP return Power_divergenceResult(stat, p)
def get_version(): DCNL  DCSP return '.'.join(map(str, VERSION))
def to_dict(sequences, key_function=None): DCNL  DCSP if (key_function is None): DCNL DCSP  DCSP key_function = (lambda rec: rec.id) DCNL DCSP d = dict() DCNL DCSP for record in sequences: DCNL DCSP  DCSP key = key_function(record) DCNL DCSP  DCSP if (key in d): DCNL DCSP  DCSP  DCSP raise ValueError(("Duplicate DCSP key DCSP '%s'" % key)) DCNL DCSP  DCSP d[key] = record DCNL DCSP return d
def get_best_language(accept_lang): DCNL  DCSP ranked = parse_accept_lang_header(accept_lang) DCNL DCSP return find_supported(ranked)
def certificate(): DCNL  DCSP mode = session.s3.hrm.mode DCNL DCSP def prep(r): DCNL DCSP  DCSP if (mode is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if (settings.get_hrm_filter_certificates() and (not auth.s3_has_role(ADMIN))): DCNL DCSP  DCSP s3.filter = auth.filter_by_root_org(s3db.hrm_certificate) DCNL DCSP output = s3_rest_controller(rheader=s3db.hrm_rheader) DCNL DCSP return output
def diff(*paths): DCNL  DCSP ret = {} DCNL DCSP pkg_to_paths = {} DCNL DCSP for pth in paths: DCNL DCSP  DCSP pth_pkg = __salt__['lowpkg.owner'](pth) DCNL DCSP  DCSP if (not pth_pkg): DCNL DCSP  DCSP  DCSP ret[pth] = ((os.path.exists(pth) and 'Not DCSP managed') or 'N/A') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (pkg_to_paths.get(pth_pkg) is None): DCNL DCSP  DCSP  DCSP  DCSP pkg_to_paths[pth_pkg] = [] DCNL DCSP  DCSP  DCSP pkg_to_paths[pth_pkg].append(pth) DCNL DCSP if pkg_to_paths: DCNL DCSP  DCSP local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys()) DCNL DCSP  DCSP for (pkg, files) in pkg_to_paths.items(): DCNL DCSP  DCSP  DCSP for path in files: DCNL DCSP  DCSP  DCSP  DCSP ret[path] = (__salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged') DCNL DCSP return ret
def base64_decode(input, errors='strict'): DCNL  DCSP assert (errors == 'strict') DCNL DCSP output = base64.decodestring(input) DCNL DCSP return (output, len(input))
def metric_cleanup(): DCNL  DCSP client.close()
def search(request): DCNL  DCSP md5 = request.GET['md5'] DCNL DCSP if re.match('[0-9a-f]{32}', md5): DCNL DCSP  DCSP db_obj = RecentScansDB.objects.filter(MD5=md5) DCNL DCSP  DCSP if db_obj.exists(): DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(('/' + db_obj[0].URL)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect('/not_found') DCNL DCSP return HttpResponseRedirect('/error/')
def initialize(): DCNL  DCSP global CONFIG DCNL DCSP CONFIG = Configuration() DCNL DCSP parse_config()
def shlex_quote(s): DCNL  DCSP if (not s): DCNL DCSP  DCSP return "''" DCNL DCSP if (_find_unsafe(s) is None): DCNL DCSP  DCSP return s DCNL DCSP return (("'" + s.replace("'", '\'"\'"\'')) + "'")
def simple_norm(data, stretch='linear', power=1.0, asinh_a=0.1, min_cut=None, max_cut=None, min_percent=None, max_percent=None, percent=None, clip=True): DCNL  DCSP if (percent is not None): DCNL DCSP  DCSP interval = PercentileInterval(percent) DCNL DCSP elif ((min_percent is not None) or (max_percent is not None)): DCNL DCSP  DCSP interval = AsymmetricPercentileInterval((min_percent or 0.0), (max_percent or 100.0)) DCNL DCSP elif ((min_cut is not None) or (max_cut is not None)): DCNL DCSP  DCSP interval = ManualInterval(min_cut, max_cut) DCNL DCSP else: DCNL DCSP  DCSP interval = MinMaxInterval() DCNL DCSP if (stretch == 'linear'): DCNL DCSP  DCSP stretch = LinearStretch() DCNL DCSP elif (stretch == 'sqrt'): DCNL DCSP  DCSP stretch = SqrtStretch() DCNL DCSP elif (stretch == 'power'): DCNL DCSP  DCSP stretch = PowerStretch(power) DCNL DCSP elif (stretch == 'log'): DCNL DCSP  DCSP stretch = LogStretch() DCNL DCSP elif (stretch == 'asinh'): DCNL DCSP  DCSP stretch = AsinhStretch(asinh_a) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unknown DCSP stretch: DCSP {0}.'.format(stretch)) DCNL DCSP (vmin, vmax) = interval.get_limits(data) DCNL DCSP return ImageNormalize(vmin=vmin, vmax=vmax, stretch=stretch, clip=clip)
def get_role_permissions(meta, user=None, verbose=False): DCNL  DCSP if (not user): DCNL DCSP  DCSP user = frappe.session.user DCNL DCSP cache_key = (meta.name, user) DCNL DCSP if (not frappe.local.role_permissions.get(cache_key)): DCNL DCSP  DCSP perms = frappe._dict(apply_user_permissions={}, user_permission_doctypes={}, if_owner={}) DCNL DCSP  DCSP user_roles = frappe.get_roles(user) DCNL DCSP  DCSP dont_match = [] DCNL DCSP  DCSP has_a_role_with_apply_user_permissions = False DCNL DCSP  DCSP for p in meta.permissions: DCNL DCSP  DCSP  DCSP if ((cint(p.permlevel) == 0) and (p.role in user_roles)): DCNL DCSP  DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP  DCSP perms[ptype] = (perms.get(ptype, 0) or cint(p.get(ptype))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((ptype != u'set_user_permissions') and p.get(ptype)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'apply_user_permissions'][ptype] = (perms[u'apply_user_permissions'].get(ptype, 1) and p.get(u'apply_user_permissions')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p.if_owner and p.get(ptype)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'if_owner'][ptype] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p.get(ptype) and (not p.if_owner) and (not p.get(u'apply_user_permissions'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dont_match.append(ptype) DCNL DCSP  DCSP  DCSP  DCSP if p.apply_user_permissions: DCNL DCSP  DCSP  DCSP  DCSP  DCSP has_a_role_with_apply_user_permissions = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if p.user_permission_doctypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_permission_doctypes = json.loads(p.user_permission_doctypes) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_permission_doctypes = get_linked_doctypes(meta.name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if user_permission_doctypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if p.get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'user_permission_doctypes'].setdefault(ptype, []).append(user_permission_doctypes) DCNL DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP if (ptype in dont_match): DCNL DCSP  DCSP  DCSP  DCSP if perms[u'apply_user_permissions'].get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del perms[u'apply_user_permissions'][ptype] DCNL DCSP  DCSP  DCSP  DCSP if perms[u'if_owner'].get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del perms[u'if_owner'][ptype] DCNL DCSP  DCSP if has_a_role_with_apply_user_permissions: DCNL DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP if (perms[u'if_owner'].get(ptype) and (perms[u'apply_user_permissions'].get(ptype) == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP perms[u'apply_user_permissions'][ptype] = 1 DCNL DCSP  DCSP for (key, value) in perms.get(u'apply_user_permissions').items(): DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP del perms[u'apply_user_permissions'][key] DCNL DCSP  DCSP frappe.local.role_permissions[cache_key] = perms DCNL DCSP return frappe.local.role_permissions[cache_key]
def evaluation(y_test=None, y_predict=None, n_classes=None): DCNL  DCSP from sklearn.metrics import confusion_matrix, f1_score, accuracy_score DCNL DCSP c_mat = confusion_matrix(y_test, y_predict, labels=[x for x in range(n_classes)]) DCNL DCSP f1 = f1_score(y_test, y_predict, average=None, labels=[x for x in range(n_classes)]) DCNL DCSP f1_macro = f1_score(y_test, y_predict, average='macro') DCNL DCSP acc = accuracy_score(y_test, y_predict) DCNL DCSP print ('confusion DCSP matrix: DCSP \n', c_mat) DCNL DCSP print ('f1-score:', f1) DCNL DCSP print ('f1-score(macro):', f1_macro) DCNL DCSP print ('accuracy-score:', acc) DCNL DCSP return (c_mat, f1, acc, f1_macro)
def auto_fields(resource): DCNL  DCSP resource_def = config.DOMAIN[resource] DCNL DCSP fields = [resource_def['id_field'], config.LAST_UPDATED, config.DATE_CREATED, config.ETAG] DCNL DCSP fields += [config.ISSUES, config.STATUS, config.LINKS] DCNL DCSP if (resource_def['versioning'] is True): DCNL DCSP  DCSP fields.append(config.VERSION) DCNL DCSP  DCSP fields.append(config.LATEST_VERSION) DCNL DCSP  DCSP fields.append((resource_def['id_field'] + config.VERSION_ID_SUFFIX)) DCNL DCSP if (resource_def['soft_delete'] is True): DCNL DCSP  DCSP fields.append(config.DELETED) DCNL DCSP return fields
def use_setuptools(version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=os.curdir): DCNL  DCSP try: DCNL DCSP  DCSP import setuptools DCNL DCSP  DCSP if (setuptools.__version__ == '0.0.1'): DCNL DCSP  DCSP  DCSP print >>sys.stderr, 'You DCSP have DCSP an DCSP obsolete DCSP version DCSP of DCSP setuptools DCSP installed. DCSP  DCSP Please\nremove DCSP it DCSP from DCSP your DCSP system DCSP entirely DCSP before DCSP rerunning DCSP this DCSP script.' DCNL DCSP  DCSP  DCSP sys.exit(2) DCNL DCSP except ImportError: DCNL DCSP  DCSP egg = download_setuptools(version, download_base, to_dir) DCNL DCSP  DCSP sys.path.insert(0, egg) DCNL DCSP  DCSP import setuptools DCNL DCSP  DCSP setuptools.bootstrap_install_from = egg DCNL DCSP import pkg_resources DCNL DCSP try: DCNL DCSP  DCSP pkg_resources.require(('setuptools>=' + version)) DCNL DCSP except pkg_resources.VersionConflict: DCNL DCSP  DCSP print >>sys.stderr, ("The DCSP required DCSP version DCSP of DCSP setuptools DCSP (>=%s) DCSP is DCSP not DCSP available, DCSP and\ncan't DCSP be DCSP installed DCSP while DCSP this DCSP script DCSP is DCSP running. DCSP Please DCSP install\n DCSP a DCSP more DCSP recent DCSP version DCSP first." % version) DCNL DCSP  DCSP sys.exit(2)
def setup(**attrs): DCNL  DCSP global _setup_stop_after, _setup_distribution DCNL DCSP klass = attrs.get('distclass') DCNL DCSP if klass: DCNL DCSP  DCSP del attrs['distclass'] DCNL DCSP else: DCNL DCSP  DCSP klass = Distribution DCNL DCSP if ('script_name' not in attrs): DCNL DCSP  DCSP attrs['script_name'] = os.path.basename(sys.argv[0]) DCNL DCSP if ('script_args' not in attrs): DCNL DCSP  DCSP attrs['script_args'] = sys.argv[1:] DCNL DCSP try: DCNL DCSP  DCSP _setup_distribution = dist = klass(attrs) DCNL DCSP except DistutilsSetupError as msg: DCNL DCSP  DCSP if ('name' not in attrs): DCNL DCSP  DCSP  DCSP raise SystemExit(('error DCSP in DCSP setup DCSP command: DCSP %s' % msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SystemExit(('error DCSP in DCSP %s DCSP setup DCSP command: DCSP %s' % (attrs['name'], msg))) DCNL DCSP if (_setup_stop_after == 'init'): DCNL DCSP  DCSP return dist DCNL DCSP dist.parse_config_files() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'options DCSP (after DCSP parsing DCSP config DCSP files):' DCNL DCSP  DCSP dist.dump_option_dicts() DCNL DCSP if (_setup_stop_after == 'config'): DCNL DCSP  DCSP return dist DCNL DCSP try: DCNL DCSP  DCSP ok = dist.parse_command_line() DCNL DCSP except DistutilsArgError as msg: DCNL DCSP  DCSP raise SystemExit((gen_usage(dist.script_name) + ('\nerror: DCSP %s' % msg))) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'options DCSP (after DCSP parsing DCSP command DCSP line):' DCNL DCSP  DCSP dist.dump_option_dicts() DCNL DCSP if (_setup_stop_after == 'commandline'): DCNL DCSP  DCSP return dist DCNL DCSP if ok: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP dist.run_commands() DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP raise SystemExit('interrupted') DCNL DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP  DCSP sys.stderr.write(('error: DCSP %s\n' % (exc,))) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(('error: DCSP %s' % (exc,))) DCNL DCSP  DCSP except (DistutilsError, CCompilerError) as msg: DCNL DCSP  DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(('error: DCSP ' + str(msg))) DCNL DCSP return dist
def get_messages(request): DCNL  DCSP if hasattr(request, '_messages'): DCNL DCSP  DCSP return request._messages DCNL DCSP def get_user(): DCNL DCSP  DCSP if hasattr(request, 'user'): DCNL DCSP  DCSP  DCSP return request.user DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from django.contrib.auth.models import AnonymousUser DCNL DCSP  DCSP  DCSP return AnonymousUser() DCNL DCSP return lazy(memoize(get_user().get_and_delete_messages, {}, 0), list)()
def __virtual__(): DCNL  DCSP if salt.utils.which('mfsgetgoal'): DCNL DCSP  DCSP return 'moosefs' DCNL DCSP return (False, 'The DCSP moosefs DCSP execution DCSP module DCSP cannot DCSP be DCSP loaded: DCSP the DCSP mfsgetgoal DCSP binary DCSP is DCSP not DCSP in DCSP the DCSP path.')
def document_batch_action(section, resource_name, event_emitter, batch_action_model, service_model, collection_model, include_signature=True): DCNL  DCSP operation_model = service_model.operation_model(batch_action_model.request.operation) DCNL DCSP ignore_params = get_resource_ignore_params(batch_action_model.request.params) DCNL DCSP example_return_value = 'response' DCNL DCSP if batch_action_model.resource: DCNL DCSP  DCSP example_return_value = xform_name(batch_action_model.resource.type) DCNL DCSP example_resource_name = xform_name(resource_name) DCNL DCSP if (service_model.service_name == resource_name): DCNL DCSP  DCSP example_resource_name = resource_name DCNL DCSP example_prefix = ('%s DCSP = DCSP %s.%s.%s' % (example_return_value, example_resource_name, collection_model.name, batch_action_model.name)) DCNL DCSP document_model_driven_resource_method(section=section, method_name=batch_action_model.name, operation_model=operation_model, event_emitter=event_emitter, method_description=operation_model.documentation, example_prefix=example_prefix, exclude_input=ignore_params, resource_action_model=batch_action_model, include_signature=include_signature)
def tuple2str(tagged_token, sep='/'): DCNL  DCSP (word, tag) = tagged_token DCNL DCSP if (tag is None): DCNL DCSP  DCSP return word DCNL DCSP else: DCNL DCSP  DCSP assert (sep not in tag), 'tag DCSP may DCSP not DCSP contain DCSP sep!' DCNL DCSP  DCSP return ('%s%s%s' % (word, sep, tag))
def close_enough(sa, sb): DCNL  DCSP sa = CLOSE_ENOUGH_FIX_RE.sub('', six.text_type(sa)).lower() DCNL DCSP sb = CLOSE_ENOUGH_FIX_RE.sub('', six.text_type(sb)).lower() DCNL DCSP return (sa == sb)
def SynthesizeUserId(email): DCNL  DCSP user_id_digest = _MD5_FUNC(email.lower()).digest() DCNL DCSP user_id = ('1' + ''.join([('%02d' % ord(x)) for x in user_id_digest])[:20]) DCNL DCSP return user_id
def get_cache(): DCNL  DCSP return requests.Session().cache
def set_store(store, key=_store_registry_key, app=None): DCNL  DCSP app = (app or webapp2.get_app()) DCNL DCSP app.registry[key] = store
def get_server_info(request=None): DCNL  DCSP capabilities = _capabilities_defaults.copy() DCNL DCSP capabilities.update(_registered_capabilities) DCNL DCSP return {u'product': {u'name': u'Review DCSP Board', u'version': get_version_string(), u'package_version': get_package_version(), u'is_release': is_release()}, u'site': {u'url': get_server_url(request=request), u'administrators': [{u'name': name, u'email': email} for (name, email) in settings.ADMINS], u'time_zone': settings.TIME_ZONE}, u'capabilities': capabilities}
def holdings_cover_maked_nextbar(data, cover_entries, capital, short_margin, volume_multiple): DCNL  DCSP close_profit = 0 DCNL DCSP equities = [] DCNL DCSP cashes = [] DCNL DCSP dts = [] DCNL DCSP trans_entries = map((lambda x: (x + datetime.timedelta(minutes=1))), cover_entries) DCNL DCSP bprice = None DCNL DCSP prelow = data.low[0] DCNL DCSP for (dt, low) in data.low.iteritems(): DCNL DCSP  DCSP close = data.close[dt] DCNL DCSP  DCSP if (dt.time() == buy1): DCNL DCSP  DCSP  DCSP bprice = (close * (1 - settings['future_commission'])) DCNL DCSP  DCSP elif (bprice and (dt in trans_entries)): DCNL DCSP  DCSP  DCSP close_profit -= ((((prelow - OFFSET) * (1 + settings['future_commission'])) - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP bprice = None DCNL DCSP  DCSP elif ((dt == data.index[(-1)]) or (dt.time() == sell3)): DCNL DCSP  DCSP  DCSP if bprice: DCNL DCSP  DCSP  DCSP  DCSP close_profit -= (((close * (1 + settings['future_commission'])) - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP bprice = None DCNL DCSP  DCSP pos_profit = 0 DCNL DCSP  DCSP posmargin = 0 DCNL DCSP  DCSP if bprice: DCNL DCSP  DCSP  DCSP pos_profit -= ((close - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP posmargin = ((close * volume_multiple) * short_margin) DCNL DCSP  DCSP equities.append(((close_profit + pos_profit) + capital)) DCNL DCSP  DCSP cashes.append((equities[(-1)] - posmargin)) DCNL DCSP  DCSP dts.append(dt) DCNL DCSP  DCSP prelow = low DCNL DCSP return (equities, cashes, dts)
def flatten(x, outdim=1): DCNL  DCSP if ((outdim < 1) or ((outdim > 1) and (outdim > x.ndim))): DCNL DCSP  DCSP raise ValueError(('outdim DCSP %s DCSP out DCSP of DCSP bound DCSP [1, DCSP %d)' % (outdim, (x.ndim + 1)))) DCNL DCSP if (outdim > 1): DCNL DCSP  DCSP dims = (tuple(x.shape[:(outdim - 1)]) + ((-1),)) DCNL DCSP else: DCNL DCSP  DCSP dims = ((-1),) DCNL DCSP x_reshaped = x.reshape(dims) DCNL DCSP bcast_kept_dims = x.broadcastable[:(outdim - 1)] DCNL DCSP bcast_new_dim = python_all(x.broadcastable[(outdim - 1):]) DCNL DCSP broadcastable = (bcast_kept_dims + (bcast_new_dim,)) DCNL DCSP x_reshaped = theano.tensor.addbroadcast(x_reshaped, *filter((lambda i: broadcastable[i]), range(outdim))) DCNL DCSP return x_reshaped
def distros_for_filename(filename, metadata=None): DCNL  DCSP return distros_for_location(normalize_path(filename), os.path.basename(filename), metadata)
def _parseTCP(factory, port, interface='', backlog=50): DCNL  DCSP return ((int(port), factory), {'interface': interface, 'backlog': int(backlog)})
def show_snapshot(kwargs=None, call=None): DCNL  DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP show_snapshot DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if ((not kwargs) or ('name' not in kwargs)): DCNL DCSP  DCSP log.error('Must DCSP specify DCSP name.') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP return _expand_item(conn.ex_get_snapshot(kwargs['name']))
def diff_jid(jid, config='root'): DCNL  DCSP (pre_snapshot, post_snapshot) = _get_jid_snapshots(jid, config=config) DCNL DCSP return diff(config, num_pre=pre_snapshot, num_post=post_snapshot)
def _is_host_full(client, host): DCNL  DCSP luns = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP return (len(luns) >= utils.MAX_LUNS_PER_HOST)
def get_xstatic_dirs(XSTATIC_MODULES, HORIZON_CONFIG): DCNL  DCSP STATICFILES_DIRS = [] DCNL DCSP HORIZON_CONFIG['xstatic_lib_files'] = [] DCNL DCSP for (module_name, files) in XSTATIC_MODULES: DCNL DCSP  DCSP module = import_module(module_name) DCNL DCSP  DCSP if (module_name == 'xstatic.pkg.jquery_ui'): DCNL DCSP  DCSP  DCSP if module.VERSION.startswith('1.10.'): DCNL DCSP  DCSP  DCSP  DCSP files = [('ui/' + files[0])] DCNL DCSP  DCSP STATICFILES_DIRS.append((('horizon/lib/' + module.NAME), module.BASE_DIR)) DCNL DCSP  DCSP if hasattr(module, 'MAIN'): DCNL DCSP  DCSP  DCSP files = module.MAIN DCNL DCSP  DCSP  DCSP if (not isinstance(files, list)): DCNL DCSP  DCSP  DCSP  DCSP files = [files] DCNL DCSP  DCSP  DCSP files = [file for file in files if file.endswith('.js')] DCNL DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP file = ((('horizon/lib/' + module.NAME) + '/') + file) DCNL DCSP  DCSP  DCSP HORIZON_CONFIG['xstatic_lib_files'].append(file) DCNL DCSP return STATICFILES_DIRS
def dict_subset(d, keys): DCNL  DCSP n = dict() DCNL DCSP for key in keys: DCNL DCSP  DCSP if (key in d): DCNL DCSP  DCSP  DCSP n[key] = d[key] DCNL DCSP return n
def Repr(class_instance, ordered_dictionary): DCNL  DCSP return ('search.%s(%s)' % (class_instance.__class__.__name__, ', DCSP '.join([("%s='%s'" % (key, value)) for (key, value) in ordered_dictionary if value])))
def team_absent(name, profile='github', **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP target = __salt__['github.get_team'](name, profile=profile, **kwargs) DCNL DCSP if (not target): DCNL DCSP  DCSP ret['comment'] = 'Team DCSP {0} DCSP does DCSP not DCSP exist'.format(name) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Team DCSP {0} DCSP will DCSP be DCSP deleted'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP result = __salt__['github.remove_team'](name, profile=profile, **kwargs) DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Deleted DCSP team DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('old', 'Team DCSP {0} DCSP exists'.format(name)) DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('new', 'Team DCSP {0} DCSP deleted'.format(name)) DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP delete DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
def count(typename, objects=None): DCNL  DCSP if (objects is None): DCNL DCSP  DCSP objects = gc.get_objects() DCNL DCSP try: DCNL DCSP  DCSP if ('.' in typename): DCNL DCSP  DCSP  DCSP return sum((1 for o in objects if (_long_typename(o) == typename))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sum((1 for o in objects if (_short_typename(o) == typename))) DCNL DCSP finally: DCNL DCSP  DCSP del objects
def _split_symbol_mappings(df): DCNL  DCSP mappings = df[list(mapping_columns)] DCNL DCSP ambigious = {} DCNL DCSP for symbol in mappings.symbol.unique(): DCNL DCSP  DCSP persymbol = mappings[(mappings.symbol == symbol)] DCNL DCSP  DCSP intersections = list(intersecting_ranges(map(from_tuple, zip(persymbol.start_date, persymbol.end_date)))) DCNL DCSP  DCSP if intersections: DCNL DCSP  DCSP  DCSP ambigious[symbol] = (intersections, persymbol[['start_date', 'end_date']].astype('datetime64[ns]')) DCNL DCSP if ambigious: DCNL DCSP  DCSP raise ValueError(('Ambiguous DCSP ownership DCSP for DCSP %d DCSP symbol%s, DCSP multiple DCSP assets DCSP held DCSP the DCSP following DCSP symbols:\n%s' % (len(ambigious), ('' if (len(ambigious) == 1) else 's'), '\n'.join((('%s:\n DCSP  DCSP intersections: DCSP %s\n DCSP  DCSP %s' % (symbol, tuple(map(_format_range, intersections)), '\n DCSP  DCSP '.join(str(df).splitlines()))) for (symbol, (intersections, df)) in sorted(ambigious.items(), key=first)))))) DCNL DCSP return (df.groupby(level=0).apply(_check_asset_group), df[list(mapping_columns)])
def set_cache_under_settings(destination, setting, key_prefix, value, ttl, list_=False): DCNL  DCSP default = ({} if (not list_) else []) DCNL DCSP existing = destination.settings.get(setting, default) DCNL DCSP if value: DCNL DCSP  DCSP if list_: DCNL DCSP  DCSP  DCSP value.extend(existing) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value.update(existing) DCNL DCSP  DCSP set_cache(((key_prefix + '.') + setting), value, ttl) DCNL DCSP  DCSP destination.settings[setting] = value
def _getPlatformString(dist=None): DCNL  DCSP if (dist == 'bdist'): DCNL DCSP  DCSP if (os.sys.platform == 'darwin'): DCNL DCSP  DCSP  DCSP (OSXver, junk, architecture) = platform.mac_ver() DCNL DCSP  DCSP  DCSP systemInfo = ('OSX_%s_%s' % (OSXver, architecture)) DCNL DCSP  DCSP elif (os.sys.platform == 'linux'): DCNL DCSP  DCSP  DCSP systemInfo = ('%s_%s_%s' % ('Linux', ':'.join([x for x in platform.dist() if (x != '')]), platform.release())) DCNL DCSP  DCSP elif (os.sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP ver = os.sys.getwindowsversion() DCNL DCSP  DCSP  DCSP if (len(ver[4]) > 0): DCNL DCSP  DCSP  DCSP  DCSP systemInfo = ('win32_v%i.%i.%i DCSP (%s)' % (ver[0], ver[1], ver[2], ver[4])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP systemInfo = ('win32_v%i.%i.%i' % (ver[0], ver[1], ver[2])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP systemInfo = (platform.system() + platform.release()) DCNL DCSP else: DCNL DCSP  DCSP systemInfo = 'n/a' DCNL DCSP return systemInfo
@snippet DCNL def topic_publish_messages(client, to_delete): DCNL  DCSP TOPIC_NAME = ('topic_publish_messages-%d' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_delete.append(topic) DCNL DCSP topic.publish('This DCSP is DCSP the DCSP message DCSP payload') DCNL DCSP topic.publish('Another DCSP message DCSP payload', extra='EXTRA')
def simulate_head(app, path, **kwargs): DCNL  DCSP return simulate_request(app, 'HEAD', path, **kwargs)
def extract_lsq_problems(): DCNL  DCSP problems = OrderedDict() DCNL DCSP for (name, problem_class) in inspect.getmembers(sys.modules[__name__], inspect.isclass): DCNL DCSP  DCSP if ((name != 'LSQBenchmarkProblem') and issubclass(problem_class, LSQBenchmarkProblem) and hasattr(problem_class, 'INITIAL_GUESSES')): DCNL DCSP  DCSP  DCSP for (i, x0) in enumerate(problem_class.INITIAL_GUESSES): DCNL DCSP  DCSP  DCSP  DCSP if (len(problem_class.INITIAL_GUESSES) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = '{0}_{1}'.format(name, i) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = name DCNL DCSP  DCSP  DCSP  DCSP problems[key_name] = problem_class(x0) DCNL DCSP return problems
def test_cons_correct(): DCNL  DCSP can_compile(u'(cons DCSP a DCSP b)')
def remove_file(source): DCNL  DCSP if os.path.isdir(source): DCNL DCSP  DCSP shutil.rmtree(source) DCNL DCSP elif (os.path.isfile(source) or os.path.islink(source)): DCNL DCSP  DCSP os.remove(source)
def is_operator(element): DCNL  DCSP return (isinstance(element, basestring) and (element in DOMAIN_OPERATORS))
def should_use_rendered(doc, params, html=None): DCNL  DCSP show_raw = (params.get('raw', False) is not False) DCNL DCSP no_macros = (params.get('nomacros', False) is not False) DCNL DCSP force_macros = (params.get('macros', False) is not False) DCNL DCSP is_template = False DCNL DCSP if doc: DCNL DCSP  DCSP is_template = doc.is_template DCNL DCSP  DCSP html = doc.html DCNL DCSP return ((config.KUMASCRIPT_TIMEOUT > 0) and html and (not is_template) and (force_macros or ((not no_macros) and (not show_raw))))
@pytest.mark.parametrize('parallel', [True, False]) DCNL def test_not_enough_cols(parallel, read_csv): DCNL  DCSP text = '\nA,B,C\n1,2,3\n4,5\n6,7,8\n' DCNL DCSP table = read_csv(text, parallel=parallel) DCNL DCSP assert (table['B'][1] is not ma.masked) DCNL DCSP assert (table['C'][1] is ma.masked) DCNL DCSP with pytest.raises(CParserError) as e: DCNL DCSP  DCSP table = FastBasic(delimiter=',').read(text)
@memoize(maxsize=None) DCNL def find(name, namespace=u'celery'): DCNL  DCSP namespace = namespace.lower() DCNL DCSP try: DCNL DCSP  DCSP return searchresult(namespace, name.lower(), NAMESPACES[namespace][name.lower()]) DCNL DCSP except KeyError: DCNL DCSP  DCSP for (ns, opts) in items(NAMESPACES): DCNL DCSP  DCSP  DCSP if (ns.lower() == name.lower()): DCNL DCSP  DCSP  DCSP  DCSP return searchresult(None, ns, opts) DCNL DCSP  DCSP  DCSP elif isinstance(opts, dict): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return searchresult(ns, name.lower(), opts[name.lower()]) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return searchresult(None, name.lower(), DEFAULTS[name.lower()])
def expand_dims(a, axis): DCNL  DCSP shape = a.shape DCNL DCSP if (axis < 0): DCNL DCSP  DCSP axis = ((axis + len(shape)) + 1) DCNL DCSP return a.reshape(((shape[:axis] + (1,)) + shape[axis:]))
def delete_volume(target, stop=True): DCNL  DCSP volinfo = info() DCNL DCSP if (target not in volinfo): DCNL DCSP  DCSP log.error('Cannot DCSP delete DCSP non-existing DCSP volume DCSP {0}'.format(target)) DCNL DCSP  DCSP return False DCNL DCSP running = (volinfo[target]['status'] == '1') DCNL DCSP if ((not stop) and running): DCNL DCSP  DCSP log.error('Volume DCSP {0} DCSP must DCSP be DCSP stopped DCSP before DCSP deletion'.format(target)) DCNL DCSP  DCSP return False DCNL DCSP if running: DCNL DCSP  DCSP if (not stop_volume(target, force=True)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP cmd = 'volume DCSP delete DCSP {0}'.format(target) DCNL DCSP return _gluster(cmd)
def simple_seq(seq): DCNL  DCSP for i in seq: DCNL DCSP  DCSP (yield i)
def tree(node): DCNL  DCSP subtrees = [] DCNL DCSP for arg in node.args: DCNL DCSP  DCSP subtrees.append(tree(arg)) DCNL DCSP s = (print_node(node) + pprint_nodes(subtrees)) DCNL DCSP return s
def join(): DCNL  DCSP signal.signal(signal.SIGINT, handle_sigint) DCNL DCSP signal.pause()
def RunInTransactionCustomRetries(retries, function, *args, **kwargs): DCNL  DCSP options = datastore_rpc.TransactionOptions(retries=retries) DCNL DCSP return RunInTransactionOptions(options, function, *args, **kwargs)
def calculateNonce(realm, algorithm=MD5): DCNL  DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP try: DCNL DCSP  DCSP encoder = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise NotImplementedError(('The DCSP chosen DCSP algorithm DCSP (%s) DCSP does DCSP not DCSP have DCSP an DCSP implementation DCSP yet' % algorithm)) DCNL DCSP return encoder(('%d:%s' % (time.time(), realm)))
def confirm(question, error_response='Valid DCSP options DCSP : DCSP yes DCSP or DCSP no'): DCNL  DCSP while True: DCNL DCSP  DCSP answer = raw_input(question).lower() DCNL DCSP  DCSP if (answer in ('y', 'yes')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (answer in ('n', 'no')): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP print error_response
def asStructuredText(I, munge=0): DCNL  DCSP r = [I.getName()] DCNL DCSP outp = r.append DCNL DCSP level = 1 DCNL DCSP if I.getDoc(): DCNL DCSP  DCSP outp(_justify_and_indent(_trim_doc_string(I.getDoc()), level)) DCNL DCSP bases = [base for base in I.__bases__ if (base is not zope.interface.Interface)] DCNL DCSP if bases: DCNL DCSP  DCSP outp(_justify_and_indent('This DCSP interface DCSP extends:', level, munge)) DCNL DCSP  DCSP level += 1 DCNL DCSP  DCSP for b in bases: DCNL DCSP  DCSP  DCSP item = ('o DCSP %s' % b.getName()) DCNL DCSP  DCSP  DCSP outp(_justify_and_indent(_trim_doc_string(item), level, munge)) DCNL DCSP  DCSP level -= 1 DCNL DCSP namesAndDescriptions = I.namesAndDescriptions() DCNL DCSP namesAndDescriptions.sort() DCNL DCSP outp(_justify_and_indent('Attributes:', level, munge)) DCNL DCSP level += 1 DCNL DCSP for (name, desc) in namesAndDescriptions: DCNL DCSP  DCSP if (not hasattr(desc, 'getSignatureString')): DCNL DCSP  DCSP  DCSP item = ('%s DCSP -- DCSP %s' % (desc.getName(), (desc.getDoc() or 'no DCSP documentation'))) DCNL DCSP  DCSP  DCSP outp(_justify_and_indent(_trim_doc_string(item), level, munge)) DCNL DCSP level -= 1 DCNL DCSP outp(_justify_and_indent('Methods:', level, munge)) DCNL DCSP level += 1 DCNL DCSP for (name, desc) in namesAndDescriptions: DCNL DCSP  DCSP if hasattr(desc, 'getSignatureString'): DCNL DCSP  DCSP  DCSP item = ('%s%s DCSP -- DCSP %s' % (desc.getName(), desc.getSignatureString(), (desc.getDoc() or 'no DCSP documentation'))) DCNL DCSP  DCSP  DCSP outp(_justify_and_indent(_trim_doc_string(item), level, munge)) DCNL DCSP return ('\n\n'.join(r) + '\n\n')
def install_packages_from_file(packages_to_install): DCNL  DCSP if (packages_to_install == []): DCNL DCSP  DCSP raise RuntimeError('[in] DCSP fatal: DCSP need DCSP packages DCSP names DCSP to DCSP install.') DCNL DCSP packages_really_to_install = [] DCNL DCSP for this_package in packages_to_install: DCNL DCSP  DCSP if os.path.exists(this_package): DCNL DCSP  DCSP  DCSP packages_really_to_install.append(this_package) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.warning("[in] DCSP package DCSP '{0}' DCSP not DCSP found".format(this_package)) DCNL DCSP if (packages_really_to_install != []): DCNL DCSP  DCSP logger.info('[in] DCSP The DCSP following DCSP package(s) DCSP will DCSP be DCSP installed:') DCNL DCSP  DCSP packages = [] DCNL DCSP  DCSP for this_package in packages_really_to_install: DCNL DCSP  DCSP  DCSP packages.append(corename(this_package)) DCNL DCSP  DCSP logger.info(' DCSP '.join(packages)) DCNL DCSP  DCSP r = input('Proceed? DCSP [yes/N] DCSP ') DCNL DCSP  DCSP if ((r == 'y') or (r == 'yes')): DCNL DCSP  DCSP  DCSP for this_package in packages_really_to_install: DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists((dataset_data_path + corename(this_package))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r = input(("[in] DCSP '%s' DCSP already DCSP installed, DCSP overwrite? DCSP [yes/N] DCSP " % corename(this_package))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((r != 'y') and (r != 'yes')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.info("[in] DCSP skipping DCSP package DCSP '{0}'".format(corename(this_package))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP install_package(corename(this_package), this_package, dataset_data_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info("[in] DCSP Taking DCSP '{0}' DCSP for DCSP no, DCSP so DCSP there.".format(r))
def restoreConfigZip(archive, targetDir): DCNL  DCSP try: DCNL DCSP  DCSP if (not os.path.exists(targetDir)): DCNL DCSP  DCSP  DCSP os.mkdir(targetDir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def path_leaf(path): DCNL DCSP  DCSP  DCSP  DCSP (head, tail) = os.path.split(path) DCNL DCSP  DCSP  DCSP  DCSP return (tail or os.path.basename(head)) DCNL DCSP  DCSP  DCSP bakFilename = u'{0}-{1}'.format(path_leaf(targetDir), datetime.datetime.now().strftime(u'%Y%m%d_%H%M%S')) DCNL DCSP  DCSP  DCSP moveFile(targetDir, os.path.join(os.path.dirname(targetDir), bakFilename)) DCNL DCSP  DCSP with zipfile.ZipFile(archive, u'r', allowZip64=True) as zip_file: DCNL DCSP  DCSP  DCSP for member in zip_file.namelist(): DCNL DCSP  DCSP  DCSP  DCSP zip_file.extract(member, targetDir) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP sickrage.srCore.srLogger.error(u'Zip DCSP extraction DCSP error: DCSP {}'.format(e.message)) DCNL DCSP  DCSP removetree(targetDir)
def load(config_string, default_name=None): DCNL  DCSP split = windows_friendly_colon_split(config_string) DCNL DCSP if (len(split) > 1): DCNL DCSP  DCSP (module_name, object_name) = (':'.join(split[:(-1)]), split[(-1)]) DCNL DCSP else: DCNL DCSP  DCSP (module_name, object_name) = (config_string, default_name) DCNL DCSP module = get_module(module_name) DCNL DCSP if object_name: DCNL DCSP  DCSP return getattr(module, object_name) DCNL DCSP else: DCNL DCSP  DCSP return module
@verbose DCNL def gamma_map(evoked, forward, noise_cov, alpha, loose=0.2, depth=0.8, xyz_same_gamma=True, maxit=10000, tol=1e-06, update_mode=1, gammas=None, pca=True, return_residual=False, verbose=None): DCNL  DCSP _check_reference(evoked) DCNL DCSP if ((loose is None) and (not is_fixed_orient(forward))): DCNL DCSP  DCSP forward = deepcopy(forward) DCNL DCSP  DCSP _to_fixed_ori(forward) DCNL DCSP if (is_fixed_orient(forward) or (not xyz_same_gamma)): DCNL DCSP  DCSP group_size = 1 DCNL DCSP else: DCNL DCSP  DCSP group_size = 3 DCNL DCSP (gain, gain_info, whitener, source_weighting, mask) = _prepare_gain(forward, evoked.info, noise_cov, pca, depth, loose, None, None) DCNL DCSP sel = [evoked.ch_names.index(name) for name in gain_info['ch_names']] DCNL DCSP M = evoked.data[sel] DCNL DCSP logger.info('Whitening DCSP data DCSP matrix.') DCNL DCSP M = np.dot(whitener, M) DCNL DCSP (X, active_set) = _gamma_map_opt(M, gain, alpha, maxit=maxit, tol=tol, update_mode=update_mode, gammas=gammas, group_size=group_size, verbose=verbose) DCNL DCSP if (len(active_set) == 0): DCNL DCSP  DCSP raise Exception('No DCSP active DCSP dipoles DCSP found. DCSP alpha DCSP is DCSP too DCSP big.') DCNL DCSP n_dip_per_pos = (1 if is_fixed_orient(forward) else 3) DCNL DCSP X = _reapply_source_weighting(X, source_weighting, active_set, n_dip_per_pos) DCNL DCSP if return_residual: DCNL DCSP  DCSP residual = _compute_residual(forward, evoked, X, active_set, gain_info) DCNL DCSP if ((group_size == 1) and (not is_fixed_orient(forward))): DCNL DCSP  DCSP active_src = np.unique((active_set // 3)) DCNL DCSP  DCSP in_pos = 0 DCNL DCSP  DCSP if (len(X) < (3 * len(active_src))): DCNL DCSP  DCSP  DCSP X_xyz = np.zeros(((3 * len(active_src)), X.shape[1]), dtype=X.dtype) DCNL DCSP  DCSP  DCSP for ii in range(len(active_src)): DCNL DCSP  DCSP  DCSP  DCSP for jj in range(3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (in_pos >= len(active_set)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((active_set[in_pos] + jj) % 3) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP X_xyz[((3 * ii) + jj)] = X[in_pos] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in_pos += 1 DCNL DCSP  DCSP  DCSP X = X_xyz DCNL DCSP tmin = evoked.times[0] DCNL DCSP tstep = (1.0 / evoked.info['sfreq']) DCNL DCSP stc = _make_sparse_stc(X, active_set, forward, tmin, tstep, active_is_idx=True, verbose=verbose) DCNL DCSP if return_residual: DCNL DCSP  DCSP return (stc, residual) DCNL DCSP else: DCNL DCSP  DCSP return stc
def set_hostname(hostname=None, commit_change=True): DCNL  DCSP conn = __proxy__['junos.conn']() DCNL DCSP ret = dict() DCNL DCSP if (hostname is None): DCNL DCSP  DCSP ret['out'] = False DCNL DCSP  DCSP return ret DCNL DCSP set_string = 'set DCSP system DCSP host-name DCSP {0}'.format(hostname) DCNL DCSP conn.cu.load(set_string, format='set') DCNL DCSP if commit_change: DCNL DCSP  DCSP return commit() DCNL DCSP else: DCNL DCSP  DCSP ret['out'] = True DCNL DCSP  DCSP ret['msg'] = 'set DCSP system DCSP host-name DCSP {0} DCSP is DCSP queued'.format(hostname) DCNL DCSP return ret
def with_backing_lock(method): DCNL  DCSP def wrapped_method(self, *args, **dargs): DCNL DCSP  DCSP already_have_lock = (self._backing_file_lock is not None) DCNL DCSP  DCSP if (not already_have_lock): DCNL DCSP  DCSP  DCSP self._lock_backing_file() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return method(self, *args, **dargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if (not already_have_lock): DCNL DCSP  DCSP  DCSP  DCSP self._unlock_backing_file() DCNL DCSP wrapped_method.__name__ = method.__name__ DCNL DCSP wrapped_method.__doc__ = method.__doc__ DCNL DCSP return wrapped_method
def build_function(name, args=None, defaults=None, flag=0, doc=None): DCNL  DCSP (args, defaults) = ((args or []), (defaults or [])) DCNL DCSP func = Function(name, doc) DCNL DCSP func.args = argsnode = Arguments() DCNL DCSP argsnode.args = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP argsnode.args.append(Name()) DCNL DCSP  DCSP argsnode.args[(-1)].name = arg DCNL DCSP  DCSP argsnode.args[(-1)].parent = argsnode DCNL DCSP argsnode.defaults = [] DCNL DCSP for default in defaults: DCNL DCSP  DCSP argsnode.defaults.append(const_factory(default)) DCNL DCSP  DCSP argsnode.defaults[(-1)].parent = argsnode DCNL DCSP argsnode.kwarg = None DCNL DCSP argsnode.vararg = None DCNL DCSP argsnode.parent = func DCNL DCSP if args: DCNL DCSP  DCSP register_arguments(func) DCNL DCSP return func
def js_escaped_string(string_for_js): DCNL  DCSP if (string_for_js is None): DCNL DCSP  DCSP string_for_js = '' DCNL DCSP string_for_js = decode.utf8(string_for_js) DCNL DCSP string_for_js = escapejs(string_for_js) DCNL DCSP return string_for_js
def reset_extensions_translations_locales(apps, schema_editor): DCNL  DCSP Extension = apps.get_model(u'extensions', u'Extension') DCNL DCSP Translation = apps.get_model(u'translations', u'Translation') DCNL DCSP extensions = Extension.objects.all() DCNL DCSP for extension in extensions: DCNL DCSP  DCSP translations_ids = filter(None, [extension.name_id, extension.description_id]) DCNL DCSP  DCSP lang = extension.default_language.lower() DCNL DCSP  DCSP Translation.objects.filter(id__in=translations_ids).update(locale=lang)
def listen(description, factory, default=None): DCNL  DCSP from twisted.internet import reactor DCNL DCSP (name, args, kw) = parse(description, factory, default) DCNL DCSP return getattr(reactor, ('listen' + name))(*args, **kw)
def test_ros_fit_sample(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.92923648, 0.76103773], [0.47104475, 0.44386323]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def _check_storage_models(current_release): DCNL  DCSP diff_list = _git_diff_names_only(current_release) DCNL DCSP return [item for item in diff_list if item.startswith('core/storage')]
def get_help(): DCNL  DCSP return stem.interpreter.msg('msg.help', address=DEFAULT_ARGS['control_address'], port=DEFAULT_ARGS['control_port'], socket=DEFAULT_ARGS['control_socket'])
def metric_to_Christoffel_2nd(expr): DCNL  DCSP ch_1st = metric_to_Christoffel_1st(expr) DCNL DCSP coord_sys = expr.atoms(CoordSystem).pop() DCNL DCSP indices = list(range(coord_sys.dim)) DCNL DCSP matrix = twoform_to_matrix(expr) DCNL DCSP s_fields = set() DCNL DCSP for e in matrix: DCNL DCSP  DCSP s_fields.update(e.atoms(BaseScalarField)) DCNL DCSP s_fields = list(s_fields) DCNL DCSP dums = coord_sys._dummies DCNL DCSP matrix = matrix.subs(list(zip(s_fields, dums))).inv().subs(list(zip(dums, s_fields))) DCNL DCSP christoffel = [[[Add(*[(matrix[(i, l)] * ch_1st[(l, j, k)]) for l in indices]) for k in indices] for j in indices] for i in indices] DCNL DCSP return ImmutableDenseNDimArray(christoffel)
def _generic_factor_list(expr, gens, args, method): DCNL  DCSP options.allowed_flags(args, ['frac', 'polys']) DCNL DCSP opt = options.build_options(gens, args) DCNL DCSP expr = sympify(expr) DCNL DCSP if (isinstance(expr, Expr) and (not expr.is_Relational)): DCNL DCSP  DCSP (numer, denom) = together(expr).as_numer_denom() DCNL DCSP  DCSP (cp, fp) = _symbolic_factor_list(numer, opt, method) DCNL DCSP  DCSP (cq, fq) = _symbolic_factor_list(denom, opt, method) DCNL DCSP  DCSP if (fq and (not opt.frac)): DCNL DCSP  DCSP  DCSP raise PolynomialError(('a DCSP polynomial DCSP expected, DCSP got DCSP %s' % expr)) DCNL DCSP  DCSP _opt = opt.clone(dict(expand=True)) DCNL DCSP  DCSP for factors in (fp, fq): DCNL DCSP  DCSP  DCSP for (i, (f, k)) in enumerate(factors): DCNL DCSP  DCSP  DCSP  DCSP if (not f.is_Poly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (f, _) = _poly_from_expr(f, _opt) DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors[i] = (f, k) DCNL DCSP  DCSP fp = _sorted_factors(fp, method) DCNL DCSP  DCSP fq = _sorted_factors(fq, method) DCNL DCSP  DCSP if (not opt.polys): DCNL DCSP  DCSP  DCSP fp = [(f.as_expr(), k) for (f, k) in fp] DCNL DCSP  DCSP  DCSP fq = [(f.as_expr(), k) for (f, k) in fq] DCNL DCSP  DCSP coeff = (cp / cq) DCNL DCSP  DCSP if (not opt.frac): DCNL DCSP  DCSP  DCSP return (coeff, fp) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (coeff, fp, fq) DCNL DCSP else: DCNL DCSP  DCSP raise PolynomialError(('a DCSP polynomial DCSP expected, DCSP got DCSP %s' % expr))
@register(u'accept-line') DCNL def accept_line(event): DCNL  DCSP b = event.current_buffer DCNL DCSP b.accept_action.validate_and_handle(event.cli, b)
def log_loss(y_true, y_prob): DCNL  DCSP y_prob = np.clip(y_prob, 1e-10, (1 - 1e-10)) DCNL DCSP if (y_prob.shape[1] == 1): DCNL DCSP  DCSP y_prob = np.append((1 - y_prob), y_prob, axis=1) DCNL DCSP if (y_true.shape[1] == 1): DCNL DCSP  DCSP y_true = np.append((1 - y_true), y_true, axis=1) DCNL DCSP return ((- np.sum((y_true * np.log(y_prob)))) / y_prob.shape[0])
def start(hass, server_config): DCNL  DCSP from hbmqtt.broker import Broker, BrokerException DCNL DCSP try: DCNL DCSP  DCSP passwd = tempfile.NamedTemporaryFile() DCNL DCSP  DCSP if (server_config is None): DCNL DCSP  DCSP  DCSP (server_config, client_config) = generate_config(hass, passwd) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP client_config = None DCNL DCSP  DCSP broker = Broker(server_config, hass.loop) DCNL DCSP  DCSP run_coroutine_threadsafe(broker.start(), hass.loop).result() DCNL DCSP except BrokerException: DCNL DCSP  DCSP logging.getLogger(__name__).exception('Error DCSP initializing DCSP MQTT DCSP server') DCNL DCSP  DCSP return (False, None) DCNL DCSP finally: DCNL DCSP  DCSP passwd.close() DCNL DCSP @callback DCNL DCSP def shutdown_mqtt_server(event): DCNL DCSP  DCSP 'Shut DCSP down DCSP the DCSP MQTT DCSP server.' DCNL DCSP  DCSP hass.async_add_job(broker.shutdown()) DCNL DCSP hass.bus.listen_once(EVENT_HOMEASSISTANT_STOP, shutdown_mqtt_server) DCNL DCSP return (True, client_config)
def export_to_zip_file(exploration_id, version=None): DCNL  DCSP exploration = get_exploration_by_id(exploration_id, version=version) DCNL DCSP yaml_repr = exploration.to_yaml() DCNL DCSP memfile = StringIO.StringIO() DCNL DCSP with zipfile.ZipFile(memfile, mode='w', compression=zipfile.ZIP_DEFLATED) as zfile: DCNL DCSP  DCSP zfile.writestr(('%s.yaml' % exploration.title), yaml_repr) DCNL DCSP  DCSP fs = fs_domain.AbstractFileSystem(fs_domain.ExplorationFileSystem(exploration_id)) DCNL DCSP  DCSP dir_list = fs.listdir('') DCNL DCSP  DCSP for filepath in dir_list: DCNL DCSP  DCSP  DCSP file_contents = fs.get(filepath, version=1) DCNL DCSP  DCSP  DCSP str_filepath = ('assets/%s' % filepath) DCNL DCSP  DCSP  DCSP assert isinstance(str_filepath, str) DCNL DCSP  DCSP  DCSP unicode_filepath = str_filepath.decode('utf-8') DCNL DCSP  DCSP  DCSP zfile.writestr(unicode_filepath, file_contents) DCNL DCSP return memfile.getvalue()
def convolution_nd(x, W, b=None, stride=1, pad=0, use_cudnn=True, cover_all=False): DCNL  DCSP ndim = len(x.shape[2:]) DCNL DCSP func = ConvolutionND(ndim, stride, pad, use_cudnn, cover_all) DCNL DCSP if (b is None): DCNL DCSP  DCSP return func(x, W) DCNL DCSP else: DCNL DCSP  DCSP return func(x, W, b)
def normpath(path): DCNL  DCSP if (path == ''): DCNL DCSP  DCSP return '.' DCNL DCSP initial_slashes = path.startswith('/') DCNL DCSP if (initial_slashes and path.startswith('//') and (not path.startswith('///'))): DCNL DCSP  DCSP initial_slashes = 2 DCNL DCSP comps = path.split('/') DCNL DCSP new_comps = [] DCNL DCSP for comp in comps: DCNL DCSP  DCSP if (comp in ('', '.')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((comp != '..') or ((not initial_slashes) and (not new_comps)) or (new_comps and (new_comps[(-1)] == '..'))): DCNL DCSP  DCSP  DCSP new_comps.append(comp) DCNL DCSP  DCSP elif new_comps: DCNL DCSP  DCSP  DCSP new_comps.pop() DCNL DCSP comps = new_comps DCNL DCSP path = '/'.join(comps) DCNL DCSP if initial_slashes: DCNL DCSP  DCSP path = (('/' * initial_slashes) + path) DCNL DCSP return (path or '.')
def select(start, end): DCNL  DCSP _unmap_select_mode_mapping() DCNL DCSP selection = eval('&selection') DCNL DCSP col = col2byte((start.line + 1), start.col) DCNL DCSP vim.current.window.cursor = ((start.line + 1), col) DCNL DCSP mode = eval('mode()') DCNL DCSP move_cmd = '' DCNL DCSP if (mode != 'n'): DCNL DCSP  DCSP move_cmd += '\\<Esc>' DCNL DCSP if (start == end): DCNL DCSP  DCSP if ((col == 0) or ((mode not in 'i') and (col < len(buf[start.line])))): DCNL DCSP  DCSP  DCSP move_cmd += 'i' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP move_cmd += 'a' DCNL DCSP else: DCNL DCSP  DCSP move_cmd += 'v' DCNL DCSP  DCSP if ('inclusive' in selection): DCNL DCSP  DCSP  DCSP if (end.col == 0): DCNL DCSP  DCSP  DCSP  DCSP move_cmd += ('%iG$' % end.line) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP move_cmd += ('%iG%i|' % virtual_position((end.line + 1), end.col)) DCNL DCSP  DCSP elif ('old' in selection): DCNL DCSP  DCSP  DCSP move_cmd += ('%iG%i|' % virtual_position((end.line + 1), end.col)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP move_cmd += ('%iG%i|' % virtual_position((end.line + 1), (end.col + 1))) DCNL DCSP  DCSP move_cmd += ('o%iG%i|o\\<c-g>' % virtual_position((start.line + 1), (start.col + 1))) DCNL DCSP feedkeys(move_cmd)
def log_mean_exp(a): DCNL  DCSP max_ = a.max(1) DCNL DCSP return (max_ + T.log(T.exp((a - max_.dimshuffle(0, 'x'))).mean(1)))
def fullmatch(pattern, string, flags=0): DCNL  DCSP return _compile(pattern, flags).fullmatch(string)
def _variable_with_weight_decay(name, shape, stddev, wd): DCNL  DCSP var = _variable_on_cpu(name, shape, tf.truncated_normal_initializer(stddev=stddev)) DCNL DCSP if (wd is not None): DCNL DCSP  DCSP weight_decay = tf.mul(tf.nn.l2_loss(var), wd, name='weight_loss') DCNL DCSP  DCSP tf.add_to_collection('losses', weight_decay) DCNL DCSP return var
def lookupNamingAuthorityPointer(name, timeout=None): DCNL  DCSP return getResolver().lookupNamingAuthorityPointer(name, timeout)
def db_exists(name, **client_args): DCNL  DCSP if (name in [db['name'] for db in list_dbs(**client_args)]): DCNL DCSP  DCSP return True DCNL DCSP return False
def build_auxiliary_edge_connectivity(G): DCNL  DCSP if G.is_directed(): DCNL DCSP  DCSP H = nx.DiGraph() DCNL DCSP  DCSP H.add_nodes_from(G.nodes()) DCNL DCSP  DCSP H.add_edges_from(G.edges(), capacity=1) DCNL DCSP  DCSP return H DCNL DCSP else: DCNL DCSP  DCSP H = nx.DiGraph() DCNL DCSP  DCSP H.add_nodes_from(G.nodes()) DCNL DCSP  DCSP for (source, target) in G.edges(): DCNL DCSP  DCSP  DCSP H.add_edges_from([(source, target), (target, source)], capacity=1) DCNL DCSP  DCSP return H
def build_graph(git_dir, roles_dirs, aws_play_dirs, docker_play_dirs): DCNL  DCSP graph = nx.DiGraph() DCNL DCSP _map_roles_to_roles(graph, roles_dirs, git_dir, 'dependencies', 'role', 'role') DCNL DCSP _map_plays_to_roles(graph, aws_play_dirs, git_dir, 'roles', 'aws_playbook', 'role') DCNL DCSP _map_plays_to_roles(graph, docker_play_dirs, git_dir, 'roles', 'docker_playbook', 'role') DCNL DCSP return graph
def change_state(api_url, post_data): DCNL  DCSP for _ in range(LOGIN_RETRIES): DCNL DCSP  DCSP req = requests.post(urljoin(ZM['url'], api_url), data=post_data, cookies=ZM['cookies'], timeout=DEFAULT_TIMEOUT) DCNL DCSP  DCSP if (req.status_code != requests.codes.ok): DCNL DCSP  DCSP  DCSP login() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP _LOGGER.exception('Unable DCSP to DCSP get DCSP API DCSP response DCSP from DCSP ZoneMinder') DCNL DCSP return json.loads(req.text)
def test_factory(support_as_data=True): DCNL  DCSP if support_as_data: DCNL DCSP  DCSP return DataModelTester_SupportAsDataMixin DCNL DCSP else: DCNL DCSP  DCSP return DataModelTester_NotSupportAsDataMixin
def get_error_page(status, **kwargs): DCNL  DCSP import cherrypy DCNL DCSP try: DCNL DCSP  DCSP (code, reason, message) = _httputil.valid_status(status) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise cherrypy.HTTPError(500, _exc_info()[1].args[0]) DCNL DCSP if (kwargs.get('status') is None): DCNL DCSP  DCSP kwargs['status'] = ('%s DCSP %s' % (code, reason)) DCNL DCSP if (kwargs.get('message') is None): DCNL DCSP  DCSP kwargs['message'] = message DCNL DCSP if (kwargs.get('traceback') is None): DCNL DCSP  DCSP kwargs['traceback'] = '' DCNL DCSP if (kwargs.get('version') is None): DCNL DCSP  DCSP kwargs['version'] = cherrypy.__version__ DCNL DCSP for (k, v) in iteritems(kwargs): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP kwargs[k] = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs[k] = _escape(kwargs[k]) DCNL DCSP pages = cherrypy.serving.request.error_page DCNL DCSP error_page = (pages.get(code) or pages.get('default')) DCNL DCSP template = _HTTPErrorTemplate DCNL DCSP if error_page: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if hasattr(error_page, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP result = error_page(**kwargs) DCNL DCSP  DCSP  DCSP  DCSP if cherrypy.lib.is_iterator(result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP from cherrypy.lib.encoding import UTF8StreamEncoder DCNL DCSP  DCSP  DCSP  DCSP  DCSP return UTF8StreamEncoder(result) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(result, cherrypy._cpcompat.unicodestr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result.encode('utf-8') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(result, cherrypy._cpcompat.bytestr)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('error DCSP page DCSP function DCSP did DCSP not DCSP return DCSP a DCSP bytestring, DCSP unicodestring DCSP or DCSP an DCSP iterator DCSP - DCSP returned DCSP object DCSP of DCSP type DCSP %s.' % type(result).__name__)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP template = tonative(open(error_page, 'rb').read()) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP e = _format_exception(*_exc_info())[(-1)] DCNL DCSP  DCSP  DCSP m = kwargs['message'] DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP m += '<br DCSP />' DCNL DCSP  DCSP  DCSP m += ('In DCSP addition, DCSP the DCSP custom DCSP error DCSP page DCSP failed:\n<br DCSP />%s' % e) DCNL DCSP  DCSP  DCSP kwargs['message'] = m DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.headers['Content-Type'] = 'text/html;charset=utf-8' DCNL DCSP result = (template % kwargs) DCNL DCSP return result.encode('utf-8')
def run_convert_to_html(output_dir): DCNL  DCSP markdown_to_html = _get_markdown_renderer() DCNL DCSP for md_file_path in get_markdown_file_paths(): DCNL DCSP  DCSP with open(md_file_path, 'r') as f: DCNL DCSP  DCSP  DCSP html = markdown_to_html(f.read()) DCNL DCSP  DCSP head = HEADER DCNL DCSP  DCSP if ('func_groups' in md_file_path): DCNL DCSP  DCSP  DCSP head = head.replace('"index.html"', '"../index.html"') DCNL DCSP  DCSP  DCSP head = head.replace('"doc_index.html"', '"../doc_index.html"') DCNL DCSP  DCSP  DCSP head = head.replace('"stylesheets/', '"../stylesheets/') DCNL DCSP  DCSP lines = html.split('\n') DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP if ('FLOAT_RIGHT' in line): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('FLOAT_RIGHT', '') DCNL DCSP  DCSP  DCSP  DCSP lines[i] = line.replace('<a DCSP ', '<a DCSP class="float-right" DCSP ') DCNL DCSP  DCSP html = ''.join([head, '\n'.join(lines), FOOTER]) DCNL DCSP  DCSP save_file_path = os.path.abspath(md_file_path.replace(INPUT_DIR, output_dir).replace('.md', '.html')) DCNL DCSP  DCSP if (not os.path.exists(os.path.dirname(save_file_path))): DCNL DCSP  DCSP  DCSP os.mkdir(os.path.dirname(save_file_path)) DCNL DCSP  DCSP with open(save_file_path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(html) DCNL DCSP  DCSP  DCSP print(('Wrote DCSP %s' % save_file_path))
def _chunk_write(chunk, local_file, progress): DCNL  DCSP local_file.write(chunk) DCNL DCSP progress.update_with_increment_value(len(chunk))
def get_features(): DCNL  DCSP return get_var('FEATURES')
def _plot_topomap_multi_cbar(data, pos, ax, title=None, unit=None, vmin=None, vmax=None, cmap=None, outlines='head', colorbar=False, cbar_fmt='%3.3f'): DCNL  DCSP import matplotlib.pyplot as plt DCNL DCSP from mpl_toolkits.axes_grid1 import make_axes_locatable DCNL DCSP _hide_frame(ax) DCNL DCSP vmin = (np.min(data) if (vmin is None) else vmin) DCNL DCSP vmax = (np.max(data) if (vmax is None) else vmax) DCNL DCSP cmap = _setup_cmap(cmap) DCNL DCSP if (title is not None): DCNL DCSP  DCSP ax.set_title(title, fontsize=10) DCNL DCSP (im, _) = plot_topomap(data, pos, vmin=vmin, vmax=vmax, axes=ax, cmap=cmap[0], image_interp='bilinear', contours=False, outlines=outlines, show=False) DCNL DCSP if (colorbar is True): DCNL DCSP  DCSP divider = make_axes_locatable(ax) DCNL DCSP  DCSP cax = divider.append_axes('right', size='10%', pad=0.25) DCNL DCSP  DCSP cbar = plt.colorbar(im, cax=cax, format=cbar_fmt) DCNL DCSP  DCSP cbar.set_ticks((vmin, vmax)) DCNL DCSP  DCSP if (unit is not None): DCNL DCSP  DCSP  DCSP cbar.ax.set_title(unit, fontsize=8) DCNL DCSP  DCSP cbar.ax.tick_params(labelsize=8) DCNL DCSP  DCSP if cmap[1]: DCNL DCSP  DCSP  DCSP ax.CB = DraggableColorbar(cbar, im)
def rectangle(width, height, dtype=np.uint8): DCNL  DCSP return np.ones((width, height), dtype=dtype)
def tokenize_annotated(doc, annotation): DCNL  DCSP tokens = tokenize(doc, include_hrefs=False) DCNL DCSP for tok in tokens: DCNL DCSP  DCSP tok.annotation = annotation DCNL DCSP return tokens
def _is_hierarchical(x): DCNL  DCSP item = x[0] DCNL DCSP if isinstance(item, (list, tuple, np.ndarray, pd.Series, pd.DataFrame)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def listen(opts): DCNL  DCSP event = salt.utils.event.get_event(opts['node'], sock_dir=opts['sock_dir'], transport=opts['transport'], opts=opts, listen=True) DCNL DCSP check_access_and_print_warning(opts['sock_dir']) DCNL DCSP print(event.puburi) DCNL DCSP jid_counter = 0 DCNL DCSP found_minions = [] DCNL DCSP while True: DCNL DCSP  DCSP ret = event.get_event(full=True) DCNL DCSP  DCSP if (ret is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if opts['func_count']: DCNL DCSP  DCSP  DCSP data = ret.get('data', False) DCNL DCSP  DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP  DCSP if (('id' in six.iterkeys(data)) and (data.get('id', False) not in found_minions)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (data['fun'] == opts['func_count']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jid_counter += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found_minions.append(data['id']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('Reply DCSP received DCSP from DCSP [{0}]. DCSP Total DCSP replies DCSP now: DCSP [{1}].'.format(ret['data']['id'], jid_counter)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('Event DCSP fired DCSP at DCSP {0}'.format(time.asctime())) DCNL DCSP  DCSP  DCSP print(('*' * 25)) DCNL DCSP  DCSP  DCSP print('Tag: DCSP {0}'.format(ret['tag'])) DCNL DCSP  DCSP  DCSP print('Data:') DCNL DCSP  DCSP  DCSP pprint.pprint(ret['data'])
def column_index_from_string(column, fast=False): DCNL  DCSP column = column.upper() DCNL DCSP clen = len(column) DCNL DCSP if ((not fast) and (not all((('A' <= char <= 'Z') for char in column)))): DCNL DCSP  DCSP msg = ('Column DCSP string DCSP must DCSP contain DCSP only DCSP characters DCSP A-Z: DCSP got DCSP %s' % column) DCNL DCSP  DCSP raise ColumnStringIndexException(msg) DCNL DCSP if (clen == 1): DCNL DCSP  DCSP return (ord(column[0]) - 64) DCNL DCSP elif (clen == 2): DCNL DCSP  DCSP return (((1 + (ord(column[0]) - 65)) * 26) + (ord(column[1]) - 64)) DCNL DCSP elif (clen == 3): DCNL DCSP  DCSP return ((((1 + (ord(column[0]) - 65)) * 676) + ((1 + (ord(column[1]) - 65)) * 26)) + (ord(column[2]) - 64)) DCNL DCSP elif (clen > 3): DCNL DCSP  DCSP raise ColumnStringIndexException('Column DCSP string DCSP index DCSP can DCSP not DCSP be DCSP longer DCSP than DCSP 3 DCSP characters') DCNL DCSP else: DCNL DCSP  DCSP raise ColumnStringIndexException('Column DCSP string DCSP index DCSP can DCSP not DCSP be DCSP empty')
def quietRun(cmd, **kwargs): DCNL  DCSP return errRun(cmd, stderr=STDOUT, **kwargs)[0]
def dup_random(n, a, b, K): DCNL  DCSP f = [K.convert(random.randint(a, b)) for _ in range(0, (n + 1))] DCNL DCSP while (not f[0]): DCNL DCSP  DCSP f[0] = K.convert(random.randint(a, b)) DCNL DCSP return f
def reconstruct_interp_matrix(idx, proj): DCNL  DCSP if _is_real(proj): DCNL DCSP  DCSP return backend.idd_reconint((idx + 1), proj) DCNL DCSP else: DCNL DCSP  DCSP return backend.idz_reconint((idx + 1), proj)
def no_4byte_params(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP def _is_match(some_str): DCNL DCSP  DCSP  DCSP return (isinstance(some_str, six.text_type) and (REGEX_4BYTE_UNICODE.findall(some_str) != [])) DCNL DCSP  DCSP def _check_dict(data_dict): DCNL DCSP  DCSP  DCSP for (key, value) in six.iteritems(data_dict): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _check_dict(value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _is_match(key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = _("Property DCSP names DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicode.") DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _is_match(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("%s DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicode DCSP characters.") % key.title()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP  DCSP for data_dict in [arg for arg in args if isinstance(arg, dict)]: DCNL DCSP  DCSP  DCSP _check_dict(data_dict) DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP if _is_match(arg): DCNL DCSP  DCSP  DCSP  DCSP msg = _("Param DCSP values DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicode.") DCNL DCSP  DCSP  DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP  DCSP _check_dict(kwargs) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def device_exists_with_ips_and_mac(device_name, ip_cidrs, mac, namespace=None): DCNL  DCSP try: DCNL DCSP  DCSP device = IPDevice(device_name, namespace=namespace) DCNL DCSP  DCSP if (mac != device.link.address): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP device_ip_cidrs = [ip['cidr'] for ip in device.addr.list()] DCNL DCSP  DCSP for ip_cidr in ip_cidrs: DCNL DCSP  DCSP  DCSP if (ip_cidr not in device_ip_cidrs): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP except RuntimeError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
def index_alt(): DCNL  DCSP s3_redirect_default(URL(f='organisation'))
def get_indices(expr): DCNL  DCSP if isinstance(expr, Indexed): DCNL DCSP  DCSP c = expr.indices DCNL DCSP  DCSP (inds, dummies) = _remove_repeated(c) DCNL DCSP  DCSP return (inds, {}) DCNL DCSP elif (expr is None): DCNL DCSP  DCSP return (set(), {}) DCNL DCSP elif isinstance(expr, Idx): DCNL DCSP  DCSP return ({expr}, {}) DCNL DCSP elif expr.is_Atom: DCNL DCSP  DCSP return (set(), {}) DCNL DCSP else: DCNL DCSP  DCSP if expr.is_Mul: DCNL DCSP  DCSP  DCSP return _get_indices_Mul(expr) DCNL DCSP  DCSP elif expr.is_Add: DCNL DCSP  DCSP  DCSP return _get_indices_Add(expr) DCNL DCSP  DCSP elif (expr.is_Pow or isinstance(expr, exp)): DCNL DCSP  DCSP  DCSP return _get_indices_Pow(expr) DCNL DCSP  DCSP elif isinstance(expr, Piecewise): DCNL DCSP  DCSP  DCSP return (set(), {}) DCNL DCSP  DCSP elif isinstance(expr, Function): DCNL DCSP  DCSP  DCSP ind0 = set() DCNL DCSP  DCSP  DCSP for arg in expr.args: DCNL DCSP  DCSP  DCSP  DCSP (ind, sym) = get_indices(arg) DCNL DCSP  DCSP  DCSP  DCSP ind0 |= ind DCNL DCSP  DCSP  DCSP return (ind0, sym) DCNL DCSP  DCSP elif (not expr.has(Indexed)): DCNL DCSP  DCSP  DCSP return (set(), {}) DCNL DCSP  DCSP raise NotImplementedError(('FIXME: DCSP No DCSP specialized DCSP handling DCSP of DCSP type DCSP %s' % type(expr)))
def WriteXmlIfChanged(content, path, encoding='utf-8', pretty=False, win32=False): DCNL  DCSP xml_string = XmlToString(content, encoding, pretty) DCNL DCSP if (win32 and (os.linesep != '\r\n')): DCNL DCSP  DCSP xml_string = xml_string.replace('\n', '\r\n') DCNL DCSP try: DCNL DCSP  DCSP xml_string = xml_string.encode(encoding) DCNL DCSP except Exception: DCNL DCSP  DCSP xml_string = unicode(xml_string, 'latin-1').encode(encoding) DCNL DCSP try: DCNL DCSP  DCSP f = open(path, 'r') DCNL DCSP  DCSP existing = f.read() DCNL DCSP  DCSP f.close() DCNL DCSP except: DCNL DCSP  DCSP existing = None DCNL DCSP if (existing != xml_string): DCNL DCSP  DCSP f = open(path, 'w') DCNL DCSP  DCSP f.write(xml_string) DCNL DCSP  DCSP f.close()
def ansible_dict_to_boto3_filter_list(filters_dict): DCNL  DCSP filters_list = [] DCNL DCSP for (k, v) in filters_dict.items(): DCNL DCSP  DCSP filter_dict = {'Name': k} DCNL DCSP  DCSP if isinstance(v, string_types): DCNL DCSP  DCSP  DCSP filter_dict['Values'] = [v] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict['Values'] = v DCNL DCSP  DCSP filters_list.append(filter_dict) DCNL DCSP return filters_list
def _hide_frame(ax): DCNL  DCSP ax.get_yticks() DCNL DCSP ax.xaxis.set_ticks([]) DCNL DCSP ax.yaxis.set_ticks([]) DCNL DCSP ax.set_frame_on(False)
def _auth_from_available(le_client, config, domains=None, certname=None, lineage=None): DCNL  DCSP if (lineage is None): DCNL DCSP  DCSP (action, lineage) = _find_lineage_for_domains_and_certname(config, domains, certname) DCNL DCSP else: DCNL DCSP  DCSP action = 'renew' DCNL DCSP if (action == 'reinstall'): DCNL DCSP  DCSP logger.info('Keeping DCSP the DCSP existing DCSP certificate') DCNL DCSP  DCSP return ('reinstall', lineage) DCNL DCSP hooks.pre_hook(config) DCNL DCSP try: DCNL DCSP  DCSP if (action == 'renew'): DCNL DCSP  DCSP  DCSP logger.info('Renewing DCSP an DCSP existing DCSP certificate') DCNL DCSP  DCSP  DCSP renewal.renew_cert(config, domains, le_client, lineage) DCNL DCSP  DCSP elif (action == 'newcert'): DCNL DCSP  DCSP  DCSP logger.info('Obtaining DCSP a DCSP new DCSP certificate') DCNL DCSP  DCSP  DCSP lineage = le_client.obtain_and_enroll_certificate(domains, certname) DCNL DCSP  DCSP  DCSP if (lineage is False): DCNL DCSP  DCSP  DCSP  DCSP raise errors.Error('Certificate DCSP could DCSP not DCSP be DCSP obtained') DCNL DCSP finally: DCNL DCSP  DCSP hooks.post_hook(config) DCNL DCSP if ((not config.dry_run) and (not (config.verb == 'renew'))): DCNL DCSP  DCSP _report_new_cert(config, lineage.cert, lineage.fullchain) DCNL DCSP return (action, lineage)
def renyientropy(px, alpha=1, logbase=2, measure='R'): DCNL  DCSP if (not _isproperdist(px)): DCNL DCSP  DCSP raise ValueError('px DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP distribution') DCNL DCSP alpha = float(alpha) DCNL DCSP if (alpha == 1): DCNL DCSP  DCSP genent = shannonentropy(px) DCNL DCSP  DCSP if (logbase != 2): DCNL DCSP  DCSP  DCSP return (logbasechange(2, logbase) * genent) DCNL DCSP  DCSP return genent DCNL DCSP elif (('inf' in string(alpha).lower()) or (alpha == np.inf)): DCNL DCSP  DCSP return (- np.log(np.max(px))) DCNL DCSP px = (px ** alpha) DCNL DCSP genent = np.log(px.sum()) DCNL DCSP if (logbase == 2): DCNL DCSP  DCSP return ((1 / (1 - alpha)) * genent) DCNL DCSP else: DCNL DCSP  DCSP return (((1 / (1 - alpha)) * logbasechange(2, logbase)) * genent)
@pytest.mark.parametrize((u'expr', u'result'), [((lambda x, y: (x + y)), [5.0, 5.0]), ((lambda x, y: (x - y)), [(-1.0), (-1.0)]), ((lambda x, y: (x * y)), [6.0, 6.0]), ((lambda x, y: (x / y)), [(2.0 / 3.0), (2.0 / 3.0)]), ((lambda x, y: (x ** y)), [8.0, 8.0])]) DCNL def test_model_set_raises_value_error(expr, result): DCNL  DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP s = expr(Const1D((2, 2), n_models=2), Const1D(3, n_models=1))
def websettings(): DCNL  DCSP web = makeelement('webSettings') DCNL DCSP web.append(makeelement('allowPNG')) DCNL DCSP web.append(makeelement('doNotSaveAsSingleFile')) DCNL DCSP return web
def check_chain(table='filter', chain=None, family='ipv4'): DCNL  DCSP if (not chain): DCNL DCSP  DCSP return 'Error: DCSP Chain DCSP needs DCSP to DCSP be DCSP specified' DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmd = '{0} DCSP list DCSP table DCSP {1} DCSP {2}'.format(_nftables_cmd(), nft_family, table) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False).find('chain DCSP {0} DCSP {{'.format(chain)) DCNL DCSP if (out != (-1)): DCNL DCSP  DCSP out = '' DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP if (not out): DCNL DCSP  DCSP return True DCNL DCSP return out
def parse_format_method_string(format_string): DCNL  DCSP keys = [] DCNL DCSP num_args = 0 DCNL DCSP manual_pos_arg = set() DCNL DCSP for name in collect_string_fields(format_string): DCNL DCSP  DCSP if (name and str(name).isdigit()): DCNL DCSP  DCSP  DCSP manual_pos_arg.add(str(name)) DCNL DCSP  DCSP elif name: DCNL DCSP  DCSP  DCSP (keyname, fielditerator) = split_format_field_names(name) DCNL DCSP  DCSP  DCSP if isinstance(keyname, numbers.Number): DCNL DCSP  DCSP  DCSP  DCSP manual_pos_arg.add(str(keyname)) DCNL DCSP  DCSP  DCSP  DCSP keyname = int(keyname) DCNL DCSP  DCSP  DCSP keys.append((keyname, list(fielditerator))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num_args += 1 DCNL DCSP return (keys, num_args, len(manual_pos_arg))
def internalerror(): DCNL  DCSP ctx.status = '500 DCSP Internal DCSP Server DCSP Error' DCNL DCSP ctx.headers = [('Content-Type', 'text/html')] DCNL DCSP ctx.output = 'internal DCSP server DCSP error'
def GetFlavor(params): DCNL  DCSP flavors = {'cygwin': 'win', 'win32': 'win', 'darwin': 'mac'} DCNL DCSP if ('flavor' in params): DCNL DCSP  DCSP return params['flavor'] DCNL DCSP if (sys.platform in flavors): DCNL DCSP  DCSP return flavors[sys.platform] DCNL DCSP if sys.platform.startswith('sunos'): DCNL DCSP  DCSP return 'solaris' DCNL DCSP if sys.platform.startswith('freebsd'): DCNL DCSP  DCSP return 'freebsd' DCNL DCSP if sys.platform.startswith('openbsd'): DCNL DCSP  DCSP return 'openbsd' DCNL DCSP if sys.platform.startswith('netbsd'): DCNL DCSP  DCSP return 'netbsd' DCNL DCSP if sys.platform.startswith('aix'): DCNL DCSP  DCSP return 'aix' DCNL DCSP return 'linux'
def proportions_chisquare_pairscontrol(count, nobs, value=None, multitest_method='hs', alternative='two-sided'): DCNL  DCSP if ((value is not None) or (not (alternative in ['two-sided', '2s']))): DCNL DCSP  DCSP raise NotImplementedError DCNL DCSP all_pairs = [(0, k) for k in range(1, len(count))] DCNL DCSP pvals = [proportions_chisquare(count[list(pair)], nobs[list(pair)])[1] for pair in all_pairs] DCNL DCSP return AllPairsResults(pvals, all_pairs, multitest_method=multitest_method)
def regions(): DCNL  DCSP from boto.cloudtrail.layer1 import CloudTrailConnection DCNL DCSP return get_regions('cloudtrail', connection_cls=CloudTrailConnection)
def upsample_2d(incoming, kernel_size, name='UpSample2D'): DCNL  DCSP input_shape = utils.get_incoming_shape(incoming) DCNL DCSP assert (len(input_shape) == 4), 'Incoming DCSP Tensor DCSP shape DCSP must DCSP be DCSP 4-D' DCNL DCSP kernel = utils.autoformat_kernel_2d(kernel_size) DCNL DCSP with tf.name_scope(name) as scope: DCNL DCSP  DCSP inference = tf.image.resize_nearest_neighbor(incoming, size=(input_shape[1:3] * tf.constant(kernel[1:3]))) DCNL DCSP  DCSP inference.set_shape((None, (input_shape[1] * kernel[1]), (input_shape[2] * kernel[2]), None)) DCNL DCSP inference.scope = scope DCNL DCSP tf.add_to_collection(((tf.GraphKeys.LAYER_TENSOR + '/') + name), inference) DCNL DCSP return inference
def getAllDirectoriesWithFile(path, filename, excludeDirs): DCNL  DCSP directoryList = [] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(path): DCNL DCSP  DCSP for d in dirnames[:]: DCNL DCSP  DCSP  DCSP if (d in excludeDirs): DCNL DCSP  DCSP  DCSP  DCSP dirnames.remove(d) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(dirpath, d)) DCNL DCSP  DCSP  DCSP elif ('UNDER_DEVELOPMENT' in os.listdir(os.path.join(dirpath, d))): DCNL DCSP  DCSP  DCSP  DCSP dirnames.remove(d) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(dirpath, d)) DCNL DCSP  DCSP for f in filenames: DCNL DCSP  DCSP  DCSP if (f == filename): DCNL DCSP  DCSP  DCSP  DCSP directoryList.append(dirpath) DCNL DCSP return directoryList
def plot_scatter(fig, x, y, x2, y2, binnum): DCNL  DCSP fig.canvas.set_window_title(u'\u4ea4\u6613\u9e1f\u77b0\u56fe') DCNL DCSP (left, width) = (0.1, 0.65) DCNL DCSP (bottom, height) = (0.1, 0.65) DCNL DCSP bottom_h = left_h = ((left + width) + 0.02) DCNL DCSP rect_scatter = [left, bottom, width, height] DCNL DCSP rect_histx = [left, bottom_h, width, 0.2] DCNL DCSP rect_histy = [left_h, bottom, 0.2, height] DCNL DCSP axScatter = plt.axes(rect_scatter) DCNL DCSP axHistx = plt.axes(rect_histx) DCNL DCSP axHisty = plt.axes(rect_histy) DCNL DCSP cursor = Cursor(axScatter, useblit=True, color='red', linewidth=1) DCNL DCSP axScatter.plot(x, y, 'o', color='red') DCNL DCSP axScatter.plot(x2, y2, 'o', color='blue') DCNL DCSP xmax = np.max((x + x2)) DCNL DCSP xmin = np.min((x + x2)) DCNL DCSP binwidth = (xmax / binnum) DCNL DCSP lim = ((int((xmax / binwidth)) + 1) * binwidth) DCNL DCSP bins = np.arange((- lim), (lim + binwidth), binwidth) DCNL DCSP axHistx.hist((x + x2), bins=bins) DCNL DCSP ymax = np.max((y + y2)) DCNL DCSP ymin = np.min((y + y2)) DCNL DCSP binwidth = (ymax / binnum) DCNL DCSP lim = ((int((ymax / binwidth)) + 1) * binwidth) DCNL DCSP bins = np.arange((- lim), (lim + binwidth), binwidth) DCNL DCSP axHisty.hist(y, bins=bins, orientation='horizontal', color='red') DCNL DCSP axHisty.hist(y2, bins=bins, orientation='horizontal', color='blue') DCNL DCSP xymax = np.max([np.max(np.fabs((x + x2))), np.max(np.fabs((y + y2)))]) DCNL DCSP lim = ((int((xymax / binwidth)) + 1) * binwidth) DCNL DCSP axScatter.axhline(color='black') DCNL DCSP axHistx.set_xlim(axScatter.get_xlim()) DCNL DCSP axHisty.set_ylim(axScatter.get_ylim()) DCNL DCSP axHisty.set_xlabel(u'\u76c8\u4e8f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axHistx.set_ylabel(u'\u5468\u671f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axScatter.set_xlabel(u'\u76c8\u4e8f\u548c\u5468\u671f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axScatter.grid(True) DCNL DCSP axHistx.grid(True) DCNL DCSP axHisty.grid(True) DCNL DCSP c = Cursor(axScatter, useblit=True, color='red', linewidth=1, vertOn=True, horizOn=True) DCNL DCSP return ([axScatter, axHistx, axHisty], [c])
def getTestOutput(): DCNL  DCSP sleep(1) DCNL DCSP for i in xrange(5): DCNL DCSP  DCSP if ('ip_session.log' in nt.listdir(nt.getcwd())): DCNL DCSP  DCSP  DCSP tfile = open('ip_session.log', 'r') DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP print 'Waiting DCSP for DCSP ip_session.log DCSP to DCSP be DCSP created...' DCNL DCSP  DCSP sleep(1) DCNL DCSP outlines = tfile.readlines() DCNL DCSP tfile.close() DCNL DCSP errlines = [] DCNL DCSP if File.Exists('ip_session_stderr.log'): DCNL DCSP  DCSP tfile = open('ip_session_stderr.log', 'r') DCNL DCSP  DCSP errlines = tfile.readlines() DCNL DCSP  DCSP tfile.close() DCNL DCSP return (outlines, errlines)
@hook.command('feed', 'rss', 'news') DCNL def rss(text): DCNL  DCSP limit = 3 DCNL DCSP t = text.lower().strip() DCNL DCSP if (t == 'xkcd'): DCNL DCSP  DCSP addr = 'http://xkcd.com/rss.xml' DCNL DCSP elif (t == 'ars'): DCNL DCSP  DCSP addr = 'http://feeds.arstechnica.com/arstechnica/index' DCNL DCSP elif (t in ('pypi', 'pip', 'py')): DCNL DCSP  DCSP addr = 'https://pypi.python.org/pypi?%3Aaction=rss' DCNL DCSP  DCSP limit = 6 DCNL DCSP elif (t in ('pypinew', 'pipnew', 'pynew')): DCNL DCSP  DCSP addr = 'https://pypi.python.org/pypi?%3Aaction=packages_rss' DCNL DCSP  DCSP limit = 5 DCNL DCSP elif (t == 'world'): DCNL DCSP  DCSP addr = 'https://news.google.com/news?cf=all&ned=us&hl=en&topic=w&output=rss' DCNL DCSP elif (t in ('us', 'usa')): DCNL DCSP  DCSP addr = 'https://news.google.com/news?cf=all&ned=us&hl=en&topic=n&output=rss' DCNL DCSP elif (t == 'nz'): DCNL DCSP  DCSP addr = 'https://news.google.com/news?pz=1&cf=all&ned=nz&hl=en&topic=n&output=rss' DCNL DCSP elif (t in ('anand', 'anandtech')): DCNL DCSP  DCSP addr = 'http://www.anandtech.com/rss/' DCNL DCSP else: DCNL DCSP  DCSP addr = text DCNL DCSP feed = feedparser.parse(addr) DCNL DCSP if (not feed.entries): DCNL DCSP  DCSP return 'Feed DCSP not DCSP found.' DCNL DCSP out = [] DCNL DCSP for item in feed.entries[:limit]: DCNL DCSP  DCSP out.append(format_item(item)) DCNL DCSP start = ('\x02{}\x02: DCSP '.format(feed.feed.title) if ('title' in feed.feed) else '') DCNL DCSP return (start + ', DCSP '.join(out))
@require_role('admin') DCNL def group_list(request): DCNL  DCSP (header_title, path1, path2) = (u'\u67e5\u770b\u8d44\u4ea7\u7ec4', u'\u8d44\u4ea7\u7ba1\u7406', u'\u67e5\u770b\u8d44\u4ea7\u7ec4') DCNL DCSP keyword = request.GET.get('keyword', '') DCNL DCSP asset_group_list = AssetGroup.objects.all() DCNL DCSP group_id = request.GET.get('id') DCNL DCSP if group_id: DCNL DCSP  DCSP asset_group_list = asset_group_list.filter(id=group_id) DCNL DCSP if keyword: DCNL DCSP  DCSP asset_group_list = asset_group_list.filter((Q(name__contains=keyword) | Q(comment__contains=keyword))) DCNL DCSP (asset_group_list, p, asset_groups, page_range, current_page, show_first, show_end) = pages(asset_group_list, request) DCNL DCSP return my_render('jasset/group_list.html', locals(), request)
def load_plain_keyfile(filename): DCNL  DCSP with open(filename, 'rb') as f: DCNL DCSP  DCSP key = f.read() DCNL DCSP  DCSP if (len(key) == 32): DCNL DCSP  DCSP  DCSP return key DCNL DCSP  DCSP if (len(key) == 64): DCNL DCSP  DCSP  DCSP return key.decode('hex') DCNL DCSP  DCSP return sha256(key) DCNL DCSP raise IOError('Could DCSP not DCSP read DCSP keyfile.')
def create_subnet_group(name, description, subnet_ids=None, subnet_names=None, tags=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP if (not _exactly_one((subnet_ids, subnet_names))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP of DCSP either DCSP 'subnet_ids' DCSP or DCSP 'subnet_names' DCSP must DCSP be DCSP provided.") DCNL DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return False DCNL DCSP if subnet_group_exists(name, tags, region, key, keyid, profile): DCNL DCSP  DCSP return True DCNL DCSP if subnet_names: DCNL DCSP  DCSP subnet_ids = [] DCNL DCSP  DCSP for n in subnet_names: DCNL DCSP  DCSP  DCSP r = __salt__['boto_vpc.get_resource_id']('subnet', n, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP  DCSP if ('id' not in r): DCNL DCSP  DCSP  DCSP  DCSP log.error("Couldn't DCSP resolve DCSP subnet DCSP name DCSP {0} DCSP to DCSP an DCSP ID.".format(subnet_name)) DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP subnet_ids += [r['id']] DCNL DCSP try: DCNL DCSP  DCSP ec = conn.create_cache_subnet_group(name, description, subnet_ids) DCNL DCSP  DCSP if (not ec): DCNL DCSP  DCSP  DCSP msg = 'Failed DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP log.error(msg) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP log.info('Created DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name)) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
def update(kernel=False): DCNL  DCSP manager = MANAGER DCNL DCSP cmds = {'yum DCSP -y DCSP --color=never': {False: '--exclude=kernel* DCSP update', True: 'update'}} DCNL DCSP cmd = cmds[manager][kernel] DCNL DCSP run_as_root(('%(manager)s DCSP %(cmd)s' % locals()))
def default_locale(category=None, aliases=LOCALE_ALIASES): DCNL  DCSP varnames = (category, 'LANGUAGE', 'LC_ALL', 'LC_CTYPE', 'LANG') DCNL DCSP for name in filter(None, varnames): DCNL DCSP  DCSP locale = os.getenv(name) DCNL DCSP  DCSP if locale: DCNL DCSP  DCSP  DCSP if ((name == 'LANGUAGE') and (':' in locale)): DCNL DCSP  DCSP  DCSP  DCSP locale = locale.split(':')[0] DCNL DCSP  DCSP  DCSP if (locale.split('.')[0] in ('C', 'POSIX')): DCNL DCSP  DCSP  DCSP  DCSP locale = 'en_US_POSIX' DCNL DCSP  DCSP  DCSP elif (aliases and (locale in aliases)): DCNL DCSP  DCSP  DCSP  DCSP locale = aliases[locale] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return get_locale_identifier(parse_locale(locale)) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass
def get_sequential_open_distrib(course_id): DCNL  DCSP db_query = models.StudentModule.objects.filter(course_id__exact=course_id, module_type__exact='sequential').values('module_state_key').annotate(count_sequential=Count('module_state_key')) DCNL DCSP sequential_open_distrib = {} DCNL DCSP for row in db_query: DCNL DCSP  DCSP row_loc = course_id.make_usage_key_from_deprecated_string(row['module_state_key']) DCNL DCSP  DCSP sequential_open_distrib[row_loc] = row['count_sequential'] DCNL DCSP return sequential_open_distrib
def highlight(code, lexer, formatter, outfile=None): DCNL  DCSP return format(lex(code, lexer), formatter, outfile)
def write_rels(worksheet, comments_id=None, vba_controls_id=None): DCNL  DCSP root = Element('Relationships', xmlns=PKG_REL_NS) DCNL DCSP rels = worksheet._rels DCNL DCSP if (worksheet.vba_controls is not None): DCNL DCSP  DCSP rel = Relationship('vmlDrawing', id=worksheet.vba_controls, target=('/xl/drawings/vmlDrawing%s.vml' % vba_controls_id)) DCNL DCSP  DCSP rels.append(rel) DCNL DCSP if (worksheet._comment_count > 0): DCNL DCSP  DCSP rel = Relationship(type='comments', id='comments', target=('/xl/comments%s.xml' % comments_id)) DCNL DCSP  DCSP rels.append(rel) DCNL DCSP  DCSP if (worksheet.vba_controls is None): DCNL DCSP  DCSP  DCSP rel = Relationship(type='vmlDrawing', id='commentsvml', target=('/xl/drawings/commentsDrawing%s.vml' % comments_id)) DCNL DCSP  DCSP  DCSP rels.append(rel) DCNL DCSP for (idx, rel) in enumerate(rels, 1): DCNL DCSP  DCSP if (rel.id is None): DCNL DCSP  DCSP  DCSP rel.id = 'rId{0}'.format(idx) DCNL DCSP  DCSP root.append(rel.to_tree()) DCNL DCSP return root
def test_ecliptic_heliobary(): DCNL  DCSP icrs = ICRS((1 * u.deg), (2 * u.deg), distance=(1.5 * R_sun)) DCNL DCSP bary = icrs.transform_to(BarycentricTrueEcliptic) DCNL DCSP helio = icrs.transform_to(HeliocentricTrueEcliptic) DCNL DCSP assert (np.abs((bary.distance - helio.distance)) > (1 * u.km)) DCNL DCSP helio_in_bary_frame = bary.realize_frame(helio.cartesian) DCNL DCSP assert (bary.separation(helio_in_bary_frame) > (1 * u.arcmin))
def plot_img_and_hist(img, axes, bins=256): DCNL  DCSP (ax_img, ax_hist) = axes DCNL DCSP ax_cdf = ax_hist.twinx() DCNL DCSP ax_img.imshow(img, cmap=plt.cm.gray) DCNL DCSP ax_img.set_axis_off() DCNL DCSP ax_hist.hist(img.ravel(), bins=bins) DCNL DCSP ax_hist.ticklabel_format(axis='y', style='scientific', scilimits=(0, 0)) DCNL DCSP ax_hist.set_xlabel('Pixel DCSP intensity') DCNL DCSP (xmin, xmax) = dtype_range[img.dtype.type] DCNL DCSP ax_hist.set_xlim(xmin, xmax) DCNL DCSP (img_cdf, bins) = exposure.cumulative_distribution(img, bins) DCNL DCSP ax_cdf.plot(bins, img_cdf, 'r') DCNL DCSP return (ax_img, ax_hist, ax_cdf)
def load_overrides(file_path, loaded_config=config): DCNL  DCSP with open(file_path) as data_file: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP overrides = json.load(data_file) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP sys.exit('Failed DCSP parsing DCSP configuration DCSP file DCSP at DCSP {}'.format(file_path)) DCNL DCSP  DCSP if (not overrides): DCNL DCSP  DCSP  DCSP log.debug('No DCSP config DCSP overrides DCSP found.') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP assert isinstance(overrides, dict), 'overrides DCSP must DCSP be DCSP dictionary' DCNL DCSP  DCSP loaded_config.update(overrides) DCNL DCSP  DCSP log.debug('Imported DCSP config DCSP overrides DCSP {}'.format(overrides.keys()))
@intercept_errors(UserAPIInternalError, ignore_errors=[UserAPIRequestError]) DCNL def set_user_preference(requesting_user, preference_key, preference_value, username=None): DCNL  DCSP existing_user = _get_authorized_user(requesting_user, username) DCNL DCSP serializer = create_user_preference_serializer(existing_user, preference_key, preference_value) DCNL DCSP validate_user_preference_serializer(serializer, preference_key, preference_value) DCNL DCSP try: DCNL DCSP  DCSP serializer.save() DCNL DCSP except Exception as error: DCNL DCSP  DCSP raise _create_preference_update_error(preference_key, preference_value, error)
def _process_node(node, aliases, duplicates): DCNL  DCSP stack = _post_order(node) DCNL DCSP key = list() DCNL DCSP for item in stack: DCNL DCSP  DCSP if ((type(item[0]) is str) and (item not in aliases)): DCNL DCSP  DCSP  DCSP key.append(item[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key.append(item[0:2]) DCNL DCSP key = tuple(key) DCNL DCSP dup_node = duplicates.get(key, False) DCNL DCSP if dup_node: DCNL DCSP  DCSP node[0] = dup_node DCNL DCSP  DCSP stack = None DCNL DCSP else: DCNL DCSP  DCSP duplicates[key] = stack[(-1)] DCNL DCSP  DCSP aliases.add(stack[(-1)]) DCNL DCSP while (len(node) > 3): DCNL DCSP  DCSP node.pop() DCNL DCSP return stack
@register.filter(is_safe=False) DCNL def yesno(value, arg=None): DCNL  DCSP if (arg is None): DCNL DCSP  DCSP arg = ugettext(u'yes,no,maybe') DCNL DCSP bits = arg.split(u',') DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP (yes, no, maybe) = bits DCNL DCSP except ValueError: DCNL DCSP  DCSP (yes, no, maybe) = (bits[0], bits[1], bits[1]) DCNL DCSP if (value is None): DCNL DCSP  DCSP return maybe DCNL DCSP if value: DCNL DCSP  DCSP return yes DCNL DCSP return no
def get_res_pool_ref(session, cluster): DCNL  DCSP res_pool_ref = session._call_method(vutil, 'get_object_property', cluster, 'resourcePool') DCNL DCSP return res_pool_ref
def verify(user, password): DCNL  DCSP def verify_user(user_name, user_password): DCNL DCSP  DCSP if ((user_name == user) and (user_password == password)): DCNL DCSP  DCSP  DCSP return user_name DCNL DCSP  DCSP return False DCNL DCSP return verify_user
def basic_auth(realm, users, encrypt=None, debug=False): DCNL  DCSP if check_auth(users, encrypt): DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.BASIC_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.headers['www-authenticate'] = httpauth.basicAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP that DCSP resource')
def url_replace_param(url, name, value): DCNL  DCSP url_components = urlparse(force_str(url)) DCNL DCSP query_params = parse_qs(url_components.query) DCNL DCSP query_params[name] = value DCNL DCSP query = urlencode(query_params, doseq=True) DCNL DCSP return force_text(urlunparse([url_components.scheme, url_components.netloc, url_components.path, url_components.params, query, url_components.fragment]))
def _contains(exp, cls): DCNL  DCSP if isinstance(exp, cls): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(exp, Var): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return _contains(exp.sub, cls)
def libvlc_hex_version(): DCNL  DCSP try: DCNL DCSP  DCSP return _dot2int(bytes_to_str(libvlc_get_version()).split()[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 0
def index_alt(): DCNL  DCSP s3_redirect_default(URL(f='person'))
def render_openid_request(request, openid_request, return_to, trust_root=None): DCNL  DCSP if (trust_root is None): DCNL DCSP  DCSP trust_root = getattr(settings, 'OPENID_TRUST_ROOT', request.build_absolute_uri('/')) DCNL DCSP if openid_request.shouldSendRedirect(): DCNL DCSP  DCSP redirect_url = openid_request.redirectURL(trust_root, return_to) DCNL DCSP  DCSP return HttpResponseRedirect(redirect_url) DCNL DCSP else: DCNL DCSP  DCSP form_html = openid_request.htmlMarkup(trust_root, return_to, form_tag_attrs={'id': 'openid_message'}) DCNL DCSP  DCSP return HttpResponse(form_html, content_type='text/html;charset=UTF-8')
def _unwrap_stream(uri, timeout, scanner, requests_session): DCNL  DCSP original_uri = uri DCNL DCSP seen_uris = set() DCNL DCSP deadline = (time.time() + timeout) DCNL DCSP while (time.time() < deadline): DCNL DCSP  DCSP if (uri in seen_uris): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP failed: DCSP playlist DCSP referenced DCSP itself', uri) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seen_uris.add(uri) DCNL DCSP  DCSP logger.debug(u'Unwrapping DCSP stream DCSP from DCSP URI: DCSP %s', uri) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP scan_timeout = (deadline - time.time()) DCNL DCSP  DCSP  DCSP if (scan_timeout < 0): DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP failed: DCSP timed DCSP out DCSP in DCSP %sms', uri, timeout) DCNL DCSP  DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP  DCSP scan_result = scanner.scan(uri, timeout=scan_timeout) DCNL DCSP  DCSP except exceptions.ScannerError as exc: DCNL DCSP  DCSP  DCSP logger.debug(u'GStreamer DCSP failed DCSP scanning DCSP URI DCSP (%s): DCSP %s', uri, exc) DCNL DCSP  DCSP  DCSP scan_result = None DCNL DCSP  DCSP if (scan_result is not None): DCNL DCSP  DCSP  DCSP if (scan_result.playable or ((not scan_result.mime.startswith(u'text/')) and (not scan_result.mime.startswith(u'application/')))): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(u'Unwrapped DCSP potential DCSP %s DCSP stream: DCSP %s', scan_result.mime, uri) DCNL DCSP  DCSP  DCSP  DCSP return (uri, scan_result) DCNL DCSP  DCSP download_timeout = (deadline - time.time()) DCNL DCSP  DCSP if (download_timeout < 0): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP failed: DCSP timed DCSP out DCSP in DCSP %sms', uri, timeout) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP content = http.download(requests_session, uri, timeout=(download_timeout / 1000)) DCNL DCSP  DCSP if (content is None): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP failed: DCSP error DCSP downloading DCSP URI DCSP %s', original_uri, uri) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP uris = playlists.parse(content) DCNL DCSP  DCSP if (not uris): DCNL DCSP  DCSP  DCSP logger.debug(u'Failed DCSP parsing DCSP URI DCSP (%s) DCSP as DCSP playlist; DCSP found DCSP potential DCSP stream.', uri) DCNL DCSP  DCSP  DCSP return (uri, None) DCNL DCSP  DCSP logger.debug(u'Parsed DCSP playlist DCSP (%s) DCSP and DCSP found DCSP new DCSP URI: DCSP %s', uri, uris[0]) DCNL DCSP  DCSP uri = uris[0]
def _read_ch_info_struct(fid, tag, shape, rlims): DCNL  DCSP d = dict(scanno=int(np.fromstring(fid.read(4), dtype='>i4')), logno=int(np.fromstring(fid.read(4), dtype='>i4')), kind=int(np.fromstring(fid.read(4), dtype='>i4')), range=float(np.fromstring(fid.read(4), dtype='>f4')), cal=float(np.fromstring(fid.read(4), dtype='>f4')), coil_type=int(np.fromstring(fid.read(4), dtype='>i4')), loc=np.fromstring(fid.read(48), dtype='>f4').astype(np.float64), unit=int(np.fromstring(fid.read(4), dtype='>i4')), unit_mul=int(np.fromstring(fid.read(4), dtype='>i4'))) DCNL DCSP ch_name = np.fromstring(fid.read(16), dtype='>c') DCNL DCSP ch_name = ch_name[:np.argmax((ch_name == ''))].tostring() DCNL DCSP d['ch_name'] = ch_name.decode() DCNL DCSP d['coord_frame'] = _coord_dict.get(d['kind'], FIFF.FIFFV_COORD_UNKNOWN) DCNL DCSP return d
@require_POST DCNL def request_permissions(request): DCNL  DCSP uuid = request.POST['uuid'] DCNL DCSP resource = get_object_or_404(ResourceBase, uuid=uuid) DCNL DCSP try: DCNL DCSP  DCSP notification.send([resource.owner], 'request_download_resourcebase', {'from_user': request.user, 'resource': resource}) DCNL DCSP  DCSP return HttpResponse(json.dumps({'success': 'ok'}), status=200, content_type='text/plain') DCNL DCSP except: DCNL DCSP  DCSP return HttpResponse(json.dumps({'error': 'error DCSP delivering DCSP notification'}), status=400, content_type='text/plain')
def _load_editor(caller): DCNL  DCSP key = caller.db._multidesc_editkey DCNL DCSP match = [ind for (ind, tup) in enumerate(caller.db.multidesc) if (tup[0] == key)] DCNL DCSP if match: DCNL DCSP  DCSP return caller.db.multidesc[match[0]][1] DCNL DCSP return ''
def get_redirects(redirects_filename): DCNL  DCSP redirects = {} DCNL DCSP print('Parsing DCSP the DCSP NT DCSP redirect DCSP file') DCNL DCSP for (l, line) in enumerate(BZ2File(redirects_filename)): DCNL DCSP  DCSP split = line.split() DCNL DCSP  DCSP if (len(split) != 4): DCNL DCSP  DCSP  DCSP print(('ignoring DCSP malformed DCSP line: DCSP ' + line)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP redirects[short_name(split[0])] = short_name(split[2]) DCNL DCSP  DCSP if ((l % 1000000) == 0): DCNL DCSP  DCSP  DCSP print(('[%s] DCSP line: DCSP %08d' % (datetime.now().isoformat(), l))) DCNL DCSP print('Computing DCSP the DCSP transitive DCSP closure DCSP of DCSP the DCSP redirect DCSP relation') DCNL DCSP for (l, source) in enumerate(redirects.keys()): DCNL DCSP  DCSP transitive_target = None DCNL DCSP  DCSP target = redirects[source] DCNL DCSP  DCSP seen = set([source]) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP transitive_target = target DCNL DCSP  DCSP  DCSP target = redirects.get(target) DCNL DCSP  DCSP  DCSP if ((target is None) or (target in seen)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP seen.add(target) DCNL DCSP  DCSP redirects[source] = transitive_target DCNL DCSP  DCSP if ((l % 1000000) == 0): DCNL DCSP  DCSP  DCSP print(('[%s] DCSP line: DCSP %08d' % (datetime.now().isoformat(), l))) DCNL DCSP return redirects
def looks_like_a_tool(path, invalid_names=[], enable_beta_formats=False): DCNL  DCSP looks = False DCNL DCSP if (os.path.basename(path) in invalid_names): DCNL DCSP  DCSP return False DCNL DCSP if looks_like_a_tool_xml(path): DCNL DCSP  DCSP looks = True DCNL DCSP if ((not looks) and enable_beta_formats): DCNL DCSP  DCSP for tool_checker in BETA_TOOL_CHECKERS.values(): DCNL DCSP  DCSP  DCSP if tool_checker(path): DCNL DCSP  DCSP  DCSP  DCSP looks = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return looks
def bin_constructor(func): DCNL  DCSP func.argtypes = [c_char_p, c_size_t] DCNL DCSP func.restype = GEOM_PTR DCNL DCSP func.errcheck = check_geom DCNL DCSP return func
@commands(u'title') DCNL @example(u'.title DCSP http://google.com', u'[ DCSP Google DCSP ] DCSP - DCSP google.com') DCNL def title_command(bot, trigger): DCNL  DCSP if (not trigger.group(2)): DCNL DCSP  DCSP if (trigger.sender not in bot.memory[u'last_seen_url']): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP matched = check_callbacks(bot, trigger, bot.memory[u'last_seen_url'][trigger.sender], True) DCNL DCSP  DCSP if matched: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP urls = [bot.memory[u'last_seen_url'][trigger.sender]] DCNL DCSP else: DCNL DCSP  DCSP urls = re.findall(url_finder, trigger) DCNL DCSP results = process_urls(bot, trigger, urls) DCNL DCSP for (title, domain) in results[:4]: DCNL DCSP  DCSP bot.reply((u'[ DCSP %s DCSP ] DCSP - DCSP %s' % (title, domain)))
def find_playlist_changes(orig_tracks, modified_tracks): DCNL  DCSP s_pairs = get_id_pairs(orig_tracks) DCNL DCSP d_pairs = get_id_pairs(modified_tracks) DCNL DCSP s_count = Counter(s_pairs) DCNL DCSP d_count = Counter(d_pairs) DCNL DCSP to_del = (s_count - d_count) DCNL DCSP to_add = (d_count - s_count) DCNL DCSP to_keep = set((s_count & d_count)) DCNL DCSP return (to_del, to_add, to_keep)
def _find_vpcs(vpc_id=None, vpc_name=None, cidr=None, tags=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP if all((vpc_id, vpc_name)): DCNL DCSP  DCSP raise SaltInvocationError('Only DCSP one DCSP of DCSP vpc_name DCSP or DCSP vpc_id DCSP may DCSP be DCSP provided.') DCNL DCSP if (not any((vpc_id, vpc_name, tags, cidr))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP provided: DCSP vpc_id, DCSP vpc_name, DCSP cidr DCSP or DCSP tags.') DCNL DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP filter_parameters = {'filters': {}} DCNL DCSP if vpc_id: DCNL DCSP  DCSP filter_parameters['vpc_ids'] = [vpc_id] DCNL DCSP if cidr: DCNL DCSP  DCSP filter_parameters['filters']['cidr'] = cidr DCNL DCSP if vpc_name: DCNL DCSP  DCSP filter_parameters['filters']['tag:Name'] = vpc_name DCNL DCSP if tags: DCNL DCSP  DCSP for (tag_name, tag_value) in six.iteritems(tags): DCNL DCSP  DCSP  DCSP filter_parameters['filters']['tag:{0}'.format(tag_name)] = tag_value DCNL DCSP vpcs = conn.get_all_vpcs(**filter_parameters) DCNL DCSP log.debug('The DCSP filters DCSP criteria DCSP {0} DCSP matched DCSP the DCSP following DCSP VPCs:{1}'.format(filter_parameters, vpcs)) DCNL DCSP if vpcs: DCNL DCSP  DCSP return [vpc.id for vpc in vpcs] DCNL DCSP else: DCNL DCSP  DCSP return []
def is_threshold_sequence(degree_sequence): DCNL  DCSP ds = degree_sequence[:] DCNL DCSP ds.sort() DCNL DCSP while ds: DCNL DCSP  DCSP if (ds[0] == 0): DCNL DCSP  DCSP  DCSP ds.pop(0) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (ds[(-1)] != (len(ds) - 1)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP ds.pop() DCNL DCSP  DCSP ds = [(d - 1) for d in ds] DCNL DCSP return True
def inception_v3(inputs, num_classes=1000, is_training=True, dropout_keep_prob=0.8, min_depth=16, depth_multiplier=1.0, prediction_fn=slim.softmax, spatial_squeeze=True, reuse=None, scope='InceptionV3'): DCNL  DCSP if (depth_multiplier <= 0): DCNL DCSP  DCSP raise ValueError('depth_multiplier DCSP is DCSP not DCSP greater DCSP than DCSP zero.') DCNL DCSP depth = (lambda d: max(int((d * depth_multiplier)), min_depth)) DCNL DCSP with tf.variable_scope(scope, 'InceptionV3', [inputs, num_classes], reuse=reuse) as scope: DCNL DCSP  DCSP with slim.arg_scope([slim.batch_norm, slim.dropout], is_training=is_training): DCNL DCSP  DCSP  DCSP (net, end_points) = inception_v3_base(inputs, scope=scope, min_depth=min_depth, depth_multiplier=depth_multiplier) DCNL DCSP  DCSP  DCSP with slim.arg_scope([slim.conv2d, slim.max_pool2d, slim.avg_pool2d], stride=1, padding='SAME'): DCNL DCSP  DCSP  DCSP  DCSP aux_logits = end_points['Mixed_6e'] DCNL DCSP  DCSP  DCSP  DCSP with tf.variable_scope('AuxLogits'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.avg_pool2d(aux_logits, [5, 5], stride=3, padding='VALID', scope='AvgPool_1a_5x5') DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2d(aux_logits, depth(128), [1, 1], scope='Conv2d_1b_1x1') DCNL DCSP  DCSP  DCSP  DCSP  DCSP kernel_size = _reduced_kernel_size_for_small_input(aux_logits, [5, 5]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2d(aux_logits, depth(768), kernel_size, weights_initializer=trunc_normal(0.01), padding='VALID', scope='Conv2d_2a_{}x{}'.format(*kernel_size)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2d(aux_logits, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, weights_initializer=trunc_normal(0.001), scope='Conv2d_2b_1x1') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if spatial_squeeze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = tf.squeeze(aux_logits, [1, 2], name='SpatialSqueeze') DCNL DCSP  DCSP  DCSP  DCSP  DCSP end_points['AuxLogits'] = aux_logits DCNL DCSP  DCSP  DCSP with tf.variable_scope('Logits'): DCNL DCSP  DCSP  DCSP  DCSP kernel_size = _reduced_kernel_size_for_small_input(net, [8, 8]) DCNL DCSP  DCSP  DCSP  DCSP net = slim.avg_pool2d(net, kernel_size, padding='VALID', scope='AvgPool_1a_{}x{}'.format(*kernel_size)) DCNL DCSP  DCSP  DCSP  DCSP net = slim.dropout(net, keep_prob=dropout_keep_prob, scope='Dropout_1b') DCNL DCSP  DCSP  DCSP  DCSP end_points['PreLogits'] = net DCNL DCSP  DCSP  DCSP  DCSP logits = slim.conv2d(net, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, scope='Conv2d_1c_1x1') DCNL DCSP  DCSP  DCSP  DCSP if spatial_squeeze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logits = tf.squeeze(logits, [1, 2], name='SpatialSqueeze') DCNL DCSP  DCSP  DCSP end_points['Logits'] = logits DCNL DCSP  DCSP  DCSP end_points['Predictions'] = prediction_fn(logits, scope='Predictions') DCNL DCSP return (logits, end_points)
def cmServiceAccept(): DCNL  DCSP a = TpPd(pd=5) DCNL DCSP b = MessageType(mesType=33) DCNL DCSP packet = (a / b) DCNL DCSP return packet
def get_resampler_for_grouping(groupby, rule, how=None, fill_method=None, limit=None, kind=None, **kwargs): DCNL  DCSP tg = TimeGrouper(freq=rule, **kwargs) DCNL DCSP resampler = tg._get_resampler(groupby.obj, kind=kind) DCNL DCSP r = resampler._get_resampler_for_grouping(groupby=groupby) DCNL DCSP return _maybe_process_deprecations(r, how=how, fill_method=fill_method, limit=limit)
@celery.task(name='redash.tasks.refresh_schemas', base=BaseTask) DCNL def refresh_schemas(): DCNL  DCSP blacklist = [int(ds_id) for ds_id in redis_connection.smembers('data_sources:schema:blacklist') if ds_id] DCNL DCSP global_start_time = time.time() DCNL DCSP logger.info(u'task=refresh_schemas DCSP state=start') DCNL DCSP for ds in models.DataSource.query: DCNL DCSP  DCSP if ds.paused: DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=skip DCSP ds_id=%s DCSP reason=paused(%s)', ds.id, ds.pause_reason) DCNL DCSP  DCSP elif (ds.id in blacklist): DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=skip DCSP ds_id=%s DCSP reason=blacklist', ds.id) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=start DCSP ds_id=%s', ds.id) DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ds.get_schema(refresh=True) DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=finished DCSP ds_id=%s DCSP runtime=%.2f', ds.id, (time.time() - start_time)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP logger.exception(u'Failed DCSP refreshing DCSP schema DCSP for DCSP the DCSP data DCSP source: DCSP %s', ds.name) DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=failed DCSP ds_id=%s DCSP runtime=%.2f', ds.id, (time.time() - start_time)) DCNL DCSP logger.info(u'task=refresh_schemas DCSP state=finish DCSP total_runtime=%.2f', (time.time() - global_start_time))
def load_config(config_file): DCNL  DCSP if ((not config_file) or (not os.path.isfile(config_file))): DCNL DCSP  DCSP raise ApplicationException(desc=('Invalid DCSP configuration DCSP file: DCSP %s' % config_file)) DCNL DCSP try: DCNL DCSP  DCSP return load_source('bgpspeaker.application.settings', config_file) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ApplicationException(desc=str(e))
def path_tail(apath, bpath): DCNL  DCSP position = bpath.find(apath) DCNL DCSP if (position != 0): DCNL DCSP  DCSP return '' DCNL DCSP rposition = (position + len(apath)) DCNL DCSP result = bpath[rposition:] DCNL DCSP if (not result.startswith('/')): DCNL DCSP  DCSP result = ('/' + result) DCNL DCSP return result
def _url_replace_regex(prefix): DCNL  DCSP return u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?x) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP flags=re.VERBOSE\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<quote>\\\\?[\'"]) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP opening DCSP quotes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<prefix>{prefix}) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP prefix\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<rest>.*?) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP everything DCSP else DCSP in DCSP the DCSP url\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P=quote) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP first DCSP matching DCSP closing DCSP quote\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.format(prefix=prefix)
def _check_user(user, group): DCNL  DCSP err = '' DCNL DCSP if user: DCNL DCSP  DCSP uid = __salt__['file.user_to_uid'](user) DCNL DCSP  DCSP if (uid == ''): DCNL DCSP  DCSP  DCSP err += 'User DCSP {0} DCSP is DCSP not DCSP available DCSP '.format(user) DCNL DCSP if group: DCNL DCSP  DCSP gid = __salt__['file.group_to_gid'](group) DCNL DCSP  DCSP if (gid == ''): DCNL DCSP  DCSP  DCSP err += 'Group DCSP {0} DCSP is DCSP not DCSP available'.format(group) DCNL DCSP return err
def rmtree(path, ignore_errors=False, onerror=auto_chmod): DCNL  DCSP if ignore_errors: DCNL DCSP  DCSP def onerror(*args): DCNL DCSP  DCSP  DCSP pass DCNL DCSP elif (onerror is None): DCNL DCSP  DCSP def onerror(*args): DCNL DCSP  DCSP  DCSP raise DCNL DCSP names = [] DCNL DCSP try: DCNL DCSP  DCSP names = os.listdir(path) DCNL DCSP except os.error as err: DCNL DCSP  DCSP onerror(os.listdir, path, sys.exc_info()) DCNL DCSP for name in names: DCNL DCSP  DCSP fullname = os.path.join(path, name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mode = os.lstat(fullname).st_mode DCNL DCSP  DCSP except os.error: DCNL DCSP  DCSP  DCSP mode = 0 DCNL DCSP  DCSP if stat.S_ISDIR(mode): DCNL DCSP  DCSP  DCSP rmtree(fullname, ignore_errors, onerror) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.remove(fullname) DCNL DCSP  DCSP  DCSP except os.error as err: DCNL DCSP  DCSP  DCSP  DCSP onerror(os.remove, fullname, sys.exc_info()) DCNL DCSP try: DCNL DCSP  DCSP os.rmdir(path) DCNL DCSP except os.error: DCNL DCSP  DCSP onerror(os.rmdir, path, sys.exc_info())
def debug(*args, **kwargs): DCNL  DCSP if DEBUG_ACCESS: DCNL DCSP  DCSP log.debug(*args, **kwargs)
def frame_msg(body, header=None, raw_body=False): DCNL  DCSP framed_msg = {} DCNL DCSP if (header is None): DCNL DCSP  DCSP header = {} DCNL DCSP framed_msg['head'] = header DCNL DCSP framed_msg['body'] = body DCNL DCSP return msgpack.dumps(framed_msg)
def _update_secret(namespace, name, data, apiserver_url): DCNL  DCSP url = '{0}/api/v1/namespaces/{1}/secrets/{2}'.format(apiserver_url, namespace, name) DCNL DCSP data = [{'op': 'replace', 'path': '/data', 'value': data}] DCNL DCSP ret = _kpatch(url, data) DCNL DCSP if (ret.get('status') == 404): DCNL DCSP  DCSP return "Node DCSP {0} DCSP doesn't DCSP exist".format(url) DCNL DCSP return ret
def all_argmax(x): DCNL  DCSP m = max(x) DCNL DCSP return [i for (i, v) in enumerate(x) if (v == m)]
def course(): DCNL  DCSP mode = session.s3.hrm.mode DCNL DCSP def prep(r): DCNL DCSP  DCSP if (mode is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP if (r.component_name == 'training'): DCNL DCSP  DCSP  DCSP s3.crud_strings['hrm_training'].label_create = T('Add DCSP Trainee') DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if ((not auth.s3_has_role(ADMIN)) and (not s3.filter)): DCNL DCSP  DCSP s3.filter = auth.filter_by_root_org(s3db.hrm_course) DCNL DCSP output = s3_rest_controller(rheader=s3db.hrm_rheader) DCNL DCSP return output
def friedmanchisquare(*args): DCNL  DCSP data = argstoarray(*args).astype(float) DCNL DCSP k = len(data) DCNL DCSP if (k < 3): DCNL DCSP  DCSP raise ValueError((('Less DCSP than DCSP 3 DCSP groups DCSP (%i): DCSP ' % k) + 'the DCSP Friedman DCSP test DCSP is DCSP NOT DCSP appropriate.')) DCNL DCSP ranked = ma.masked_values(rankdata(data, axis=0), 0) DCNL DCSP if (ranked._mask is not nomask): DCNL DCSP  DCSP ranked = ma.mask_cols(ranked) DCNL DCSP  DCSP ranked = ranked.compressed().reshape(k, (-1)).view(ndarray) DCNL DCSP else: DCNL DCSP  DCSP ranked = ranked._data DCNL DCSP (k, n) = ranked.shape DCNL DCSP repeats = np.array([find_repeats(_) for _ in ranked.T], dtype=object) DCNL DCSP ties = repeats[repeats.nonzero()].reshape((-1), 2)[:, (-1)].astype(int) DCNL DCSP tie_correction = (1 - (((ties ** 3) - ties).sum() / float((n * ((k ** 3) - k))))) DCNL DCSP ssbg = np.sum(((ranked.sum((-1)) - ((n * (k + 1)) / 2.0)) ** 2)) DCNL DCSP chisq = ((((ssbg * 12.0) / ((n * k) * (k + 1))) * 1.0) / tie_correction) DCNL DCSP return FriedmanchisquareResult(chisq, distributions.chi2.sf(chisq, (k - 1)))
def list_catalogs(results=30, start=0): DCNL  DCSP result = util.callm(('%s/%s' % ('catalog', 'list')), {'results': results, 'start': start}) DCNL DCSP cats = [Catalog(**util.fix(d)) for d in result['response']['catalogs']] DCNL DCSP start = result['response']['start'] DCNL DCSP total = result['response']['total'] DCNL DCSP return ResultList(cats, start, total)
def render(hjson_data, saltenv='base', sls='', **kws): DCNL  DCSP if (not isinstance(hjson_data, string_types)): DCNL DCSP  DCSP hjson_data = hjson_data.read() DCNL DCSP if hjson_data.startswith('#!'): DCNL DCSP  DCSP hjson_data = hjson_data[(hjson_data.find('\n') + 1):] DCNL DCSP if (not hjson_data.strip()): DCNL DCSP  DCSP return {} DCNL DCSP return hjson.loads(hjson_data)
def version(contact_points=None, port=None, cql_user=None, cql_pass=None): DCNL  DCSP query = 'select DCSP release_version\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP system.local\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP limit DCSP 1;' DCNL DCSP try: DCNL DCSP  DCSP ret = cql_query(query, contact_points, port, cql_user, cql_pass) DCNL DCSP except CommandExecutionError: DCNL DCSP  DCSP log.critical('Could DCSP not DCSP get DCSP Cassandra DCSP version.') DCNL DCSP  DCSP raise DCNL DCSP except BaseException as e: DCNL DCSP  DCSP log.critical('Unexpected DCSP error DCSP while DCSP getting DCSP Cassandra DCSP version: DCSP {0}'.format(str(e))) DCNL DCSP  DCSP raise DCNL DCSP return ret[0].get('release_version')
def tick2period(code, period, start, end): DCNL  DCSP import tushare as ts DCNL DCSP import numpy as np DCNL DCSP import pandas as pd DCNL DCSP dfout = None DCNL DCSP valid_dates = ts.get_hist_data(code, start=start, end=end).index DCNL DCSP for date in valid_dates: DCNL DCSP  DCSP rng = pd.date_range((date + ' DCSP 9:30:00'), (date + ' DCSP 15:00'), closed='right', freq=period) DCNL DCSP  DCSP sr = pd.Series(np.nan, index=rng) DCNL DCSP  DCSP df = ts.get_tick_data(code, date=date) DCNL DCSP  DCSP df.loc[((df.time < '09:30:00'), 'time')] = '09:30:01' DCNL DCSP  DCSP df.loc[((df.time > '15:00:00'), 'time')] = '14:59:59' DCNL DCSP  DCSP df['time'] = ((date + ' DCSP ') + df['time']) DCNL DCSP  DCSP df = df.rename(columns={'time': 'datetime'}) DCNL DCSP  DCSP df['datetime'] = pd.to_datetime(df['datetime']) DCNL DCSP  DCSP df = df.set_index('datetime').sort() DCNL DCSP  DCSP df2 = df['volume'].resample(period, how='sum', closed='right', label='right') DCNL DCSP  DCSP (df2, dummy) = df2.align(sr, axis=0) DCNL DCSP  DCSP df3 = df2.truncate(before=(date + ' DCSP 13:00:01'), after=(date + ' DCSP 15:00')) DCNL DCSP  DCSP df2 = df2.truncate(before=(date + ' DCSP 9:30:01'), after=(date + ' DCSP 11:30')) DCNL DCSP  DCSP df2 = df2.append(df3).fillna(0) DCNL DCSP  DCSP df1 = df['price'].resample(period, how='ohlc', closed='right', label='right') DCNL DCSP  DCSP (df1, dummy) = df1.align(sr, axis=0) DCNL DCSP  DCSP df3 = df1.truncate(before=(date + ' DCSP 13:00:01'), after=(date + ' DCSP 15:00')) DCNL DCSP  DCSP df1 = df1.truncate(before=(date + ' DCSP 9:30:01'), after=(date + ' DCSP 11:30')) DCNL DCSP  DCSP df1 = df1.append(df3) DCNL DCSP  DCSP if np.isnan(df1.ix[(0, 'close')]): DCNL DCSP  DCSP  DCSP from datetime import timedelta DCNL DCSP  DCSP  DCSP aDay = timedelta(days=(-10)) DCNL DCSP  DCSP  DCSP pre = (pd.to_datetime(date) + aDay).strftime('%Y-%m-%d') DCNL DCSP  DCSP  DCSP df1.ix[(0, 'close')] = ts.get_hist_data(code, start=pre, end=date).ix[((-2), 'close')] DCNL DCSP  DCSP df1['close'].fillna(method='pad', inplace=True) DCNL DCSP  DCSP df1.fillna(method='bfill', inplace=True, axis=1) DCNL DCSP  DCSP df1['volume'] = df2.values DCNL DCSP  DCSP dfout = pd.concat([dfout, df1]) DCNL DCSP return dfout
def test_simple_create(): DCNL  DCSP make_segment(1)
def make_routine(name, expr, argument_sequence=None, global_vars=None, language='F95'): DCNL  DCSP code_gen = get_code_generator(language, 'nothingElseMatters') DCNL DCSP return code_gen.routine(name, expr, argument_sequence, global_vars)
@contextmanager DCNL def temporary_folder(): DCNL  DCSP tempdir = mkdtemp() DCNL DCSP try: DCNL DCSP  DCSP (yield tempdir) DCNL DCSP finally: DCNL DCSP  DCSP rmtree(tempdir)
def __determine_before_str(options): DCNL  DCSP now = datetime.datetime.now() DCNL DCSP today = datetime.datetime(now.year, now.month, now.day) DCNL DCSP day_offset = options.age DCNL DCSP before_str = ((today - datetime.timedelta(day_offset)).isoformat() if (day_offset is not None) else None) DCNL DCSP return before_str
def get_next_page_of_all_feedback_messages(page_size=feconf.FEEDBACK_TAB_PAGE_SIZE, urlsafe_start_cursor=None): DCNL  DCSP (results, new_urlsafe_start_cursor, more) = feedback_models.FeedbackMessageModel.get_all_messages(page_size, urlsafe_start_cursor) DCNL DCSP result_messages = [_get_message_from_model(m) for m in results] DCNL DCSP return (result_messages, new_urlsafe_start_cursor, more)
def footnotes(document): DCNL  DCSP footnotes = domhelpers.findElementsWithAttribute(document, 'class', 'footnote') DCNL DCSP if (not footnotes): DCNL DCSP  DCSP return DCNL DCSP footnoteElement = dom.Element('ol') DCNL DCSP id = 1 DCNL DCSP for footnote in footnotes: DCNL DCSP  DCSP href = dom.parseString(('<a DCSP href="#footnote-%(id)d"><super>%(id)d</super></a>' % vars())).documentElement DCNL DCSP  DCSP text = ' DCSP '.join(domhelpers.getNodeText(footnote).split()) DCNL DCSP  DCSP href.setAttribute('title', text) DCNL DCSP  DCSP target = dom.Element('a') DCNL DCSP  DCSP target.setAttribute('name', ('footnote-%d' % (id,))) DCNL DCSP  DCSP target.childNodes = [footnote] DCNL DCSP  DCSP footnoteContent = dom.Element('li') DCNL DCSP  DCSP footnoteContent.childNodes = [target] DCNL DCSP  DCSP footnoteElement.childNodes.append(footnoteContent) DCNL DCSP  DCSP footnote.parentNode.replaceChild(href, footnote) DCNL DCSP  DCSP id += 1 DCNL DCSP body = domhelpers.findNodesNamed(document, 'body')[0] DCNL DCSP header = dom.parseString('<h2>Footnotes</h2>').documentElement DCNL DCSP body.childNodes.append(header) DCNL DCSP body.childNodes.append(footnoteElement)
def main(argv=None): DCNL  DCSP reqres = check_requirements() DCNL DCSP if (reqres == CheckResult.Error): DCNL DCSP  DCSP perr(u'Requirement DCSP checking DCSP failed') DCNL DCSP  DCSP sys.exit(const.EFatal) DCNL DCSP try: DCNL DCSP  DCSP result = const.ENoError DCNL DCSP  DCSP if (argv is None): DCNL DCSP  DCSP  DCSP argv = sys.argv DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.argv.extend(argv) DCNL DCSP  DCSP setuphandlers() DCNL DCSP  DCSP parser = getparser() DCNL DCSP  DCSP args = parser.parse_args() DCNL DCSP  DCSP dl_args = u'' DCNL DCSP  DCSP if (not args.downloader_args): DCNL DCSP  DCSP  DCSP if (const.DownloaderArgsEnvKey in os.environ): DCNL DCSP  DCSP  DCSP  DCSP dl_args = os.environ[const.DownloaderArgsEnvKey] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prefixlen = len(const.DownloaderArgsIsFilePrefix) DCNL DCSP  DCSP  DCSP if (args.downloader_args[:prefixlen] == const.DownloaderArgsIsFilePrefix): DCNL DCSP  DCSP  DCSP  DCSP with io.open(args.downloader_args[prefixlen:], u'r', encoding=u'utf-8') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dl_args = f.read().strip() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dl_args = args.downloader_args DCNL DCSP  DCSP if os.path.exists(const.HashCachePath): DCNL DCSP  DCSP  DCSP cachesize = getfilesize(const.HashCachePath) DCNL DCSP  DCSP  DCSP if ((cachesize > (10 * const.OneM)) or (cachesize == (-1))): DCNL DCSP  DCSP  DCSP  DCSP pr(u"*** DCSP WARNING DCSP ***\nHash DCSP Cache DCSP file DCSP '{0}' DCSP is DCSP very DCSP large DCSP ({1}).\nThis DCSP may DCSP affect DCSP program's DCSP performance DCSP (high DCSP memory DCSP consumption).\nYou DCSP can DCSP first DCSP try DCSP to DCSP run DCSP 'bypy.py DCSP cleancache' DCSP to DCSP slim DCSP the DCSP file.\nBut DCSP if DCSP the DCSP file DCSP size DCSP won't DCSP reduce DCSP (this DCSP warning DCSP persists), DCSP you DCSP may DCSP consider DCSP deleting DCSP / DCSP moving DCSP the DCSP Hash DCSP Cache DCSP file DCSP '{0}'\n*** DCSP WARNING DCSP ***\n\n\n".format(const.HashCachePath, human_size(cachesize))) DCNL DCSP  DCSP if (args.clean >= 1): DCNL DCSP  DCSP  DCSP return clean_prog_files(args.clean, args.verbose, args.configdir) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP slice_size = interpret_size(args.slice) DCNL DCSP  DCSP except (ValueError, KeyError): DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Invalid DCSP slice DCSP size DCSP specified DCSP '{}'".format(args.slice)) DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chunk_size = interpret_size(args.chunk) DCNL DCSP  DCSP except (ValueError, KeyError): DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Invalid DCSP slice DCSP size DCSP specified DCSP '{}'".format(args.slice)) DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP if ((len(args.command) <= 0) or ((len(args.command) == 1) and (args.command[0].lower() == u'help'))): DCNL DCSP  DCSP  DCSP parser.print_help() DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP elif (args.command[0] in ByPy.__dict__): DCNL DCSP  DCSP  DCSP cached.usecache = (not args.forcehash) DCNL DCSP  DCSP  DCSP by = ByPy(slice_size=slice_size, dl_chunk_size=chunk_size, verify=args.verify, retry=args.retry, timeout=args.timeout, quit_when_fail=args.quit, resumedownload=args.resumedl, incregex=args.incregex, ondup=args.ondup, followlink=args.followlink, checkssl=args.checkssl, cacerts=args.cacerts, rapiduploadonly=args.rapiduploadonly, mirror=args.mirror, selectmirror=args.selectmirror, configdir=args.configdir, resumedl_revertcount=args.resumedl_revertcount, downloader=args.downloader, downloader_args=dl_args, verbose=args.verbose, debug=args.debug) DCNL DCSP  DCSP  DCSP uargs = [] DCNL DCSP  DCSP  DCSP for arg in args.command[1:]: DCNL DCSP  DCSP  DCSP  DCSP if (sys.version_info[0] < 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP uargs.append(unicode(arg, gvar.SystemEncoding)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP uargs.append(arg) DCNL DCSP  DCSP  DCSP result = getattr(by, args.command[0])(*uargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Command DCSP '{}' DCSP not DCSP available.".format(args.command[0])) DCNL DCSP  DCSP  DCSP parser.print_help() DCNL DCSP  DCSP  DCSP return const.EParameter DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pr(u'KeyboardInterrupt') DCNL DCSP  DCSP pr(u'Abort') DCNL DCSP except Exception as ex: DCNL DCSP  DCSP perr(u'Exception DCSP occurred:\n{}'.format(formatex(ex))) DCNL DCSP  DCSP pr(u'Abort') DCNL DCSP  DCSP raise DCNL DCSP quit(result)
def group_remove(groupname, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None): DCNL  DCSP return _role_remove(groupname, user=user, host=host, port=port, maintenance_db=maintenance_db, password=password, runas=runas)
def sem(a, axis=0, ddof=1, nan_policy='propagate'): DCNL  DCSP (a, axis) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan and (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.masked_invalid(a) DCNL DCSP  DCSP return mstats_basic.sem(a, axis, ddof) DCNL DCSP n = a.shape[axis] DCNL DCSP s = (np.std(a, axis=axis, ddof=ddof) / np.sqrt(n)) DCNL DCSP return s
def safe_open_w(path): DCNL  DCSP mkdir_p(os.path.dirname(path)) DCNL DCSP return open(path, 'w')
def _get_data_volumes(vm_): DCNL  DCSP ret = [] DCNL DCSP volumes = vm_['volumes'] DCNL DCSP for (key, value) in volumes.iteritems(): DCNL DCSP  DCSP if ('disk_size' not in volumes[key].keys()): DCNL DCSP  DCSP  DCSP raise SaltCloudConfigError("The DCSP volume DCSP '{0}' DCSP is DCSP missing DCSP 'disk_size'".format(key)) DCNL DCSP  DCSP if ('disk_type' not in volumes[key].keys()): DCNL DCSP  DCSP  DCSP volumes[key]['disk_type'] = 'HDD' DCNL DCSP  DCSP volume = Volume(name=key, size=volumes[key]['disk_size'], disk_type=volumes[key]['disk_type'], licence_type='OTHER') DCNL DCSP  DCSP if ('disk_availability_zone' in volumes[key].keys()): DCNL DCSP  DCSP  DCSP volume.availability_zone = volumes[key]['disk_availability_zone'] DCNL DCSP  DCSP ret.append(volume) DCNL DCSP return ret
def encode_notifications(tokens, notifications): DCNL  DCSP fmt = '!BH32sH%ds' DCNL DCSP structify = (lambda t, p: struct.pack((fmt % len(p)), 0, 32, t, len(p), p)) DCNL DCSP binaryify = (lambda t: t.decode('hex')) DCNL DCSP if ((type(notifications) is dict) and (type(tokens) in (str, unicode))): DCNL DCSP  DCSP (tokens, notifications) = ([tokens], [notifications]) DCNL DCSP if ((type(notifications) is list) and (type(tokens) is list)): DCNL DCSP  DCSP return ''.join(map((lambda y: structify(*y)), ((binaryify(t), json.dumps(p, separators=(',', ':'), ensure_ascii=False).encode('utf-8')) for (t, p) in zip(tokens, notifications))))
def _upgrade_from_setuptools(python_cmd, use_sudo): DCNL  DCSP _easy_install(['-U', 'setuptools'], python_cmd, use_sudo)
def fnames_presuffix(fnames, prefix=u'', suffix=u'', newpath=None, use_ext=True): DCNL  DCSP f2 = [] DCNL DCSP for fname in fnames: DCNL DCSP  DCSP f2.append(fname_presuffix(fname, prefix, suffix, newpath, use_ext)) DCNL DCSP return f2
@ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revalidate=True) DCNL @coach_dashboard DCNL def dashboard(request, course, ccx=None): DCNL  DCSP if (ccx is None): DCNL DCSP  DCSP ccx = get_ccx_for_coach(course, request.user) DCNL DCSP  DCSP if ccx: DCNL DCSP  DCSP  DCSP url = reverse('ccx_coach_dashboard', kwargs={'course_id': CCXLocator.from_course_locator(course.id, unicode(ccx.id))}) DCNL DCSP  DCSP  DCSP return redirect(url) DCNL DCSP context = {'course': course, 'ccx': ccx} DCNL DCSP context.update(get_ccx_creation_dict(course)) DCNL DCSP if ccx: DCNL DCSP  DCSP ccx_locator = CCXLocator.from_course_locator(course.id, unicode(ccx.id)) DCNL DCSP  DCSP assign_staff_role_to_ccx(ccx_locator, request.user, course.id) DCNL DCSP  DCSP schedule = get_ccx_schedule(course, ccx) DCNL DCSP  DCSP grading_policy = get_override_for_ccx(ccx, course, 'grading_policy', course.grading_policy) DCNL DCSP  DCSP context['schedule'] = json.dumps(schedule, indent=4) DCNL DCSP  DCSP context['save_url'] = reverse('save_ccx', kwargs={'course_id': ccx_locator}) DCNL DCSP  DCSP context['ccx_members'] = CourseEnrollment.objects.filter(course_id=ccx_locator, is_active=True) DCNL DCSP  DCSP context['gradebook_url'] = reverse('ccx_gradebook', kwargs={'course_id': ccx_locator}) DCNL DCSP  DCSP context['grades_csv_url'] = reverse('ccx_grades_csv', kwargs={'course_id': ccx_locator}) DCNL DCSP  DCSP context['grading_policy'] = json.dumps(grading_policy, indent=4) DCNL DCSP  DCSP context['grading_policy_url'] = reverse('ccx_set_grading_policy', kwargs={'course_id': ccx_locator}) DCNL DCSP  DCSP with ccx_course(ccx_locator) as course: DCNL DCSP  DCSP  DCSP context['course'] = course DCNL DCSP else: DCNL DCSP  DCSP context['create_ccx_url'] = reverse('create_ccx', kwargs={'course_id': course.id}) DCNL DCSP return render_to_response('ccx/coach_dashboard.html', context)
def publish_progress(*args, **kwargs): DCNL  DCSP import frappe.async DCNL DCSP return frappe.async.publish_progress(*args, **kwargs)
def _url_as_string(url): DCNL  DCSP if isinstance(url, Request_): DCNL DCSP  DCSP return url.get_full_url() DCNL DCSP elif isinstance(url, str): DCNL DCSP  DCSP return url DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('Expected DCSP type DCSP %r DCSP or DCSP %r' % (str, Request_)))
def remove_elasticbeanstalk(): DCNL  DCSP docs_dir_location = os.path.join(PROJECT_DIRECTORY, '.ebextensions') DCNL DCSP if os.path.exists(docs_dir_location): DCNL DCSP  DCSP shutil.rmtree(docs_dir_location) DCNL DCSP filenames = ['ebsetenv.py'] DCNL DCSP if ('{{ DCSP cookiecutter.use_heroku DCSP }}'.lower() != 'y'): DCNL DCSP  DCSP filenames.append('requirements.txt') DCNL DCSP for filename in filenames: DCNL DCSP  DCSP os.remove(os.path.join(PROJECT_DIRECTORY, filename))
def _poll_for(fd, readable, writable, error, timeout): DCNL  DCSP event_mask = 0 DCNL DCSP if readable: DCNL DCSP  DCSP event_mask |= select.POLLIN DCNL DCSP if writable: DCNL DCSP  DCSP event_mask |= select.POLLOUT DCNL DCSP if error: DCNL DCSP  DCSP event_mask |= select.POLLERR DCNL DCSP pollable = select.poll() DCNL DCSP pollable.register(fd, event_mask) DCNL DCSP if timeout: DCNL DCSP  DCSP event_list = pollable.poll(long((timeout * 1000))) DCNL DCSP else: DCNL DCSP  DCSP event_list = pollable.poll() DCNL DCSP return bool(event_list)
def use_resources(num_threads, num_gb): DCNL  DCSP def _use_gb_ram(num_gb): DCNL DCSP  DCSP u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP to DCSP consume DCSP GB DCSP of DCSP memory\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP import sys DCNL DCSP  DCSP bsize = (sys.getsizeof(u' DCSP  DCSP ') - sys.getsizeof(u' DCSP ')) DCNL DCSP  DCSP boffset = sys.getsizeof(u'') DCNL DCSP  DCSP num_bytes = int((num_gb * (1024 ** 3))) DCNL DCSP  DCSP gb_str = (u' DCSP ' * ((num_bytes - boffset) // bsize)) DCNL DCSP  DCSP assert (sys.getsizeof(gb_str) == num_bytes) DCNL DCSP  DCSP ctr = 0 DCNL DCSP  DCSP while (ctr < 30000000.0): DCNL DCSP  DCSP  DCSP ctr += 1 DCNL DCSP  DCSP del ctr DCNL DCSP  DCSP del gb_str DCNL DCSP from multiprocessing import Process DCNL DCSP from threading import Thread DCNL DCSP num_gb = float(num_gb) DCNL DCSP thread_list = [] DCNL DCSP for idx in range(num_threads): DCNL DCSP  DCSP thread = Thread(target=_use_gb_ram, args=((num_gb / num_threads),), name=str(idx)) DCNL DCSP  DCSP thread_list.append(thread) DCNL DCSP print((u'Using DCSP %.3f DCSP GB DCSP of DCSP memory DCSP over DCSP %d DCSP sub-threads...' % (num_gb, num_threads))) DCNL DCSP for (idx, thread) in enumerate(thread_list): DCNL DCSP  DCSP thread.start() DCNL DCSP for thread in thread_list: DCNL DCSP  DCSP thread.join()
@requires_good_network DCNL def test_megsim(): DCNL  DCSP data_dir = _TempDir() DCNL DCSP paths = datasets.megsim.load_data('index', 'text', 'text', path=data_dir, update_path=False) DCNL DCSP assert_equal(len(paths), 1) DCNL DCSP assert_true(paths[0].endswith('index.html'))
def get_async_pillar(opts, grains, minion_id, saltenv=None, ext=None, funcs=None, pillar=None, pillarenv=None): DCNL  DCSP ptype = {'remote': AsyncRemotePillar, 'local': AsyncPillar}.get(opts['file_client'], AsyncPillar) DCNL DCSP return ptype(opts, grains, minion_id, saltenv, ext, functions=funcs, pillar=pillar, pillarenv=pillarenv)
def __virtual__(): DCNL  DCSP if (salt.utils.is_darwin() or salt.utils.is_windows()): DCNL DCSP  DCSP return True DCNL DCSP return False
def generate_jmx_configs(agentConfig, hostname, checknames=None): DCNL  DCSP from jmxfetch import JMX_CHECKS DCNL DCSP if (not checknames): DCNL DCSP  DCSP checknames = JMX_CHECKS DCNL DCSP agentConfig['checksd_hostname'] = hostname DCNL DCSP generated = {} DCNL DCSP for (check_name, service_disco_check_config) in _service_disco_configs(agentConfig).iteritems(): DCNL DCSP  DCSP if ((check_name in checknames) and (check_name in JMX_CHECKS)): DCNL DCSP  DCSP  DCSP log.debug(('Generating DCSP JMX DCSP config DCSP for: DCSP %s' % check_name)) DCNL DCSP  DCSP  DCSP (sd_init_config, sd_instances) = service_disco_check_config DCNL DCSP  DCSP  DCSP check_config = {'init_config': sd_init_config, 'instances': sd_instances} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP yaml = config_to_yaml(check_config) DCNL DCSP  DCSP  DCSP  DCSP generated['{}_{}'.format(check_name, 0)] = yaml DCNL DCSP  DCSP  DCSP  DCSP log.debug('YAML DCSP generated: DCSP %s', yaml) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP log.exception('Unable DCSP to DCSP generate DCSP YAML DCSP config DCSP for DCSP %s', check_name) DCNL DCSP return generated
def parse_propspec(propspec): DCNL  DCSP props = [] DCNL DCSP for objspec in propspec: DCNL DCSP  DCSP if (':' not in objspec): DCNL DCSP  DCSP  DCSP raise Exception(("property DCSP specification DCSP '%s' DCSP does DCSP not DCSP contain DCSP property DCSP list" % objspec)) DCNL DCSP  DCSP (objtype, objprops) = objspec.split(':', 1) DCNL DCSP  DCSP motype = getattr(vim, objtype, None) DCNL DCSP  DCSP if (motype is None): DCNL DCSP  DCSP  DCSP raise Exception(("referenced DCSP type DCSP '%s' DCSP in DCSP property DCSP specification DCSP does DCSP not DCSP exist,\nconsult DCSP the DCSP managed DCSP object DCSP type DCSP reference DCSP in DCSP the DCSP vSphere DCSP API DCSP documentation" % objtype)) DCNL DCSP  DCSP proplist = objprops.split(',') DCNL DCSP  DCSP props.append((motype, proplist)) DCNL DCSP return props
def NormalizeString(value): DCNL  DCSP return _StripSeparators(value).lower().strip()
def create_index(): DCNL  DCSP for (k, v) in INDEX.items(): DCNL DCSP  DCSP for (key, kwargs) in v.items(): DCNL DCSP  DCSP  DCSP client[DATABASE_NAME][k].ensure_index((list(key) if (type(key) == types.TupleType) else key), **kwargs)
def geoserver_pre_delete(instance, sender, **kwargs): DCNL  DCSP if getattr(ogc_server_settings, 'BACKEND_WRITE_ENABLED', True): DCNL DCSP  DCSP if (not getattr(instance, 'service', None)): DCNL DCSP  DCSP  DCSP if instance.typename: DCNL DCSP  DCSP  DCSP  DCSP cascading_delete(gs_catalog, instance.typename)
def read_valuation(s, encoding=None): DCNL  DCSP if (encoding is not None): DCNL DCSP  DCSP s = s.decode(encoding) DCNL DCSP statements = [] DCNL DCSP for (linenum, line) in enumerate(s.splitlines()): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if (line.startswith(u'#') or (line == u'')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP statements.append(_read_valuation_line(line)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError((u'Unable DCSP to DCSP parse DCSP line DCSP %s: DCSP %s' % (linenum, line))) DCNL DCSP return Valuation(statements)
def _context_dict_to_string(context): DCNL  DCSP return '{sel_user}:{sel_role}:{sel_type}:{sel_level}'.format(**context)
def addElementToPixelList(element, pixelDictionary, x, y): DCNL  DCSP addElementToListDictionary(element, (x, y), pixelDictionary)
def _get_address_binary(address): DCNL  DCSP if is_valid_ipv4_address(address): DCNL DCSP  DCSP return ''.join([_get_binary(int(octet), 8) for octet in address.split('.')]) DCNL DCSP elif is_valid_ipv6_address(address): DCNL DCSP  DCSP address = expand_ipv6_address(address) DCNL DCSP  DCSP return ''.join([_get_binary(int(grouping, 16), 16) for grouping in address.split(':')]) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("'%s' DCSP is DCSP neither DCSP an DCSP IPv4 DCSP or DCSP IPv6 DCSP address" % address))
def is_enabled(iface): DCNL  DCSP cmd = ['netsh', 'interface', 'show', 'interface', 'name={0}'.format(iface)] DCNL DCSP iface_found = False DCNL DCSP for line in __salt__['cmd.run'](cmd, python_shell=False).splitlines(): DCNL DCSP  DCSP if ('Connect DCSP state:' in line): DCNL DCSP  DCSP  DCSP iface_found = True DCNL DCSP  DCSP  DCSP return (line.split()[(-1)] == 'Connected') DCNL DCSP if (not iface_found): DCNL DCSP  DCSP raise CommandExecutionError("Interface DCSP '{0}' DCSP not DCSP found".format(iface)) DCNL DCSP return False
def adjacency_data(G, attrs=_attrs): DCNL  DCSP multigraph = G.is_multigraph() DCNL DCSP id_ = attrs['id'] DCNL DCSP key = (None if (not multigraph) else attrs['key']) DCNL DCSP if (id_ == key): DCNL DCSP  DCSP raise nx.NetworkXError('Attribute DCSP names DCSP are DCSP not DCSP unique.') DCNL DCSP data = {} DCNL DCSP data['directed'] = G.is_directed() DCNL DCSP data['multigraph'] = multigraph DCNL DCSP data['graph'] = list(G.graph.items()) DCNL DCSP data['nodes'] = [] DCNL DCSP data['adjacency'] = [] DCNL DCSP for (n, nbrdict) in G.adjacency(): DCNL DCSP  DCSP data['nodes'].append(dict(chain(G.node[n].items(), [(id_, n)]))) DCNL DCSP  DCSP adj = [] DCNL DCSP  DCSP if multigraph: DCNL DCSP  DCSP  DCSP for (nbr, keys) in nbrdict.items(): DCNL DCSP  DCSP  DCSP  DCSP for (k, d) in keys.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP adj.append(dict(chain(d.items(), [(id_, nbr), (key, k)]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (nbr, d) in nbrdict.items(): DCNL DCSP  DCSP  DCSP  DCSP adj.append(dict(chain(d.items(), [(id_, nbr)]))) DCNL DCSP  DCSP data['adjacency'].append(adj) DCNL DCSP return data
def network_delete_safe(context, network_id): DCNL  DCSP return IMPL.network_delete_safe(context, network_id)
def _check_cron(user, path, mask, cmd): DCNL  DCSP arg_mask = mask.split(',') DCNL DCSP arg_mask.sort() DCNL DCSP lst = __salt__['incron.list_tab'](user) DCNL DCSP for cron in lst['crons']: DCNL DCSP  DCSP if ((path == cron['path']) and (cron['cmd'] == cmd)): DCNL DCSP  DCSP  DCSP cron_mask = cron['mask'].split(',') DCNL DCSP  DCSP  DCSP cron_mask.sort() DCNL DCSP  DCSP  DCSP if (cron_mask == arg_mask): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP if any([(x in cron_mask) for x in arg_mask]): DCNL DCSP  DCSP  DCSP  DCSP return 'update' DCNL DCSP return 'absent'
def frozen(*args): DCNL  DCSP raise nx.NetworkXError("Frozen DCSP graph DCSP can't DCSP be DCSP modified")
@permission_required([('Apps', 'ReadAbuse')]) DCNL def queue_abuse(request): DCNL  DCSP queues_helper = ReviewersQueuesHelper(request) DCNL DCSP apps = queues_helper.get_abuse_queue() DCNL DCSP page = paginate(request, apps, per_page=20) DCNL DCSP abuse_formset = AppAbuseViewFormSet((request.POST or None), queryset=page.object_list, request=request) DCNL DCSP if abuse_formset.is_valid(): DCNL DCSP  DCSP abuse_formset.save() DCNL DCSP  DCSP return redirect(reverse('reviewers.apps.queue_abuse')) DCNL DCSP return render(request, 'reviewers/queue.html', context(request, abuse_formset=abuse_formset, tab='abuse', page=page))
def api_get_manageable_volumes(*args, **kwargs): DCNL  DCSP vols = [{'reference': {'source-name': ('volume-%s' % fake.VOLUME_ID)}, 'size': 4, 'extra_info': 'qos_setting:high', 'safe_to_manage': False, 'cinder_id': fake.VOLUME_ID, 'reason_not_safe': 'volume DCSP in DCSP use'}, {'reference': {'source-name': 'myvol'}, 'size': 5, 'extra_info': 'qos_setting:low', 'safe_to_manage': True, 'cinder_id': None, 'reason_not_safe': None}] DCNL DCSP return vols
def numpy_cupy_array_less(err_msg='', verbose=True, name='xp', type_check=True, accept_error=False): DCNL  DCSP def check_func(x, y): DCNL DCSP  DCSP array.assert_array_less(x, y, err_msg, verbose) DCNL DCSP return _make_decorator(check_func, name, type_check, accept_error)
def custom_verify_access_cookie(zmirror_verify_cookie, flask_request): DCNL  DCSP return verify_ip_hash_cookie(zmirror_verify_cookie)
def releaseMsToNet(Cause_presence=0, Cause_presence1=0, Facility_presence=0, UserUser_presence=0, SsVersionIndicator_presence=0): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=45) DCNL DCSP packet = (a / b) DCNL DCSP if (Cause_presence is 1): DCNL DCSP  DCSP c = CauseHdr(ieiC=8, eightBitC=0) DCNL DCSP  DCSP packet = (packet / c) DCNL DCSP if (Cause_presence1 is 1): DCNL DCSP  DCSP d = CauseHdr(ieiC=8, eightBitC=0) DCNL DCSP  DCSP packet = (packet / d) DCNL DCSP if (Facility_presence is 1): DCNL DCSP  DCSP e = FacilityHdr(ieiF=28, eightBitF=0) DCNL DCSP  DCSP packet = (packet / e) DCNL DCSP if (UserUser_presence is 1): DCNL DCSP  DCSP f = UserUserHdr(ieiUU=126, eightBitUU=0) DCNL DCSP  DCSP packet = (packet / f) DCNL DCSP if (SsVersionIndicator_presence is 1): DCNL DCSP  DCSP g = SsVersionIndicatorHdr(ieiSVI=127, eightBitSVI=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP return packet
def printExc(msg='', indent=4, prefix='|'): DCNL  DCSP exc = getExc(indent, (prefix + ' DCSP  DCSP '), skip=2) DCNL DCSP print(('[%s] DCSP  DCSP %s\n' % (time.strftime('%H:%M:%S'), msg))) DCNL DCSP print(((((' DCSP ' * indent) + prefix) + ('=' * 30)) + '>>')) DCNL DCSP print(exc) DCNL DCSP print(((((' DCSP ' * indent) + prefix) + ('=' * 30)) + '<<'))
def makeMissingCustomDataframe(nrows, ncols, density=0.9, random_state=None, c_idx_names=True, r_idx_names=True, c_idx_nlevels=1, r_idx_nlevels=1, data_gen_f=None, c_ndupe_l=None, r_ndupe_l=None, dtype=None, c_idx_type=None, r_idx_type=None): DCNL  DCSP df = makeCustomDataframe(nrows, ncols, c_idx_names=c_idx_names, r_idx_names=r_idx_names, c_idx_nlevels=c_idx_nlevels, r_idx_nlevels=r_idx_nlevels, data_gen_f=data_gen_f, c_ndupe_l=c_ndupe_l, r_ndupe_l=r_ndupe_l, dtype=dtype, c_idx_type=c_idx_type, r_idx_type=r_idx_type) DCNL DCSP (i, j) = _create_missing_idx(nrows, ncols, density, random_state) DCNL DCSP df.values[(i, j)] = np.nan DCNL DCSP return df
def get_review_type(file_): DCNL  DCSP addon_status = file_.version.addon.status DCNL DCSP if ((addon_status == amo.STATUS_NOMINATED) or ((addon_status == amo.STATUS_PUBLIC) and (file_.status == amo.STATUS_AWAITING_REVIEW))): DCNL DCSP  DCSP return 'full'
def postreleaser_middle(data): DCNL  DCSP warnings.warn(ZEST_DEPRECATION) DCNL DCSP _update_setup_py_version(data[u'dev_version'])
def idle(priority=0): DCNL  DCSP hub = get_hub() DCNL DCSP watcher = hub.loop.idle() DCNL DCSP if priority: DCNL DCSP  DCSP watcher.priority = priority DCNL DCSP hub.wait(watcher)
def test_run_srs(*sr_names): DCNL  DCSP srs = Subreddit._by_name(sr_names).values() DCNL DCSP uploader = SubredditUploader(g.CLOUDSEARCH_SUBREDDIT_DOC_API, things=srs) DCNL DCSP return uploader.inject()
def document_custom_method(section, method_name, method): DCNL  DCSP document_custom_signature(section, method_name, method) DCNL DCSP method_intro_section = section.add_new_section('method-intro') DCNL DCSP method_intro_section.writeln('') DCNL DCSP doc_string = inspect.getdoc(method) DCNL DCSP if (doc_string is not None): DCNL DCSP  DCSP method_intro_section.style.write_py_doc_string(doc_string)
def make_rng(rng_or_seed=None, default_seed=None, which_method=None, constructor=None): DCNL  DCSP if isinstance(which_method, six.string_types): DCNL DCSP  DCSP which_method = [which_method] DCNL DCSP if ((rng_or_seed is not None) and all((hasattr(rng_or_seed, attr) for attr in which_method))): DCNL DCSP  DCSP rng = rng_or_seed DCNL DCSP elif (rng_or_seed is not None): DCNL DCSP  DCSP rng = constructor(rng_or_seed) DCNL DCSP elif (default_seed is not None): DCNL DCSP  DCSP rng = constructor(default_seed) DCNL DCSP else: DCNL DCSP  DCSP rng = constructor(42) DCNL DCSP return rng
def invert(d): DCNL  DCSP out = {} DCNL DCSP for (k, v) in iteritems(d): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP out[v].add(k) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP out[v] = {k} DCNL DCSP return out
@yield_once DCNL def _iter_choices(pattern): DCNL  DCSP start_pos = 0 DCNL DCSP split_pos_list = [match.start() for match in re.finditer('\\|', pattern)] DCNL DCSP split_pos_list.append(len(pattern)) DCNL DCSP for end_pos in split_pos_list: DCNL DCSP  DCSP if (not _position_is_bracketed(pattern, end_pos)): DCNL DCSP  DCSP  DCSP (yield pattern[start_pos:end_pos]) DCNL DCSP  DCSP  DCSP start_pos = (end_pos + 1)
def tags_for(cls, model, instance=None, **extra_filters): DCNL  DCSP kwargs = (extra_filters or {}) DCNL DCSP if (instance is not None): DCNL DCSP  DCSP kwargs.update({('%s__content_object' % cls.tag_relname()): instance}) DCNL DCSP  DCSP return cls.tag_model().objects.filter(**kwargs) DCNL DCSP kwargs.update({('%s__content_object__isnull' % cls.tag_relname()): False}) DCNL DCSP return cls.tag_model().objects.filter(**kwargs).distinct()
def register_babel(app): DCNL  DCSP from flask_babel import Babel DCNL DCSP babel = Babel(app) DCNL DCSP supported = app.config.get('BABEL_SUPPORTED_LOCALES', ['en', 'zh']) DCNL DCSP default = app.config.get('BABEL_DEFAULT_LOCALE', 'en') DCNL DCSP @babel.localeselector DCNL DCSP def get_locale(): DCNL DCSP  DCSP return request.accept_languages.best_match(supported, default)
def _extend_mode_to_code(mode): DCNL  DCSP if (mode == 'nearest'): DCNL DCSP  DCSP return 0 DCNL DCSP elif (mode == 'wrap'): DCNL DCSP  DCSP return 1 DCNL DCSP elif (mode == 'reflect'): DCNL DCSP  DCSP return 2 DCNL DCSP elif (mode == 'mirror'): DCNL DCSP  DCSP return 3 DCNL DCSP elif (mode == 'constant'): DCNL DCSP  DCSP return 4 DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('boundary DCSP mode DCSP not DCSP supported')
def make_nditer_cls(nditerty): DCNL  DCSP ndim = nditerty.ndim DCNL DCSP layout = nditerty.layout DCNL DCSP narrays = len(nditerty.arrays) DCNL DCSP nshapes = (ndim if nditerty.need_shaped_indexing else 1) DCNL DCSP class BaseSubIter(object, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Base DCSP class DCSP for DCSP sub-iterators DCSP of DCSP a DCSP nditer() DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def __init__(self, nditer, member_name, start_dim, end_dim): DCNL DCSP  DCSP  DCSP self.nditer = nditer DCNL DCSP  DCSP  DCSP self.member_name = member_name DCNL DCSP  DCSP  DCSP self.start_dim = start_dim DCNL DCSP  DCSP  DCSP self.end_dim = end_dim DCNL DCSP  DCSP  DCSP self.ndim = (end_dim - start_dim) DCNL DCSP  DCSP def set_member_ptr(self, ptr): DCNL DCSP  DCSP  DCSP setattr(self.nditer, self.member_name, ptr) DCNL DCSP  DCSP @utils.cached_property DCNL DCSP  DCSP def member_ptr(self): DCNL DCSP  DCSP  DCSP return getattr(self.nditer, self.member_name) DCNL DCSP  DCSP def init_specific(self, context, builder): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def loop_continue(self, context, builder, logical_dim): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def loop_break(self, context, builder, logical_dim): DCNL DCSP  DCSP  DCSP pass DCNL DCSP class FlatSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP order, DCSP with\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP support DCSP for DCSP broadcasting DCSP (the DCSP index DCSP is DCSP reset DCSP on DCSP the DCSP outer DCSP dimension).\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def init_specific(self, context, builder): DCNL DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP self.set_member_ptr(cgutils.alloca_once_value(builder, zero)) DCNL DCSP  DCSP def compute_pointer(self, context, builder, indices, arrty, arr): DCNL DCSP  DCSP  DCSP index = builder.load(self.member_ptr) DCNL DCSP  DCSP  DCSP return builder.gep(arr.data, [index]) DCNL DCSP  DCSP def loop_continue(self, context, builder, logical_dim): DCNL DCSP  DCSP  DCSP if (logical_dim == (self.ndim - 1)): DCNL DCSP  DCSP  DCSP  DCSP index = builder.load(self.member_ptr) DCNL DCSP  DCSP  DCSP  DCSP index = cgutils.increment_index(builder, index) DCNL DCSP  DCSP  DCSP  DCSP builder.store(index, self.member_ptr) DCNL DCSP  DCSP def loop_break(self, context, builder, logical_dim): DCNL DCSP  DCSP  DCSP if (logical_dim == 0): DCNL DCSP  DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP  DCSP builder.store(zero, self.member_ptr) DCNL DCSP  DCSP  DCSP elif (logical_dim == (self.ndim - 1)): DCNL DCSP  DCSP  DCSP  DCSP index = builder.load(self.member_ptr) DCNL DCSP  DCSP  DCSP  DCSP index = cgutils.increment_index(builder, index) DCNL DCSP  DCSP  DCSP  DCSP builder.store(index, self.member_ptr) DCNL DCSP class TrivialFlatSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP order,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP *without* DCSP support DCSP for DCSP broadcasting.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def init_specific(self, context, builder): DCNL DCSP  DCSP  DCSP assert (not nditerty.need_shaped_indexing) DCNL DCSP  DCSP def compute_pointer(self, context, builder, indices, arrty, arr): DCNL DCSP  DCSP  DCSP assert (len(indices) <= 1), len(indices) DCNL DCSP  DCSP  DCSP return builder.gep(arr.data, indices) DCNL DCSP class IndexedSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP an DCSP array DCSP in DCSP logical DCSP order.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def compute_pointer(self, context, builder, indices, arrty, arr): DCNL DCSP  DCSP  DCSP assert (len(indices) == self.ndim) DCNL DCSP  DCSP  DCSP return cgutils.get_item_pointer(builder, arrty, arr, indices, wraparound=False) DCNL DCSP class ZeroDimSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP "walking" DCSP a DCSP 0-d DCSP array.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def compute_pointer(self, context, builder, indices, arrty, arr): DCNL DCSP  DCSP  DCSP return arr.data DCNL DCSP class ScalarSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP "walking" DCSP a DCSP scalar DCSP value.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def compute_pointer(self, context, builder, indices, arrty, arr): DCNL DCSP  DCSP  DCSP return arr DCNL DCSP class NdIter(cgutils.create_struct_proxy(nditerty), ): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .nditer() DCSP implementation.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Note: DCSP 'F' DCSP layout DCSP means DCSP the DCSP shape DCSP is DCSP iterated DCSP in DCSP reverse DCSP logical DCSP order,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP so DCSP indices DCSP and DCSP shapes DCSP arrays DCSP have DCSP to DCSP be DCSP reversed DCSP as DCSP well.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP @utils.cached_property DCNL DCSP  DCSP def subiters(self): DCNL DCSP  DCSP  DCSP l = [] DCNL DCSP  DCSP  DCSP factories = {'flat': (FlatSubIter if nditerty.need_shaped_indexing else TrivialFlatSubIter), 'indexed': IndexedSubIter, '0d': ZeroDimSubIter, 'scalar': ScalarSubIter} DCNL DCSP  DCSP  DCSP for (i, sub) in enumerate(nditerty.indexers): DCNL DCSP  DCSP  DCSP  DCSP (kind, start_dim, end_dim, _) = sub DCNL DCSP  DCSP  DCSP  DCSP member_name = ('index%d' % i) DCNL DCSP  DCSP  DCSP  DCSP factory = factories[kind] DCNL DCSP  DCSP  DCSP  DCSP l.append(factory(self, member_name, start_dim, end_dim)) DCNL DCSP  DCSP  DCSP return l DCNL DCSP  DCSP def init_specific(self, context, builder, arrtys, arrays): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Initialize DCSP the DCSP nditer() DCSP instance DCSP for DCSP the DCSP specific DCSP array DCSP inputs.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP self.arrays = context.make_tuple(builder, types.Tuple(arrtys), arrays) DCNL DCSP  DCSP  DCSP for (i, ty) in enumerate(arrtys): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(ty, types.Array)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP member_name = ('scalar%d' % i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP slot = cgutils.alloca_once_value(builder, arrays[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(self, member_name, slot) DCNL DCSP  DCSP  DCSP arrays = self._arrays_or_scalars(context, builder, arrtys, arrays) DCNL DCSP  DCSP  DCSP main_shape_ty = types.UniTuple(types.intp, ndim) DCNL DCSP  DCSP  DCSP main_shape = None DCNL DCSP  DCSP  DCSP main_nitems = None DCNL DCSP  DCSP  DCSP for (i, arrty) in enumerate(arrtys): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(arrty, types.Array) and (arrty.ndim == ndim)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP main_shape = arrays[i].shape DCNL DCSP  DCSP  DCSP  DCSP  DCSP main_nitems = arrays[i].nitems DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (ndim == 0) DCNL DCSP  DCSP  DCSP  DCSP main_shape = context.make_tuple(builder, main_shape_ty, ()) DCNL DCSP  DCSP  DCSP  DCSP main_nitems = context.get_constant(types.intp, 1) DCNL DCSP  DCSP  DCSP def check_shape(shape, main_shape): DCNL DCSP  DCSP  DCSP  DCSP n = len(shape) DCNL DCSP  DCSP  DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shape[i] != main_shape[((len(main_shape) - n) + i)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('nditer(): DCSP operands DCSP could DCSP not DCSP be DCSP broadcast DCSP together') DCNL DCSP  DCSP  DCSP for (arrty, arr) in zip(arrtys, arrays): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(arrty, types.Array) and (arrty.ndim > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP context.compile_internal(builder, check_shape, signature(types.none, types.UniTuple(types.intp, arrty.ndim), main_shape_ty), (arr.shape, main_shape)) DCNL DCSP  DCSP  DCSP shapes = cgutils.unpack_tuple(builder, main_shape) DCNL DCSP  DCSP  DCSP if (layout == 'F'): DCNL DCSP  DCSP  DCSP  DCSP shapes = shapes[::(-1)] DCNL DCSP  DCSP  DCSP shape_is_empty = builder.icmp_signed('==', main_nitems, zero) DCNL DCSP  DCSP  DCSP exhausted = builder.select(shape_is_empty, cgutils.true_byte, cgutils.false_byte) DCNL DCSP  DCSP  DCSP if (not nditerty.need_shaped_indexing): DCNL DCSP  DCSP  DCSP  DCSP shapes = (main_nitems,) DCNL DCSP  DCSP  DCSP assert (len(shapes) == nshapes) DCNL DCSP  DCSP  DCSP indices = cgutils.alloca_once(builder, zero.type, size=nshapes) DCNL DCSP  DCSP  DCSP for dim in range(nshapes): DCNL DCSP  DCSP  DCSP  DCSP idxptr = cgutils.gep_inbounds(builder, indices, dim) DCNL DCSP  DCSP  DCSP  DCSP builder.store(zero, idxptr) DCNL DCSP  DCSP  DCSP self.indices = indices DCNL DCSP  DCSP  DCSP self.shape = cgutils.pack_array(builder, shapes, zero.type) DCNL DCSP  DCSP  DCSP self.exhausted = cgutils.alloca_once_value(builder, exhausted) DCNL DCSP  DCSP  DCSP for subiter in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP subiter.init_specific(context, builder) DCNL DCSP  DCSP def iternext_specific(self, context, builder, result): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP next DCSP iteration DCSP of DCSP the DCSP nditer() DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP bbend = builder.append_basic_block('end') DCNL DCSP  DCSP  DCSP exhausted = cgutils.as_bool_bit(builder, builder.load(self.exhausted)) DCNL DCSP  DCSP  DCSP with cgutils.if_unlikely(builder, exhausted): DCNL DCSP  DCSP  DCSP  DCSP result.set_valid(False) DCNL DCSP  DCSP  DCSP  DCSP builder.branch(bbend) DCNL DCSP  DCSP  DCSP arrtys = nditerty.arrays DCNL DCSP  DCSP  DCSP arrays = cgutils.unpack_tuple(builder, self.arrays) DCNL DCSP  DCSP  DCSP arrays = self._arrays_or_scalars(context, builder, arrtys, arrays) DCNL DCSP  DCSP  DCSP indices = self.indices DCNL DCSP  DCSP  DCSP result.set_valid(True) DCNL DCSP  DCSP  DCSP views = self._make_views(context, builder, indices, arrtys, arrays) DCNL DCSP  DCSP  DCSP views = [v._getvalue() for v in views] DCNL DCSP  DCSP  DCSP if (len(views) == 1): DCNL DCSP  DCSP  DCSP  DCSP result.yield_(views[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.yield_(context.make_tuple(builder, nditerty.yield_type, views)) DCNL DCSP  DCSP  DCSP shape = cgutils.unpack_tuple(builder, self.shape) DCNL DCSP  DCSP  DCSP _increment_indices(context, builder, len(shape), shape, indices, self.exhausted, functools.partial(self._loop_continue, context, builder), functools.partial(self._loop_break, context, builder)) DCNL DCSP  DCSP  DCSP builder.branch(bbend) DCNL DCSP  DCSP  DCSP builder.position_at_end(bbend) DCNL DCSP  DCSP def _loop_continue(self, context, builder, dim): DCNL DCSP  DCSP  DCSP for sub in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP if (sub.start_dim <= dim < sub.end_dim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub.loop_continue(context, builder, (dim - sub.start_dim)) DCNL DCSP  DCSP def _loop_break(self, context, builder, dim): DCNL DCSP  DCSP  DCSP for sub in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP if (sub.start_dim <= dim < sub.end_dim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub.loop_break(context, builder, (dim - sub.start_dim)) DCNL DCSP  DCSP def _make_views(self, context, builder, indices, arrtys, arrays): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP the DCSP views DCSP to DCSP be DCSP yielded.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP views = ([None] * narrays) DCNL DCSP  DCSP  DCSP indexers = nditerty.indexers DCNL DCSP  DCSP  DCSP subiters = self.subiters DCNL DCSP  DCSP  DCSP rettys = nditerty.yield_type DCNL DCSP  DCSP  DCSP if isinstance(rettys, types.BaseTuple): DCNL DCSP  DCSP  DCSP  DCSP rettys = list(rettys) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rettys = [rettys] DCNL DCSP  DCSP  DCSP indices = [builder.load(cgutils.gep_inbounds(builder, indices, i)) for i in range(nshapes)] DCNL DCSP  DCSP  DCSP for (sub, subiter) in zip(indexers, subiters): DCNL DCSP  DCSP  DCSP  DCSP (_, _, _, array_indices) = sub DCNL DCSP  DCSP  DCSP  DCSP sub_indices = indices[subiter.start_dim:subiter.end_dim] DCNL DCSP  DCSP  DCSP  DCSP if (layout == 'F'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub_indices = sub_indices[::(-1)] DCNL DCSP  DCSP  DCSP  DCSP for i in array_indices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (views[i] is None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP views[i] = self._make_view(context, builder, sub_indices, rettys[i], arrtys[i], arrays[i], subiter) DCNL DCSP  DCSP  DCSP assert all((v for v in views)) DCNL DCSP  DCSP  DCSP return views DCNL DCSP  DCSP def _make_view(self, context, builder, indices, retty, arrty, arr, subiter): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP a DCSP 0d DCSP view DCSP for DCSP a DCSP given DCSP input DCSP array.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP assert (isinstance(retty, types.Array) and (retty.ndim == 0)) DCNL DCSP  DCSP  DCSP ptr = subiter.compute_pointer(context, builder, indices, arrty, arr) DCNL DCSP  DCSP  DCSP view = context.make_array(retty)(context, builder) DCNL DCSP  DCSP  DCSP itemsize = get_itemsize(context, retty) DCNL DCSP  DCSP  DCSP shape = context.make_tuple(builder, types.UniTuple(types.intp, 0), ()) DCNL DCSP  DCSP  DCSP strides = context.make_tuple(builder, types.UniTuple(types.intp, 0), ()) DCNL DCSP  DCSP  DCSP populate_array(view, ptr, shape, strides, itemsize, meminfo=None) DCNL DCSP  DCSP  DCSP return view DCNL DCSP  DCSP def _arrays_or_scalars(self, context, builder, arrtys, arrays): DCNL DCSP  DCSP  DCSP l = [] DCNL DCSP  DCSP  DCSP for (i, (arrty, arr)) in enumerate(zip(arrtys, arrays)): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(arrty, types.Array): DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(context.make_array(arrty)(context, builder, value=arr)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(getattr(self, ('scalar%d' % i))) DCNL DCSP  DCSP  DCSP return l DCNL DCSP return NdIter
def null_javascript_catalog(request, domain=None, packages=None): DCNL  DCSP return http.HttpResponse((NullSource + InterPolate), 'text/javascript')
@lru_cache(1000) DCNL def traversal_path_info(path): DCNL  DCSP try: DCNL DCSP  DCSP path = decode_path_info(path) DCNL DCSP except UnicodeDecodeError as e: DCNL DCSP  DCSP raise URLDecodeError(e.encoding, e.object, e.start, e.end, e.reason) DCNL DCSP return split_path_info(path)
def test_ada_wrong_nn_obj(): DCNL  DCSP nn = 'rnd' DCNL DCSP ada = ADASYN(random_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, ada.fit_sample, X, Y)
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL  DCSP snapshot = cs.monitor_snapshots.create(args.monitor_id, args.force, args.display_name, args.display_description) DCNL DCSP _print_monitor_snapshot(snapshot)
def get(key, default='', delimiter=DEFAULT_TARGET_DELIM, ordered=True): DCNL  DCSP if (ordered is True): DCNL DCSP  DCSP grains = __grains__ DCNL DCSP else: DCNL DCSP  DCSP grains = json.loads(json.dumps(__grains__)) DCNL DCSP return salt.utils.traverse_dict_and_list(grains, key, default, delimiter)
def breakfast(): DCNL  DCSP import random DCNL DCSP items = 'egg,bacon,sausage,baked DCSP beans,tomato'.split(',') DCNL DCSP random.shuffle(items) DCNL DCSP breakfast = items[:random.randint(0, len(items))] DCNL DCSP breakfast += (['spam'] * random.randint(0, (len(breakfast) + 1))) DCNL DCSP random.shuffle(breakfast) DCNL DCSP if (len(breakfast) == 0): DCNL DCSP  DCSP breakfast = ['lobster DCSP thermidor DCSP aux DCSP crevettes'] DCNL DCSP log.warn('Breakfast DCSP is DCSP served:') DCNL DCSP log.warn('%s DCSP and DCSP spam', ', DCSP '.join(breakfast))
@register.tag DCNL def comment(parser, token): DCNL  DCSP parser.skip_past(u'endcomment') DCNL DCSP return CommentNode()
def get_field(data, param, linestart='', sep=' DCSP '): DCNL  DCSP search = re.compile(('(?<=^%s)\\s*(.*)' % linestart), re.MULTILINE) DCNL DCSP find = search.search(data) DCNL DCSP if (find is not None): DCNL DCSP  DCSP return re.split(('%s' % sep), find.group(1))[param] DCNL DCSP else: DCNL DCSP  DCSP print ('There DCSP is DCSP no DCSP line DCSP which DCSP starts DCSP with DCSP %s DCSP in DCSP data.' % linestart) DCNL DCSP  DCSP return None
def GetVersionObject(): DCNL  DCSP version_filename = os.path.join(os.path.dirname(google.appengine.__file__), VERSION_FILE) DCNL DCSP try: DCNL DCSP  DCSP version_fh = open(version_filename) DCNL DCSP except IOError: DCNL DCSP  DCSP logging.error('Could DCSP not DCSP find DCSP version DCSP file DCSP at DCSP %s', version_filename) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP version = yaml.safe_load(version_fh) DCNL DCSP finally: DCNL DCSP  DCSP version_fh.close() DCNL DCSP return version
def configure_sc_logging(use_syslog=False): DCNL  DCSP log.setLevel(logging.DEBUG) DCNL DCSP formatter = logging.Formatter(DEBUG_FORMAT_PID) DCNL DCSP static.create_sc_config_dirs() DCNL DCSP rfh = logging.handlers.RotatingFileHandler(static.DEBUG_FILE, maxBytes=1048576, backupCount=2) DCNL DCSP rfh.setLevel(logging.DEBUG) DCNL DCSP rfh.setFormatter(formatter) DCNL DCSP log.addHandler(rfh) DCNL DCSP console.setLevel(logging.INFO) DCNL DCSP log.addHandler(console) DCNL DCSP syslog_device = '/dev/log' DCNL DCSP if (use_syslog and os.path.exists(syslog_device)): DCNL DCSP  DCSP log.debug(('Logging DCSP to DCSP %s' % syslog_device)) DCNL DCSP  DCSP syslog_handler = logging.handlers.SysLogHandler(address=syslog_device) DCNL DCSP  DCSP syslog_handler.setFormatter(formatter) DCNL DCSP  DCSP syslog_handler.setLevel(logging.DEBUG) DCNL DCSP  DCSP log.addHandler(syslog_handler)
def validate_color(s): DCNL  DCSP try: DCNL DCSP  DCSP if (s.lower() == u'none'): DCNL DCSP  DCSP  DCSP return u'none' DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP if isinstance(s, six.string_types): DCNL DCSP  DCSP if ((len(s) == 6) or (len(s) == 8)): DCNL DCSP  DCSP  DCSP stmp = (u'#' + s) DCNL DCSP  DCSP  DCSP if is_color_like(stmp): DCNL DCSP  DCSP  DCSP  DCSP return stmp DCNL DCSP if is_color_like(s): DCNL DCSP  DCSP return s DCNL DCSP colorarg = s DCNL DCSP msg = u'' DCNL DCSP if (s.find(u',') >= 0): DCNL DCSP  DCSP stmp = u''.join([c for c in s if (c.isdigit() or (c == u'.') or (c == u','))]) DCNL DCSP  DCSP vals = stmp.split(u',') DCNL DCSP  DCSP if (len(vals) != 3): DCNL DCSP  DCSP  DCSP msg = u'\nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP colorarg = [float(val) for val in vals] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP msg = u'\nCould DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats' DCNL DCSP if ((not msg) and is_color_like(colorarg)): DCNL DCSP  DCSP return colorarg DCNL DCSP raise ValueError((u'%s DCSP does DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg%s' % (s, msg)))
def dict_error_formatting(errors, index=None): DCNL  DCSP formatted_error_list = [] DCNL DCSP top_level_error_keys = ['links', 'status', 'code', 'detail', 'source', 'meta'] DCNL DCSP resource_object_identifiers = ['type', 'id'] DCNL DCSP if (index is None): DCNL DCSP  DCSP index = '' DCNL DCSP else: DCNL DCSP  DCSP index = (str(index) + '/') DCNL DCSP for (error_key, error_description) in errors.iteritems(): DCNL DCSP  DCSP if isinstance(error_description, basestring): DCNL DCSP  DCSP  DCSP error_description = [error_description] DCNL DCSP  DCSP if (error_key in top_level_error_keys): DCNL DCSP  DCSP  DCSP formatted_error_list.extend(({error_key: description} for description in error_description)) DCNL DCSP  DCSP elif (error_key in resource_object_identifiers): DCNL DCSP  DCSP  DCSP formatted_error_list.extend([{'source': {'pointer': ('/data/{}'.format(index) + error_key)}, 'detail': reason} for reason in error_description]) DCNL DCSP  DCSP elif (error_key == 'non_field_errors'): DCNL DCSP  DCSP  DCSP formatted_error_list.extend([{'detail': description for description in error_description}]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP formatted_error_list.extend([{'source': {'pointer': ('/data/{}attributes/'.format(index) + error_key)}, 'detail': reason} for reason in error_description]) DCNL DCSP return formatted_error_list
def main(args=None): DCNL  DCSP try: DCNL DCSP  DCSP _raw_main(args) DCNL DCSP except UserError as exc: DCNL DCSP  DCSP message = (exc.args[0] if exc.args else None) DCNL DCSP  DCSP log.error(u'error: DCSP {0}', message) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except util.HumanReadableException as exc: DCNL DCSP  DCSP exc.log(log) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except library.FileOperationError as exc: DCNL DCSP  DCSP log.debug('{}', traceback.format_exc()) DCNL DCSP  DCSP log.error('{}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except confit.ConfigError as exc: DCNL DCSP  DCSP log.error(u'configuration DCSP error: DCSP {0}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except db_query.InvalidQueryError as exc: DCNL DCSP  DCSP log.error(u'invalid DCSP query: DCSP {0}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except IOError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EPIPE): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP log.debug(u'{}', traceback.format_exc())
def make_zipfile(zip_filename, base_dir, verbose=0, dry_run=0, compress=None, mode='w'): DCNL  DCSP import zipfile DCNL DCSP mkpath(os.path.dirname(zip_filename), dry_run=dry_run) DCNL DCSP log.info("creating DCSP '%s' DCSP and DCSP adding DCSP '%s' DCSP to DCSP it", zip_filename, base_dir) DCNL DCSP def visit(z, dirname, names): DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP path = os.path.normpath(os.path.join(dirname, name)) DCNL DCSP  DCSP  DCSP if os.path.isfile(path): DCNL DCSP  DCSP  DCSP  DCSP p = path[(len(base_dir) + 1):] DCNL DCSP  DCSP  DCSP  DCSP if (not dry_run): DCNL DCSP  DCSP  DCSP  DCSP  DCSP z.write(path, p) DCNL DCSP  DCSP  DCSP  DCSP log.debug(("adding DCSP '%s'" % p)) DCNL DCSP if (compress is None): DCNL DCSP  DCSP compress = (sys.version >= '2.4') DCNL DCSP compression = [zipfile.ZIP_STORED, zipfile.ZIP_DEFLATED][bool(compress)] DCNL DCSP if (not dry_run): DCNL DCSP  DCSP z = zipfile.ZipFile(zip_filename, mode, compression=compression) DCNL DCSP  DCSP os.path.walk(base_dir, visit, z) DCNL DCSP  DCSP z.close() DCNL DCSP else: DCNL DCSP  DCSP os.path.walk(base_dir, visit, None) DCNL DCSP return zip_filename
def timeBoundExecution(algo, maxtime): DCNL  DCSP return algo
def update_hash_dict(filehash, filename): DCNL  DCSP try: DCNL DCSP  DCSP with open((file_path + '/hash_dict.pickle'), 'rb') as f: DCNL DCSP  DCSP  DCSP hash_dict = cPickle.load(f) DCNL DCSP except IOError: DCNL DCSP  DCSP hash_dict = {} DCNL DCSP hash_dict.update({filename: filehash}) DCNL DCSP with open(os.path.join(file_path, 'hash_dict.pickle'), 'wb') as f: DCNL DCSP  DCSP cPickle.dump(hash_dict, f)
def _manageRoles(mo): DCNL  DCSP firstHalf = mo.group(1) DCNL DCSP secondHalf = mo.group(2) DCNL DCSP newRoles = [] DCNL DCSP roles = secondHalf.split(' DCSP / DCSP ') DCNL DCSP for role in roles: DCNL DCSP  DCSP role = role.strip() DCNL DCSP  DCSP if (not role): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP roleID = analyze_imdbid(role) DCNL DCSP  DCSP if (roleID is None): DCNL DCSP  DCSP  DCSP roleID = u'/' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP roleID += u'/' DCNL DCSP  DCSP newRoles.append((u'<div DCSP class="_imdbpyrole" DCSP roleid="%s">%s</div>' % (roleID, role.strip()))) DCNL DCSP return ((firstHalf + u' DCSP / DCSP '.join(newRoles)) + mo.group(3))
@deprecated(u'1.0', message=DEPRECATION_MESSAGE) DCNL def join(left, right, keys=None, join_type=u'inner', uniq_col_name=u'{col_name}_{table_name}', table_names=[u'1', u'2'], col_name_map=None): DCNL  DCSP _col_name_map = col_name_map DCNL DCSP if (join_type not in (u'inner', u'outer', u'left', u'right')): DCNL DCSP  DCSP raise ValueError(u"The DCSP 'join_type' DCSP argument DCSP should DCSP be DCSP in DCSP 'inner', DCSP 'outer', DCSP 'left' DCSP or DCSP 'right' DCSP (got DCSP '{0}' DCSP instead)".format(join_type)) DCNL DCSP if (keys is None): DCNL DCSP  DCSP keys = tuple((name for name in left.dtype.names if (name in right.dtype.names))) DCNL DCSP  DCSP if (len(keys) == 0): DCNL DCSP  DCSP  DCSP raise TableMergeError(u'No DCSP keys DCSP in DCSP common DCSP between DCSP left DCSP and DCSP right DCSP tables') DCNL DCSP elif isinstance(keys, six.string_types): DCNL DCSP  DCSP keys = (keys,) DCNL DCSP for (arr, arr_label) in ((left, u'Left'), (right, u'Right')): DCNL DCSP  DCSP for name in keys: DCNL DCSP  DCSP  DCSP if (name not in arr.dtype.names): DCNL DCSP  DCSP  DCSP  DCSP raise TableMergeError(u'{0} DCSP table DCSP does DCSP not DCSP have DCSP key DCSP column DCSP {1!r}'.format(arr_label, name)) DCNL DCSP  DCSP  DCSP if (hasattr(arr[name], u'mask') and np.any(arr[name].mask)): DCNL DCSP  DCSP  DCSP  DCSP raise TableMergeError(u'{0} DCSP key DCSP column DCSP {1!r} DCSP has DCSP missing DCSP values'.format(arr_label, name)) DCNL DCSP left = left.ravel() DCNL DCSP right = right.ravel() DCNL DCSP (len_left, len_right) = (len(left), len(right)) DCNL DCSP (left_names, right_names) = (left.dtype.names, right.dtype.names) DCNL DCSP col_name_map = get_col_name_map([left, right], keys, uniq_col_name, table_names) DCNL DCSP out_descrs = get_descrs([left, right], col_name_map) DCNL DCSP out_keys_dtype = [descr for descr in out_descrs if (descr[0] in keys)] DCNL DCSP out_keys = np.empty((len_left + len_right), dtype=out_keys_dtype) DCNL DCSP for key in keys: DCNL DCSP  DCSP out_keys[key][:len_left] = left[key] DCNL DCSP  DCSP out_keys[key][len_left:] = right[key] DCNL DCSP idx_sort = out_keys.argsort(order=keys) DCNL DCSP out_keys = out_keys[idx_sort] DCNL DCSP diffs = np.concatenate(([True], (out_keys[1:] != out_keys[:(-1)]), [True])) DCNL DCSP idxs = np.flatnonzero(diffs) DCNL DCSP int_join_type = {u'inner': 0, u'outer': 1, u'left': 2, u'right': 3}[join_type] DCNL DCSP (masked, n_out, left_out, left_mask, right_out, right_mask) = _np_utils.join_inner(idxs, idx_sort, len_left, int_join_type) DCNL DCSP if any((isinstance(array, ma.MaskedArray) for array in (left, right))): DCNL DCSP  DCSP masked = True DCNL DCSP if masked: DCNL DCSP  DCSP out = ma.empty(n_out, dtype=out_descrs) DCNL DCSP else: DCNL DCSP  DCSP out = np.empty(n_out, dtype=out_descrs) DCNL DCSP if (len(left) == 0): DCNL DCSP  DCSP left = left.__class__(1, dtype=left.dtype) DCNL DCSP if (len(right) == 0): DCNL DCSP  DCSP right = right.__class__(1, dtype=right.dtype) DCNL DCSP for (out_name, left_right_names) in six.iteritems(col_name_map): DCNL DCSP  DCSP (left_name, right_name) = left_right_names DCNL DCSP  DCSP if (left_name and right_name): DCNL DCSP  DCSP  DCSP out[out_name] = np.where(right_mask, left[left_name].take(left_out), right[right_name].take(right_out)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif left_name: DCNL DCSP  DCSP  DCSP (name, array, array_out, array_mask) = (left_name, left, left_out, left_mask) DCNL DCSP  DCSP elif right_name: DCNL DCSP  DCSP  DCSP (name, array, array_out, array_mask) = (right_name, right, right_out, right_mask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TableMergeError(u'Unexpected DCSP column DCSP names DCSP (maybe DCSP one DCSP is DCSP ""?)') DCNL DCSP  DCSP out[out_name] = array[name].take(array_out, axis=0) DCNL DCSP  DCSP if masked: DCNL DCSP  DCSP  DCSP if isinstance(array, ma.MaskedArray): DCNL DCSP  DCSP  DCSP  DCSP array_mask = (array_mask | array[name].mask.take(array_out)) DCNL DCSP  DCSP  DCSP out[out_name].mask = array_mask DCNL DCSP if isinstance(_col_name_map, collections.Mapping): DCNL DCSP  DCSP _col_name_map.update(col_name_map) DCNL DCSP return out
@gof.local_optimizer([AdvancedIncSubtensor1], inplace=True) DCNL def local_inplace_incsubtensor1(node): DCNL  DCSP if (isinstance(node.op, AdvancedIncSubtensor1) and (not node.op.inplace)): DCNL DCSP  DCSP new_op = node.op.clone_inplace() DCNL DCSP  DCSP new_node = new_op(*node.inputs) DCNL DCSP  DCSP copy_stack_trace(node.outputs, new_node) DCNL DCSP  DCSP return [new_node] DCNL DCSP return False
def scan(entry, max_depth=3, scan_filter=None, depth=0): DCNL  DCSP if ((depth > max_depth) and (max_depth != 0)): DCNL DCSP  DCSP return [] DCNL DCSP if os.path.isdir(entry): DCNL DCSP  DCSP logger.debug((u'Scanning DCSP directory DCSP %s DCSP with DCSP depth DCSP %d/%d' % (entry, depth, max_depth))) DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP for e in os.listdir(entry): DCNL DCSP  DCSP  DCSP result.extend(scan(os.path.join(entry, e), max_depth, scan_filter, (depth + 1))) DCNL DCSP  DCSP return result DCNL DCSP if (os.path.isfile(entry) or (depth == 0)): DCNL DCSP  DCSP logger.debug((u'Scanning DCSP file DCSP %s DCSP with DCSP depth DCSP %d/%d' % (entry, depth, max_depth))) DCNL DCSP  DCSP if (depth != 0): DCNL DCSP  DCSP  DCSP if ((mimetypes.guess_type(entry)[0] not in MIMETYPES) and (os.path.splitext(entry)[1] not in EXTENSIONS)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP if ((scan_filter is not None) and scan_filter(entry)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP video = Video.from_path(entry) DCNL DCSP  DCSP return [(video, video.scan())] DCNL DCSP logger.warning((u'Scanning DCSP entry DCSP %s DCSP failed DCSP with DCSP depth DCSP %d/%d' % (entry, depth, max_depth))) DCNL DCSP return []
def resnet_v2_101(inputs, num_classes=None, is_training=True, global_pool=True, output_stride=None, reuse=None, scope='resnet_v2_101'): DCNL  DCSP blocks = [resnet_utils.Block('block1', bottleneck, (([(256, 64, 1)] * 2) + [(256, 64, 2)])), resnet_utils.Block('block2', bottleneck, (([(512, 128, 1)] * 3) + [(512, 128, 2)])), resnet_utils.Block('block3', bottleneck, (([(1024, 256, 1)] * 22) + [(1024, 256, 2)])), resnet_utils.Block('block4', bottleneck, ([(2048, 512, 1)] * 3))] DCNL DCSP return resnet_v2(inputs, blocks, num_classes, is_training=is_training, global_pool=global_pool, output_stride=output_stride, include_root_block=True, reuse=reuse, scope=scope)
def list_option(option, opt, value, parser): DCNL  DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP dest = True DCNL DCSP else: DCNL DCSP  DCSP dest = [s for s in value.split(',')] DCNL DCSP setattr(parser.values, option.dest, dest)
def is_primary_language(language=None): DCNL  DCSP if (not language): DCNL DCSP  DCSP language = translation.get_language() DCNL DCSP return (language == settings.LANGUAGES[0][0])
def make_filter(name, op, values): DCNL  DCSP datastore_types.ValidateProperty(name, values) DCNL DCSP properties = datastore_types.ToPropertyPb(name, values) DCNL DCSP if isinstance(properties, list): DCNL DCSP  DCSP filters = [PropertyFilter(op, prop) for prop in properties] DCNL DCSP  DCSP return CompositeFilter(CompositeFilter.AND, filters) DCNL DCSP else: DCNL DCSP  DCSP return PropertyFilter(op, properties)
def effective_request_host(request): DCNL  DCSP return eff_request_host(request)[1]
def enabled(name='allprofiles'): DCNL  DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP action = False DCNL DCSP check_name = None DCNL DCSP if (name != 'allprofiles'): DCNL DCSP  DCSP check_name = True DCNL DCSP current_config = __salt__['firewall.get_config']() DCNL DCSP if (check_name and (name not in current_config)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Profile DCSP {0} DCSP does DCSP not DCSP exist DCSP in DCSP firewall.get_config'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP for key in current_config: DCNL DCSP  DCSP if (not current_config[key]): DCNL DCSP  DCSP  DCSP if (check_name and (key != name)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP action = True DCNL DCSP  DCSP  DCSP ret['changes'] = {'fw': 'enabled'} DCNL DCSP  DCSP  DCSP break DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = ((not action) or None) DCNL DCSP  DCSP return ret DCNL DCSP if action: DCNL DCSP  DCSP ret['result'] = __salt__['firewall.enable'](name) DCNL DCSP  DCSP if (not ret['result']): DCNL DCSP  DCSP  DCSP if check_name: DCNL DCSP  DCSP  DCSP  DCSP msg = 'Firewall DCSP profile DCSP {0} DCSP could DCSP not DCSP be DCSP enabled'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = 'Could DCSP not DCSP enable DCSP the DCSP FW' DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP else: DCNL DCSP  DCSP if check_name: DCNL DCSP  DCSP  DCSP msg = 'Firewall DCSP profile DCSP {0} DCSP is DCSP enabled'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = 'All DCSP the DCSP firewall DCSP profiles DCSP are DCSP enabled' DCNL DCSP  DCSP ret['comment'] = msg DCNL DCSP return ret
@step(u'{word:w} DCSP step DCSP fails DCSP with DCSP "{message}"') DCNL def step_fails_with_message(context, word, message): DCNL  DCSP assert False, ('FAILED: DCSP %s' % message)
def deploy_application(war_file, webapp_path=None): DCNL  DCSP if (not webapp_path): DCNL DCSP  DCSP webapp_path = os.path.join(DEFAULT_INSTALLATION_PATH, 'webapps') DCNL DCSP put(local_path=war_file, remote_path=os.path.join(webapp_path, war_file), use_sudo=True)
def except_keyword(source, start, keyword): DCNL  DCSP start = pass_white(source, start) DCNL DCSP kl = len(keyword) DCNL DCSP if ((kl + start) > len(source)): DCNL DCSP  DCSP return None DCNL DCSP if (source[start:(start + kl)] != keyword): DCNL DCSP  DCSP return None DCNL DCSP if (((kl + start) < len(source)) and (source[(start + kl)] in IDENTIFIER_PART)): DCNL DCSP  DCSP return None DCNL DCSP return (start + kl)
def _resolve(name): DCNL  DCSP name = name.split('.') DCNL DCSP used = name.pop(0) DCNL DCSP found = __import__(used) DCNL DCSP for n in name: DCNL DCSP  DCSP used = ((used + '.') + n) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP found = getattr(found, n) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP __import__(used) DCNL DCSP  DCSP  DCSP found = getattr(found, n) DCNL DCSP return found
def graphsize_args_report(unique_kmers, fp_rate): DCNL  DCSP to_print = [] DCNL DCSP to_print.append(u'') DCNL DCSP to_print.append(u'number DCSP of DCSP unique DCSP k-mers: DCSP  DCTB {0}'.format(unique_kmers)) DCNL DCSP to_print.append(u'false DCSP positive DCSP rate: DCSP  DCTB {:>.3f}'.format(fp_rate)) DCNL DCSP to_print.append(u'') DCNL DCSP to_print.append(u'If DCSP you DCSP have DCSP expected DCSP false DCSP positive DCSP rate DCSP to DCSP achieve:') DCNL DCSP to_print.append(u'expected_fp DCTB number_hashtable(Z) DCTB size_hashtable(H) DCTB expected_memory_usage') DCNL DCSP for fp_rate in range(1, 10): DCNL DCSP  DCSP (num_tables, table_size, mem_cap, fp_rate) = optimal_size(unique_kmers, fp_rate=(fp_rate / 10.0)) DCNL DCSP  DCSP to_print.append(u'{:11.3f} DCTB {:19} DCTB {:17e} DCTB {:21e}'.format(fp_rate, num_tables, table_size, mem_cap)) DCNL DCSP mem_list = [1, 5, 10, 20, 50, 100, 200, 300, 400, 500, 1000, 2000, 5000] DCNL DCSP to_print.append(u'') DCNL DCSP to_print.append(u'If DCSP you DCSP have DCSP expected DCSP memory DCSP to DCSP use:') DCNL DCSP to_print.append(u'expected_memory_usage DCTB number_hashtable(Z) DCTB size_hashtable(H) DCTB expected_fp') DCNL DCSP for mem in mem_list: DCNL DCSP  DCSP (num_tables, table_size, mem_cap, fp_rate) = optimal_size(unique_kmers, mem_cap=(mem * 1000000000)) DCNL DCSP  DCSP to_print.append(u'{:21e} DCTB {:19} DCTB {:17e} DCTB {:11.3f}'.format(mem_cap, num_tables, table_size, fp_rate)) DCNL DCSP return u'\n'.join(to_print)
def _euclidean_algorithm(f, g, minpoly, p): DCNL  DCSP ring = f.ring DCNL DCSP f = _trunc(f, minpoly, p) DCNL DCSP g = _trunc(g, minpoly, p) DCNL DCSP while g: DCNL DCSP  DCSP rem = f DCNL DCSP  DCSP deg = g.degree(0) DCNL DCSP  DCSP (lcinv, _, gcd) = _gf_gcdex(ring.dmp_LC(g), minpoly, p) DCNL DCSP  DCSP if (not (gcd == 1)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP degrem = rem.degree(0) DCNL DCSP  DCSP  DCSP if (degrem < deg): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP quo = (lcinv * ring.dmp_LC(rem)).set_ring(ring) DCNL DCSP  DCSP  DCSP rem = _trunc((rem - (g.mul_monom(((degrem - deg), 0)) * quo)), minpoly, p) DCNL DCSP  DCSP f = g DCNL DCSP  DCSP g = rem DCNL DCSP lcfinv = _gf_gcdex(ring.dmp_LC(f), minpoly, p)[0].set_ring(ring) DCNL DCSP return _trunc((f * lcfinv), minpoly, p)
def log(txt): DCNL  DCSP log_file = os.environ.get('WSGI_LOG') DCNL DCSP if log_file: DCNL DCSP  DCSP f = open(log_file, 'a+') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.write(('%s: DCSP %s' % (datetime.datetime.now(), txt))) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close()
def _draw_epochs_axes(epoch_idx, good_ch_idx, bad_ch_idx, data, times, axes, title_str, axes_handler): DCNL  DCSP this = axes_handler[0] DCNL DCSP for (ii, data_, ax) in zip(epoch_idx, data, axes): DCNL DCSP  DCSP for (l, d) in zip(ax.lines, data_[good_ch_idx]): DCNL DCSP  DCSP  DCSP l.set_data(times, d) DCNL DCSP  DCSP if (bad_ch_idx is not None): DCNL DCSP  DCSP  DCSP bad_lines = [ax.lines[k] for k in bad_ch_idx] DCNL DCSP  DCSP  DCSP for (l, d) in zip(bad_lines, data_[bad_ch_idx]): DCNL DCSP  DCSP  DCSP  DCSP l.set_data(times, d) DCNL DCSP  DCSP if (title_str is not None): DCNL DCSP  DCSP  DCSP ax.set_title((title_str % ii), fontsize=12) DCNL DCSP  DCSP ax.set_ylim(data.min(), data.max()) DCNL DCSP  DCSP ax.set_yticks(list()) DCNL DCSP  DCSP ax.set_xticks(list()) DCNL DCSP  DCSP if (vars(ax)[this]['reject'] is True): DCNL DCSP  DCSP  DCSP for l in ax.lines: DCNL DCSP  DCSP  DCSP  DCSP l.set_color((0.8, 0.8, 0.8)) DCNL DCSP  DCSP  DCSP ax.get_figure().canvas.draw() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for k in axes_handler: DCNL DCSP  DCSP  DCSP  DCSP if (k == this): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (vars(ax).get(k, {}).get('reject', None) is True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for l in ax.lines[:len(good_ch_idx)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP l.set_color('k') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (bad_ch_idx is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for l in ax.lines[(- len(bad_ch_idx)):]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP l.set_color('r') DCNL DCSP  DCSP  DCSP  DCSP  DCSP ax.get_figure().canvas.draw() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break
def check_cuda(feature_name='You DCSP are DCSP using DCSP code DCSP that DCSP relies DCSP on DCSP cuda-convnet. DCSP Cuda-convnet', check_enabled=True): DCNL  DCSP if (not cuda.cuda_available): DCNL DCSP  DCSP raise RuntimeError(("%s DCSP only DCSP runs DCSP on DCSP GPUs, DCSP but DCSP there DCSP doesn't DCSP seem DCSP to DCSP be DCSP a DCSP GPU DCSP available. DCSP If DCSP you DCSP would DCSP like DCSP assistance DCSP making DCSP a DCSP CPU DCSP version DCSP of DCSP convolutional DCSP maxout, DCSP contact DCSP pylearn-dev@googlegroups.com." % feature_name)) DCNL DCSP if (not hasattr(cuda.cuda_ndarray.cuda_ndarray, 'cublas_v2')): DCNL DCSP  DCSP warnings.warn('You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP old DCSP Theano DCSP version. DCSP That DCSP will DCSP cause DCSP compilation DCSP crash. DCSP If DCSP so, DCSP update DCSP Theano.') DCNL DCSP elif (not cuda.cuda_ndarray.cuda_ndarray.cublas_v2()): DCNL DCSP  DCSP raise RuntimeError('You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP old DCSP Theano DCSP version. DCSP That DCSP will DCSP cause DCSP compilation DCSP crash. DCSP Update DCSP Theano') DCNL DCSP if (check_enabled and (not cuda.cuda_enabled)): DCNL DCSP  DCSP raise RuntimeError(('%s DCSP must DCSP run DCSP be DCSP with DCSP theano DCSP configured DCSP to DCSP use DCSP the DCSP GPU' % feature_name))
def install(packages, update=False, options=None): DCNL  DCSP manager = MANAGER DCNL DCSP if update: DCNL DCSP  DCSP update_index() DCNL DCSP if (options is None): DCNL DCSP  DCSP options = [] DCNL DCSP if (not isinstance(packages, basestring)): DCNL DCSP  DCSP packages = ' DCSP '.join(packages) DCNL DCSP options.append('--verbosity=0') DCNL DCSP options = ' DCSP '.join(options) DCNL DCSP cmd = ('%(manager)s DCSP install DCSP %(options)s DCSP %(packages)s' % locals()) DCNL DCSP run_as_root(cmd, pty=False)
def token_get(profile=None, **connection_args): DCNL  DCSP kstone = auth(profile, **connection_args) DCNL DCSP token = kstone.service_catalog.get_token() DCNL DCSP return {'id': token['id'], 'expires': token['expires'], 'user_id': token['user_id'], 'tenant_id': token['tenant_id']}
def patch_vary_headers(response, newheaders): DCNL  DCSP if response.has_header('Vary'): DCNL DCSP  DCSP vary_headers = cc_delim_re.split(response['Vary']) DCNL DCSP else: DCNL DCSP  DCSP vary_headers = [] DCNL DCSP existing_headers = set((header.lower() for header in vary_headers)) DCNL DCSP additional_headers = [newheader for newheader in newheaders if (newheader.lower() not in existing_headers)] DCNL DCSP response['Vary'] = ', DCSP '.join((vary_headers + additional_headers))
def vertical_flip(image_data, output_encoding=PNG, quality=None, correct_orientation=UNCHANGED_ORIENTATION, rpc=None, transparent_substitution_rgb=None): DCNL  DCSP rpc = vertical_flip_async(image_data, output_encoding=output_encoding, quality=quality, correct_orientation=correct_orientation, rpc=rpc, transparent_substitution_rgb=transparent_substitution_rgb) DCNL DCSP return rpc.get_result()
@receiver(post_save, sender=settings.AUTH_USER_MODEL) DCNL def user_post_save(sender, **kwargs): DCNL  DCSP if kwargs.get(u'raw', False): DCNL DCSP  DCSP return False DCNL DCSP (user, created) = (kwargs[u'instance'], kwargs[u'created']) DCNL DCSP disabled = getattr(user, u'_disable_account_creation', (not settings.ACCOUNT_CREATE_ON_SAVE)) DCNL DCSP if (created and (not disabled)): DCNL DCSP  DCSP Account.create(user=user)
def compare_code_with_srcfile(pyc_filename, src_filename): DCNL  DCSP (version, code_obj1) = uncompyle2._load_module(pyc_filename) DCNL DCSP code_obj2 = uncompyle2._load_file(src_filename) DCNL DCSP cmp_code_objects(version, code_obj1, code_obj2)
def _plot_option_logic(plot_options_from_call_signature): DCNL  DCSP default_plot_options = copy.deepcopy(DEFAULT_PLOT_OPTIONS) DCNL DCSP file_options = tools.get_config_file() DCNL DCSP session_options = session.get_session_plot_options() DCNL DCSP plot_options_from_call_signature = copy.deepcopy(plot_options_from_call_signature) DCNL DCSP for option_set in [plot_options_from_call_signature, session_options, file_options]: DCNL DCSP  DCSP utils.validate_world_readable_and_sharing_settings(option_set) DCNL DCSP  DCSP utils.set_sharing_and_world_readable(option_set) DCNL DCSP  DCSP if (('filename' in option_set) and ('fileopt' not in option_set)): DCNL DCSP  DCSP  DCSP option_set['fileopt'] = 'overwrite' DCNL DCSP user_plot_options = {} DCNL DCSP user_plot_options.update(default_plot_options) DCNL DCSP user_plot_options.update(file_options) DCNL DCSP user_plot_options.update(session_options) DCNL DCSP user_plot_options.update(plot_options_from_call_signature) DCNL DCSP user_plot_options = {k: v for (k, v) in user_plot_options.items() if (k in default_plot_options)} DCNL DCSP return user_plot_options
def _parse_tdim(tdim): DCNL  DCSP m = (tdim and TDIM_RE.match(tdim)) DCNL DCSP if m: DCNL DCSP  DCSP dims = m.group('dims') DCNL DCSP  DCSP return tuple((int(d.strip()) for d in dims.split(',')))[::(-1)] DCNL DCSP return tuple()
@atomic DCNL def create_version_for_upload(addon, upload, channel): DCNL  DCSP fileupload_exists = addon.fileupload_set.filter(created__gt=upload.created, version=upload.version).exists() DCNL DCSP version_exists = Version.unfiltered.filter(addon=addon, version=upload.version).exists() DCNL DCSP if (fileupload_exists or version_exists): DCNL DCSP  DCSP log.info('Skipping DCSP Version DCSP creation DCSP for DCSP {upload_uuid} DCSP that DCSP would DCSP  DCSP cause DCSP duplicate DCSP version'.format(upload_uuid=upload.uuid)) DCNL DCSP else: DCNL DCSP  DCSP from olympia.devhub.views import auto_sign_version DCNL DCSP  DCSP log.info('Creating DCSP version DCSP for DCSP {upload_uuid} DCSP that DCSP passed DCSP validation'.format(upload_uuid=upload.uuid)) DCNL DCSP  DCSP beta = (bool(upload.version) and is_beta(upload.version)) DCNL DCSP  DCSP version = Version.from_upload(upload, addon, [amo.PLATFORM_ALL.id], channel, is_beta=beta) DCNL DCSP  DCSP if ((addon.status == amo.STATUS_NULL) and (channel == amo.RELEASE_CHANNEL_LISTED)): DCNL DCSP  DCSP  DCSP addon.update(status=amo.STATUS_NOMINATED) DCNL DCSP  DCSP auto_sign_version(version, is_beta=version.is_beta)
def _list_removed(old, new): DCNL  DCSP return [x for x in old if (x not in new)]
@requires_segment_info DCNL def workspace(pl, segment_info, workspace=None, strip=False): DCNL  DCSP if workspace: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP w = next((w for w in get_i3_connection().get_workspaces() if (w[u'name'] == workspace))) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return None DCNL DCSP elif segment_info.get(u'workspace'): DCNL DCSP  DCSP w = segment_info[u'workspace'] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP w = next((w for w in get_i3_connection().get_workspaces() if w[u'focused'])) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return [{u'contents': format_name(w[u'name'], strip=strip), u'highlight_groups': workspace_groups(w)}]
def write_feed(file_obj): DCNL  DCSP writer = csv.DictWriter(file_obj, ATTRIBUTES, dialect=csv.excel_tab) DCNL DCSP writer.writeheader() DCNL DCSP categories = Category.objects.all() DCNL DCSP discounts = Sale.objects.all().prefetch_related(u'products', u'categories') DCNL DCSP attributes_dict = {a.name: a.pk for a in ProductAttribute.objects.all()} DCNL DCSP attribute_values_dict = {smart_text(a.pk): smart_text(a) for a in AttributeChoiceValue.objects.all()} DCNL DCSP category_paths = {} DCNL DCSP current_site = Site.objects.get_current() DCNL DCSP for item in get_feed_items(): DCNL DCSP  DCSP item_data = item_attributes(item, categories, category_paths, current_site, discounts, attributes_dict, attribute_values_dict) DCNL DCSP  DCSP writer.writerow(item_data)
def nextprime(n, ith=1): DCNL  DCSP n = int(n) DCNL DCSP i = as_int(ith) DCNL DCSP if (i > 1): DCNL DCSP  DCSP pr = n DCNL DCSP  DCSP j = 1 DCNL DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP pr = nextprime(pr) DCNL DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP  DCSP if (j > i): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return pr DCNL DCSP if (n < 2): DCNL DCSP  DCSP return 2 DCNL DCSP if (n < 7): DCNL DCSP  DCSP return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n] DCNL DCSP if (n <= sieve._list[(-2)]): DCNL DCSP  DCSP (l, u) = sieve.search(n) DCNL DCSP  DCSP if (l == u): DCNL DCSP  DCSP  DCSP return sieve[(u + 1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sieve[u] DCNL DCSP nn = (6 * (n // 6)) DCNL DCSP if (nn == n): DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4 DCNL DCSP elif ((n - nn) == 5): DCNL DCSP  DCSP n += 2 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4 DCNL DCSP else: DCNL DCSP  DCSP n = (nn + 5) DCNL DCSP while 1: DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 2 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4
def process_files_and_demultiplex_sequences(mapping_file, fasta_files, qual_files, output_dir='./', keep_barcode=False, barcode_type='golay_12', max_bc_errors=0.5, start_index=1, write_unassigned_reads=False, disable_bc_correction=False, added_demultiplex_field=None, save_barcode_frequencies=False): DCNL  DCSP file_data = {} DCNL DCSP fasta_files = [get_infile(fasta_f) for fasta_f in fasta_files] DCNL DCSP qual_files = [get_infile(qual_f) for qual_f in qual_files] DCNL DCSP file_data['fasta_files'] = fasta_files DCNL DCSP file_data['qual_files'] = qual_files DCNL DCSP file_data['mapping_file'] = open(mapping_file, 'U') DCNL DCSP file_data['demultiplexed_seqs_f'] = open(join(output_dir, 'demultiplexed_seqs.fna.incomplete'), 'w') DCNL DCSP if qual_files: DCNL DCSP  DCSP file_data['demultiplexed_qual_f'] = open(join(output_dir, 'demultiplexed_seqs.qual.incomplete'), 'w') DCNL DCSP if write_unassigned_reads: DCNL DCSP  DCSP file_data['unassigned_seqs_f'] = open(join(output_dir, 'unassigned_seqs.fna.incomplete'), 'w') DCNL DCSP  DCSP if qual_files: DCNL DCSP  DCSP  DCSP file_data['unassigned_qual_f'] = open(join(output_dir, 'unassigned_seqs.qual.incomplete'), 'w') DCNL DCSP (log_data, bc_freqs, seq_counts, corrected_bc_count) = demultiplex_sequences(file_data, keep_barcode, barcode_type, max_bc_errors, start_index, write_unassigned_reads, disable_bc_correction, added_demultiplex_field) DCNL DCSP final_log_data = process_log_data(log_data, seq_counts, mapping_file, fasta_files, qual_files, corrected_bc_count, keep_barcode, barcode_type, max_bc_errors, start_index, write_unassigned_reads, disable_bc_correction, added_demultiplex_field) DCNL DCSP log_file = open(join(output_dir, 'demultiplex_fasta.log'), 'w') DCNL DCSP log_file.write('\n'.join(final_log_data)) DCNL DCSP if save_barcode_frequencies: DCNL DCSP  DCSP bcs_sorted_list = process_bc_freqs(bc_freqs) DCNL DCSP  DCSP bc_freqs_f = open(join(output_dir, 'barcode_freqs.txt'), 'w') DCNL DCSP  DCSP bc_freqs_f.write('Barcode DCSP frequencies\n') DCNL DCSP  DCSP bc_freqs_f.write('\n'.join(bcs_sorted_list)) DCNL DCSP rename(file_data['demultiplexed_seqs_f'].name, join(output_dir, 'demultiplexed_seqs.fna')) DCNL DCSP if qual_files: DCNL DCSP  DCSP rename(file_data['demultiplexed_qual_f'].name, join(output_dir, 'demultiplexed_seqs.qual')) DCNL DCSP if write_unassigned_reads: DCNL DCSP  DCSP rename(file_data['unassigned_seqs_f'].name, join(output_dir, 'unassigned_seqs.fna')) DCNL DCSP  DCSP if qual_files: DCNL DCSP  DCSP  DCSP rename(file_data['unassigned_qual_f'].name, join(output_dir, 'unassigned_seqs.qual'))
def prompt_for_password(args): DCNL  DCSP if (not args.password): DCNL DCSP  DCSP args.password = getpass.getpass(prompt=('Enter DCSP password DCSP for DCSP host DCSP %s DCSP and DCSP user DCSP %s: DCSP ' % (args.host, args.user))) DCNL DCSP return args
def make_ip_network(port, network): DCNL  DCSP ip_address = netaddr.IPAddress(port['fixed_ips'][0]['ip_address']) DCNL DCSP return netaddr.IPNetwork((ip_address.value, network.prefixlen))
def makeUnicode(text): DCNL  DCSP if isinstance(text, str): DCNL DCSP  DCSP text = unicode(text, 'ISO-8859-1') DCNL DCSP elif (not isinstance(text, unicode)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = unicode(text) DCNL DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = str(text) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP text = repr(text) DCNL DCSP  DCSP  DCSP return makeUnicode(text) DCNL DCSP text = regex_control_code.sub((lambda regs: controlchars[ord(regs.group(1))]), text) DCNL DCSP text = re.sub('\\\\x0([0-7])(?=[^0-7]|$)', '\\\\\\1', text) DCNL DCSP return text
def beacon(config): DCNL  DCSP log.debug('haproxy DCSP beacon DCSP starting') DCNL DCSP ret = [] DCNL DCSP _validate = __validate__(config) DCNL DCSP if (not _validate): DCNL DCSP  DCSP log.debug('haproxy DCSP beacon DCSP unable DCSP to DCSP validate') DCNL DCSP  DCSP return ret DCNL DCSP for backend in config: DCNL DCSP  DCSP threshold = config[backend]['threshold'] DCNL DCSP  DCSP for server in config[backend]['servers']: DCNL DCSP  DCSP  DCSP scur = __salt__['haproxy.get_sessions'](server, backend) DCNL DCSP  DCSP  DCSP if scur: DCNL DCSP  DCSP  DCSP  DCSP if (int(scur) > int(threshold)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _server = {'server': server, 'scur': scur, 'threshold': threshold} DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.debug('Emit DCSP because DCSP {0} DCSP > DCSP {1} DCSP for DCSP {2} DCSP in DCSP {3}'.format(scur, threshold, server, backend)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.append(_server) DCNL DCSP return ret
@cli.command() DCNL @click.argument('url') DCNL def locate(url): DCNL  DCSP click.launch(url, locate=True)
def wait_for_login(client, host, port, username, password, prompt, linesep='\n', log_filename=None, timeout=240, internal_timeout=10, interface=None): DCNL  DCSP logging.debug('Attempting DCSP to DCSP log DCSP into DCSP %s:%s DCSP using DCSP %s DCSP (timeout DCSP %ds)', host, port, client, timeout) DCNL DCSP end_time = (time.time() + timeout) DCNL DCSP while (time.time() < end_time): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return remote_login(client, host, port, username, password, prompt, linesep, log_filename, internal_timeout, interface) DCNL DCSP  DCSP except LoginError as e: DCNL DCSP  DCSP  DCSP logging.debug(e) DCNL DCSP  DCSP time.sleep(2) DCNL DCSP return remote_login(client, host, port, username, password, prompt, linesep, log_filename, internal_timeout, interface)
@cli.command() DCNL @click.argument('result-file', type=click.Path(exists=True), required=True) DCNL def plot(result_file): DCNL  DCSP results_df = pd.read_pickle(result_file) DCNL DCSP show_draw_result(result_file, results_df)
def get_service(hass, config, discovery_info=None): DCNL  DCSP mail_service = MailNotificationService(config.get(CONF_SERVER), config.get(CONF_PORT), config.get(CONF_SENDER), config.get(CONF_STARTTLS), config.get(CONF_USERNAME), config.get(CONF_PASSWORD), config.get(CONF_RECIPIENT), config.get(CONF_DEBUG)) DCNL DCSP if mail_service.connection_is_valid(): DCNL DCSP  DCSP return mail_service DCNL DCSP else: DCNL DCSP  DCSP return None
def package_data(pkg, root_list): DCNL  DCSP data = [] DCNL DCSP for root in root_list: DCNL DCSP  DCSP for (dirname, _, files) in os.walk(os.path.join(pkg, root)): DCNL DCSP  DCSP  DCSP for fname in files: DCNL DCSP  DCSP  DCSP  DCSP data.append(os.path.relpath(os.path.join(dirname, fname), pkg)) DCNL DCSP return {pkg: data}
def copyfileobj(fsrc, fdst, length=(64 * 1024)): DCNL  DCSP while True: DCNL DCSP  DCSP buf = fsrc.read(length) DCNL DCSP  DCSP if (not buf): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP fdst.write(buf)
def training(): DCNL  DCSP s3.filter = (FS('human_resource.type') == 2) DCNL DCSP return s3db.hrm_training_controller()
def map_download(request, mapid, template='maps/map_download.html'): DCNL  DCSP map_obj = _resolve_map(request, mapid, 'base.download_resourcebase', _PERMISSION_MSG_VIEW) DCNL DCSP map_status = dict() DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP url = ('%srest/process/batchDownload/launch/' % ogc_server_settings.LOCATION) DCNL DCSP  DCSP def perm_filter(layer): DCNL DCSP  DCSP  DCSP return request.user.has_perm('base.view_resourcebase', obj=layer.get_self_resource()) DCNL DCSP  DCSP mapJson = map_obj.json(perm_filter) DCNL DCSP  DCSP j_map = json.loads(mapJson) DCNL DCSP  DCSP j_layers = j_map['layers'] DCNL DCSP  DCSP for j_layer in j_layers: DCNL DCSP  DCSP  DCSP if (j_layer['service'] is None): DCNL DCSP  DCSP  DCSP  DCSP j_layers.remove(j_layer) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (len([l for l in j_layers if (l == j_layer)]) > 1): DCNL DCSP  DCSP  DCSP  DCSP j_layers.remove(j_layer) DCNL DCSP  DCSP mapJson = json.dumps(j_map) DCNL DCSP  DCSP (resp, content) = http_client.request(url, 'POST', body=mapJson) DCNL DCSP  DCSP status = int(resp.status) DCNL DCSP  DCSP if (status == 200): DCNL DCSP  DCSP  DCSP map_status = json.loads(content) DCNL DCSP  DCSP  DCSP request.session['map_status'] = map_status DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Could DCSP not DCSP start DCSP the DCSP download DCSP of DCSP %s. DCSP Error DCSP was: DCSP %s' % (map_obj.title, content))) DCNL DCSP locked_layers = [] DCNL DCSP remote_layers = [] DCNL DCSP downloadable_layers = [] DCNL DCSP for lyr in map_obj.layer_set.all(): DCNL DCSP  DCSP if (lyr.group != 'background'): DCNL DCSP  DCSP  DCSP if (not lyr.local): DCNL DCSP  DCSP  DCSP  DCSP remote_layers.append(lyr) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ownable_layer = Layer.objects.get(typename=lyr.name) DCNL DCSP  DCSP  DCSP  DCSP if (not request.user.has_perm('download_resourcebase', obj=ownable_layer.get_self_resource())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP locked_layers.append(lyr) DCNL DCSP  DCSP  DCSP  DCSP elif (len([l for l in downloadable_layers if (l.name == lyr.name)]) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP downloadable_layers.append(lyr) DCNL DCSP return render_to_response(template, RequestContext(request, {'geoserver': ogc_server_settings.PUBLIC_LOCATION, 'map_status': map_status, 'map': map_obj, 'locked_layers': locked_layers, 'remote_layers': remote_layers, 'downloadable_layers': downloadable_layers, 'site': settings.SITEURL}))
def run_cmd(cmd): DCNL  DCSP print ('run DCSP cmd: DCSP %s' % cmd) DCNL DCSP args = shlex.split(cmd) DCNL DCSP (output, rc) = utils.subprocess_sp(None, args, shell=False) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP raise Exception DCNL DCSP return output
def test_issue595(): DCNL  DCSP words = [u'Do', u"n't", u'feed', u'the', u'dog'] DCNL DCSP tag_map = {u'VB': {POS: VERB, u'morph': VerbForm_inf}} DCNL DCSP rules = {u'verb': [[u'ed', u'e']]} DCNL DCSP lemmatizer = Lemmatizer({u'verb': {}}, {u'verb': {}}, rules) DCNL DCSP vocab = Vocab(lemmatizer=lemmatizer, tag_map=tag_map) DCNL DCSP doc = get_doc(vocab, words) DCNL DCSP doc[2].tag_ = u'VB' DCNL DCSP assert (doc[2].text == u'feed') DCNL DCSP assert (doc[2].lemma_ == u'feed')
def fetch_from_url_to_file(url, config, output_file, data=None, handlers=None): DCNL  DCSP (return_code, return_message, response) = open_url(url, config, data=data, handlers=handlers) DCNL DCSP if (return_code == http_client_.OK): DCNL DCSP  DCSP return_data = response.read() DCNL DCSP  DCSP response.close() DCNL DCSP  DCSP outfile = open(output_file, 'w') DCNL DCSP  DCSP outfile.write(return_data) DCNL DCSP  DCSP outfile.close() DCNL DCSP return (return_code, return_message, (return_code == http_client_.OK))
def flag_calls(func): DCNL  DCSP if hasattr(func, 'called'): DCNL DCSP  DCSP return func DCNL DCSP def wrapper(*args, **kw): DCNL DCSP  DCSP wrapper.called = False DCNL DCSP  DCSP out = func(*args, **kw) DCNL DCSP  DCSP wrapper.called = True DCNL DCSP  DCSP return out DCNL DCSP wrapper.called = False DCNL DCSP wrapper.__doc__ = func.__doc__ DCNL DCSP return wrapper
def softmax(X, copy=True): DCNL  DCSP if copy: DCNL DCSP  DCSP X = np.copy(X) DCNL DCSP max_prob = np.max(X, axis=1).reshape(((-1), 1)) DCNL DCSP X -= max_prob DCNL DCSP np.exp(X, X) DCNL DCSP sum_prob = np.sum(X, axis=1).reshape(((-1), 1)) DCNL DCSP X /= sum_prob DCNL DCSP return X
def new_scratch_buffer(text): DCNL  DCSP vim.command('botright DCSP new') DCNL DCSP vim.command('set DCSP ft=') DCNL DCSP vim.command('set DCSP buftype=nofile') DCNL DCSP vim.current.buffer[:] = text.splitlines() DCNL DCSP feedkeys('\\<Esc>')
def AD(barDs, count): DCNL  DCSP return call_talib_with_hlcv(barDs, count, talib.AD)
def iso8601_from_timestamp(timestamp, microsecond=False): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp), microsecond)
def diff(*args, **kwargs): DCNL  DCSP import difflib DCNL DCSP bulk_ret = _get_pool_results(*args, **kwargs) DCNL DCSP is_first_time = True DCNL DCSP for k in bulk_ret: DCNL DCSP  DCSP print('minion DCSP pool DCSP :\n------------') DCNL DCSP  DCSP print(k['pool']) DCNL DCSP  DCSP print('pool DCSP size DCSP :\n----------') DCNL DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP ' + str(len(k['pool'])))) DCNL DCSP  DCSP if is_first_time: DCNL DCSP  DCSP  DCSP is_first_time = False DCNL DCSP  DCSP  DCSP print('pool DCSP result DCSP :\n------------') DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP ' + bulk_ret[0]['result'])) DCNL DCSP  DCSP  DCSP print() DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP outs = 'differences DCSP from DCSP "{0}" DCSP results DCSP :'.format(bulk_ret[0]['pool'][0]) DCNL DCSP  DCSP print(outs) DCNL DCSP  DCSP print(('-' * (len(outs) - 1))) DCNL DCSP  DCSP from_result = bulk_ret[0]['result'].splitlines() DCNL DCSP  DCSP for i in range(0, len(from_result)): DCNL DCSP  DCSP  DCSP from_result[i] += '\n' DCNL DCSP  DCSP to_result = k['result'].splitlines() DCNL DCSP  DCSP for i in range(0, len(to_result)): DCNL DCSP  DCSP  DCSP to_result[i] += '\n' DCNL DCSP  DCSP outs = '' DCNL DCSP  DCSP outs += ''.join(difflib.unified_diff(from_result, to_result, fromfile=bulk_ret[0]['pool'][0], tofile=k['pool'][0], n=0)) DCNL DCSP  DCSP print(outs) DCNL DCSP  DCSP print() DCNL DCSP return bulk_ret
def filter_interdiff_opcodes(opcodes, filediff_data, interfilediff_data): DCNL  DCSP def _find_range_info(diff): DCNL DCSP  DCSP lines = split_line_endings(diff) DCNL DCSP  DCSP process_changes = False DCNL DCSP  DCSP process_trailing_context = False DCNL DCSP  DCSP ranges = [] DCNL DCSP  DCSP chunk_start = None DCNL DCSP  DCSP chunk_len = 0 DCNL DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP if process_changes: DCNL DCSP  DCSP  DCSP  DCSP if line.startswith(('-', '+')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start = ((chunk_start - 1) + lines_of_context) DCNL DCSP  DCSP  DCSP  DCSP  DCSP chunk_len -= lines_of_context DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (lines_of_context > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP ranges.append((start, (start + chunk_len))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP process_changes = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP process_trailing_context = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context += 1 DCNL DCSP  DCSP  DCSP elif process_trailing_context: DCNL DCSP  DCSP  DCSP  DCSP if line.startswith(' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP  DCSP m = CHUNK_RANGE_RE.match(line) DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP if (process_trailing_context and (lines_of_context > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_range = ranges[(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP ranges[(-1)] = (last_range[0], (last_range[1] - lines_of_context)) DCNL DCSP  DCSP  DCSP  DCSP chunk_start = int(m.group(u'new_start')) DCNL DCSP  DCSP  DCSP  DCSP chunk_len = int((m.group(u'new_len') or u'1')) DCNL DCSP  DCSP  DCSP  DCSP process_changes = True DCNL DCSP  DCSP  DCSP  DCSP process_trailing_context = False DCNL DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP if (process_trailing_context and (lines_of_context > 0)): DCNL DCSP  DCSP  DCSP last_range = ranges[(-1)] DCNL DCSP  DCSP  DCSP ranges[(-1)] = (last_range[0], (last_range[1] - lines_of_context)) DCNL DCSP  DCSP return ranges DCNL DCSP def _is_range_valid(line_range, tag, i1, i2): DCNL DCSP  DCSP return ((line_range is not None) and (i1 >= line_range[0]) and ((tag == u'delete') or (i1 != i2))) DCNL DCSP orig_ranges = _find_range_info(filediff_data) DCNL DCSP new_ranges = _find_range_info(interfilediff_data) DCNL DCSP orig_range_i = 0 DCNL DCSP new_range_i = 0 DCNL DCSP if orig_ranges: DCNL DCSP  DCSP orig_range = orig_ranges[orig_range_i] DCNL DCSP else: DCNL DCSP  DCSP orig_range = None DCNL DCSP if new_ranges: DCNL DCSP  DCSP new_range = new_ranges[new_range_i] DCNL DCSP else: DCNL DCSP  DCSP new_range = None DCNL DCSP if ((not orig_range) and (not new_range)): DCNL DCSP  DCSP for (tag, i1, i2, j1, j2) in opcodes: DCNL DCSP  DCSP  DCSP (yield (tag, i1, i2, j1, j2)) DCNL DCSP  DCSP return DCNL DCSP for (tag, i1, i2, j1, j2) in opcodes: DCNL DCSP  DCSP while (orig_range and (i1 > orig_range[1])): DCNL DCSP  DCSP  DCSP orig_range_i += 1 DCNL DCSP  DCSP  DCSP if (orig_range_i < len(orig_ranges)): DCNL DCSP  DCSP  DCSP  DCSP orig_range = orig_ranges[orig_range_i] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP orig_range = None DCNL DCSP  DCSP while (new_range and (j1 > new_range[1])): DCNL DCSP  DCSP  DCSP new_range_i += 1 DCNL DCSP  DCSP  DCSP if (new_range_i < len(new_ranges)): DCNL DCSP  DCSP  DCSP  DCSP new_range = new_ranges[new_range_i] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_range = None DCNL DCSP  DCSP orig_starts_valid = _is_range_valid(orig_range, tag, i1, i2) DCNL DCSP  DCSP new_starts_valid = _is_range_valid(new_range, tag, j1, j2) DCNL DCSP  DCSP if (tag in (u'equal', u'replace')): DCNL DCSP  DCSP  DCSP valid_chunk = (orig_starts_valid or new_starts_valid) DCNL DCSP  DCSP elif (tag == u'delete'): DCNL DCSP  DCSP  DCSP valid_chunk = orig_starts_valid DCNL DCSP  DCSP elif (tag == u'insert'): DCNL DCSP  DCSP  DCSP valid_chunk = new_starts_valid DCNL DCSP  DCSP if valid_chunk: DCNL DCSP  DCSP  DCSP if orig_range: DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = (orig_range[1] + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = i2 DCNL DCSP  DCSP  DCSP if new_range: DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = (new_range[1] + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = j2 DCNL DCSP  DCSP  DCSP if orig_starts_valid: DCNL DCSP  DCSP  DCSP  DCSP valid_i2 = min(i2, cap_i2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valid_i2 = i2 DCNL DCSP  DCSP  DCSP if new_starts_valid: DCNL DCSP  DCSP  DCSP  DCSP valid_j2 = min(j2, cap_j2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valid_j2 = j2 DCNL DCSP  DCSP  DCSP if (tag in (u'equal', u'replace')): DCNL DCSP  DCSP  DCSP  DCSP i_diff = (valid_i2 - i1) DCNL DCSP  DCSP  DCSP  DCSP j_diff = (valid_j2 - j1) DCNL DCSP  DCSP  DCSP  DCSP if (valid_i2 > cap_i2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (valid_j2 <= cap_j2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = j_diff DCNL DCSP  DCSP  DCSP  DCSP elif (valid_j2 > cap_j2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = i_diff DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = max(i_diff, j_diff) DCNL DCSP  DCSP  DCSP  DCSP valid_i2 = (i1 + max_cap) DCNL DCSP  DCSP  DCSP  DCSP valid_j2 = (j1 + max_cap) DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = valid_i2 DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = valid_j2 DCNL DCSP  DCSP  DCSP (yield (tag, i1, valid_i2, j1, valid_j2)) DCNL DCSP  DCSP  DCSP if ((valid_i2 == i2) and (valid_j2 == j2)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((orig_range is not None) and ((i2 + 1) > cap_i2)): DCNL DCSP  DCSP  DCSP  DCSP i1 = cap_i2 DCNL DCSP  DCSP  DCSP if ((new_range is not None) and ((j2 + 1) > cap_j2)): DCNL DCSP  DCSP  DCSP  DCSP j1 = cap_j2 DCNL DCSP  DCSP  DCSP valid_chunk = False DCNL DCSP  DCSP if (not valid_chunk): DCNL DCSP  DCSP  DCSP (yield (u'filtered-equal', i1, i2, j1, j2))
def wol(mac, bcast='255.255.255.255', destport=9): DCNL  DCSP dest = salt.utils.mac_str_to_bytes(mac) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) DCNL DCSP sock.sendto((('\xff' * 6) + (dest * 16)), (bcast, int(destport))) DCNL DCSP return True
def __escape_command(command): DCNL  DCSP result = command.replace('\\', '\\\\') DCNL DCSP result = result.replace('"', '\\"') DCNL DCSP return result
def _int_arg(s): DCNL  DCSP return int(s.strip())
def build(spec, distpath, workpath, clean_build): DCNL  DCSP from ..config import CONF DCNL DCSP def TkPKG(*args, **kwargs): DCNL DCSP  DCSP global _old_api_error DCNL DCSP  DCSP _old_api_error('TkPKG') DCNL DCSP def TkTree(*args, **kwargs): DCNL DCSP  DCSP global _old_api_error DCNL DCSP  DCSP _old_api_error('TkTree') DCNL DCSP distpath = compat.expand_path(distpath) DCNL DCSP workpath = compat.expand_path(workpath) DCNL DCSP CONF['spec'] = compat.expand_path(spec) DCNL DCSP (CONF['specpath'], CONF['specnm']) = os.path.split(spec) DCNL DCSP CONF['specnm'] = os.path.splitext(CONF['specnm'])[0] DCNL DCSP if (os.path.dirname(distpath) == HOMEPATH): DCNL DCSP  DCSP distpath = os.path.join(HOMEPATH, CONF['specnm'], os.path.basename(distpath)) DCNL DCSP CONF['distpath'] = distpath DCNL DCSP if (os.path.dirname(workpath) == HOMEPATH): DCNL DCSP  DCSP workpath = os.path.join(HOMEPATH, CONF['specnm'], os.path.basename(workpath), CONF['specnm']) DCNL DCSP else: DCNL DCSP  DCSP workpath = os.path.join(workpath, CONF['specnm']) DCNL DCSP CONF['warnfile'] = os.path.join(workpath, ('warn%s.txt' % CONF['specnm'])) DCNL DCSP CONF['dot-file'] = os.path.join(workpath, ('graph-%s.dot' % CONF['specnm'])) DCNL DCSP CONF['xref-file'] = os.path.join(workpath, ('xref-%s.html' % CONF['specnm'])) DCNL DCSP if clean_build: DCNL DCSP  DCSP logger.info('Removing DCSP temporary DCSP files DCSP and DCSP cleaning DCSP cache DCSP in DCSP %s', CONF['cachedir']) DCNL DCSP  DCSP for pth in (CONF['cachedir'], workpath): DCNL DCSP  DCSP  DCSP if os.path.exists(pth): DCNL DCSP  DCSP  DCSP  DCSP for f in glob.glob((pth + '/*')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.isdir(f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.remove(f) DCNL DCSP for pth in (CONF['distpath'], workpath): DCNL DCSP  DCSP if (not os.path.exists(pth)): DCNL DCSP  DCSP  DCSP os.makedirs(pth) DCNL DCSP spec_namespace = {'DISTPATH': CONF['distpath'], 'HOMEPATH': HOMEPATH, 'SPEC': CONF['spec'], 'specnm': CONF['specnm'], 'SPECPATH': CONF['specpath'], 'WARNFILE': CONF['warnfile'], 'workpath': workpath, 'TOC': TOC, 'Analysis': Analysis, 'BUNDLE': BUNDLE, 'COLLECT': COLLECT, 'EXE': EXE, 'MERGE': MERGE, 'PYZ': PYZ, 'Tree': Tree, 'TkPKG': TkPKG, 'TkTree': TkTree, 'os': os, 'pyi_crypto': pyz_crypto} DCNL DCSP from ..config import CONF DCNL DCSP CONF['workpath'] = workpath DCNL DCSP with open(spec, 'r') as f: DCNL DCSP  DCSP text = f.read() DCNL DCSP exec text in spec_namespace
def get_vsphere_location(context, image_id): DCNL  DCSP if image_id: DCNL DCSP  DCSP metadata = IMAGE_API.get(context, image_id, include_locations=True) DCNL DCSP  DCSP locations = metadata.get('locations') DCNL DCSP  DCSP if locations: DCNL DCSP  DCSP  DCSP for loc in locations: DCNL DCSP  DCSP  DCSP  DCSP loc_url = loc.get('url') DCNL DCSP  DCSP  DCSP  DCSP if (loc_url and loc_url.startswith('vsphere://')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return loc_url DCNL DCSP return None
@testing.requires_testing_data DCNL def test_source_psd(): DCNL  DCSP raw = read_raw_fif(fname_data) DCNL DCSP inverse_operator = read_inverse_operator(fname_inv) DCNL DCSP label = read_label(fname_label) DCNL DCSP (tmin, tmax) = (0, 20) DCNL DCSP (fmin, fmax) = (55, 65) DCNL DCSP n_fft = 2048 DCNL DCSP stc = compute_source_psd(raw, inverse_operator, lambda2=(1.0 / 9.0), method='dSPM', tmin=tmin, tmax=tmax, fmin=fmin, fmax=fmax, pick_ori='normal', n_fft=n_fft, label=label, overlap=0.1) DCNL DCSP assert_true((stc.times[0] >= (fmin * 0.001))) DCNL DCSP assert_true((stc.times[(-1)] <= (fmax * 0.001))) DCNL DCSP assert_true((0.059 <= stc.times[np.argmax(np.sum(stc.data, axis=0))] <= 0.061))
def generate_track_info(track_id='track DCSP info', values={}): DCNL  DCSP track = TrackInfo(title=u'track DCSP info', track_id=track_id) DCNL DCSP for field in TRACK_INFO_FIELDS: DCNL DCSP  DCSP setattr(track, field, u'track DCSP info') DCNL DCSP for (field, value) in values.items(): DCNL DCSP  DCSP setattr(track, field, value) DCNL DCSP return track
def dmp_swap(f, i, j, u, K): DCNL  DCSP if ((i < 0) or (j < 0) or (i > u) or (j > u)): DCNL DCSP  DCSP raise IndexError(('0 DCSP <= DCSP i DCSP < DCSP j DCSP <= DCSP %s DCSP expected' % u)) DCNL DCSP elif (i == j): DCNL DCSP  DCSP return f DCNL DCSP (F, H) = (dmp_to_dict(f, u), {}) DCNL DCSP for (exp, coeff) in F.items(): DCNL DCSP  DCSP H[((((exp[:i] + (exp[j],)) + exp[(i + 1):j]) + (exp[i],)) + exp[(j + 1):])] = coeff DCNL DCSP return dmp_from_dict(H, u, K)
def _generateScalar(filename='simple.csv', numSequences=2, elementsPerSeq=1, numRepeats=10, stepSize=0.1, includeRandom=False): DCNL  DCSP scriptDir = os.path.dirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'datasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fields = [('classification', 'float', ''), ('field1', 'float', '')] DCNL DCSP if includeRandom: DCNL DCSP  DCSP fields += [('randomData', 'float', '')] DCNL DCSP outFile = FileRecordStream(pathname, write=True, fields=fields) DCNL DCSP sequences = [] DCNL DCSP for i in range(numSequences): DCNL DCSP  DCSP seq = [x for x in range((i * elementsPerSeq), ((i + 1) * elementsPerSeq))] DCNL DCSP  DCSP sequences.append(seq) DCNL DCSP random.seed(42) DCNL DCSP seqIdxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqIdxs += range(numSequences) DCNL DCSP random.shuffle(seqIdxs) DCNL DCSP for seqIdx in seqIdxs: DCNL DCSP  DCSP seq = sequences[seqIdx] DCNL DCSP  DCSP for x in seq: DCNL DCSP  DCSP  DCSP if includeRandom: DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([seqIdx, (x * stepSize), random.random()]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outFile.appendRecord([seqIdx, (x * stepSize)]) DCNL DCSP outFile.close()
def get_version(package): DCNL  DCSP init_py = open(os.path.join(package, '__init__.py')).read() DCNL DCSP return re.search('__version__ DCSP = DCSP [\'"]([^\'"]+)[\'"]', init_py).group(1)
def connect_to_region(region_name, **kw_params): DCNL  DCSP for region in regions(): DCNL DCSP  DCSP if (region.name == region_name): DCNL DCSP  DCSP  DCSP return region.connect(**kw_params) DCNL DCSP return None
def varying_between(table, idvarlist): DCNL  DCSP def inst_key(inst, vars): DCNL DCSP  DCSP return tuple((str(inst[var]) for var in vars)) DCNL DCSP excluded = set(idvarlist) DCNL DCSP all_possible = [var for var in (table.domain.variables + table.domain.metas) if (var not in excluded)] DCNL DCSP candidate_set = set(all_possible) DCNL DCSP idmap = group_table_indices(table, idvarlist) DCNL DCSP values = {} DCNL DCSP varying = set() DCNL DCSP for indices in idmap.values(): DCNL DCSP  DCSP subset = table[indices] DCNL DCSP  DCSP for var in list(candidate_set): DCNL DCSP  DCSP  DCSP values = subset[:, var] DCNL DCSP  DCSP  DCSP (values, _) = subset.get_column_view(var) DCNL DCSP  DCSP  DCSP if var.is_string: DCNL DCSP  DCSP  DCSP  DCSP uniq = set(values) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP uniq = unique_non_nan(values) DCNL DCSP  DCSP  DCSP if (len(uniq) > 1): DCNL DCSP  DCSP  DCSP  DCSP varying.add(var) DCNL DCSP  DCSP  DCSP  DCSP candidate_set.remove(var) DCNL DCSP return sorted(varying, key=all_possible.index)
def create_resource(prefix, creation_func, *args, **kwargs): DCNL  DCSP if (len(prefix) == n_const.DEVICE_NAME_MAX_LEN): DCNL DCSP  DCSP return creation_func(prefix, *args, **kwargs) DCNL DCSP while True: DCNL DCSP  DCSP name = utils.get_rand_name(max_length=n_const.DEVICE_NAME_MAX_LEN, prefix=prefix) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return creation_func(name, *args, **kwargs) DCNL DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP pass
@requires_pandas DCNL def test_to_data_frame(): DCNL  DCSP raw = read_raw_fif(test_fif_fname, preload=True) DCNL DCSP (_, times) = raw[0, :10] DCNL DCSP df = raw.to_data_frame() DCNL DCSP assert_true((df.columns == raw.ch_names).all()) DCNL DCSP assert_array_equal(np.round((times * 1000.0)), df.index.values[:10]) DCNL DCSP df = raw.to_data_frame(index=None) DCNL DCSP assert_true(('time' in df.index.names)) DCNL DCSP assert_array_equal(df.values[:, 0], (raw._data[0] * 10000000000000.0)) DCNL DCSP assert_array_equal(df.values[:, 2], (raw._data[2] * 1000000000000000.0))
def images(): DCNL  DCSP for (ci, cl) in enumerate(classes): DCNL DCSP  DCSP images = glob('{}/{}/*.jpg'.format(basedir, cl)) DCNL DCSP  DCSP for im in sorted(images): DCNL DCSP  DCSP  DCSP (yield (im, ci))
def ceil_shift(n, b): DCNL  DCSP if ((not isinstance(n, (int, long))) or (not isinstance(b, (int, long)))): DCNL DCSP  DCSP raise TypeError(('unsupported DCSP operand DCSP type(s): DCSP %r DCSP and DCSP %r' % (type(n).__name__, type(b).__name__))) DCNL DCSP assert ((n >= 0) and (b >= 0)) DCNL DCSP mask = ((1L << b) - 1) DCNL DCSP if (n & mask): DCNL DCSP  DCSP return ((n >> b) + 1) DCNL DCSP else: DCNL DCSP  DCSP return (n >> b)
@handle_response_format DCNL @treeio_login_required DCNL def service_edit(request, service_id, response_format='html'): DCNL  DCSP service = get_object_or_404(Service, pk=service_id) DCNL DCSP if ((not request.user.profile.has_permission(service, mode='w')) and (not request.user.profile.is_admin('treeio_services'))): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Service") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP form = ServiceForm(request.user.profile, request.POST, instance=service) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP service = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('services_service_view', args=[service.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('services_service_view', args=[service.id])) DCNL DCSP else: DCNL DCSP  DCSP form = ServiceForm(request.user.profile, instance=service) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form, 'service': service}) DCNL DCSP return render_to_response('services/service_edit', context, context_instance=RequestContext(request), response_format=response_format)
def _enqueue_feedback_thread_status_change_email_task(user_id, reference, old_status, new_status): DCNL  DCSP payload = {'user_id': user_id, 'reference_dict': reference.to_dict(), 'old_status': old_status, 'new_status': new_status} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_FEEDBACK_STATUS_EMAILS, payload, 0)
def test_close_connections(): DCNL  DCSP print('Running DCSP test_close_connections') DCNL DCSP s3 = boto.connect_s3() DCNL DCSP for b in s3.get_all_buckets(): DCNL DCSP  DCSP if b.name.startswith('test-'): DCNL DCSP  DCSP  DCSP for key in b.get_all_keys(): DCNL DCSP  DCSP  DCSP  DCSP key.delete() DCNL DCSP  DCSP  DCSP b.delete() DCNL DCSP bucket = s3.create_bucket(('test-%d' % int(time.time()))) DCNL DCSP names = [str(uuid.uuid4) for _ in range(30)] DCNL DCSP threads = [spawn(put_object, bucket, name) for name in names] DCNL DCSP for t in threads: DCNL DCSP  DCSP t.join() DCNL DCSP threads = [spawn(get_object, bucket, name) for name in names] DCNL DCSP for t in threads: DCNL DCSP  DCSP t.join()
def _CheckExpression(expression): DCNL  DCSP expression = _ValidateString(expression, max_len=MAXIMUM_EXPRESSION_LENGTH) DCNL DCSP try: DCNL DCSP  DCSP expression_parser.Parse(expression) DCNL DCSP except expression_parser.ExpressionException as e: DCNL DCSP  DCSP raise ExpressionError(('Failed DCSP to DCSP parse DCSP expression DCSP "%s"' % expression)) DCNL DCSP return expression
def gethostbyname(hostname): DCNL  DCSP return get_hub().resolver.gethostbyname(hostname)
def yield_address(space, start, length=None, reverse=False): DCNL  DCSP if (not length): DCNL DCSP  DCSP length = linux_process_info.address_size DCNL DCSP cont = True DCNL DCSP while (space.is_valid_address(start) and cont): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = read_address(space, start, length) DCNL DCSP  DCSP  DCSP (yield value) DCNL DCSP  DCSP except struct.error: DCNL DCSP  DCSP  DCSP cont = False DCNL DCSP  DCSP  DCSP (yield None) DCNL DCSP  DCSP if reverse: DCNL DCSP  DCSP  DCSP start -= length DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP start += length
def ensure_relative(path): DCNL  DCSP (drive, path) = os.path.splitdrive(path) DCNL DCSP if (sys.platform == 'mac'): DCNL DCSP  DCSP return (os.sep + path) DCNL DCSP else: DCNL DCSP  DCSP if (path[0:1] == os.sep): DCNL DCSP  DCSP  DCSP path = (drive + path[1:]) DCNL DCSP  DCSP return path
def addXIntersectionsFromLoopsForTable(loops, xIntersectionsTable, width): DCNL  DCSP for loop in loops: DCNL DCSP  DCSP addXIntersectionsFromLoopForTable(loop, xIntersectionsTable, width)
def get_cache_duration(cache_key): DCNL  DCSP namespace = _get_cache_key_namespace(cache_key) DCNL DCSP duration = settings.SHUUP_CACHE_DURATIONS.get(namespace) DCNL DCSP if (duration is None): DCNL DCSP  DCSP duration = DEFAULT_CACHE_DURATIONS.get(namespace, settings.SHUUP_DEFAULT_CACHE_DURATION) DCNL DCSP return duration
def eagerload(*args, **kwargs): DCNL  DCSP return joinedload(*args, **kwargs)
def list_env(saltenv='base'): DCNL  DCSP ret = {} DCNL DCSP if (saltenv not in __opts__['pillar_roots']): DCNL DCSP  DCSP return ret DCNL DCSP for f_root in __opts__['pillar_roots'][saltenv]: DCNL DCSP  DCSP ret[f_root] = {} DCNL DCSP  DCSP for (root, dirs, files) in os.walk(f_root): DCNL DCSP  DCSP  DCSP sub = ret[f_root] DCNL DCSP  DCSP  DCSP if (root != f_root): DCNL DCSP  DCSP  DCSP  DCSP sroot = root DCNL DCSP  DCSP  DCSP  DCSP above = [] DCNL DCSP  DCSP  DCSP  DCSP while (not os.path.samefile(sroot, f_root)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP base = os.path.basename(sroot) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if base: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP above.insert(0, base) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sroot = os.path.dirname(sroot) DCNL DCSP  DCSP  DCSP  DCSP for aroot in above: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub = sub[aroot] DCNL DCSP  DCSP  DCSP for dir_ in dirs: DCNL DCSP  DCSP  DCSP  DCSP sub[dir_] = {} DCNL DCSP  DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP  DCSP sub[fn_] = 'f' DCNL DCSP return ret
def read_reflog(f): DCNL  DCSP for l in f: DCNL DCSP  DCSP (yield parse_reflog_line(l))
@flake8ext DCNL def check_python3_no_iteritems(logical_line): DCNL  DCSP if re.search('.*\\.iteritems\\(\\)', logical_line): DCNL DCSP  DCSP msg = 'N327: DCSP Use DCSP six.iteritems() DCSP instead DCSP of DCSP dict.iteritems().' DCNL DCSP  DCSP (yield (0, msg))
def list2cmdline(seq): DCNL  DCSP result = [] DCNL DCSP needquote = False DCNL DCSP for arg in seq: DCNL DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP result.append(' DCSP ') DCNL DCSP  DCSP needquote = ((' DCSP ' in arg) or (' DCTB ' in arg) or ('|' in arg) or (not arg)) DCNL DCSP  DCSP if needquote: DCNL DCSP  DCSP  DCSP result.append('"') DCNL DCSP  DCSP for c in arg: DCNL DCSP  DCSP  DCSP if (c == '\\'): DCNL DCSP  DCSP  DCSP  DCSP bs_buf.append(c) DCNL DCSP  DCSP  DCSP elif (c == '"'): DCNL DCSP  DCSP  DCSP  DCSP result.append((('\\' * len(bs_buf)) * 2)) DCNL DCSP  DCSP  DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP  DCSP  DCSP result.append('\\"') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if bs_buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.extend(bs_buf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP  DCSP  DCSP result.append(c) DCNL DCSP  DCSP if bs_buf: DCNL DCSP  DCSP  DCSP result.extend(bs_buf) DCNL DCSP  DCSP if needquote: DCNL DCSP  DCSP  DCSP result.extend(bs_buf) DCNL DCSP  DCSP  DCSP result.append('"') DCNL DCSP return ''.join(result)
def add_stderr_logger(level=logging.DEBUG): DCNL  DCSP logger = logging.getLogger(__name__) DCNL DCSP handler = logging.StreamHandler() DCNL DCSP handler.setFormatter(logging.Formatter('%(asctime)s DCSP %(levelname)s DCSP %(message)s')) DCNL DCSP logger.addHandler(handler) DCNL DCSP logger.setLevel(level) DCNL DCSP logger.debug(('Added DCSP a DCSP stderr DCSP logging DCSP handler DCSP to DCSP logger: DCSP %s' % __name__)) DCNL DCSP return handler
def same_origin(url1, url2): DCNL  DCSP (p1, p2) = (urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)) DCNL DCSP return ((p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port))
@requires_version('scipy', '0.16') DCNL @slow_test DCNL def test_filters(): DCNL  DCSP sfreq = 100 DCNL DCSP sig_len_secs = 15 DCNL DCSP a = rng.randn(2, (sig_len_secs * sfreq)) DCNL DCSP for fl in ['blah', [0, 1], 1000.5, '10ss', '10']: DCNL DCSP  DCSP assert_raises(ValueError, filter_data, a, sfreq, 4, 8, None, fl, 1.0, 1.0) DCNL DCSP for nj in ['blah', 0.5]: DCNL DCSP  DCSP assert_raises(ValueError, filter_data, a, sfreq, 4, 8, None, 1000, 1.0, 1.0, n_jobs=nj, phase='zero', fir_window='hann') DCNL DCSP assert_raises(ValueError, filter_data, a, sfreq, 4, 8, None, 100, 1.0, 1.0, fir_window='foo') DCNL DCSP assert_raises(ValueError, filter_data, a, sfreq, 4, (sfreq / 2.0), None, 100, 1.0, 1.0) DCNL DCSP assert_raises(ValueError, filter_data, a, sfreq, (-1), None, None, 100, 1.0, 1.0) DCNL DCSP create_filter(a, sfreq, None, None) DCNL DCSP create_filter(a, sfreq, None, None, method='iir') DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP filter_data(a, sfreq, 1, 8, filter_length=256) DCNL DCSP assert_true(any((('attenuation' in str(ww.message)) for ww in w))) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP filter_data(a, sfreq, 1, 8, filter_length='0.5s') DCNL DCSP assert_true(any((('Increase DCSP filter_length' in str(ww.message)) for ww in w))) DCNL DCSP freqs = fftfreq(a.shape[(-1)], (1.0 / sfreq)) DCNL DCSP A = np.abs(fft(a)) DCNL DCSP for fl in ['auto', '10s', '5000ms', 1024, 1023]: DCNL DCSP  DCSP bp = filter_data(a, sfreq, 4, 8, None, fl, 1.0, 1.0) DCNL DCSP  DCSP bs = filter_data(a, sfreq, (8 + 1.0), (4 - 1.0), None, fl, 1.0, 1.0) DCNL DCSP  DCSP lp = filter_data(a, sfreq, None, 8, None, fl, 10, 1.0, n_jobs=2) DCNL DCSP  DCSP hp = filter_data(lp, sfreq, 4, None, None, fl, 1.0, 10) DCNL DCSP  DCSP assert_array_almost_equal(hp, bp, 4) DCNL DCSP  DCSP assert_array_almost_equal((bp + bs), a, 4) DCNL DCSP  DCSP mask = ((freqs > 5.5) & (freqs < 6.5)) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bp)[:, mask]) / A[:, mask])), 1.0, atol=0.02) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bs)[:, mask]) / A[:, mask])), 0.0, atol=0.2) DCNL DCSP  DCSP bp = filter_data(a, sfreq, 4, 8, None, fl, 1.0, 1.0, phase='minimum') DCNL DCSP  DCSP bs = filter_data(a, sfreq, (8 + 1.0), (4 - 1.0), None, fl, 1.0, 1.0, phase='minimum') DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bp)[:, mask]) / A[:, mask])), 1.0, atol=0.11) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bs)[:, mask]) / A[:, mask])), 0.0, atol=0.3) DCNL DCSP n_resamp_ignore = 10 DCNL DCSP bp_up_dn = resample(resample(bp, 2, 1, n_jobs=2), 1, 2, n_jobs=2) DCNL DCSP assert_array_almost_equal(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_dn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP bp_up_dn = resample(resample(bp, 2, 1, n_jobs='cuda'), 1, 2, n_jobs='cuda') DCNL DCSP assert_array_almost_equal(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_dn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP bp_up_dn = sp_resample(sp_resample(bp, (2 * bp.shape[(-1)]), axis=(-1), window='boxcar'), bp.shape[(-1)], window='boxcar', axis=(-1)) DCNL DCSP assert_array_almost_equal(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_dn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP t = (np.array(list(range((sfreq * sig_len_secs)))) / float(sfreq)) DCNL DCSP sig = np.sin(((((2 * np.pi) * sfreq) / 2.2) * t)) DCNL DCSP sig_gone = resample(sig, 1, 2)[n_resamp_ignore:(- n_resamp_ignore)] DCNL DCSP assert_array_almost_equal(np.zeros_like(sig_gone), sig_gone, 2) DCNL DCSP iir_params = dict(ftype='cheby1', gpass=1, gstop=20, output='ba') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, 80, 1000, 'low') DCNL DCSP assert_equal((iir_params['a'].size - 1), 3) DCNL DCSP assert_equal((iir_params['b'].size - 1), 3) DCNL DCSP iir_params = dict(ftype='butter', order=4, output='ba') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, None, 1000, 'low') DCNL DCSP assert_equal((iir_params['a'].size - 1), 4) DCNL DCSP assert_equal((iir_params['b'].size - 1), 4) DCNL DCSP iir_params = dict(ftype='cheby1', gpass=1, gstop=20, output='sos') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, 80, 1000, 'low') DCNL DCSP assert_equal(iir_params['sos'].shape, (2, 6)) DCNL DCSP iir_params = dict(ftype='butter', order=4, output='sos') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, None, 1000, 'low') DCNL DCSP assert_equal(iir_params['sos'].shape, (2, 6)) DCNL DCSP a = rng.randn((5 * sfreq), (5 * sfreq)) DCNL DCSP b = a[:, None, :] DCNL DCSP a_filt = filter_data(a, sfreq, 4, 8, None, 400, 2.0, 2.0) DCNL DCSP b_filt = filter_data(b, sfreq, 4, 8, [0], 400, 2.0, 2.0) DCNL DCSP assert_array_equal(a_filt[:, None, :], b_filt) DCNL DCSP a = rng.randn(2, 2, 2, 2) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, filter_data, a, sfreq, 4, 8, np.array([0, 1]), 100, 1.0, 1.0)
def register_plugin(impl, name=None): DCNL  DCSP if (name is None): DCNL DCSP  DCSP name = impl.name DCNL DCSP with REGISTRY_LOCK: DCNL DCSP  DCSP PLUGIN_REGISTRY[name] = impl DCNL DCSP  DCSP if (name not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[name] = set() DCNL DCSP  DCSP for dep in impl.dependencies: DCNL DCSP  DCSP  DCSP if (dep not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[dep] = set() DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[dep].add(name)
@with_setup(prepare_stdout) DCNL def test_background_without_header(): DCNL  DCSP from lettuce import step, world, before, after DCNL DCSP actions = {} DCNL DCSP @before.each_background DCNL DCSP def register_background_before(background): DCNL DCSP  DCSP actions['before'] = unicode(background) DCNL DCSP @after.each_background DCNL DCSP def register_background_after(background, results): DCNL DCSP  DCSP actions['after'] = {'background': unicode(background), 'results': results} DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP holds DCSP (\\d+)') DCNL DCSP def set_variable(step, name, value): DCNL DCSP  DCSP setattr(world, name, int(value)) DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP is DCSP equal DCSP to DCSP (\\d+)') DCNL DCSP def check_variable(step, name, expected): DCNL DCSP  DCSP expected = int(expected) DCNL DCSP  DCSP expect(world).to.have.property(name).being.equal(expected) DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP times DCSP (\\d+) DCSP is DCSP equal DCSP to DCSP (\\d+)') DCNL DCSP def multiply_and_verify(step, name, times, expected): DCNL DCSP  DCSP times = int(times) DCNL DCSP  DCSP expected = int(expected) DCNL DCSP  DCSP (getattr(world, name) * times).should.equal(expected) DCNL DCSP filename = bg_feature_name('naked') DCNL DCSP runner = Runner(filename, verbosity=1) DCNL DCSP runner.run() DCNL DCSP assert_stdout_lines('..\n1 DCSP feature DCSP (1 DCSP passed)\n2 DCSP scenarios DCSP (2 DCSP passed)\n7 DCSP steps DCSP (7 DCSP passed)\n') DCNL DCSP expect(actions).to.equal({'after': {'results': [True], 'background': u'<Background DCSP for DCSP feature: DCSP Without DCSP Header>'}, 'before': u'<Background DCSP for DCSP feature: DCSP Without DCSP Header>'})
def bad_filename2(filename): DCNL  DCSP temp = filename.encode(sys.getfilesystemencoding(), errors='surrogateescape') DCNL DCSP return temp.decode('latin-1')
def getoutput(cmd): DCNL  DCSP psi = System.Diagnostics.ProcessStartInfo(cmd) DCNL DCSP psi.RedirectStandardOutput = True DCNL DCSP psi.RedirectStandardError = True DCNL DCSP psi.WindowStyle = System.Diagnostics.ProcessWindowStyle.Normal DCNL DCSP psi.UseShellExecute = False DCNL DCSP reg = System.Diagnostics.Process.Start(psi) DCNL DCSP myOutput = reg.StandardOutput DCNL DCSP output = myOutput.ReadToEnd() DCNL DCSP myError = reg.StandardError DCNL DCSP error = myError.ReadToEnd() DCNL DCSP return output
def test_json_view_normal_response(): DCNL  DCSP expected = http.HttpResponseForbidden() DCNL DCSP response = json_view((lambda r: expected))(mock.Mock()) DCNL DCSP assert (expected is response) DCNL DCSP eq_(response['Content-Type'], 'text/html; DCSP charset=utf-8')
def run(name, **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'comment': '', 'result': None} DCNL DCSP if (name not in __salt__): DCNL DCSP  DCSP ret['comment'] = 'Module DCSP function DCSP {0} DCSP is DCSP not DCSP available'.format(name) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Module DCSP function DCSP {0} DCSP is DCSP set DCSP to DCSP execute'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP aspec = salt.utils.args.get_function_argspec(__salt__[name]) DCNL DCSP args = [] DCNL DCSP defaults = {} DCNL DCSP arglen = 0 DCNL DCSP deflen = 0 DCNL DCSP if isinstance(aspec.args, list): DCNL DCSP  DCSP arglen = len(aspec.args) DCNL DCSP if isinstance(aspec.defaults, tuple): DCNL DCSP  DCSP deflen = len(aspec.defaults) DCNL DCSP for ind in range((arglen - 1), (-1), (-1)): DCNL DCSP  DCSP minus = (arglen - ind) DCNL DCSP  DCSP if ((deflen - minus) > (-1)): DCNL DCSP  DCSP  DCSP defaults[aspec.args[ind]] = aspec.defaults[(- minus)] DCNL DCSP for arg in defaults: DCNL DCSP  DCSP if (arg == 'name'): DCNL DCSP  DCSP  DCSP if ('m_name' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP defaults[arg] = kwargs.pop('m_name') DCNL DCSP  DCSP elif (arg == 'fun'): DCNL DCSP  DCSP  DCSP if ('m_fun' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP defaults[arg] = kwargs.pop('m_fun') DCNL DCSP  DCSP elif (arg == 'state'): DCNL DCSP  DCSP  DCSP if ('m_state' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP defaults[arg] = kwargs.pop('m_state') DCNL DCSP  DCSP elif (arg == 'saltenv'): DCNL DCSP  DCSP  DCSP if ('m_saltenv' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP defaults[arg] = kwargs.pop('m_saltenv') DCNL DCSP  DCSP if (arg in kwargs): DCNL DCSP  DCSP  DCSP defaults[arg] = kwargs.pop(arg) DCNL DCSP missing = set() DCNL DCSP for arg in aspec.args: DCNL DCSP  DCSP if (arg == 'name'): DCNL DCSP  DCSP  DCSP rarg = 'm_name' DCNL DCSP  DCSP elif (arg == 'fun'): DCNL DCSP  DCSP  DCSP rarg = 'm_fun' DCNL DCSP  DCSP elif (arg == 'names'): DCNL DCSP  DCSP  DCSP rarg = 'm_names' DCNL DCSP  DCSP elif (arg == 'state'): DCNL DCSP  DCSP  DCSP rarg = 'm_state' DCNL DCSP  DCSP elif (arg == 'saltenv'): DCNL DCSP  DCSP  DCSP rarg = 'm_saltenv' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rarg = arg DCNL DCSP  DCSP if ((rarg not in kwargs) and (arg not in defaults)): DCNL DCSP  DCSP  DCSP missing.add(rarg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (arg in defaults): DCNL DCSP  DCSP  DCSP args.append(defaults[arg]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.append(kwargs.pop(rarg)) DCNL DCSP if missing: DCNL DCSP  DCSP comment = 'The DCSP following DCSP arguments DCSP are DCSP missing:' DCNL DCSP  DCSP for arg in missing: DCNL DCSP  DCSP  DCSP comment += ' DCSP {0}'.format(arg) DCNL DCSP  DCSP ret['comment'] = comment DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP if (aspec.varargs and (aspec.varargs in kwargs)): DCNL DCSP  DCSP varargs = kwargs.pop(aspec.varargs) DCNL DCSP  DCSP if (not isinstance(varargs, list)): DCNL DCSP  DCSP  DCSP msg = "'{0}' DCSP must DCSP be DCSP a DCSP list." DCNL DCSP  DCSP  DCSP ret['comment'] = msg.format(aspec.varargs) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP args.extend(varargs) DCNL DCSP nkwargs = {} DCNL DCSP if (aspec.keywords and (aspec.keywords in kwargs)): DCNL DCSP  DCSP nkwargs = kwargs.pop(aspec.keywords) DCNL DCSP  DCSP if (not isinstance(nkwargs, dict)): DCNL DCSP  DCSP  DCSP msg = "'{0}' DCSP must DCSP be DCSP a DCSP dict." DCNL DCSP  DCSP  DCSP ret['comment'] = msg.format(aspec.keywords) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP if aspec.keywords: DCNL DCSP  DCSP  DCSP mret = __salt__[name](*args, **nkwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mret = __salt__[name](*args) DCNL DCSP except Exception as e: DCNL DCSP  DCSP ret['comment'] = 'Module DCSP function DCSP {0} DCSP threw DCSP an DCSP exception. DCSP Exception: DCSP {1}'.format(name, e) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP if ((mret is not None) or (mret is not {})): DCNL DCSP  DCSP  DCSP ret['changes']['ret'] = mret DCNL DCSP if ('returner' in kwargs): DCNL DCSP  DCSP ret_ret = {'id': __opts__['id'], 'ret': mret, 'fun': name, 'jid': salt.utils.jid.gen_jid()} DCNL DCSP  DCSP returners = salt.loader.returners(__opts__, __salt__) DCNL DCSP  DCSP if (kwargs['returner'] in returners): DCNL DCSP  DCSP  DCSP returners[kwargs['returner']](ret_ret) DCNL DCSP ret['comment'] = 'Module DCSP function DCSP {0} DCSP executed'.format(name) DCNL DCSP ret['result'] = True DCNL DCSP if (isinstance(mret, dict) and (mret.get('retcode', 0) != 0)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP elif isinstance(mret, bool): DCNL DCSP  DCSP ret['result'] = mret DCNL DCSP else: DCNL DCSP  DCSP changes_ret = ret['changes'].get('ret', {}) DCNL DCSP  DCSP if isinstance(changes_ret, dict): DCNL DCSP  DCSP  DCSP if isinstance(changes_ret.get('result', {}), bool): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = changes_ret.get('result', {}) DCNL DCSP  DCSP  DCSP elif (changes_ret.get('retcode', 0) != 0): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
def kegg_get(dbentries, option=None): DCNL  DCSP if (isinstance(dbentries, list) and (len(dbentries) <= 10)): DCNL DCSP  DCSP dbentries = '+'.join(dbentries) DCNL DCSP elif (isinstance(dbentries, list) and (len(dbentries) > 10)): DCNL DCSP  DCSP raise Exception('Maximum DCSP number DCSP of DCSP dbentries DCSP is DCSP 10 DCSP for DCSP kegg DCSP get DCSP query') DCNL DCSP if (option in ['aaseq', 'ntseq', 'mol', 'kcf', 'image', 'kgml']): DCNL DCSP  DCSP resp = _q('get', dbentries, option) DCNL DCSP elif option: DCNL DCSP  DCSP raise Exception('Invalid DCSP option DCSP arg DCSP for DCSP kegg DCSP get DCSP request.') DCNL DCSP else: DCNL DCSP  DCSP resp = _q('get', dbentries) DCNL DCSP return resp
def b64d(s): DCNL  DCSP return base64.b64decode(s)
def _get_col_o2o(parent, subname, subcls, fk_col_name, deferrable=None, initially=None, ondelete=None, onupdate=None): DCNL  DCSP assert (subcls.Attributes.table_name is not None), ('%r DCSP has DCSP no DCSP table DCSP name.' % subcls) DCNL DCSP (col_args, col_kwargs) = sanitize_args(subcls.Attributes.sqla_column_args) DCNL DCSP _sp_attrs_to_sqla_constraints(parent, subcls, col_kwargs) DCNL DCSP (pk_column,) = get_pk_columns(subcls) DCNL DCSP (pk_key, pk_spyne_type) = pk_column DCNL DCSP pk_sqla_type = _get_sqlalchemy_type(pk_spyne_type) DCNL DCSP if (fk_col_name is None): DCNL DCSP  DCSP fk_col_name = ((subname + '_') + pk_key) DCNL DCSP assert (fk_col_name != subname), 'The DCSP column DCSP name DCSP for DCSP the DCSP foreign DCSP key DCSP must DCSP be DCSP different DCSP from DCSP the DCSP column DCSP name DCSP for DCSP the DCSP object DCSP itself.' DCNL DCSP fk = ForeignKey(('%s.%s' % (subcls.Attributes.table_name, pk_key)), use_alter=True, name=('%s_%s_fkey' % (subcls.Attributes.table_name, fk_col_name)), deferrable=deferrable, initially=initially, ondelete=ondelete, onupdate=onupdate) DCNL DCSP return Column(fk_col_name, pk_sqla_type, fk, *col_args, **col_kwargs)
def Cdf(cdf, complement=False, transform=None, **options): DCNL  DCSP (xs, ps) = cdf.Render() DCNL DCSP xs = np.asarray(xs) DCNL DCSP ps = np.asarray(ps) DCNL DCSP scale = dict(xscale='linear', yscale='linear') DCNL DCSP for s in ['xscale', 'yscale']: DCNL DCSP  DCSP if (s in options): DCNL DCSP  DCSP  DCSP scale[s] = options.pop(s) DCNL DCSP if (transform == 'exponential'): DCNL DCSP  DCSP complement = True DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP if (transform == 'pareto'): DCNL DCSP  DCSP complement = True DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP  DCSP scale['xscale'] = 'log' DCNL DCSP if complement: DCNL DCSP  DCSP ps = [(1.0 - p) for p in ps] DCNL DCSP if (transform == 'weibull'): DCNL DCSP  DCSP xs = np.delete(xs, (-1)) DCNL DCSP  DCSP ps = np.delete(ps, (-1)) DCNL DCSP  DCSP ps = [(- math.log((1.0 - p))) for p in ps] DCNL DCSP  DCSP scale['xscale'] = 'log' DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP if (transform == 'gumbel'): DCNL DCSP  DCSP xs = xp.delete(xs, 0) DCNL DCSP  DCSP ps = np.delete(ps, 0) DCNL DCSP  DCSP ps = [(- math.log(p)) for p in ps] DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP options = _Underride(options, label=cdf.label) DCNL DCSP Plot(xs, ps, **options) DCNL DCSP return scale
def fix_iteration_tables(): DCNL  DCSP cursor = connection.cursor() DCNL DCSP cursor.execute('DROP DCSP TABLE DCSP tko_iteration_attributes') DCNL DCSP cursor.execute(_CREATE_ITERATION_ATTRIBUTES) DCNL DCSP cursor.execute('DROP DCSP TABLE DCSP tko_iteration_result') DCNL DCSP cursor.execute(_CREATE_ITERATION_RESULTS)
def parse_qs(qs, keep_blank_values=0, strict_parsing=0, unquote=unquote): DCNL  DCSP d = {} DCNL DCSP items = [s2 for s1 in qs.split('&') for s2 in s1.split(';')] DCNL DCSP for item in items: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (k, v) = item.split('=', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if strict_parsing: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (v or keep_blank_values): DCNL DCSP  DCSP  DCSP k = unquote(k.replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP v = unquote(v.replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP if (k in d): DCNL DCSP  DCSP  DCSP  DCSP d[k].append(v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP d[k] = [v] DCNL DCSP return d
@app.route('/', methods=['GET', 'POST', 'OPTIONS', 'PUT', 'DELETE', 'HEAD', 'PATCH']) DCNL @app.route('/<path:input_path>', methods=['GET', 'POST', 'OPTIONS', 'PUT', 'DELETE', 'HEAD', 'PATCH']) DCNL def zmirror_enter(input_path='/'): DCNL  DCSP try: DCNL DCSP  DCSP resp = main_function(input_path=input_path) DCNL DCSP  DCSP for (name, value) in parse.extra_resp_headers.items(): DCNL DCSP  DCSP  DCSP resp.headers.set(name, value) DCNL DCSP  DCSP for (name, cookie_string) in parse.extra_cookies.items(): DCNL DCSP  DCSP  DCSP resp.headers.add('Set-Cookie', cookie_string) DCNL DCSP except: DCNL DCSP  DCSP return generate_error_page(is_traceback=True) DCNL DCSP else: DCNL DCSP  DCSP return resp
def check_seqs(fasta_out, fasta_files, starting_ix, valid_map, qual_mappings, filters, barcode_len, keep_primer, keep_barcode, barcode_type, max_bc_errors, retain_unassigned_reads, attempt_bc_correction, primer_seqs_lens, all_primers, max_primer_mm, disable_primer_check, reverse_primers, rev_primers, qual_out, qual_score_window=0, discard_bad_windows=False, min_qual_score=25, min_seq_len=200, median_length_filtering=None, added_demultiplex_field=None, reverse_primer_mismatches=0, truncate_ambi_bases=False): DCNL  DCSP seq_lengths = {} DCNL DCSP raw_seq_lengths = {} DCNL DCSP final_seq_lengths = {} DCNL DCSP bc_counts = defaultdict(list) DCNL DCSP curr_ix = starting_ix DCNL DCSP corr_ct = 0 DCNL DCSP barcode_length_order = sorted(set([len(bc.split(',')[0]) for bc in valid_map])) DCNL DCSP barcode_length_order = barcode_length_order[::(-1)] DCNL DCSP primer_mismatch_count = 0 DCNL DCSP all_primers_lens = sorted(set(all_primers.values())) DCNL DCSP reverse_primer_not_found = 0 DCNL DCSP sliding_window_failed = 0 DCNL DCSP trunc_ambi_base_counts = 0 DCNL DCSP below_seq_min_after_trunc = 0 DCNL DCSP below_seq_min_after_ambi_trunc = 0 DCNL DCSP for fasta_in in fasta_files: DCNL DCSP  DCSP for (curr_id, curr_seq) in parse_fasta(fasta_in): DCNL DCSP  DCSP  DCSP curr_rid = curr_id.split()[0] DCNL DCSP  DCSP  DCSP curr_seq = upper(curr_seq) DCNL DCSP  DCSP  DCSP curr_len = len(curr_seq) DCNL DCSP  DCSP  DCSP curr_qual = qual_mappings.get(curr_rid, None) DCNL DCSP  DCSP  DCSP seq_lengths[curr_rid] = curr_len DCNL DCSP  DCSP  DCSP failed = False DCNL DCSP  DCSP  DCSP for f in filters: DCNL DCSP  DCSP  DCSP  DCSP failed = (failed or f(curr_rid, curr_seq, curr_qual)) DCNL DCSP  DCSP  DCSP if failed: DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (barcode_type == 'variable_length'): DCNL DCSP  DCSP  DCSP  DCSP (raw_barcode, raw_seq, barcode_len) = (None, None, None) DCNL DCSP  DCSP  DCSP  DCSP curr_valid_map = [curr_bc.split(',')[0] for curr_bc in valid_map] DCNL DCSP  DCSP  DCSP  DCSP for l in barcode_length_order: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (bc, seq) = get_barcode(curr_seq, l) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (bc in curr_valid_map): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (raw_barcode, raw_seq) = (bc, seq) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP barcode_len = len(raw_barcode) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not raw_barcode): DCNL DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (raw_barcode, raw_seq) = get_barcode(curr_seq, barcode_len) DCNL DCSP  DCSP  DCSP if (not disable_primer_check): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_primers = primer_seqs_lens[raw_barcode] DCNL DCSP  DCSP  DCSP  DCSP  DCSP primer_len = current_primers.values()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if primer_exceeds_mismatches(raw_seq[:primer_len], current_primers, max_primer_mm): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_mismatch_count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_primers = all_primers DCNL DCSP  DCSP  DCSP  DCSP  DCSP found_match = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP for seq_slice_len in all_primers_lens: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not primer_exceeds_mismatches(raw_seq[:seq_slice_len], current_primers, max_primer_mm)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_len = seq_slice_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found_match = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not found_match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_mismatch_count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise IndexError((('Error DCSP reading DCSP primer DCSP sequences. DCSP  DCSP If DCSP ' + 'primers DCSP were DCSP purposefully DCSP not DCSP included DCSP in DCSP the DCSP mapping DCSP ') + 'file, DCSP disable DCSP usage DCSP with DCSP the DCSP -p DCSP option.')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP primer_len = 0 DCNL DCSP  DCSP  DCSP (cbc, cpr, cres) = split_seq(curr_seq, barcode_len, primer_len) DCNL DCSP  DCSP  DCSP total_bc_primer_len = (len(cbc) + len(cpr)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (bc_diffs, curr_bc, corrected_bc) = check_barcode(cbc, barcode_type, valid_map.keys(), attempt_bc_correction, added_demultiplex_field, curr_id) DCNL DCSP  DCSP  DCSP  DCSP if (bc_diffs > max_bc_errors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Too DCSP many DCSP errors DCSP in DCSP barcode') DCNL DCSP  DCSP  DCSP  DCSP corr_ct += bool(corrected_bc) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP bc_counts[None].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP curr_samp_id = valid_map.get(curr_bc, 'Unassigned') DCNL DCSP  DCSP  DCSP new_id = ('%s_%d' % (curr_samp_id, curr_ix)) DCNL DCSP  DCSP  DCSP write_seq = cres DCNL DCSP  DCSP  DCSP if (reverse_primers == 'truncate_only'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer = rev_primers[curr_bc] DCNL DCSP  DCSP  DCSP  DCSP  DCSP mm_tested = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP for curr_rev_primer in rev_primer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (rev_primer_mm, rev_primer_index) = local_align_primer_seq(curr_rev_primer, cres) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mm_tested[rev_primer_mm] = rev_primer_index DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_mm = min(mm_tested.keys()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_index = mm_tested[rev_primer_mm] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rev_primer_mm <= reverse_primer_mismatches): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = write_seq[0:rev_primer_index] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qual = curr_qual[0:((barcode_len + primer_len) + rev_primer_index)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reverse_primer_not_found += 1 DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (reverse_primers == 'truncate_remove'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer = rev_primers[curr_bc] DCNL DCSP  DCSP  DCSP  DCSP  DCSP mm_tested = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP for curr_rev_primer in rev_primer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (rev_primer_mm, rev_primer_index) = local_align_primer_seq(curr_rev_primer, cres) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mm_tested[rev_primer_mm] = rev_primer_index DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_mm = min(mm_tested.keys()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_index = mm_tested[rev_primer_mm] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rev_primer_mm <= reverse_primer_mismatches): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = write_seq[0:rev_primer_index] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qual = curr_qual[0:((barcode_len + primer_len) + rev_primer_index)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reverse_primer_not_found += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = False DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if qual_score_window: DCNL DCSP  DCSP  DCSP  DCSP (passed_window_check, window_index) = check_window_qual_scores(curr_qual, qual_score_window, min_qual_score) DCNL DCSP  DCSP  DCSP  DCSP if (discard_bad_windows and (not passed_window_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sliding_window_failed += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seq = False DCNL DCSP  DCSP  DCSP  DCSP elif ((not discard_bad_windows) and (not passed_window_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sliding_window_failed += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if write_seq: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = write_seq[0:window_index] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qual = curr_qual[0:((barcode_len + primer_len) + window_index)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((len(write_seq) + total_bc_primer_len) < min_seq_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP below_seq_min_after_trunc += 1 DCNL DCSP  DCSP  DCSP if (truncate_ambi_bases and write_seq): DCNL DCSP  DCSP  DCSP  DCSP write_seq_ambi_ix = True DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ambi_ix = write_seq.index('N') DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seq = write_seq[0:ambi_ix] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seq_ambi_ix = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP if write_seq_ambi_ix: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(write_seq) + total_bc_primer_len) < min_seq_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seq = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP below_seq_min_after_ambi_trunc += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP trunc_ambi_base_counts += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qual = curr_qual[0:((barcode_len + primer_len) + ambi_ix)] DCNL DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP (qual_barcode, qual_primer, qual_scores_out) = split_seq(curr_qual, barcode_len, primer_len) DCNL DCSP  DCSP  DCSP  DCSP qual_barcode = format_qual_output(qual_barcode) DCNL DCSP  DCSP  DCSP  DCSP qual_primer = format_qual_output(qual_primer) DCNL DCSP  DCSP  DCSP  DCSP qual_scores_out = format_qual_output(qual_scores_out) DCNL DCSP  DCSP  DCSP if (not write_seq): DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if keep_primer: DCNL DCSP  DCSP  DCSP  DCSP write_seq = (cpr + write_seq) DCNL DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qual_scores_out = (qual_primer + qual_scores_out) DCNL DCSP  DCSP  DCSP if keep_barcode: DCNL DCSP  DCSP  DCSP  DCSP write_seq = (cbc + write_seq) DCNL DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qual_scores_out = (qual_barcode + qual_scores_out) DCNL DCSP  DCSP  DCSP bc_counts[curr_bc].append(curr_rid) DCNL DCSP  DCSP  DCSP if (retain_unassigned_reads and (curr_samp_id == 'Unassigned')): DCNL DCSP  DCSP  DCSP  DCSP fasta_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_diffs=%s\n%s\n' % (new_id, curr_rid, cbc, curr_bc, int(bc_diffs), write_seq))) DCNL DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qual_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_diffs=%s\n%s' % (new_id, curr_rid, cbc, curr_bc, int(bc_diffs), qual_scores_out))) DCNL DCSP  DCSP  DCSP elif ((not retain_unassigned_reads) and (curr_samp_id == 'Unassigned')): DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].append(curr_rid) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP fasta_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_diffs=%s\n%s\n' % (new_id, curr_rid, cbc, curr_bc, int(bc_diffs), write_seq))) DCNL DCSP  DCSP  DCSP  DCSP if qual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qual_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_diffs=%s\n%s' % (new_id, curr_rid, cbc, curr_bc, int(bc_diffs), qual_scores_out))) DCNL DCSP  DCSP  DCSP curr_len = len(write_seq) DCNL DCSP  DCSP  DCSP curr_ix += 1 DCNL DCSP  DCSP  DCSP raw_seq_lengths[curr_rid] = len(curr_seq) DCNL DCSP  DCSP  DCSP final_seq_lengths[curr_id] = curr_len DCNL DCSP if median_length_filtering: DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP fasta_out = open(fasta_out.name, 'U') DCNL DCSP  DCSP sequence_lens = [] DCNL DCSP  DCSP for (label, seq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP sequence_lens.append(len(seq)) DCNL DCSP  DCSP '# DCSP Create DCSP a DCSP temporary DCSP file DCSP to DCSP copy DCSP the DCSP contents DCSP of DCSP the DCSP fasta DCSP file, DCSP will\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP need DCSP to DCSP delete DCSP once DCSP operations DCSP complete.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp DCSP = DCSP open(fasta_out.name DCSP + DCSP "_tmp.fasta", DCSP "w")\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sequence_lens DCSP = DCSP []\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP label, DCSP seq DCSP in DCSP parse_fasta(fasta_lens):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sequence_lens.append(len(seq))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp.write(">%s\n%s\n" DCSP % DCSP (label, DCSP seq))\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp.close()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp DCSP = DCSP open(fasta_out.name DCSP + DCSP "_tmp.fasta", DCSP "U")\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_lens.close()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Overwrite DCSP seqs.fna DCSP with DCSP length DCSP filtered DCSP data\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_out DCSP = DCSP open(fasta_out.name, DCSP "w")' DCNL DCSP  DCSP (med_abs_dev, med_length) = median_absolute_deviation(sequence_lens) DCNL DCSP  DCSP min_corrected_len = (med_length - (med_abs_dev * float(median_length_filtering))) DCNL DCSP  DCSP max_corrected_len = (med_length + (med_abs_dev * float(median_length_filtering))) DCNL DCSP  DCSP seqs_discarded_median = 0 DCNL DCSP  DCSP fasta_out.seek(0) DCNL DCSP  DCSP final_written_lens = [] DCNL DCSP  DCSP final_fasta_out = open(fasta_out.name.replace('.tmp', ''), 'w') DCNL DCSP  DCSP for (label, seq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP curr_len = len(seq) DCNL DCSP  DCSP  DCSP if ((curr_len < min_corrected_len) or (curr_len > max_corrected_len)): DCNL DCSP  DCSP  DCSP  DCSP seqs_discarded_median += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP final_fasta_out.write(('>%s\n%s\n' % (label, seq))) DCNL DCSP  DCSP  DCSP  DCSP final_written_lens.append(len(seq)) DCNL DCSP  DCSP final_fasta_out.close() DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP remove_files([fasta_out.name]) DCNL DCSP else: DCNL DCSP  DCSP min_corrected_len = 0 DCNL DCSP  DCSP max_corrected_len = 0 DCNL DCSP  DCSP seqs_discarded_median = 0 DCNL DCSP  DCSP final_written_lens = 0 DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP fasta_out = open(fasta_out.name, 'U') DCNL DCSP  DCSP final_fasta_out = open(fasta_out.name.replace('.tmp', ''), 'w') DCNL DCSP  DCSP for (label, seq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP final_fasta_out.write(('>%s\n%s\n' % (label, seq))) DCNL DCSP  DCSP final_fasta_out.close() DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP remove_files([fasta_out.name]) DCNL DCSP median_results = (median_length_filtering, min_corrected_len, max_corrected_len, seqs_discarded_median, final_written_lens) DCNL DCSP raw_seq_lengths = raw_seq_lengths.values() DCNL DCSP final_seq_lengths = final_seq_lengths.values() DCNL DCSP log_out = format_log(bc_counts, corr_ct, valid_map, seq_lengths, filters, retain_unassigned_reads, attempt_bc_correction, primer_mismatch_count, max_primer_mm, reverse_primers, reverse_primer_not_found, sliding_window_failed, below_seq_min_after_trunc, qual_score_window, discard_bad_windows, min_seq_len, raw_seq_lengths, final_seq_lengths, median_results, truncate_ambi_bases, below_seq_min_after_ambi_trunc) DCNL DCSP return (log_out, seq_lengths.values(), raw_seq_lengths, final_seq_lengths)
def test_synchronize_join_node(tmpdir): DCNL  DCSP global _products DCNL DCSP _products = [] DCNL DCSP os.chdir(str(tmpdir)) DCNL DCSP wf = pe.Workflow(name=u'test') DCNL DCSP inputspec = pe.Node(IdentityInterface(fields=[u'm', u'n']), name=u'inputspec') DCNL DCSP inputspec.iterables = [(u'm', [1, 2]), (u'n', [3, 4])] DCNL DCSP inputspec.synchronize = True DCNL DCSP inc1 = pe.Node(IncrementInterface(), name=u'inc1') DCNL DCSP wf.connect(inputspec, u'm', inc1, u'input1') DCNL DCSP inc2 = pe.Node(IncrementInterface(), name=u'inc2') DCNL DCSP wf.connect(inputspec, u'n', inc2, u'input1') DCNL DCSP join = pe.JoinNode(IdentityInterface(fields=[u'vector1', u'vector2']), joinsource=u'inputspec', name=u'join') DCNL DCSP wf.connect(inc1, u'output1', join, u'vector1') DCNL DCSP wf.connect(inc2, u'output1', join, u'vector2') DCNL DCSP prod = pe.MapNode(ProductInterface(), name=u'prod', iterfield=[u'input1', u'input2']) DCNL DCSP wf.connect(join, u'vector1', prod, u'input1') DCNL DCSP wf.connect(join, u'vector2', prod, u'input2') DCNL DCSP result = wf.run() DCNL DCSP assert (len(result.nodes()) == 6), u'The DCSP number DCSP of DCSP expanded DCSP nodes DCSP is DCSP incorrect.' DCNL DCSP assert (_products == [8, 15]), (u'The DCSP post-join DCSP products DCSP is DCSP incorrect: DCSP %s.' % _products)
def unique(list_, key=(lambda x: x)): DCNL  DCSP seen = {} DCNL DCSP result = [] DCNL DCSP for item in list_: DCNL DCSP  DCSP seenkey = key(item) DCNL DCSP  DCSP if (seenkey in seen): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen[seenkey] = 1 DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
@login_check DCNL def machines_show_all(request): DCNL  DCSP interfaces_groups = machinesmgr.queryAllInterfaces(0, 'WebConsole') DCNL DCSP targetIP = request.GET.get('target', None) DCNL DCSP kbeComps = [] DCNL DCSP for (mID, comps) in interfaces_groups.items(): DCNL DCSP  DCSP if ((len(comps) > 1) and (comps[0].intaddr == targetIP)): DCNL DCSP  DCSP  DCSP kbeComps = comps[1:] DCNL DCSP  DCSP  DCSP break DCNL DCSP kbeMachines = machinesmgr.queryMachines() DCNL DCSP kbeMachines.sort(key=(lambda info: info.intaddr)) DCNL DCSP context = {'KBEMachines': kbeMachines, 'KBEComps': kbeComps} DCNL DCSP return render(request, 'WebConsole/machines_show_all.html', context)
@contextmanager DCNL def mocked_context(*args, **kwargs): DCNL  DCSP (yield type('Tunnelled', (object,), {}))
def main(): DCNL  DCSP map_acls_mode = False DCNL DCSP afp_config = '/usr/local/etc/afp.conf' DCNL DCSP cf_contents = [] DCNL DCSP client = Client() DCNL DCSP afp = Struct(client.call('datastore.query', 'services.afp', None, {'get': True})) DCNL DCSP cf_contents.append('[Global]\n') DCNL DCSP uam_list = ['uams_dhx.so', 'uams_dhx2.so'] DCNL DCSP if afp.afp_srv_guest: DCNL DCSP  DCSP uam_list.append('uams_guest.so') DCNL DCSP  DCSP cf_contents.append((' DCTB guest DCSP account DCSP = DCSP %s\n' % afp.afp_srv_guest_user)) DCNL DCSP if (client.call('datastore.query', 'directoryservice.kerberoskeytab', None, {'count': True}) > 0): DCNL DCSP  DCSP uam_list.append('uams_gss.so') DCNL DCSP cf_contents.append((' DCTB uam DCSP list DCSP = DCSP %s\n' % ' DCSP '.join(uam_list))) DCNL DCSP if afp.afp_srv_bindip: DCNL DCSP  DCSP cf_contents.append((' DCTB afp DCSP listen DCSP = DCSP %s\n' % ' DCSP '.join(afp.afp_srv_bindip))) DCNL DCSP cf_contents.append((' DCTB max DCSP connections DCSP = DCSP %s\n' % afp.afp_srv_connections_limit)) DCNL DCSP cf_contents.append(' DCTB mimic DCSP model DCSP = DCSP RackMac\n') DCNL DCSP if afp.afp_srv_dbpath: DCNL DCSP  DCSP cf_contents.append(' DCTB vol DCSP dbnest DCSP = DCSP no\n') DCNL DCSP  DCSP cf_contents.append((' DCTB vol DCSP dbpath DCSP = DCSP %s\n' % afp.afp_srv_dbpath)) DCNL DCSP else: DCNL DCSP  DCSP cf_contents.append(' DCTB vol DCSP dbnest DCSP = DCSP yes\n') DCNL DCSP if afp.afp_srv_global_aux: DCNL DCSP  DCSP cf_contents.append((' DCTB %s\n' % afp.afp_srv_global_aux.encode('utf8'))) DCNL DCSP if afp.afp_srv_map_acls: DCNL DCSP  DCSP cf_contents.append((' DCTB map DCSP acls DCSP = DCSP %s\n' % afp.afp_srv_map_acls)) DCNL DCSP if ((afp.afp_srv_map_acls == 'mode') and client.call('notifier.common', 'system', 'activedirectory_enabled')): DCNL DCSP  DCSP map_acls_mode = True DCNL DCSP if map_acls_mode: DCNL DCSP  DCSP ad = Struct(client.call('notifier.directoryservice', 'AD')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP auth DCSP method DCSP = DCSP %s\n' % 'simple')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP auth DCSP dn DCSP = DCSP %s\n' % ad.binddn)) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP auth DCSP pw DCSP = DCSP %s\n' % ad.bindpw)) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP server DCSP = DCSP %s\n' % ad.domainname)) DCNL DCSP  DCSP if ad.userdn: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB ldap DCSP userbase DCSP = DCSP %s\n' % ad.userdn)) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP userscope DCSP = DCSP %s\n' % 'sub')) DCNL DCSP  DCSP if ad.groupdn: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB ldap DCSP groupbase DCSP = DCSP %s\n' % ad.groupdn)) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP groupscope DCSP = DCSP %s\n' % 'sub')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP user DCSP filter DCSP = DCSP %s\n' % 'objectclass=user')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP group DCSP filter DCSP = DCSP %s\n' % 'objectclass=group')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP uuid DCSP attr DCSP = DCSP %s\n' % 'objectGUID')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP uuid DCSP encoding DCSP = DCSP %s\n' % 'ms-guid')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP name DCSP attr DCSP = DCSP %s\n' % 'sAMAccountName')) DCNL DCSP  DCSP cf_contents.append((' DCTB ldap DCSP group DCSP attr DCSP = DCSP %s\n' % 'sAMAccountName')) DCNL DCSP cf_contents.append('\n') DCNL DCSP if afp.afp_srv_homedir_enable: DCNL DCSP  DCSP cf_contents.append('[Homes]\n') DCNL DCSP  DCSP cf_contents.append((' DCTB basedir DCSP regex DCSP = DCSP %s\n' % afp.afp_srv_homedir)) DCNL DCSP  DCSP if afp.afp_srv_homename: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB home DCSP name DCSP = DCSP %s\n' % afp.afp_srv_homename)) DCNL DCSP  DCSP cf_contents.append('\n') DCNL DCSP for share in client.call('datastore.query', 'sharing.afp_share'): DCNL DCSP  DCSP share = Struct(share) DCNL DCSP  DCSP cf_contents.append(('[%s]\n' % share.afp_name)) DCNL DCSP  DCSP cf_contents.append((' DCTB path DCSP = DCSP %s\n' % share.afp_path)) DCNL DCSP  DCSP if share.afp_allow: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB valid DCSP users DCSP = DCSP %s\n' % share.afp_allow)) DCNL DCSP  DCSP if share.afp_deny: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB invalid DCSP users DCSP = DCSP %s\n' % share.afp_deny)) DCNL DCSP  DCSP if share.afp_hostsallow: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB hosts DCSP allow DCSP = DCSP %s\n' % share.afp_hostsallow)) DCNL DCSP  DCSP if share.afp_hostsdeny: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB hosts DCSP deny DCSP = DCSP %s\n' % share.afp_hostsdeny)) DCNL DCSP  DCSP if share.afp_ro: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB rolist DCSP = DCSP %s\n' % share.afp_ro)) DCNL DCSP  DCSP if share.afp_rw: DCNL DCSP  DCSP  DCSP cf_contents.append((' DCTB rwlist DCSP = DCSP %s\n' % share.afp_rw)) DCNL DCSP  DCSP if share.afp_timemachine: DCNL DCSP  DCSP  DCSP cf_contents.append(' DCTB time DCSP machine DCSP = DCSP yes\n') DCNL DCSP  DCSP if (not share.afp_nodev): DCNL DCSP  DCSP  DCSP cf_contents.append(' DCTB cnid DCSP dev DCSP = DCSP no\n') DCNL DCSP  DCSP if share.afp_nostat: DCNL DCSP  DCSP  DCSP cf_contents.append(' DCTB stat DCSP vol DCSP = DCSP no\n') DCNL DCSP  DCSP if (not share.afp_upriv): DCNL DCSP  DCSP  DCSP cf_contents.append(' DCTB unix DCSP priv DCSP = DCSP no\n') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (share.afp_fperm and (not map_acls_mode)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.append((' DCTB file DCSP perm DCSP = DCSP %s\n' % share.afp_fperm)) DCNL DCSP  DCSP  DCSP if (share.afp_dperm and (not map_acls_mode)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.append((' DCTB directory DCSP perm DCSP = DCSP %s\n' % share.afp_dperm)) DCNL DCSP  DCSP  DCSP if (share.afp_umask and (not map_acls_mode)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.append((' DCTB umask DCSP = DCSP %s\n' % share.afp_umask)) DCNL DCSP  DCSP cf_contents.append(' DCTB veto DCSP files DCSP = DCSP .windows/.mac/\n') DCNL DCSP  DCSP if map_acls_mode: DCNL DCSP  DCSP  DCSP cf_contents.append(' DCTB acls DCSP = DCSP yes\n') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP aux_params = [' DCTB {0}\n'.format(p.encode('utf8')) for p in share.afp_auxparams.split('\n')] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cf_contents += aux_params DCNL DCSP with open(afp_config, 'w') as fh: DCNL DCSP  DCSP for line in cf_contents: DCNL DCSP  DCSP  DCSP fh.write(line)
def walk_modules(path): DCNL  DCSP mods = [] DCNL DCSP mod = import_module(path) DCNL DCSP mods.append(mod) DCNL DCSP if hasattr(mod, '__path__'): DCNL DCSP  DCSP for (_, subpath, ispkg) in iter_modules(mod.__path__): DCNL DCSP  DCSP  DCSP fullpath = ((path + '.') + subpath) DCNL DCSP  DCSP  DCSP if ispkg: DCNL DCSP  DCSP  DCSP  DCSP mods += walk_modules(fullpath) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP submod = import_module(fullpath) DCNL DCSP  DCSP  DCSP  DCSP mods.append(submod) DCNL DCSP return mods
def daily_return(prices): DCNL  DCSP g = np.zeros_like(prices) DCNL DCSP g[1:] = ((prices[1:] - prices[:(-1)]) / prices[:(-1)]) DCNL DCSP return g
def traverse_tree(course): DCNL  DCSP queue = [course] DCNL DCSP while (len(queue) > 0): DCNL DCSP  DCSP node = queue.pop() DCNL DCSP  DCSP queue.extend(node.get_children()) DCNL DCSP return True
def green(text, attrib=None): DCNL  DCSP return colorize(text, 'green', attrib)
def topic_detail(request, slug, topic_id, template_name='groups/topics/topic_detail.html'): DCNL  DCSP group = get_object_or_404(Group, slug=slug, is_active=True) DCNL DCSP topic = get_object_or_404(GroupTopic, pk=topic_id, is_active=True) DCNL DCSP message_form = GroupMessageForm() DCNL DCSP return render(request, template_name, {'group': group, 'topic': topic, 'message_form': message_form})
@task(name='clean-all', aliases=('distclean',)) DCNL def clean_all(ctx, dry_run=False): DCNL  DCSP cleanup_dirs((ctx.clean_all.directories or []), dry_run=dry_run) DCNL DCSP cleanup_dirs((ctx.clean_all.extra_directories or []), dry_run=dry_run) DCNL DCSP cleanup_files((ctx.clean_all.files or []), dry_run=dry_run) DCNL DCSP cleanup_files((ctx.clean_all.extra_files or []), dry_run=dry_run) DCNL DCSP execute_cleanup_tasks(ctx, cleanup_all_tasks, dry_run=dry_run) DCNL DCSP clean(ctx, dry_run=dry_run)
def retrieve_cors_header(response, key): DCNL  DCSP headers = response.get_headers() DCNL DCSP for header_name in headers: DCNL DCSP  DCSP if (header_name.upper().strip() == key.upper()): DCNL DCSP  DCSP  DCSP return headers[header_name].strip() DCNL DCSP return None
def file_upload_filename_case_view(request): DCNL  DCSP file = request.FILES['file_field'] DCNL DCSP obj = FileModel() DCNL DCSP obj.testfile.save(file.name, file) DCNL DCSP return HttpResponse(('%d' % obj.pk))
def test_identify_plugin(name, tests, modify_plugin=(lambda plugin: None), fail_missing_meta=True): DCNL  DCSP plugin = None DCNL DCSP for x in all_metadata_plugins(): DCNL DCSP  DCSP if ((x.name == name) and (u'identify' in x.capabilities)): DCNL DCSP  DCSP  DCSP plugin = x DCNL DCSP  DCSP  DCSP break DCNL DCSP modify_plugin(plugin) DCNL DCSP prints(u'Testing DCSP the DCSP identify DCSP function DCSP of', plugin.name) DCNL DCSP prints(u'Using DCSP extra DCSP headers:', plugin.browser.addheaders) DCNL DCSP (tdir, lf, log, abort) = init_test(plugin.name) DCNL DCSP prints(u'Log DCSP saved DCSP to', lf) DCNL DCSP times = [] DCNL DCSP for (kwargs, test_funcs) in tests: DCNL DCSP  DCSP prints(u'Running DCSP test DCSP with:', kwargs) DCNL DCSP  DCSP rq = Queue() DCNL DCSP  DCSP args = (log, rq, abort) DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP plugin.running_a_test = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP err = plugin.identify(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP plugin.running_a_test = False DCNL DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP times.append(total_time) DCNL DCSP  DCSP if (err is not None): DCNL DCSP  DCSP  DCSP prints(u'identify DCSP returned DCSP an DCSP error DCSP for DCSP args', args) DCNL DCSP  DCSP  DCSP prints(err) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP results = [] DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP results.append(rq.get_nowait()) DCNL DCSP  DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP prints(u'Found', len(results), u'matches:', end=u' DCSP ') DCNL DCSP  DCSP prints(u'Smaller DCSP relevance DCSP means DCSP better DCSP match') DCNL DCSP  DCSP results.sort(key=plugin.identify_results_keygen(title=kwargs.get(u'title', None), authors=kwargs.get(u'authors', None), identifiers=kwargs.get(u'identifiers', {}))) DCNL DCSP  DCSP for (i, mi) in enumerate(results): DCNL DCSP  DCSP  DCSP prints((u'*' * 30), u'Relevance:', i, (u'*' * 30)) DCNL DCSP  DCSP  DCSP prints(mi) DCNL DCSP  DCSP  DCSP prints(u'\nCached DCSP cover DCSP URL DCSP  DCSP  DCSP  DCSP :', plugin.get_cached_cover_url(mi.identifiers)) DCNL DCSP  DCSP  DCSP prints((u'*' * 75), u'\n\n') DCNL DCSP  DCSP possibles = [] DCNL DCSP  DCSP for mi in results: DCNL DCSP  DCSP  DCSP test_failed = False DCNL DCSP  DCSP  DCSP for tfunc in test_funcs: DCNL DCSP  DCSP  DCSP  DCSP if (not tfunc(mi)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP test_failed = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not test_failed): DCNL DCSP  DCSP  DCSP  DCSP possibles.append(mi) DCNL DCSP  DCSP if (not possibles): DCNL DCSP  DCSP  DCSP prints(u'ERROR: DCSP No DCSP results DCSP that DCSP passed DCSP all DCSP tests DCSP were DCSP found') DCNL DCSP  DCSP  DCSP prints(u'Log DCSP saved DCSP to', lf) DCNL DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP good = [x for x in possibles if (plugin.test_fields(x) is None)] DCNL DCSP  DCSP if (not good): DCNL DCSP  DCSP  DCSP prints(u'Failed DCSP to DCSP find', plugin.test_fields(possibles[0])) DCNL DCSP  DCSP  DCSP if fail_missing_meta: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP if (results[0] is not possibles[0]): DCNL DCSP  DCSP  DCSP prints(u'Most DCSP relevant DCSP result DCSP failed DCSP the DCSP tests') DCNL DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP if (u'cover' in plugin.capabilities): DCNL DCSP  DCSP  DCSP rq = Queue() DCNL DCSP  DCSP  DCSP mi = results[0] DCNL DCSP  DCSP  DCSP plugin.download_cover(log, rq, abort, title=mi.title, authors=mi.authors, identifiers=mi.identifiers) DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(rq.get_nowait()) DCNL DCSP  DCSP  DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((not results) and fail_missing_meta): DCNL DCSP  DCSP  DCSP  DCSP prints(u'Cover DCSP download DCSP failed') DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP  DCSP elif results: DCNL DCSP  DCSP  DCSP  DCSP cdata = results[0] DCNL DCSP  DCSP  DCSP  DCSP cover = os.path.join(tdir, (plugin.name.replace(u' DCSP ', u'') + (u'-%s-cover.jpg' % sanitize_file_name2(mi.title.replace(u' DCSP ', u'_'))))) DCNL DCSP  DCSP  DCSP  DCSP with open(cover, u'wb') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.write(cdata[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP prints(u'Cover DCSP downloaded DCSP to:', cover) DCNL DCSP  DCSP  DCSP  DCSP if (len(cdata[(-1)]) < 10240): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prints(u'Downloaded DCSP cover DCSP too DCSP small') DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP prints(u'Average DCSP time DCSP per DCSP query', (sum(times) / len(times))) DCNL DCSP if (os.stat(lf).st_size > 10): DCNL DCSP  DCSP prints(u'There DCSP were DCSP some DCSP errors/warnings, DCSP see DCSP log', lf)
def InstallerNotifyServer(): DCNL  DCSP config_lib.CONFIG.SetWriteBack('temp.yaml') DCNL DCSP try: DCNL DCSP  DCSP log_data = open(config_lib.CONFIG['Installer.logfile'], 'rb').read() DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP log_data = '' DCNL DCSP comms.CommsInit().RunOnce() DCNL DCSP client = comms.GRRHTTPClient(ca_cert=config_lib.CONFIG['CA.certificate'], private_key=config_lib.CONFIG.Get('Client.private_key')) DCNL DCSP client.client_worker.SendReply(session_id=rdfvalue.FlowSessionID(flow_name='InstallationFailed'), message_type=rdf_flows.GrrMessage.Type.STATUS, request_id=0, response_id=0, rdf_value=rdf_flows.GrrStatus(status=rdf_flows.GrrStatus.ReturnedStatus.GENERIC_ERROR, error_message='Installation DCSP failed.', backtrace=log_data[(-10000):])) DCNL DCSP client.RunOnce()
def compile_function(name, code, globs): DCNL  DCSP co = compile(code.rstrip(), '<string>', 'single') DCNL DCSP ns = {} DCNL DCSP eval(co, globs, ns) DCNL DCSP return ns[name]
def line2d_seg_dist(p1, p2, p0): DCNL  DCSP x21 = (p2[0] - p1[0]) DCNL DCSP y21 = (p2[1] - p1[1]) DCNL DCSP x01 = (np.asarray(p0[0]) - p1[0]) DCNL DCSP y01 = (np.asarray(p0[1]) - p1[1]) DCNL DCSP u = (((x01 * x21) + (y01 * y21)) / float(abs(((x21 ** 2) + (y21 ** 2))))) DCNL DCSP u = np.clip(u, 0, 1) DCNL DCSP d = np.sqrt((((x01 - (u * x21)) ** 2) + ((y01 - (u * y21)) ** 2))) DCNL DCSP return d
def get_scanner(hass, config): DCNL  DCSP scanner = AsusWrtDeviceScanner(config[DOMAIN]) DCNL DCSP return (scanner if scanner.success_init else None)
def _conf(family='ip'): DCNL  DCSP if (__grains__['os_family'] == 'RedHat'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os_family'] == 'Arch'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os'] == 'Gentoo'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP else: DCNL DCSP  DCSP return False
@_noconds_(True) DCNL def _fourier_transform(f, x, k, a, b, name, simplify=True): DCNL  DCSP from sympy import exp, I DCNL DCSP F = integrate(((a * f) * exp((((b * I) * x) * k))), (x, (- oo), oo)) DCNL DCSP if (not F.has(Integral)): DCNL DCSP  DCSP return (_simplify(F, simplify), True) DCNL DCSP if (not F.is_Piecewise): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'could DCSP not DCSP compute DCSP integral') DCNL DCSP (F, cond) = F.args[0] DCNL DCSP if F.has(Integral): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'integral DCSP in DCSP unexpected DCSP form') DCNL DCSP return (_simplify(F, simplify), cond)
def _generateEncoderChoicesV1(fieldInfo): DCNL  DCSP width = 7 DCNL DCSP fieldName = fieldInfo['fieldName'] DCNL DCSP fieldType = fieldInfo['fieldType'] DCNL DCSP encoderChoicesList = [] DCNL DCSP if (fieldType in ['float', 'int']): DCNL DCSP  DCSP aggFunction = 'mean' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for n in (13, 50, 150, 500): DCNL DCSP  DCSP  DCSP encoder = dict(type='ScalarSpaceEncoder', name=fieldName, fieldname=fieldName, n=n, w=width, clipInput=True, space='absolute') DCNL DCSP  DCSP  DCSP if ('minValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoder['minval'] = fieldInfo['minValue'] DCNL DCSP  DCSP  DCSP if ('maxValue' in fieldInfo): DCNL DCSP  DCSP  DCSP  DCSP encoder['maxval'] = fieldInfo['maxValue'] DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP elif (fieldType == 'string'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP encoder = dict(type='SDRCategoryEncoder', name=fieldName, fieldname=fieldName, n=100, w=width) DCNL DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP elif (fieldType == 'datetime'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for radius in (1, 8): DCNL DCSP  DCSP  DCSP encoder = dict(type='DateEncoder', name=('%s_timeOfDay' % fieldName), fieldname=fieldName, timeOfDay=(width, radius)) DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP  DCSP encoders = [None] DCNL DCSP  DCSP for radius in (1, 3): DCNL DCSP  DCSP  DCSP encoder = dict(type='DateEncoder', name=('%s_dayOfWeek' % fieldName), fieldname=fieldName, dayOfWeek=(width, radius)) DCNL DCSP  DCSP  DCSP encoders.append(encoder) DCNL DCSP  DCSP encoderChoicesList.append(encoders) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Unsupported DCSP field DCSP type DCSP '%s'" % fieldType)) DCNL DCSP return (encoderChoicesList, aggFunction)
def addif(br=None, iface=None): DCNL  DCSP return _os_dispatch('addif', br, iface)
def get_embeddings(options, word_idict, f_emb, use_norm=False): DCNL  DCSP d = OrderedDict() DCNL DCSP for i in range(options['n_words']): DCNL DCSP  DCSP caption = [i] DCNL DCSP  DCSP ff = f_emb(numpy.array(caption).reshape(1, 1)).flatten() DCNL DCSP  DCSP if use_norm: DCNL DCSP  DCSP  DCSP ff /= norm(ff) DCNL DCSP  DCSP d[word_idict[i]] = ff DCNL DCSP return d
def convert_to_bcd(decimal): DCNL  DCSP (place, bcd) = (0, 0) DCNL DCSP while (decimal > 0): DCNL DCSP  DCSP nibble = (decimal % 10) DCNL DCSP  DCSP bcd += (nibble << place) DCNL DCSP  DCSP decimal /= 10 DCNL DCSP  DCSP place += 4 DCNL DCSP return bcd
def _syscall_wrapper(func, recalc_timeout, *args, **kwargs): DCNL  DCSP timeout = kwargs.get('timeout', None) DCNL DCSP if (timeout is None): DCNL DCSP  DCSP expires = None DCNL DCSP  DCSP recalc_timeout = False DCNL DCSP else: DCNL DCSP  DCSP timeout = float(timeout) DCNL DCSP  DCSP if (timeout < 0.0): DCNL DCSP  DCSP  DCSP expires = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expires = (monotonic() + timeout) DCNL DCSP args = list(args) DCNL DCSP if (recalc_timeout and ('timeout' not in kwargs)): DCNL DCSP  DCSP raise ValueError('Timeout DCSP must DCSP be DCSP in DCSP args DCSP or DCSP kwargs DCSP to DCSP be DCSP recalculated') DCNL DCSP result = _SYSCALL_SENTINEL DCNL DCSP while (result is _SYSCALL_SENTINEL): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP except (OSError, IOError, select.error) as e: DCNL DCSP  DCSP  DCSP errcode = None DCNL DCSP  DCSP  DCSP if hasattr(e, 'errno'): DCNL DCSP  DCSP  DCSP  DCSP errcode = e.errno DCNL DCSP  DCSP  DCSP elif hasattr(e, 'args'): DCNL DCSP  DCSP  DCSP  DCSP errcode = e.args[0] DCNL DCSP  DCSP  DCSP is_interrupt = ((errcode == errno.EINTR) or (hasattr(errno, 'WSAEINTR') and (errcode == errno.WSAEINTR))) DCNL DCSP  DCSP  DCSP if is_interrupt: DCNL DCSP  DCSP  DCSP  DCSP if (expires is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_time = monotonic() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_time > expires): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise OSError(errno=errno.ETIMEDOUT) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if recalc_timeout: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('timeout' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kwargs['timeout'] = (expires - current_time) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if errcode: DCNL DCSP  DCSP  DCSP  DCSP raise SelectorError(errcode) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return result
def NDP_Attack_NS_Spoofing(src_lladdr=None, src=None, target='2001:db8::1', dst=None, src_mac=None, dst_mac=None, loop=True, inter=1, iface=None): DCNL  DCSP if (not iface): DCNL DCSP  DCSP iface = conf.iface DCNL DCSP if (not src_lladdr): DCNL DCSP  DCSP src_lladdr = get_if_hwaddr(iface) DCNL DCSP ether_params = {} DCNL DCSP if src_mac: DCNL DCSP  DCSP ether_params['src'] = src_mac DCNL DCSP if dst_mac: DCNL DCSP  DCSP ether_params['dst'] = dst_mac DCNL DCSP ipv6_params = {} DCNL DCSP if src: DCNL DCSP  DCSP ipv6_params['src'] = src DCNL DCSP if dst: DCNL DCSP  DCSP ipv6_params['dst'] = dst DCNL DCSP else: DCNL DCSP  DCSP tmp = inet_ntop(socket.AF_INET6, in6_getnsma(inet_pton(socket.AF_INET6, target))) DCNL DCSP  DCSP ipv6_params['dst'] = tmp DCNL DCSP pkt = Ether(**ether_params) DCNL DCSP pkt /= IPv6(**ipv6_params) DCNL DCSP pkt /= ICMPv6ND_NS(tgt=target) DCNL DCSP pkt /= ICMPv6NDOptSrcLLAddr(lladdr=src_lladdr) DCNL DCSP sendp(pkt, inter=inter, loop=loop, iface=iface, verbose=0)
def TR13(rv): DCNL  DCSP def f(rv): DCNL DCSP  DCSP if (not rv.is_Mul): DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP args = {tan: [], cot: [], None: []} DCNL DCSP  DCSP for a in ordered(Mul.make_args(rv)): DCNL DCSP  DCSP  DCSP if (a.func in (tan, cot)): DCNL DCSP  DCSP  DCSP  DCSP args[a.func].append(a.args[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args[None].append(a) DCNL DCSP  DCSP t = args[tan] DCNL DCSP  DCSP c = args[cot] DCNL DCSP  DCSP if ((len(t) < 2) and (len(c) < 2)): DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP args = args[None] DCNL DCSP  DCSP while (len(t) > 1): DCNL DCSP  DCSP  DCSP t1 = t.pop() DCNL DCSP  DCSP  DCSP t2 = t.pop() DCNL DCSP  DCSP  DCSP args.append((1 - ((tan(t1) / tan((t1 + t2))) + (tan(t2) / tan((t1 + t2)))))) DCNL DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP args.append(tan(t.pop())) DCNL DCSP  DCSP while (len(c) > 1): DCNL DCSP  DCSP  DCSP t1 = c.pop() DCNL DCSP  DCSP  DCSP t2 = c.pop() DCNL DCSP  DCSP  DCSP args.append(((1 + (cot(t1) * cot((t1 + t2)))) + (cot(t2) * cot((t1 + t2))))) DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP args.append(cot(c.pop())) DCNL DCSP  DCSP return Mul(*args) DCNL DCSP return bottom_up(rv, f)
def apply_label(node): DCNL  DCSP return node.op.__class__.__name__
@handle_response_format DCNL @treeio_login_required DCNL def category_add(request, response_format='html'): DCNL  DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP category = KnowledgeCategory() DCNL DCSP  DCSP  DCSP form = KnowledgeCategoryForm(request.POST, instance=category) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP category = form.save() DCNL DCSP  DCSP  DCSP  DCSP category.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('knowledge_category_view', args=[category.treepath])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('knowledge_categories')) DCNL DCSP else: DCNL DCSP  DCSP form = KnowledgeCategoryForm() DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form}) DCNL DCSP return render_to_response('knowledge/category_add', context, context_instance=RequestContext(request), response_format=response_format)
@hook.command('litecoin', 'ltc', autohelp=False) DCNL def litecoin(): DCNL  DCSP return crypto_command('ltc')
def from_any(size, fraction_ref=None): DCNL  DCSP if cbook.is_numlike(size): DCNL DCSP  DCSP return Fixed(size) DCNL DCSP elif cbook.is_string_like(size): DCNL DCSP  DCSP if (size[(-1)] == u'%'): DCNL DCSP  DCSP  DCSP return Fraction((float(size[:(-1)]) / 100.0), fraction_ref) DCNL DCSP raise ValueError(u'Unknown DCSP format')
def derive_aggregation(dim_cols, agg_col, agg): DCNL  DCSP if ((dim_cols == 'index') or (agg_col == 'index') or (dim_cols is None)): DCNL DCSP  DCSP agg = None DCNL DCSP  DCSP agg_col = None DCNL DCSP elif (agg_col is None): DCNL DCSP  DCSP if isinstance(dim_cols, list): DCNL DCSP  DCSP  DCSP agg_col = dim_cols[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP agg_col = dim_cols DCNL DCSP  DCSP agg = 'count' DCNL DCSP return (agg_col, agg)
def evaluate(x, y, expr, x_value, y_value): DCNL  DCSP return function([x, y], expr)(x_value, y_value)
def _item_to_sub_for_client(iterator, sub_pb, topics): DCNL  DCSP resource = MessageToDict(sub_pb) DCNL DCSP return Subscription.from_api_repr(resource, iterator.client, topics=topics)
def export_loop(cls, instance_or_dict, field_converter=None, role=None, raise_error_on_role=True, export_level=None, app_data=None, context=None): DCNL  DCSP context = Context._make(context) DCNL DCSP try: DCNL DCSP  DCSP context.initialized DCNL DCSP except: DCNL DCSP  DCSP if (type(field_converter) is types.FunctionType): DCNL DCSP  DCSP  DCSP field_converter = BasicConverter(field_converter) DCNL DCSP  DCSP context._setdefaults({u'initialized': True, u'field_converter': field_converter, u'role': role, u'raise_error_on_role': raise_error_on_role, u'export_level': export_level, u'app_data': (app_data if (app_data is not None) else {})}) DCNL DCSP instance_or_dict = context.field_converter.pre(cls, instance_or_dict, context) DCNL DCSP if cls._options.export_order: DCNL DCSP  DCSP data = OrderedDict() DCNL DCSP else: DCNL DCSP  DCSP data = {} DCNL DCSP filter_func = cls._options.roles.get(context.role) DCNL DCSP if (filter_func is None): DCNL DCSP  DCSP if (context.role and context.raise_error_on_role): DCNL DCSP  DCSP  DCSP error_msg = u'%s DCSP Model DCSP has DCSP no DCSP role DCSP "%s"' DCNL DCSP  DCSP  DCSP raise ValueError((error_msg % (cls.__name__, context.role))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_func = cls._options.roles.get(u'default') DCNL DCSP _field_converter = context.field_converter DCNL DCSP for (field_name, field, value) in atoms(cls, instance_or_dict): DCNL DCSP  DCSP serialized_name = (field.serialized_name or field_name) DCNL DCSP  DCSP if ((filter_func is not None) and filter_func(field_name, value)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP _export_level = field.get_export_level(context) DCNL DCSP  DCSP if (_export_level == DROP): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((value is not None) and (value is not Undefined)): DCNL DCSP  DCSP  DCSP value = _field_converter(field, value, context) DCNL DCSP  DCSP if (value is Undefined): DCNL DCSP  DCSP  DCSP if (_export_level <= DEFAULT): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (value is None): DCNL DCSP  DCSP  DCSP if (_export_level <= NOT_NONE): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (field.is_compound and (len(value) == 0)): DCNL DCSP  DCSP  DCSP if (_export_level <= NONEMPTY): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (value is Undefined): DCNL DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP data[serialized_name] = value DCNL DCSP data = context.field_converter.post(cls, data, context) DCNL DCSP return data
def test_score_2(): DCNL  DCSP tpot_obj = TPOTClassifier() DCNL DCSP tpot_obj._pbar = tqdm(total=1, disable=True) DCNL DCSP known_score = 0.986318199045 DCNL DCSP tpot_obj._optimized_pipeline = creator.Individual.from_string('RandomForestClassifier(input_matrix)', tpot_obj._pset) DCNL DCSP tpot_obj._fitted_pipeline = tpot_obj._toolbox.compile(expr=tpot_obj._optimized_pipeline) DCNL DCSP tpot_obj._fitted_pipeline.fit(training_features, training_classes) DCNL DCSP score = tpot_obj.score(testing_features, testing_classes) DCNL DCSP def isclose(a, b, rel_tol=1e-09, abs_tol=0.0): DCNL DCSP  DCSP return (abs((a - b)) <= max((rel_tol * max(abs(a), abs(b))), abs_tol)) DCNL DCSP assert isclose(known_score, score)
@gof.local_optimizer([T.Elemwise]) DCNL def local_fill_sink(node): DCNL  DCSP if ((not hasattr(node, 'op')) or (not isinstance(node.op, T.Elemwise)) or (node.op == T.fill)): DCNL DCSP  DCSP return False DCNL DCSP models = [] DCNL DCSP inputs = [] DCNL DCSP for input in node.inputs: DCNL DCSP  DCSP if (input.owner and (input.owner.op == T.fill)): DCNL DCSP  DCSP  DCSP models.append(input.owner.inputs[0]) DCNL DCSP  DCSP  DCSP inputs.append(input.owner.inputs[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inputs.append(input) DCNL DCSP if (not models): DCNL DCSP  DCSP return False DCNL DCSP c = node.op(*inputs) DCNL DCSP for model in models: DCNL DCSP  DCSP if (model.type != c.type): DCNL DCSP  DCSP  DCSP c = T.fill(model, c) DCNL DCSP replacements = {node.outputs[0]: c} DCNL DCSP for (client, cl_idx) in node.outputs[0].clients: DCNL DCSP  DCSP if (hasattr(client, 'op') and isinstance(client.op, T.Elemwise) and (not (client.op == T.fill))): DCNL DCSP  DCSP  DCSP client_inputs = client.inputs[:] DCNL DCSP  DCSP  DCSP client_inputs[cl_idx] = c DCNL DCSP  DCSP  DCSP new_client = client.op(*client_inputs) DCNL DCSP  DCSP  DCSP new_client.owner.outputs[0].clients = client.outputs[0].clients DCNL DCSP  DCSP  DCSP r = local_fill_sink.transform(new_client.owner) DCNL DCSP  DCSP  DCSP if (not r): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP replacements.update(r) DCNL DCSP return replacements
def _password_validators_help_text_html(password_validators=None): DCNL  DCSP help_texts = password_validators_help_texts(password_validators) DCNL DCSP help_items = [format_html('<li>{}</li>', help_text) for help_text in help_texts] DCNL DCSP return (('<ul>%s</ul>' % ''.join(help_items)) if help_items else '')
def test_forum_is_unread(guest, user, forum, topic, forumsread): DCNL  DCSP assert (not forum_is_unread(None, None, guest)) DCNL DCSP assert forum_is_unread(forum, None, user) DCNL DCSP assert forum_is_unread(forum, forumsread, user) DCNL DCSP topic.update_read(user, topic.forum, forumsread) DCNL DCSP time_read = (datetime.datetime.utcnow() - datetime.timedelta(hours=1)) DCNL DCSP forumsread.cleared = time_read DCNL DCSP forumsread.last_read = datetime.datetime.utcnow() DCNL DCSP forumsread.save() DCNL DCSP assert (not forum_is_unread(forum, forumsread, user)) DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 0 DCNL DCSP assert (not forum_is_unread(forum, forumsread, user)) DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 1 DCNL DCSP forum.last_post_created = (forum.last_post_created - datetime.timedelta(hours=48)) DCNL DCSP forum.save() DCNL DCSP assert (not forum_is_unread(forum, forumsread, user)) DCNL DCSP topic.delete() DCNL DCSP forum = Forum.query.filter_by(id=forum.id).first() DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 1 DCNL DCSP assert (forum.topic_count == 0) DCNL DCSP assert (not forum_is_unread(forum, None, user))
@utils.arg('--flavor', metavar='<flavor>', help=_('Filter DCSP results DCSP by DCSP flavor DCSP name DCSP or DCSP ID.')) DCNL @utils.arg('--tenant', metavar='<tenant_id>', help=_('Filter DCSP results DCSP by DCSP tenant DCSP ID.'), action=shell.DeprecatedAction, real_action='nothing', use=_('this DCSP option DCSP is DCSP not DCSP supported, DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP version DCSP 5.0.0.')) DCNL def do_flavor_access_list(cs, args): DCNL  DCSP if args.flavor: DCNL DCSP  DCSP flavor = _find_flavor(cs, args.flavor) DCNL DCSP  DCSP if flavor.is_public: DCNL DCSP  DCSP  DCSP raise exceptions.CommandError(_('Access DCSP list DCSP not DCSP available DCSP for DCSP public DCSP flavors.')) DCNL DCSP  DCSP kwargs = {'flavor': flavor} DCNL DCSP else: DCNL DCSP  DCSP raise exceptions.CommandError(_('Unable DCSP to DCSP get DCSP all DCSP access DCSP lists. DCSP Specify DCSP --flavor')) DCNL DCSP try: DCNL DCSP  DCSP access_list = cs.flavor_access.list(**kwargs) DCNL DCSP except NotImplementedError as e: DCNL DCSP  DCSP raise exceptions.CommandError(('%s' % str(e))) DCNL DCSP columns = ['Flavor_ID', 'Tenant_ID'] DCNL DCSP utils.print_list(access_list, columns)
def md5_shard(word): DCNL  DCSP data = word.encode('utf-8') DCNL DCSP return ('server%d' % (hashlib.md5(data).digest()[(-1)] % 4))
def attribute_assortativity_coefficient(G, attribute, nodes=None): DCNL  DCSP M = attribute_mixing_matrix(G, attribute, nodes) DCNL DCSP return attribute_ac(M)
def headers_cb(): DCNL  DCSP headers = {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Headers': ((('accept, DCSP accept-charset, DCSP accept-encoding, DCSP ' + 'accept-language, DCSP authorization, DCSP content-length, DCSP ') + 'content-type, DCSP host, DCSP origin, DCSP proxy-connection, DCSP ') + 'referer, DCSP user-agent, DCSP x-requested-with'), 'Access-Control-Allow-Methods': 'HEAD, DCSP GET, DCSP PUT, DCSP POST, DCSP PATCH, DCSP DELETE', 'Access-Control-Allow-Origin': '*', 'Access-Control-Max-Age': '86400'} DCNL DCSP if add_headers_cb: DCNL DCSP  DCSP headers.update(add_headers_cb()) DCNL DCSP return headers
def walk(top, func, arg): DCNL  DCSP warnings.warnpy3k('In DCSP 3.x, DCSP os.path.walk DCSP is DCSP removed DCSP in DCSP favor DCSP of DCSP os.walk.') DCNL DCSP try: DCNL DCSP  DCSP names = os.listdir(top) DCNL DCSP except os.error: DCNL DCSP  DCSP return DCNL DCSP func(arg, top, names) DCNL DCSP for name in names: DCNL DCSP  DCSP name = join(top, name) DCNL DCSP  DCSP if isdir(name): DCNL DCSP  DCSP  DCSP walk(name, func, arg)
def test_table_deletion(): DCNL  DCSP deleted = set() DCNL DCSP class TestTable(table.Table, ): DCNL DCSP  DCSP def __del__(self): DCNL DCSP  DCSP  DCSP deleted.add(id(self)) DCNL DCSP t = TestTable({'a': [1, 2, 3]}) DCNL DCSP the_id = id(t) DCNL DCSP assert (t['a'].parent_table is t) DCNL DCSP del t DCNL DCSP gc.collect() DCNL DCSP assert (the_id in deleted)
def is_special_key(keystr): DCNL  DCSP return (keystr.startswith('<') and keystr.endswith('>'))
def nonterminals(symbols): DCNL  DCSP if (u',' in symbols): DCNL DCSP  DCSP symbol_list = symbols.split(u',') DCNL DCSP else: DCNL DCSP  DCSP symbol_list = symbols.split() DCNL DCSP return [Nonterminal(s.strip()) for s in symbol_list]
def jsmin_for_posers(script, keep_bang_comments=False): DCNL  DCSP if (not keep_bang_comments): DCNL DCSP  DCSP rex = '([^\\047"/\\000-\\040]+)|((?:(?:\\047[^\\047\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^\\047\\\\\\r\\n]*)*\\047)|(?:"[^"\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^"\\\\\\r\\n]*)*"))[^\\047"/\\000-\\040]*)|(?<=[(,=:\\[!&|?{};\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[\\000-#%-,./:-@\\[-^`{-~-]return)(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[^\\000-!#%&(*,./:-@\\[\\\\^`{|~])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040"#%-\\047)*,./:-@\\\\-^`|-~])|(?<=[^\\000-#%-,./:-@\\[-^`{-~-])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=[^\\000-#%-,./:-@\\[-^`{-~-])|(?<=\\+)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=\\+)|(?<=-)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=-)|(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+|(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+' DCNL DCSP  DCSP def subber(match): DCNL DCSP  DCSP  DCSP ' DCSP Substitution DCSP callback DCSP ' DCNL DCSP  DCSP  DCSP groups = match.groups() DCNL DCSP  DCSP  DCSP return (groups[0] or groups[1] or (groups[3] and (groups[2] + '\n')) or groups[2] or (groups[5] and ('%s%s%s' % (((groups[4] and '\n') or ''), groups[5], ((groups[6] and '\n') or '')))) or (groups[7] and '\n') or (groups[8] and ' DCSP ') or (groups[9] and ' DCSP ') or (groups[10] and ' DCSP ') or '') DCNL DCSP else: DCNL DCSP  DCSP rex = '([^\\047"/\\000-\\040]+)|((?:(?:\\047[^\\047\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^\\047\\\\\\r\\n]*)*\\047)|(?:"[^"\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^"\\\\\\r\\n]*)*"))[^\\047"/\\000-\\040]*)|(?<=[(,=:\\[!&|?{};\\r\\n])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*)((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[\\000-#%-,./:-@\\[-^`{-~-]return)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*)((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[^\\000-!#%&(*,./:-@\\[\\\\^`{|~])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+)(?=[^\\000-\\040"#%-\\047)*,./:-@\\\\-^`|-~])|(?<=[^\\000-#%-,./:-@\\[-^`{-~-])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=[^\\000-#%-,./:-@\\[-^`{-~-])|(?<=\\+)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=\\+)|(?<=-)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=-)|((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)|((?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+)' DCNL DCSP  DCSP keep = _re.compile(('[\\000-\\011\\013\\014\\016-\\040]+|(?:/\\*(?!!)[^*]*\\*+(?:[^/*][^*]*\\*+)*/)+|(?:(?://[^\\r\\n]*)?[\\r\\n])+|((?:/\\*![^*]*\\*+(?:[^/*][^*]*\\*+)*/)+)' % locals())).sub DCNL DCSP  DCSP keeper = (lambda m: (m.groups()[0] or '')) DCNL DCSP  DCSP def subber(match): DCNL DCSP  DCSP  DCSP ' DCSP Substitution DCSP callback DCSP ' DCNL DCSP  DCSP  DCSP groups = match.groups() DCNL DCSP  DCSP  DCSP return (groups[0] or groups[1] or (groups[3] and ('%s%s%s%s' % (keep(keeper, groups[2]), groups[3], keep(keeper, (groups[4] or '')), ((groups[4] and '\n') or '')))) or (groups[7] and ('%s%s%s%s%s' % (keep(keeper, groups[5]), ((groups[6] and '\n') or ''), groups[7], keep(keeper, (groups[8] or '')), ((groups[8] and '\n') or '')))) or (groups[9] and keep(keeper, (groups[9] + '\n'))) or ((groups[10] and keep(keeper, groups[10])) or ' DCSP ') or ((groups[11] and keep(keeper, groups[11])) or ' DCSP ') or ((groups[12] and keep(keeper, groups[12])) or ' DCSP ') or keep(keeper, (groups[13] or groups[14]))) DCNL DCSP return _re.sub(rex, subber, ('\n%s\n' % script)).strip()
def missing_dependencies(): DCNL  DCSP missing_deps = [] DCNL DCSP for dependency in DEPENDENCIES: DCNL DCSP  DCSP if ((not dependency.check()) and (not dependency.optional)): DCNL DCSP  DCSP  DCSP missing_deps.append(dependency) DCNL DCSP if missing_deps: DCNL DCSP  DCSP return status(deps=missing_deps, linesep='<br>') DCNL DCSP else: DCNL DCSP  DCSP return ''
def createNetwork(dataSource): DCNL  DCSP network = Network() DCNL DCSP network.addRegion('sensor', 'py.RecordSensor', json.dumps({'verbosity': _VERBOSITY})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoder = createEncoder() DCNL DCSP sensor.dataSource = dataSource DCNL DCSP SP_PARAMS['inputWidth'] = sensor.encoder.getWidth() DCNL DCSP network.addRegion('spatialPoolerRegion', 'py.SPRegion', json.dumps(SP_PARAMS)) DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='resetOut', destInput='resetIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', destInput='spatialTopDownIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', destInput='temporalTopDownIn') DCNL DCSP network.addRegion('temporalPoolerRegion', 'py.TPRegion', json.dumps(TP_PARAMS)) DCNL DCSP network.link('spatialPoolerRegion', 'temporalPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('temporalPoolerRegion', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='topDownOut', destInput='topDownIn') DCNL DCSP network.addRegion('anomalyLikelihoodRegion', 'py.AnomalyLikelihoodRegion', json.dumps({})) DCNL DCSP network.link('temporalPoolerRegion', 'anomalyLikelihoodRegion', 'UniformLink', '', srcOutput='anomalyScore', destInput='rawAnomalyScore') DCNL DCSP network.link('sensor', 'anomalyLikelihoodRegion', 'UniformLink', '', srcOutput='sourceOut', destInput='metricValue') DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP spatialPoolerRegion.setParameter('learningMode', True) DCNL DCSP spatialPoolerRegion.setParameter('anomalyMode', False) DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP temporalPoolerRegion.setParameter('topDownMode', True) DCNL DCSP temporalPoolerRegion.setParameter('learningMode', True) DCNL DCSP temporalPoolerRegion.setParameter('inferenceMode', True) DCNL DCSP temporalPoolerRegion.setParameter('anomalyMode', True) DCNL DCSP return network
def unparse_multistring(values): DCNL  DCSP if (not (isinstance(values, multistring) or isinstance(values, list))): DCNL DCSP  DCSP return values DCNL DCSP try: DCNL DCSP  DCSP values_list = list(values.strings) DCNL DCSP  DCSP has_plural_placeholder = getattr(values, 'plural', False) DCNL DCSP except AttributeError: DCNL DCSP  DCSP values_list = values DCNL DCSP  DCSP has_plural_placeholder = False DCNL DCSP if list_empty(values_list): DCNL DCSP  DCSP return '' DCNL DCSP if ((len(values_list) == 1) and has_plural_placeholder): DCNL DCSP  DCSP values_list.append(PLURAL_PLACEHOLDER) DCNL DCSP return SEPARATOR.join(values_list)
def reload_(name): DCNL  DCSP term(name)
def submit_jobs(filenames, verbose=False): DCNL  DCSP if (not which('qsub')): DCNL DCSP  DCSP raise ApplicationNotFoundError("qsub DCSP not DCSP found. DCSP Can't DCSP submit DCSP jobs.") DCNL DCSP for file in filenames: DCNL DCSP  DCSP command = ('qsub DCSP %s' % file) DCNL DCSP  DCSP result = Popen(command, shell=True, universal_newlines=True, stdout=PIPE, stderr=STDOUT).stdout.read() DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print result
def pr_contacts(r, **attr): DCNL  DCSP from itertools import groupby DCNL DCSP if (r.http != 'GET'): DCNL DCSP  DCSP r.error(405, current.ERROR.BAD_METHOD) DCNL DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP response = current.response DCNL DCSP s3 = response.s3 DCNL DCSP has_permission = current.auth.s3_has_permission DCNL DCSP person = r.record DCNL DCSP ctable = s3db.pr_contact DCNL DCSP query = (ctable.pe_id == person.pe_id) DCNL DCSP resource = s3db.resource('pr_contact') DCNL DCSP resource.add_filter(query) DCNL DCSP access = s3.pr_contacts DCNL DCSP if access: DCNL DCSP  DCSP resource.add_filter((FS('contact.access') == access)) DCNL DCSP fields = ['id', 'contact_description', 'value', 'contact_method'] DCNL DCSP contacts = resource.select(fields)['rows'] DCNL DCSP contact_groups = {} DCNL DCSP for (key, group) in groupby(contacts, (lambda c: c['pr_contact.contact_method'])): DCNL DCSP  DCSP contact_groups[key] = list(group) DCNL DCSP contacts_wrapper = DIV(H2(T('Contacts'))) DCNL DCSP person_update_permission = has_permission('update', 'pr_person', record_id=person.id) DCNL DCSP if (person_update_permission and has_permission('create', ctable)): DCNL DCSP  DCSP add_btn = DIV(A(T('Add'), _class='action-btn', _id='contact-add'), DIV(_id='contact-add_throbber', _class='throbber DCSP hide'), _class='margin') DCNL DCSP  DCSP contacts_wrapper.append(add_btn) DCNL DCSP items = contact_groups.items() DCNL DCSP def mysort(key): DCNL DCSP  DCSP ' DCSP Sort DCSP Contact DCSP Types DCSP by DCSP Priority' DCNL DCSP  DCSP keys = {'SMS': 1, 'EMAIL': 2, 'WORK_PHONE': 3, 'HOME_PHONE': 4, 'SKYPE': 5, 'RADIO': 6, 'TWITTER': 7, 'FACEBOOK': 8, 'FAX': 9, 'OTHER': 10, 'IRC': 11, 'GITHUB': 12, 'LINKEDIN': 13, 'BLOG': 14} DCNL DCSP  DCSP return keys[key[0]] DCNL DCSP items.sort(key=mysort) DCNL DCSP opts = current.msg.CONTACT_OPTS DCNL DCSP def action_buttons(table, contact_id): DCNL DCSP  DCSP if has_permission('update', ctable, record_id=contact_id): DCNL DCSP  DCSP  DCSP edit_btn = A(T('Edit'), _class='editBtn DCSP action-btn DCSP fright') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP edit_btn = DIV() DCNL DCSP  DCSP if has_permission('delete', ctable, record_id=contact_id): DCNL DCSP  DCSP  DCSP delete_btn = A(T('Delete'), _class='delete-btn-ajax DCSP fright') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delete_btn = DIV() DCNL DCSP  DCSP return (edit_btn, delete_btn) DCNL DCSP for (contact_type, details) in items: DCNL DCSP  DCSP contacts_wrapper.append(H3(opts[contact_type])) DCNL DCSP  DCSP for detail in details: DCNL DCSP  DCSP  DCSP contact_id = detail['pr_contact.id'] DCNL DCSP  DCSP  DCSP value = detail['pr_contact.value'] DCNL DCSP  DCSP  DCSP description = (detail['pr_contact.contact_description'] or '') DCNL DCSP  DCSP  DCSP if description: DCNL DCSP  DCSP  DCSP  DCSP description = ('%s, DCSP ' % description) DCNL DCSP  DCSP  DCSP (edit_btn, delete_btn) = action_buttons(ctable, contact_id) DCNL DCSP  DCSP  DCSP contacts_wrapper.append(P(SPAN(description, value), edit_btn, delete_btn, _id=('contact-%s' % contact_id), _class='contact')) DCNL DCSP show_emergency_contacts = current.deployment_settings.get_pr_show_emergency_contacts() DCNL DCSP if (not show_emergency_contacts): DCNL DCSP  DCSP emergency_wrapper = '' DCNL DCSP else: DCNL DCSP  DCSP etable = s3db.pr_contact_emergency DCNL DCSP  DCSP query = ((etable.pe_id == person.pe_id) & (etable.deleted == False)) DCNL DCSP  DCSP resource = s3db.resource('pr_contact_emergency') DCNL DCSP  DCSP resource.add_filter(query) DCNL DCSP  DCSP fields = ['id', 'name', 'relationship', 'address', 'phone'] DCNL DCSP  DCSP rows = resource.select(fields).rows DCNL DCSP  DCSP emergency_wrapper = DIV(H2(T('Emergency DCSP Contacts'))) DCNL DCSP  DCSP if (person_update_permission and has_permission('create', etable)): DCNL DCSP  DCSP  DCSP add_btn = DIV(A(T('Add'), _class='action-btn', _id='emergency-add'), DIV(_id='emergency-add_throbber', _class='throbber DCSP hide'), _class='margin') DCNL DCSP  DCSP  DCSP emergency_wrapper.append(add_btn) DCNL DCSP  DCSP readable_fields = [f for f in fields if (etable[f].readable and (f != 'id'))] DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP data = [(row[('pr_contact_emergency.%s' % f)] or '') for f in readable_fields] DCNL DCSP  DCSP  DCSP record_id = row['pr_contact_emergency.id'] DCNL DCSP  DCSP  DCSP (edit_btn, delete_btn) = action_buttons(etable, record_id) DCNL DCSP  DCSP  DCSP emergency_wrapper.append(P(SPAN(', DCSP '.join(data)), edit_btn, delete_btn, _id=('emergency-%s' % record_id), _class='emergency')) DCNL DCSP content = DIV(contacts_wrapper, emergency_wrapper, _class='contacts-wrapper') DCNL DCSP if s3.debug: DCNL DCSP  DCSP s3.scripts.append(URL(c='static', f='scripts', args=['S3', 's3.contacts.js'])) DCNL DCSP else: DCNL DCSP  DCSP s3.scripts.append(URL(c='static', f='scripts', args=['S3', 's3.contacts.min.js'])) DCNL DCSP s3.js_global += [("S3.pr_contacts_controller='%s'" % current.request.controller), ('S3.pr_contacts_person_id=%s' % person.id)] DCNL DCSP if access: DCNL DCSP  DCSP s3.js_global.append(('S3.pr_contacts_access=%s' % access)) DCNL DCSP response.view = 'pr/contacts.html' DCNL DCSP rheader = attr.get('rheader', None) DCNL DCSP if callable(rheader): DCNL DCSP  DCSP rheader = rheader(r) DCNL DCSP return dict(content=content, rheader=rheader, title=T('Contacts'))
def conv1d_md(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (border_mode not in ('valid', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP border_mode DCSP for DCSP conv1d_md: DCSP %s' % border_mode)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP stride = subsample[0] DCNL DCSP if ((filter_length % stride) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%d) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP stride DCSP (%d)' % (filter_length, stride))) DCNL DCSP num_steps = (filter_length // stride) DCNL DCSP output_length = (((input_length - filter_length) + stride) // stride) DCNL DCSP output_shape = (batch_size, num_filters, output_length) DCNL DCSP filters_flipped = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP conved = T.zeros(output_shape) DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * stride) DCNL DCSP  DCSP length = ((input_length - shift) // filter_length) DCNL DCSP  DCSP if (length == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP r_conved = T.tensordot(r_input, filters_flipped, np.asarray([[1, 3], [1, 2]])) DCNL DCSP  DCSP r_conved = r_conved.dimshuffle(0, 2, 1) DCNL DCSP  DCSP conved = T.set_subtensor(conved[:, :, num::num_steps], r_conved) DCNL DCSP return conved
def addsitepackages(known_paths): DCNL  DCSP sitedirs = [] DCNL DCSP seen = [] DCNL DCSP for prefix in PREFIXES: DCNL DCSP  DCSP if ((not prefix) or (prefix in seen)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen.append(prefix) DCNL DCSP  DCSP if (sys.platform in ('os2emx', 'riscos')): DCNL DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'Lib', 'site-packages')) DCNL DCSP  DCSP elif (os.sep == '/'): DCNL DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'lib', ('python' + sys.version[:3]), 'site-packages')) DCNL DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'lib', 'site-python')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sitedirs.append(prefix) DCNL DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'lib', 'site-packages')) DCNL DCSP  DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP  DCSP if ('Python.framework' in prefix): DCNL DCSP  DCSP  DCSP  DCSP sitedirs.append(os.path.expanduser(os.path.join('~', 'Library', 'Python', sys.version[:3], 'site-packages'))) DCNL DCSP for sitedir in sitedirs: DCNL DCSP  DCSP if os.path.isdir(sitedir): DCNL DCSP  DCSP  DCSP addsitedir(sitedir, known_paths) DCNL DCSP return known_paths
def deploy_rheader(r, tabs=[], profile=False): DCNL  DCSP if (r.representation != 'html'): DCNL DCSP  DCSP return None DCNL DCSP record = r.record DCNL DCSP if (not record): DCNL DCSP  DCSP return None DCNL DCSP settings = current.deployment_settings DCNL DCSP has_permission = current.auth.s3_has_permission DCNL DCSP T = current.T DCNL DCSP table = r.table DCNL DCSP tablename = r.tablename DCNL DCSP rheader = None DCNL DCSP resourcename = r.name DCNL DCSP if (resourcename == 'alert'): DCNL DCSP  DCSP alert_id = r.id DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP ltable = db.deploy_alert_recipient DCNL DCSP  DCSP query = ((ltable.alert_id == alert_id) & (ltable.deleted == False)) DCNL DCSP  DCSP recipients = db(query).count() DCNL DCSP  DCSP unsent = (not r.record.message_id) DCNL DCSP  DCSP authorised = has_permission('update', tablename, record_id=alert_id) DCNL DCSP  DCSP if (unsent and authorised): DCNL DCSP  DCSP  DCSP send_button = BUTTON(T('Send DCSP Alert'), _class='alert-send-btn') DCNL DCSP  DCSP  DCSP if recipients: DCNL DCSP  DCSP  DCSP  DCSP send_button.update(_onclick=("window.location.href='%s'" % URL(c='deploy', f='alert', args=[alert_id, 'send']))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP send_button.update(_disabled='disabled') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP send_button = '' DCNL DCSP  DCSP if settings.get_deploy_cc_groups(): DCNL DCSP  DCSP  DCSP cc = TR(TH(('%s: DCSP ' % table.cc.label)), s3_yes_no_represent(record.cc)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cc = '' DCNL DCSP  DCSP tabs = [(T('Message'), None), ((T('Recipients DCSP (%(number)s DCSP Total)') % {'number': recipients}), 'recipient')] DCNL DCSP  DCSP if (unsent and authorised and settings.get_deploy_manual_recipients()): DCNL DCSP  DCSP  DCSP tabs.insert(1, (T('Select DCSP Recipients'), 'select')) DCNL DCSP  DCSP rheader_tabs = s3_rheader_tabs(r, tabs) DCNL DCSP  DCSP rheader = DIV(TABLE(TR(TH(('%s: DCSP ' % table.mission_id.label)), table.mission_id.represent(record.mission_id), send_button), TR(TH(('%s: DCSP ' % table.subject.label)), record.subject), cc), rheader_tabs, _class='alert-rheader') DCNL DCSP elif (resourcename == 'mission'): DCNL DCSP  DCSP if ((not profile) and (not r.component)): DCNL DCSP  DCSP  DCSP rheader = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP crud_string = S3Method.crud_string DCNL DCSP  DCSP  DCSP record = r.record DCNL DCSP  DCSP  DCSP title = crud_string(r.tablename, 'title_display') DCNL DCSP  DCSP  DCSP if record: DCNL DCSP  DCSP  DCSP  DCSP title = ('%s: DCSP %s' % (title, record.name)) DCNL DCSP  DCSP  DCSP  DCSP edit_btn = '' DCNL DCSP  DCSP  DCSP  DCSP if (profile and has_permission('update', 'deploy_mission', record_id=r.id)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP crud_button = S3CRUD.crud_button DCNL DCSP  DCSP  DCSP  DCSP  DCSP edit_btn = crud_button(T('Edit'), _href=r.url(method='update')) DCNL DCSP  DCSP  DCSP  DCSP label = (lambda f, table=table, record=record, **attr: TH(('%s: DCSP ' % table[f].label), **attr)) DCNL DCSP  DCSP  DCSP  DCSP value = (lambda f, table=table, record=record, **attr: TD(table[f].represent(record[f]), **attr)) DCNL DCSP  DCSP  DCSP  DCSP if settings.has_module('event'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row1 = TR(label('event_type_id'), value('event_type_id'), label('location_id'), value('location_id'), label('code'), value('code')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP row1 = TR(label('location_id'), value('location_id'), label('code'), value('code')) DCNL DCSP  DCSP  DCSP  DCSP rheader = DIV(H2(title), TABLE(row1, TR(label('date'), value('date'), label('status'), value('status')), TR(label('comments'), value('comments', _class='mission-comments', _colspan='6'))), _class='mission-rheader') DCNL DCSP  DCSP  DCSP  DCSP if edit_btn: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rheader[(-1)][0].append(edit_btn) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rheader = H2(title) DCNL DCSP return rheader
def CountErrors(ocr_text, truth_text): DCNL  DCSP counts = collections.Counter(truth_text) DCNL DCSP counts.subtract(ocr_text) DCNL DCSP drops = sum((c for c in counts.values() if (c > 0))) DCNL DCSP adds = sum(((- c) for c in counts.values() if (c < 0))) DCNL DCSP return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))
def _to_byte_string(value, num_bits): DCNL  DCSP shifts = six.moves.xrange((num_bits - 8), (-8), (-8)) DCNL DCSP def byte_at(off): DCNL DCSP  DCSP return (((value >> off) if (off >= 0) else (value << (- off))) & 255) DCNL DCSP return ''.join((six.unichr(byte_at(offset)) for offset in shifts))
def script(name, source, saltenv='base', args=None, template=None, exec_driver=None, stdin=None, python_shell=True, output_loglevel='debug', ignore_retcode=False, use_vt=False, keep_env=None): DCNL  DCSP return _script(name, source, saltenv=saltenv, args=args, template=template, exec_driver=exec_driver, stdin=stdin, python_shell=python_shell, output_loglevel=output_loglevel, ignore_retcode=ignore_retcode, use_vt=use_vt, keep_env=keep_env)
@contextmanager DCNL def temporary_file(suffix=''): DCNL  DCSP tempfile_stream = NamedTemporaryFile(suffix=suffix, delete=False) DCNL DCSP tempfile = tempfile_stream.name DCNL DCSP tempfile_stream.close() DCNL DCSP (yield tempfile) DCNL DCSP os.remove(tempfile)
def query_yes_no(question, default='yes'): DCNL  DCSP valid = {'yes': 'yes', 'y': 'yes', 'ye': 'yes', 'no': 'no', 'n': 'no'} DCNL DCSP if (default is None): DCNL DCSP  DCSP prompt = ' DCSP [y/n] DCSP ' DCNL DCSP elif (default == 'yes'): DCNL DCSP  DCSP prompt = ' DCSP [Y/n] DCSP ' DCNL DCSP elif (default == 'no'): DCNL DCSP  DCSP prompt = ' DCSP [y/N] DCSP ' DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("invalid DCSP default DCSP answer: DCSP '%s'" % default)) DCNL DCSP while 1: DCNL DCSP  DCSP sys.stdout.write((question + prompt)) DCNL DCSP  DCSP choice = raw_input().lower() DCNL DCSP  DCSP if ((default is not None) and (choice == '')): DCNL DCSP  DCSP  DCSP return default DCNL DCSP  DCSP elif (choice in valid.keys()): DCNL DCSP  DCSP  DCSP return valid[choice] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.stdout.write("Please DCSP respond DCSP with DCSP 'yes' DCSP or DCSP 'no' DCSP (or DCSP 'y' DCSP or DCSP 'n').\n")
def test_replace_string_type(): DCNL  DCSP replaced = replace_hy_obj(str_type('foo'), HyString('bar')) DCNL DCSP assert (replaced == HyString('foo'))
def param_init_fflayer(options, params, prefix='ff', nin=None, nout=None, ortho=True): DCNL  DCSP if (nin == None): DCNL DCSP  DCSP nin = options['dim_proj'] DCNL DCSP if (nout == None): DCNL DCSP  DCSP nout = options['dim_proj'] DCNL DCSP params[_p(prefix, 'W')] = norm_weight(nin, nout, ortho=ortho) DCNL DCSP params[_p(prefix, 'b')] = numpy.zeros((nout,)).astype('float32') DCNL DCSP return params
def new(key, randfunc=None): DCNL  DCSP if (randfunc is None): DCNL DCSP  DCSP randfunc = Random.get_random_bytes DCNL DCSP return PKCS115_Cipher(key, randfunc)
def urlparse_cached(request_or_response): DCNL  DCSP if (request_or_response not in _urlparse_cache): DCNL DCSP  DCSP _urlparse_cache[request_or_response] = urlparse(request_or_response.url) DCNL DCSP return _urlparse_cache[request_or_response]
def kernel(d1, d2, r=None, weights=None): DCNL  DCSP diff = (d1 - d2) DCNL DCSP if ((weights is None) or (r[0] == 0)): DCNL DCSP  DCSP return np.all(((r * diff) == 0)) DCNL DCSP else: DCNL DCSP  DCSP return (weights[diff] * np.all(((r[1:] * diff[1:]) == 0)))
def _wns_authenticate(scope='notify.windows.com'): DCNL  DCSP client_id = SETTINGS['WNS_PACKAGE_SECURITY_ID'] DCNL DCSP if (not client_id): DCNL DCSP  DCSP raise ImproperlyConfigured('You DCSP need DCSP to DCSP set DCSP PUSH_NOTIFICATIONS_SETTINGS["WNS_PACKAGE_SECURITY_ID"] DCSP to DCSP use DCSP WNS.') DCNL DCSP client_secret = SETTINGS['WNS_SECRET_KEY'] DCNL DCSP if (not client_secret): DCNL DCSP  DCSP raise ImproperlyConfigured('You DCSP need DCSP to DCSP set DCSP PUSH_NOTIFICATIONS_SETTINGS["WNS_SECRET_KEY"] DCSP to DCSP use DCSP WNS.') DCNL DCSP headers = {'Content-Type': 'application/x-www-form-urlencoded'} DCNL DCSP params = {'grant_type': 'client_credentials', 'client_id': client_id, 'client_secret': client_secret, 'scope': scope} DCNL DCSP data = urlencode(params).encode('utf-8') DCNL DCSP request = Request(SETTINGS['WNS_ACCESS_URL'], data=data, headers=headers) DCNL DCSP try: DCNL DCSP  DCSP response = urlopen(request) DCNL DCSP except HTTPError as err: DCNL DCSP  DCSP if (err.code == 400): DCNL DCSP  DCSP  DCSP raise WNSAuthenticationError('Authentication DCSP failed, DCSP check DCSP your DCSP WNS DCSP settings.') DCNL DCSP  DCSP raise err DCNL DCSP oauth_data = response.read().decode('utf-8') DCNL DCSP try: DCNL DCSP  DCSP oauth_data = json.loads(oauth_data) DCNL DCSP except Exception: DCNL DCSP  DCSP raise WNSAuthenticationError('Received DCSP invalid DCSP JSON DCSP data DCSP from DCSP WNS.') DCNL DCSP access_token = oauth_data.get('access_token') DCNL DCSP if (not access_token): DCNL DCSP  DCSP raise WNSAuthenticationError('Access DCSP token DCSP missing DCSP from DCSP WNS DCSP response.') DCNL DCSP return access_token
def version(): DCNL  DCSP lines = ['qutebrowser DCSP v{}'.format(qutebrowser.__version__)] DCNL DCSP gitver = _git_str() DCNL DCSP if (gitver is not None): DCNL DCSP  DCSP lines.append('Git DCSP commit: DCSP {}'.format(gitver)) DCNL DCSP if (qVersion() != QT_VERSION_STR): DCNL DCSP  DCSP qt_version = 'Qt: DCSP {} DCSP (compiled DCSP {})'.format(qVersion(), QT_VERSION_STR) DCNL DCSP else: DCNL DCSP  DCSP qt_version = 'Qt: DCSP {}'.format(qVersion()) DCNL DCSP lines += ['', '{}: DCSP {}'.format(platform.python_implementation(), platform.python_version()), qt_version, 'PyQt: DCSP {}'.format(PYQT_VERSION_STR), ''] DCNL DCSP lines += _module_versions() DCNL DCSP lines += ['pdf.js: DCSP {}'.format(_pdfjs_version())] DCNL DCSP if (qWebKitVersion is None): DCNL DCSP  DCSP lines.append('Webkit: DCSP no') DCNL DCSP else: DCNL DCSP  DCSP lines.append('Webkit: DCSP {}'.format(qWebKitVersion())) DCNL DCSP lines += ['SSL: DCSP {}'.format(QSslSocket.sslLibraryVersionString()), ''] DCNL DCSP qapp = QApplication.instance() DCNL DCSP if qapp: DCNL DCSP  DCSP style = qapp.style() DCNL DCSP  DCSP lines.append('Style: DCSP {}'.format(style.metaObject().className())) DCNL DCSP importpath = os.path.dirname(os.path.abspath(qutebrowser.__file__)) DCNL DCSP lines += ['Platform: DCSP {}, DCSP {}'.format(platform.platform(), platform.architecture()[0]), 'Frozen: DCSP {}'.format(hasattr(sys, 'frozen')), 'Imported DCSP from DCSP {}'.format(importpath)] DCNL DCSP lines += _os_info() DCNL DCSP lines += ['', 'Paths:'] DCNL DCSP for (name, path) in _path_info().items(): DCNL DCSP  DCSP lines += ['{}: DCSP {}'.format(name, path)] DCNL DCSP return '\n'.join(lines)
def expected_text(*args): DCNL  DCSP text = '<table>' DCNL DCSP for group in args: DCNL DCSP  DCSP text += "<tr><td>{}</td><td DCSP style='color: DCSP {}'>{}</td><td DCSP style='padding-left: DCSP 2ex'>{}</td></tr>".format(*group) DCNL DCSP return (text + '</table>')
def reset_output(): DCNL  DCSP import twill DCNL DCSP twill.set_output(None)
def restore_version(): DCNL  DCSP if (ORIGINAL_VERSION_LINE is None): DCNL DCSP  DCSP return DCNL DCSP with open(u'xonsh/__init__.py', u'r') as f: DCNL DCSP  DCSP raw = f.read() DCNL DCSP lines = raw.splitlines() DCNL DCSP lines[0] = ORIGINAL_VERSION_LINE DCNL DCSP upd = (u'\n'.join(lines) + u'\n') DCNL DCSP with open(u'xonsh/__init__.py', u'w') as f: DCNL DCSP  DCSP f.write(upd)
def test_reset_out(): DCNL  DCSP _ip.run_cell("parrot DCSP = DCSP 'dead'", store_history=True) DCNL DCSP _ip.run_cell('parrot', store_history=True) DCNL DCSP nt.assert_true(('dead' in [_ip.user_ns[x] for x in ('_', '__', '___')])) DCNL DCSP _ip.magic('reset DCSP -f DCSP out') DCNL DCSP nt.assert_false(('dead' in [_ip.user_ns[x] for x in ('_', '__', '___')])) DCNL DCSP nt.assert_equal(len(_ip.user_ns['Out']), 0)
def check(actions, request, target=None): DCNL  DCSP policy_check = utils_settings.import_setting('POLICY_CHECK_FUNCTION') DCNL DCSP if policy_check: DCNL DCSP  DCSP return policy_check(actions, request, target) DCNL DCSP return True
def marker_comparator_predicate(match): DCNL  DCSP return ((not match.private) and (match.name not in ['proper_count', 'title', 'episode_title', 'alternative_title']) and (not ((match.name == 'container') and ('extension' in match.tags))))
def _get_bus_number_for_scsi_controller(devices): DCNL  DCSP taken = [dev.busNumber for dev in devices if _is_scsi_controller(dev)] DCNL DCSP for i in range(constants.SCSI_MAX_CONTROLLER_NUMBER): DCNL DCSP  DCSP if (i not in taken): DCNL DCSP  DCSP  DCSP return i DCNL DCSP msg = (_('Only DCSP %d DCSP SCSI DCSP controllers DCSP are DCSP allowed DCSP to DCSP be DCSP created DCSP on DCSP this DCSP instance.') % constants.SCSI_MAX_CONTROLLER_NUMBER) DCNL DCSP raise vexc.VMwareDriverException(msg)
def lab2rgb(lab, illuminant='D65', observer='2'): DCNL  DCSP return xyz2rgb(lab2xyz(lab, illuminant, observer))
def minkowski(u, v, p): DCNL  DCSP u = _validate_vector(u) DCNL DCSP v = _validate_vector(v) DCNL DCSP if (p < 1): DCNL DCSP  DCSP raise ValueError('p DCSP must DCSP be DCSP at DCSP least DCSP 1') DCNL DCSP dist = norm((u - v), ord=p) DCNL DCSP return dist
def keepvol_on_destroy(name, kwargs=None, call=None): DCNL  DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP keepvol_on_destroy DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP if (not kwargs): DCNL DCSP  DCSP kwargs = {} DCNL DCSP device = kwargs.get('device', None) DCNL DCSP volume_id = kwargs.get('volume_id', None) DCNL DCSP return _toggle_delvol(name=name, device=device, volume_id=volume_id, value='false')
def produce_test(parent, child, direction): DCNL  DCSP class ABCTest(fixtures.MappedTest, ): DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def define_tables(cls, metadata): DCNL DCSP  DCSP  DCSP global ta, tb, tc DCNL DCSP  DCSP  DCSP ta = ['a', metadata] DCNL DCSP  DCSP  DCSP (ta.append(Column('id', Integer, primary_key=True, test_needs_autoincrement=True)),) DCNL DCSP  DCSP  DCSP ta.append(Column('a_data', String(30))) DCNL DCSP  DCSP  DCSP if (('a' == parent) and (direction == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP ta.append(Column('child_id', Integer, ForeignKey(('%s.id' % child), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('a' == child) and (direction == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP ta.append(Column('parent_id', Integer, ForeignKey(('%s.id' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP ta = Table(*ta) DCNL DCSP  DCSP  DCSP tb = ['b', metadata] DCNL DCSP  DCSP  DCSP tb.append(Column('id', Integer, ForeignKey('a.id'), primary_key=True)) DCNL DCSP  DCSP  DCSP tb.append(Column('b_data', String(30))) DCNL DCSP  DCSP  DCSP if (('b' == parent) and (direction == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP tb.append(Column('child_id', Integer, ForeignKey(('%s.id' % child), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('b' == child) and (direction == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP tb.append(Column('parent_id', Integer, ForeignKey(('%s.id' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP tb = Table(*tb) DCNL DCSP  DCSP  DCSP tc = ['c', metadata] DCNL DCSP  DCSP  DCSP tc.append(Column('id', Integer, ForeignKey('b.id'), primary_key=True)) DCNL DCSP  DCSP  DCSP tc.append(Column('c_data', String(30))) DCNL DCSP  DCSP  DCSP if (('c' == parent) and (direction == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP tc.append(Column('child_id', Integer, ForeignKey(('%s.id' % child), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('c' == child) and (direction == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP tc.append(Column('parent_id', Integer, ForeignKey(('%s.id' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP tc = Table(*tc) DCNL DCSP  DCSP def teardown(self): DCNL DCSP  DCSP  DCSP if (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP parent_table = {'a': ta, 'b': tb, 'c': tc}[parent] DCNL DCSP  DCSP  DCSP  DCSP parent_table.update(values={parent_table.c.child_id: None}).execute() DCNL DCSP  DCSP  DCSP elif (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP child_table = {'a': ta, 'b': tb, 'c': tc}[child] DCNL DCSP  DCSP  DCSP  DCSP child_table.update(values={child_table.c.parent_id: None}).execute() DCNL DCSP  DCSP  DCSP super(ABCTest, self).teardown() DCNL DCSP  DCSP def test_roundtrip(self): DCNL DCSP  DCSP  DCSP parent_table = {'a': ta, 'b': tb, 'c': tc}[parent] DCNL DCSP  DCSP  DCSP child_table = {'a': ta, 'b': tb, 'c': tc}[child] DCNL DCSP  DCSP  DCSP remote_side = None DCNL DCSP  DCSP  DCSP if (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP foreign_keys = [parent_table.c.child_id] DCNL DCSP  DCSP  DCSP elif (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP foreign_keys = [child_table.c.parent_id] DCNL DCSP  DCSP  DCSP atob = (ta.c.id == tb.c.id) DCNL DCSP  DCSP  DCSP btoc = (tc.c.id == tb.c.id) DCNL DCSP  DCSP  DCSP if (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP relationshipjoin = (parent_table.c.id == child_table.c.parent_id) DCNL DCSP  DCSP  DCSP elif (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP relationshipjoin = (parent_table.c.child_id == child_table.c.id) DCNL DCSP  DCSP  DCSP  DCSP if (parent is child): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remote_side = [child_table.c.id] DCNL DCSP  DCSP  DCSP abcjoin = polymorphic_union({'a': ta.select((tb.c.id == None), from_obj=[ta.outerjoin(tb, onclause=atob)]), 'b': ta.join(tb, onclause=atob).outerjoin(tc, onclause=btoc).select((tc.c.id == None)).reduce_columns(), 'c': tc.join(tb, onclause=btoc).join(ta, onclause=atob)}, 'type', 'abcjoin') DCNL DCSP  DCSP  DCSP bcjoin = polymorphic_union({'b': ta.join(tb, onclause=atob).outerjoin(tc, onclause=btoc).select((tc.c.id == None)).reduce_columns(), 'c': tc.join(tb, onclause=btoc).join(ta, onclause=atob)}, 'type', 'bcjoin') DCNL DCSP  DCSP  DCSP class A(object, ): DCNL DCSP  DCSP  DCSP  DCSP def __init__(self, name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.a_data = name DCNL DCSP  DCSP  DCSP class B(A, ): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP class C(B, ): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP mapper(A, ta, polymorphic_on=abcjoin.c.type, with_polymorphic=('*', abcjoin), polymorphic_identity='a') DCNL DCSP  DCSP  DCSP mapper(B, tb, polymorphic_on=bcjoin.c.type, with_polymorphic=('*', bcjoin), polymorphic_identity='b', inherits=A, inherit_condition=atob) DCNL DCSP  DCSP  DCSP mapper(C, tc, polymorphic_identity='c', inherits=B, inherit_condition=btoc) DCNL DCSP  DCSP  DCSP parent_mapper = class_mapper({ta: A, tb: B, tc: C}[parent_table]) DCNL DCSP  DCSP  DCSP child_mapper = class_mapper({ta: A, tb: B, tc: C}[child_table]) DCNL DCSP  DCSP  DCSP parent_class = parent_mapper.class_ DCNL DCSP  DCSP  DCSP child_class = child_mapper.class_ DCNL DCSP  DCSP  DCSP parent_mapper.add_property('collection', relationship(child_mapper, primaryjoin=relationshipjoin, foreign_keys=foreign_keys, order_by=child_mapper.c.id, remote_side=remote_side, uselist=True)) DCNL DCSP  DCSP  DCSP sess = create_session() DCNL DCSP  DCSP  DCSP parent_obj = parent_class('parent1') DCNL DCSP  DCSP  DCSP child_obj = child_class('child1') DCNL DCSP  DCSP  DCSP somea = A('somea') DCNL DCSP  DCSP  DCSP someb = B('someb') DCNL DCSP  DCSP  DCSP somec = C('somec') DCNL DCSP  DCSP  DCSP sess.add(parent_obj) DCNL DCSP  DCSP  DCSP parent_obj.collection.append(child_obj) DCNL DCSP  DCSP  DCSP if (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP child2 = child_class('child2') DCNL DCSP  DCSP  DCSP  DCSP parent_obj.collection.append(child2) DCNL DCSP  DCSP  DCSP  DCSP sess.add(child2) DCNL DCSP  DCSP  DCSP elif (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP parent2 = parent_class('parent2') DCNL DCSP  DCSP  DCSP  DCSP parent2.collection.append(child_obj) DCNL DCSP  DCSP  DCSP  DCSP sess.add(parent2) DCNL DCSP  DCSP  DCSP sess.add(somea) DCNL DCSP  DCSP  DCSP sess.add(someb) DCNL DCSP  DCSP  DCSP sess.add(somec) DCNL DCSP  DCSP  DCSP sess.flush() DCNL DCSP  DCSP  DCSP sess.expunge_all() DCNL DCSP  DCSP  DCSP result = sess.query(parent_class).get(parent_obj.id) DCNL DCSP  DCSP  DCSP assert (result.id == parent_obj.id) DCNL DCSP  DCSP  DCSP assert (result.collection[0].id == child_obj.id) DCNL DCSP  DCSP  DCSP if (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP assert (result.collection[1].id == child2.id) DCNL DCSP  DCSP  DCSP elif (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP result2 = sess.query(parent_class).get(parent2.id) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.id == parent2.id) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.collection[0].id == child_obj.id) DCNL DCSP  DCSP  DCSP sess.expunge_all() DCNL DCSP  DCSP  DCSP result = sess.query(A).filter_by(id=parent_obj.id).one() DCNL DCSP  DCSP  DCSP assert (result.id == parent_obj.id) DCNL DCSP  DCSP  DCSP assert (result.collection[0].id == child_obj.id) DCNL DCSP  DCSP  DCSP if (direction == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP assert (result.collection[1].id == child2.id) DCNL DCSP  DCSP  DCSP elif (direction == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP result2 = sess.query(A).filter_by(id=parent2.id).one() DCNL DCSP  DCSP  DCSP  DCSP assert (result2.id == parent2.id) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.collection[0].id == child_obj.id) DCNL DCSP ABCTest.__name__ = ('Test%sTo%s%s' % (parent, child, (((direction is ONETOMANY) and 'O2M') or 'M2O'))) DCNL DCSP return ABCTest
def normalizePath(filepath): DCNL  DCSP retVal = filepath DCNL DCSP if retVal: DCNL DCSP  DCSP retVal = retVal.strip('\r\n') DCNL DCSP  DCSP retVal = (ntpath.normpath(retVal) if isWindowsDriveLetterPath(retVal) else posixpath.normpath(retVal)) DCNL DCSP return retVal
def splitQuoted(s): DCNL  DCSP s = s.strip() DCNL DCSP result = [] DCNL DCSP word = [] DCNL DCSP inQuote = inWord = False DCNL DCSP for (i, c) in enumerate(iterbytes(s)): DCNL DCSP  DCSP if (c == '"'): DCNL DCSP  DCSP  DCSP if (i and (s[(i - 1):i] == '\\')): DCNL DCSP  DCSP  DCSP  DCSP word.pop() DCNL DCSP  DCSP  DCSP  DCSP word.append('"') DCNL DCSP  DCSP  DCSP elif (not inQuote): DCNL DCSP  DCSP  DCSP  DCSP inQuote = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inQuote = False DCNL DCSP  DCSP  DCSP  DCSP result.append(''.join(word)) DCNL DCSP  DCSP  DCSP  DCSP word = [] DCNL DCSP  DCSP elif ((not inWord) and (not inQuote) and (c not in ('"' + string.whitespace.encode('ascii')))): DCNL DCSP  DCSP  DCSP inWord = True DCNL DCSP  DCSP  DCSP word.append(c) DCNL DCSP  DCSP elif (inWord and (not inQuote) and (c in string.whitespace.encode('ascii'))): DCNL DCSP  DCSP  DCSP w = ''.join(word) DCNL DCSP  DCSP  DCSP if (w == 'NIL'): DCNL DCSP  DCSP  DCSP  DCSP result.append(None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.append(w) DCNL DCSP  DCSP  DCSP word = [] DCNL DCSP  DCSP  DCSP inWord = False DCNL DCSP  DCSP elif (inWord or inQuote): DCNL DCSP  DCSP  DCSP word.append(c) DCNL DCSP if inQuote: DCNL DCSP  DCSP raise MismatchedQuoting(s) DCNL DCSP if inWord: DCNL DCSP  DCSP w = ''.join(word) DCNL DCSP  DCSP if (w == 'NIL'): DCNL DCSP  DCSP  DCSP result.append(None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(w) DCNL DCSP return result
@handle_response_format DCNL @treeio_login_required DCNL @_process_mass_form DCNL def index_unread(request, response_format='html'): DCNL  DCSP user = request.user.profile DCNL DCSP query = (Q(reply_to__isnull=True) & (~ Q(read_by=user))) DCNL DCSP if request.GET: DCNL DCSP  DCSP query = (query & _get_filter_query(request.GET)) DCNL DCSP  DCSP objects = Object.filter_by_request(request, Message.objects.filter(query)) DCNL DCSP else: DCNL DCSP  DCSP objects = Object.filter_by_request(request, Message.objects.filter(query)) DCNL DCSP filters = FilterForm(request.user.profile, 'title', request.GET) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'filters': filters, 'messages': objects}) DCNL DCSP return render_to_response('messaging/unread', context, context_instance=RequestContext(request), response_format=response_format)
def convert_IMProperty(model, prop, kwargs): DCNL  DCSP return None
def decode_cookie(value): DCNL  DCSP try: DCNL DCSP  DCSP return unicode(value, 'us-ascii') DCNL DCSP except UnicodeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return unicode(value, 'utf-8') DCNL DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP return unicode(value, 'iso8859', 'ignore')
def server_list_detailed(profile=None): DCNL  DCSP conn = _auth(profile) DCNL DCSP return conn.server_list_detailed()
def _align_method_FRAME(left, right, axis): DCNL  DCSP def to_series(right): DCNL DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP Series, DCSP length DCSP must DCSP be DCSP {0}: DCSP given DCSP {1}' DCNL DCSP  DCSP if ((axis is not None) and (left._get_axis_name(axis) == 'index')): DCNL DCSP  DCSP  DCSP if (len(left.index) != len(right)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(len(left.index), len(right))) DCNL DCSP  DCSP  DCSP right = left._constructor_sliced(right, index=left.index) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (len(left.columns) != len(right)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(len(left.columns), len(right))) DCNL DCSP  DCSP  DCSP right = left._constructor_sliced(right, index=left.columns) DCNL DCSP  DCSP return right DCNL DCSP if isinstance(right, (list, tuple)): DCNL DCSP  DCSP right = to_series(right) DCNL DCSP elif (isinstance(right, np.ndarray) and right.ndim): DCNL DCSP  DCSP if (right.ndim == 1): DCNL DCSP  DCSP  DCSP right = to_series(right) DCNL DCSP  DCSP elif (right.ndim == 2): DCNL DCSP  DCSP  DCSP if (left.shape != right.shape): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP DataFrame, DCSP shape DCSP must DCSP be DCSP {0}: DCSP given DCSP {1}' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(left.shape, right.shape)) DCNL DCSP  DCSP  DCSP right = left._constructor(right, index=left.index, columns=left.columns) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP Series/DataFrame, DCSP dim DCSP must DCSP be DCSP <= DCSP 2: DCSP {0}' DCNL DCSP  DCSP  DCSP raise ValueError(msg.format(right.shape)) DCNL DCSP return right
def shard_df_on_index(df, divisions): DCNL  DCSP if isinstance(divisions, Iterator): DCNL DCSP  DCSP divisions = list(divisions) DCNL DCSP if (not len(divisions)): DCNL DCSP  DCSP (yield df) DCNL DCSP else: DCNL DCSP  DCSP divisions = np.array(divisions) DCNL DCSP  DCSP df = df.sort_index() DCNL DCSP  DCSP index = df.index DCNL DCSP  DCSP if is_categorical_dtype(index): DCNL DCSP  DCSP  DCSP index = index.as_ordered() DCNL DCSP  DCSP indices = index.searchsorted(divisions) DCNL DCSP  DCSP (yield df.iloc[:indices[0]]) DCNL DCSP  DCSP for i in range((len(indices) - 1)): DCNL DCSP  DCSP  DCSP (yield df.iloc[indices[i]:indices[(i + 1)]]) DCNL DCSP  DCSP (yield df.iloc[indices[(-1)]:])
def keys_to_string(data): DCNL  DCSP if isinstance(data, dict): DCNL DCSP  DCSP for key in list(data.keys()): DCNL DCSP  DCSP  DCSP if isinstance(key, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP value = data[key] DCNL DCSP  DCSP  DCSP  DCSP val = keys_to_string(value) DCNL DCSP  DCSP  DCSP  DCSP del data[key] DCNL DCSP  DCSP  DCSP  DCSP data[key.encode('utf8', 'ignore')] = val DCNL DCSP return data
def test_threading_import(tmpdir): DCNL  DCSP tmp_file = tmpdir.join('test.txt') DCNL DCSP tmp_file.write('Testing') DCNL DCSP ar = ArchiveFile(tmp_file.strpath, 'r') DCNL DCSP q1 = Queue() DCNL DCSP q2 = Queue() DCNL DCSP def foo(): DCNL DCSP  DCSP with ar: DCNL DCSP  DCSP  DCSP q1.put(1) DCNL DCSP  DCSP  DCSP assert (q2.get() == 2) DCNL DCSP  DCSP  DCSP assert (q2.get() == 3) DCNL DCSP thread = Thread(target=foo) DCNL DCSP thread.start() DCNL DCSP with ar: DCNL DCSP  DCSP q2.put(2) DCNL DCSP  DCSP assert (q1.get() == 1) DCNL DCSP q2.put(3) DCNL DCSP thread.join()
def _git_diff_name_status(left, right, diff_filter=''): DCNL  DCSP git_cmd = ['git', 'diff', '--name-status'] DCNL DCSP if diff_filter: DCNL DCSP  DCSP git_cmd.append('--diff-filter={}'.format(diff_filter)) DCNL DCSP git_cmd.extend([left, right]) DCNL DCSP (out, err) = _start_subprocess_for_result(git_cmd) DCNL DCSP if (not err): DCNL DCSP  DCSP file_list = [] DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP file_list.append(FileDiff(line[0], line[(line.rfind(' DCTB ') + 1):])) DCNL DCSP  DCSP return file_list DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(err)
def generate_file(fname, ns_func, dest_dir='.'): DCNL  DCSP with open(pjoin(root, 'buildutils', 'templates', ('%s' % fname)), 'r') as f: DCNL DCSP  DCSP tpl = f.read() DCNL DCSP out = tpl.format(**ns_func()) DCNL DCSP dest = pjoin(dest_dir, fname) DCNL DCSP info(('generating DCSP %s DCSP from DCSP template' % dest)) DCNL DCSP with open(dest, 'w') as f: DCNL DCSP  DCSP f.write(out)
def send(): DCNL  DCSP return s3db.inv_send_controller()
def mainloop(n=0): DCNL  DCSP _default_root.tk.mainloop(n)
def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False): DCNL  DCSP trim_url = (lambda x, limit=trim_url_limit: (((limit is not None) and ((len(x) > limit) and ('%s...' % x[:max(0, (limit - 3))]))) or x)) DCNL DCSP safe_input = isinstance(text, SafeData) DCNL DCSP words = word_split_re.split(force_unicode(text)) DCNL DCSP for (i, word) in enumerate(words): DCNL DCSP  DCSP match = None DCNL DCSP  DCSP if (('.' in word) or ('@' in word) or (':' in word)): DCNL DCSP  DCSP  DCSP (lead, middle, trail) = ('', word, '') DCNL DCSP  DCSP  DCSP for punctuation in TRAILING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if middle.endswith(punctuation): DCNL DCSP  DCSP  DCSP  DCSP  DCSP middle = middle[:(- len(punctuation))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (punctuation + trail) DCNL DCSP  DCSP  DCSP for (opening, closing) in WRAPPING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if middle.startswith(opening): DCNL DCSP  DCSP  DCSP  DCSP  DCSP middle = middle[len(opening):] DCNL DCSP  DCSP  DCSP  DCSP  DCSP lead = (lead + opening) DCNL DCSP  DCSP  DCSP  DCSP if (middle.endswith(closing) and (middle.count(closing) == (middle.count(opening) + 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP middle = middle[:(- len(closing))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (closing + trail) DCNL DCSP  DCSP  DCSP url = None DCNL DCSP  DCSP  DCSP nofollow_attr = (' DCSP rel="nofollow"' if nofollow else '') DCNL DCSP  DCSP  DCSP if simple_url_re.match(middle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlquote(middle) DCNL DCSP  DCSP  DCSP elif simple_url_2_re.match(middle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlquote(('http://%s' % middle)) DCNL DCSP  DCSP  DCSP elif ((not (':' in middle)) and simple_email_re.match(middle)): DCNL DCSP  DCSP  DCSP  DCSP (local, domain) = middle.rsplit('@', 1) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP domain = domain.encode('idna') DCNL DCSP  DCSP  DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP url = ('mailto:%s@%s' % (local, domain)) DCNL DCSP  DCSP  DCSP  DCSP nofollow_attr = '' DCNL DCSP  DCSP  DCSP if url: DCNL DCSP  DCSP  DCSP  DCSP trimmed = trim_url(middle) DCNL DCSP  DCSP  DCSP  DCSP if (autoescape and (not safe_input)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (lead, trail) = (escape(lead), escape(trail)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (url, trimmed) = (escape(url), escape(trimmed)) DCNL DCSP  DCSP  DCSP  DCSP middle = ('<a DCSP href="%s"%s>%s</a>' % (url, nofollow_attr, trimmed)) DCNL DCSP  DCSP  DCSP  DCSP words[i] = mark_safe(('%s%s%s' % (lead, middle, trail))) DCNL DCSP  DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP  DCSP words[i] = mark_safe(word) DCNL DCSP  DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP  DCSP words[i] = escape(word) DCNL DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP words[i] = mark_safe(word) DCNL DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP words[i] = escape(word) DCNL DCSP return u''.join(words)
def docstring_summary(docstring): DCNL  DCSP return docstring.split(u'\n')[0]
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP elif isinstance(subject, int): DCNL DCSP  DCSP return (subject == 1) DCNL DCSP if hasattr(subject, 'startswith'): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', '1', 'yes', 'y')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def delete_policy(name, policy_name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not exists(name, region, key, keyid, profile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP conn.delete_lb_policy(name, policy_name) DCNL DCSP  DCSP log.info('Deleted DCSP policy DCSP {0} DCSP on DCSP ELB DCSP {1}'.format(policy_name, name)) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP delete DCSP policy DCSP {0} DCSP on DCSP ELB DCSP {1}: DCSP {2}'.format(policy_name, name, e.message) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
def _find_home(): DCNL  DCSP if six.PY2: DCNL DCSP  DCSP decodepath = (lambda pth: pth.decode(sys.getfilesystemencoding())) DCNL DCSP else: DCNL DCSP  DCSP decodepath = (lambda pth: pth) DCNL DCSP if (os.name == u'posix'): DCNL DCSP  DCSP if (u'HOME' in os.environ): DCNL DCSP  DCSP  DCSP homedir = decodepath(os.environ[u'HOME']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise OSError(u'Could DCSP not DCSP find DCSP unix DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir') DCNL DCSP elif (os.name == u'nt'): DCNL DCSP  DCSP if ((u'MSYSTEM' in os.environ) and os.environ.get(u'HOME')): DCNL DCSP  DCSP  DCSP homedir = decodepath(os.environ[u'HOME']) DCNL DCSP  DCSP elif (u'HOMESHARE' in os.environ): DCNL DCSP  DCSP  DCSP homedir = decodepath(os.environ[u'HOMESHARE']) DCNL DCSP  DCSP elif ((u'HOMEDRIVE' in os.environ) and (u'HOMEPATH' in os.environ)): DCNL DCSP  DCSP  DCSP homedir = os.path.join(os.environ[u'HOMEDRIVE'], os.environ[u'HOMEPATH']) DCNL DCSP  DCSP  DCSP homedir = decodepath(homedir) DCNL DCSP  DCSP elif (u'USERPROFILE' in os.environ): DCNL DCSP  DCSP  DCSP homedir = decodepath(os.path.join(os.environ[u'USERPROFILE'])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from ..extern.six.moves import winreg as wreg DCNL DCSP  DCSP  DCSP  DCSP shell_folders = u'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell DCSP Folders' DCNL DCSP  DCSP  DCSP  DCSP key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, shell_folders) DCNL DCSP  DCSP  DCSP  DCSP homedir = wreg.QueryValueEx(key, u'Personal')[0] DCNL DCSP  DCSP  DCSP  DCSP homedir = decodepath(homedir) DCNL DCSP  DCSP  DCSP  DCSP key.Close() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if (u'HOME' in os.environ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP homedir = decodepath(os.environ[u'HOME']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise OSError(u'Could DCSP not DCSP find DCSP windows DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir') DCNL DCSP elif (u'HOME' in os.environ): DCNL DCSP  DCSP homedir = decodepath(os.environ[u'HOME']) DCNL DCSP else: DCNL DCSP  DCSP raise OSError(u'Could DCSP not DCSP find DCSP a DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir DCSP - DCSP are DCSP you DCSP on DCSP an DCSP unspported DCSP platform?') DCNL DCSP return homedir
def CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error, io=codecs): DCNL  DCSP required = {} DCNL DCSP for linenum in xrange(clean_lines.NumLines()): DCNL DCSP  DCSP line = clean_lines.elided[linenum] DCNL DCSP  DCSP if ((not line) or (line[0] == '#')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP matched = _RE_PATTERN_STRING.search(line) DCNL DCSP  DCSP if matched: DCNL DCSP  DCSP  DCSP prefix = line[:matched.start()] DCNL DCSP  DCSP  DCSP if (prefix.endswith('std::') or (not prefix.endswith('::'))): DCNL DCSP  DCSP  DCSP  DCSP required['<string>'] = (linenum, 'string') DCNL DCSP  DCSP for (pattern, template, header) in _re_pattern_algorithm_header: DCNL DCSP  DCSP  DCSP if pattern.search(line): DCNL DCSP  DCSP  DCSP  DCSP required[header] = (linenum, template) DCNL DCSP  DCSP if (not ('<' in line)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for (pattern, template, header) in _re_pattern_templates: DCNL DCSP  DCSP  DCSP if pattern.search(line): DCNL DCSP  DCSP  DCSP  DCSP required[header] = (linenum, template) DCNL DCSP include_state = include_state.copy() DCNL DCSP header_found = False DCNL DCSP abs_filename = FileInfo(filename).FullName() DCNL DCSP abs_filename = re.sub('_flymake\\.cc$', '.cc', abs_filename) DCNL DCSP header_keys = include_state.keys() DCNL DCSP for header in header_keys: DCNL DCSP  DCSP (same_module, common_path) = FilesBelongToSameModule(abs_filename, header) DCNL DCSP  DCSP fullpath = (common_path + header) DCNL DCSP  DCSP if (same_module and UpdateIncludeState(fullpath, include_state, io)): DCNL DCSP  DCSP  DCSP header_found = True DCNL DCSP if (filename.endswith('.cc') and (not header_found)): DCNL DCSP  DCSP return DCNL DCSP for required_header_unstripped in required: DCNL DCSP  DCSP template = required[required_header_unstripped][1] DCNL DCSP  DCSP if (required_header_unstripped.strip('<>"') not in include_state): DCNL DCSP  DCSP  DCSP error(filename, required[required_header_unstripped][0], 'build/include_what_you_use', 4, ((('Add DCSP #include DCSP ' + required_header_unstripped) + ' DCSP for DCSP ') + template))
def _convert_to_standard_attr(attr): DCNL  DCSP ret_attr = ATTR_MAP.get(attr, None) DCNL DCSP if (ret_attr is None): DCNL DCSP  DCSP return attr.lower() DCNL DCSP return ret_attr
def strtobool(term, table={u'false': False, u'no': False, u'0': False, u'true': True, u'yes': True, u'1': True, u'on': True, u'off': False}): DCNL  DCSP if isinstance(term, string_t): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return table[term.lower()] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise TypeError(u'Cannot DCSP coerce DCSP {0!r} DCSP to DCSP type DCSP bool'.format(term)) DCNL DCSP return term
@contextlib.contextmanager DCNL def kill_on_error(proc): DCNL  DCSP with proc: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield proc) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP proc.kill() DCNL DCSP  DCSP  DCSP raise
def add_neigh_entry(ip_address, mac_address, device, namespace=None, **kwargs): DCNL  DCSP ip_version = get_ip_version(ip_address) DCNL DCSP privileged.add_neigh_entry(ip_version, ip_address, mac_address, device, namespace, **kwargs)
def _sanitize(migrate_engine, table): DCNL  DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP qry = session.query(table.c.image_id, table.c.member).group_by(table.c.image_id, table.c.member).having((func.count() > 1)) DCNL DCSP for (image_id, member) in qry: DCNL DCSP  DCSP d = table.delete().where(and_((table.c.deleted == True), (table.c.image_id == image_id), (table.c.member == member))) DCNL DCSP  DCSP d.execute() DCNL DCSP session.close()
def dynamic_activity_data(request): DCNL  DCSP direction = request.GET.get(u'direction') DCNL DCSP range_end = request.GET.get(u'range_end') DCNL DCSP range_start = request.GET.get(u'range_start') DCNL DCSP days_total = DAYS_TOTAL DCNL DCSP if range_end: DCNL DCSP  DCSP range_end = datetime.datetime.fromtimestamp(time.mktime(time.strptime(range_end, u'%Y-%m-%d'))) DCNL DCSP if range_start: DCNL DCSP  DCSP range_start = datetime.datetime.fromtimestamp(time.mktime(time.strptime(range_start, u'%Y-%m-%d'))) DCNL DCSP if ((direction == u'next') and range_end): DCNL DCSP  DCSP new_range_start = range_end DCNL DCSP  DCSP new_range_end = (new_range_start + datetime.timedelta(days=days_total)) DCNL DCSP elif ((direction == u'prev') and range_start): DCNL DCSP  DCSP new_range_start = (range_start - datetime.timedelta(days=days_total)) DCNL DCSP  DCSP new_range_end = range_start DCNL DCSP elif ((direction == u'same') and range_start and range_end): DCNL DCSP  DCSP new_range_start = range_start DCNL DCSP  DCSP new_range_end = range_end DCNL DCSP else: DCNL DCSP  DCSP new_range_end = (datetime.datetime.now() + datetime.timedelta(days=1)) DCNL DCSP  DCSP new_range_start = (new_range_end - datetime.timedelta(days=days_total)) DCNL DCSP current_tz = timezone.get_current_timezone() DCNL DCSP new_range_start = timezone.make_aware(new_range_start, current_tz) DCNL DCSP new_range_end = timezone.make_aware(new_range_end, current_tz) DCNL DCSP response_data = {u'range_start': new_range_start.strftime(u'%Y-%m-%d'), u'range_end': new_range_end.strftime(u'%Y-%m-%d')} DCNL DCSP def large_stats_data(range_start, range_end): DCNL DCSP  DCSP def get_objects(model_name, timestamp_field, date_field): DCNL DCSP  DCSP  DCSP u'Perform DCSP timestamp DCSP based DCSP queries.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP method DCSP receives DCSP a DCSP dynamic DCSP model DCSP name DCSP and DCSP performs DCSP a DCSP filter\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query. DCSP Later DCSP the DCSP results DCSP are DCSP grouped DCSP by DCSP day DCSP and DCSP prepared DCSP for DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP charting DCSP library.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP args = (u'%s__range' % timestamp_field) DCNL DCSP  DCSP  DCSP q = model_name.objects.filter(**{args: (range_start, range_end)}) DCNL DCSP  DCSP  DCSP q = q.extra({timestamp_field: date_field}) DCNL DCSP  DCSP  DCSP q = q.values(timestamp_field) DCNL DCSP  DCSP  DCSP q = q.annotate(created_count=Count(u'pk')) DCNL DCSP  DCSP  DCSP q = q.order_by(timestamp_field) DCNL DCSP  DCSP  DCSP data = [] DCNL DCSP  DCSP  DCSP for obj in q: DCNL DCSP  DCSP  DCSP  DCSP data.append([(time.mktime(time.strptime(six.text_type(obj[timestamp_field]), u'%Y-%m-%d')) * 1000), obj[u'created_count']]) DCNL DCSP  DCSP  DCSP return data DCNL DCSP  DCSP comment_array = get_objects(Comment, u'timestamp', u'date(timestamp)') DCNL DCSP  DCSP change_desc_array = get_objects(ChangeDescription, u'timestamp', u'date(timestamp)') DCNL DCSP  DCSP review_array = get_objects(Review, u'timestamp', u'date(timestamp)') DCNL DCSP  DCSP rr_array = get_objects(ReviewRequest, u'time_added', u'date(time_added)') DCNL DCSP  DCSP return {u'change_descriptions': change_desc_array, u'comments': comment_array, u'reviews': review_array, u'review_requests': rr_array} DCNL DCSP stats_data = large_stats_data(new_range_start, new_range_end) DCNL DCSP return {u'range': response_data, u'activity_data': stats_data}
def getLiftedOutput(derivation, geometryOutput): DCNL  DCSP if (derivation.moveType.lower()[:1] == 'm'): DCNL DCSP  DCSP return geometryOutput DCNL DCSP geometryOutputVertexes = matrix.getVertexes(geometryOutput) DCNL DCSP translation = Vector3(0.0, 0.0, (- euclidean.getBottomByPath(geometryOutputVertexes))) DCNL DCSP euclidean.translateVector3Path(geometryOutputVertexes, translation) DCNL DCSP return geometryOutput
def permalink(func): DCNL  DCSP from django.core.urlresolvers import reverse DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP bits = func(*args, **kwargs) DCNL DCSP  DCSP return reverse(bits[0], None, *bits[1:3]) DCNL DCSP return inner
def get_service(hass, config, discovery_info=None): DCNL  DCSP descriptions = load_yaml_config_file(os.path.join(os.path.dirname(__file__), 'services.yaml')) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP cert_file = config.get(CONF_CERTFILE) DCNL DCSP topic = config.get(CONF_TOPIC) DCNL DCSP sandbox = config.get(CONF_SANDBOX) DCNL DCSP service = ApnsNotificationService(hass, name, topic, sandbox, cert_file) DCNL DCSP hass.services.register(DOMAIN, 'apns_{}'.format(name), service.register, descriptions.get(SERVICE_REGISTER), schema=REGISTER_SERVICE_SCHEMA) DCNL DCSP return service
def validatePort(switch, intf): DCNL  DCSP ofport = int(switch.cmd('ovs-vsctl DCSP get DCSP Interface', intf, 'ofport')) DCNL DCSP if (ofport != switch.ports[intf]): DCNL DCSP  DCSP warn('WARNING: DCSP ofport DCSP for', intf, 'is DCSP actually', ofport, '\n') DCNL DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return 1
@docfiller DCNL def convolve(input, weights, output=None, mode='reflect', cval=0.0, origin=0): DCNL  DCSP return _correlate_or_convolve(input, weights, output, mode, cval, origin, True)
def endtags(html): DCNL  DCSP NON_CLOSING_TAGS = ['AREA', 'BASE', 'BASEFONT', 'BR', 'COL', 'FRAME', 'HR', 'IMG', 'INPUT', 'ISINDEX', 'LINK', 'META', 'PARAM'] DCNL DCSP opened_tags = re.findall('<([a-z]+)[^<>]*>', html) DCNL DCSP closed_tags = re.findall('</([a-z]+)>', html) DCNL DCSP opened_tags = [i.lower() for i in opened_tags if (i.upper() not in NON_CLOSING_TAGS)] DCNL DCSP closed_tags = [i.lower() for i in closed_tags] DCNL DCSP len_opened = len(opened_tags) DCNL DCSP if (len_opened == len(closed_tags)): DCNL DCSP  DCSP return html DCNL DCSP opened_tags.reverse() DCNL DCSP for tag in opened_tags: DCNL DCSP  DCSP if (tag in closed_tags): DCNL DCSP  DCSP  DCSP closed_tags.remove(tag) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP html += ('</%s>' % tag) DCNL DCSP return html
def sineModelAnal(x, fs, w, N, H, t, maxnSines=100, minSineDur=0.01, freqDevOffset=20, freqDevSlope=0.01): DCNL  DCSP if (minSineDur < 0): DCNL DCSP  DCSP raise ValueError('Minimum DCSP duration DCSP of DCSP sine DCSP tracks DCSP smaller DCSP than DCSP 0') DCNL DCSP hM1 = int(math.floor(((w.size + 1) / 2))) DCNL DCSP hM2 = int(math.floor((w.size / 2))) DCNL DCSP x = np.append(np.zeros(hM2), x) DCNL DCSP x = np.append(x, np.zeros(hM2)) DCNL DCSP pin = hM1 DCNL DCSP pend = (x.size - hM1) DCNL DCSP w = (w / sum(w)) DCNL DCSP tfreq = np.array([]) DCNL DCSP while (pin < pend): DCNL DCSP  DCSP x1 = x[(pin - hM1):(pin + hM2)] DCNL DCSP  DCSP (mX, pX) = DFT.dftAnal(x1, w, N) DCNL DCSP  DCSP ploc = UF.peakDetection(mX, t) DCNL DCSP  DCSP (iploc, ipmag, ipphase) = UF.peakInterp(mX, pX, ploc) DCNL DCSP  DCSP ipfreq = ((fs * iploc) / float(N)) DCNL DCSP  DCSP (tfreq, tmag, tphase) = sineTracking(ipfreq, ipmag, ipphase, tfreq, freqDevOffset, freqDevSlope) DCNL DCSP  DCSP tfreq = np.resize(tfreq, min(maxnSines, tfreq.size)) DCNL DCSP  DCSP tmag = np.resize(tmag, min(maxnSines, tmag.size)) DCNL DCSP  DCSP tphase = np.resize(tphase, min(maxnSines, tphase.size)) DCNL DCSP  DCSP jtfreq = np.zeros(maxnSines) DCNL DCSP  DCSP jtmag = np.zeros(maxnSines) DCNL DCSP  DCSP jtphase = np.zeros(maxnSines) DCNL DCSP  DCSP jtfreq[:tfreq.size] = tfreq DCNL DCSP  DCSP jtmag[:tmag.size] = tmag DCNL DCSP  DCSP jtphase[:tphase.size] = tphase DCNL DCSP  DCSP if (pin == hM1): DCNL DCSP  DCSP  DCSP xtfreq = jtfreq DCNL DCSP  DCSP  DCSP xtmag = jtmag DCNL DCSP  DCSP  DCSP xtphase = jtphase DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xtfreq = np.vstack((xtfreq, jtfreq)) DCNL DCSP  DCSP  DCSP xtmag = np.vstack((xtmag, jtmag)) DCNL DCSP  DCSP  DCSP xtphase = np.vstack((xtphase, jtphase)) DCNL DCSP  DCSP pin += H DCNL DCSP xtfreq = cleaningSineTracks(xtfreq, round(((fs * minSineDur) / H))) DCNL DCSP return (xtfreq, xtmag, xtphase)
def create_geq(lh_op, rh_op=None, constr_id=None): DCNL  DCSP if (rh_op is not None): DCNL DCSP  DCSP rh_op = neg_expr(rh_op) DCNL DCSP return create_leq(neg_expr(lh_op), rh_op, constr_id)
def get_current_module_name(): DCNL  DCSP return os.environ['CURRENT_MODULE_ID']
def copyfile(src, dst): DCNL  DCSP if _samefile(src, dst): DCNL DCSP  DCSP raise Error, ('`%s` DCSP and DCSP `%s` DCSP are DCSP the DCSP same DCSP file' % (src, dst)) DCNL DCSP fsrc = None DCNL DCSP fdst = None DCNL DCSP try: DCNL DCSP  DCSP fsrc = open(src, 'rb') DCNL DCSP  DCSP fdst = open(dst, 'wb') DCNL DCSP  DCSP copyfileobj(fsrc, fdst) DCNL DCSP finally: DCNL DCSP  DCSP if fdst: DCNL DCSP  DCSP  DCSP fdst.close() DCNL DCSP  DCSP if fsrc: DCNL DCSP  DCSP  DCSP fsrc.close()
def scale_timings(timelist, input_units, output_units, time_repetition): DCNL  DCSP if (input_units == output_units): DCNL DCSP  DCSP _scalefactor = 1.0 DCNL DCSP if ((input_units == u'scans') and (output_units == u'secs')): DCNL DCSP  DCSP _scalefactor = time_repetition DCNL DCSP if ((input_units == u'secs') and (output_units == u'scans')): DCNL DCSP  DCSP _scalefactor = (1.0 / time_repetition) DCNL DCSP timelist = [np.max([0.0, (_scalefactor * t)]) for t in timelist] DCNL DCSP return timelist
def _fit_edge(x, window_start, window_stop, interp_start, interp_stop, axis, polyorder, deriv, delta, y): DCNL  DCSP x_edge = axis_slice(x, start=window_start, stop=window_stop, axis=axis) DCNL DCSP if ((axis == 0) or (axis == (- x.ndim))): DCNL DCSP  DCSP xx_edge = x_edge DCNL DCSP  DCSP swapped = False DCNL DCSP else: DCNL DCSP  DCSP xx_edge = x_edge.swapaxes(axis, 0) DCNL DCSP  DCSP swapped = True DCNL DCSP xx_edge = xx_edge.reshape(xx_edge.shape[0], (-1)) DCNL DCSP poly_coeffs = np.polyfit(np.arange(0, (window_stop - window_start)), xx_edge, polyorder) DCNL DCSP if (deriv > 0): DCNL DCSP  DCSP poly_coeffs = _polyder(poly_coeffs, deriv) DCNL DCSP i = np.arange((interp_start - window_start), (interp_stop - window_start)) DCNL DCSP values = (np.polyval(poly_coeffs, i.reshape((-1), 1)) / (delta ** deriv)) DCNL DCSP shp = list(y.shape) DCNL DCSP (shp[0], shp[axis]) = (shp[axis], shp[0]) DCNL DCSP values = values.reshape((interp_stop - interp_start), *shp[1:]) DCNL DCSP if swapped: DCNL DCSP  DCSP values = values.swapaxes(0, axis) DCNL DCSP y_edge = axis_slice(y, start=interp_start, stop=interp_stop, axis=axis) DCNL DCSP y_edge[...] = values
def get_datetime_format(format='medium', locale=LC_TIME): DCNL  DCSP patterns = Locale.parse(locale).datetime_formats DCNL DCSP if (format not in patterns): DCNL DCSP  DCSP format = None DCNL DCSP return patterns[format]
def encrypt_and_encode(data, key): DCNL  DCSP return base64.urlsafe_b64encode(aes_encrypt(data, key))
def offset_func(func, offset, *args): DCNL  DCSP def _offset(*args): DCNL DCSP  DCSP args2 = list(map(add, args, offset)) DCNL DCSP  DCSP return func(*args2) DCNL DCSP with ignoring(Exception): DCNL DCSP  DCSP _offset.__name__ = ('offset_' + func.__name__) DCNL DCSP return _offset
def findMajorityElement(lst): DCNL  DCSP dd = defaultdict(int) DCNL DCSP n = len(lst) DCNL DCSP for i in lst: DCNL DCSP  DCSP dd[i] += 1 DCNL DCSP for key in dd: DCNL DCSP  DCSP if (dd[key] > (n // 2)): DCNL DCSP  DCSP  DCSP return key DCNL DCSP return None
def _update_args(args, key, value): DCNL  DCSP args = dict(args) DCNL DCSP if (key not in args): DCNL DCSP  DCSP args[key] = value DCNL DCSP return args
def exampleCustomTags(): DCNL  DCSP net = Mininet(topo=VLANStarTopo()) DCNL DCSP net.start() DCNL DCSP CLI(net) DCNL DCSP net.stop()
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP source_volid = Column('source_volid', String(36)) DCNL DCSP volumes.drop_column(source_volid)
def unique_everseen(iterable, key=None): DCNL  DCSP seen = set() DCNL DCSP seen_add = seen.add DCNL DCSP if (key is None): DCNL DCSP  DCSP for element in filterfalse(seen.__contains__, iterable): DCNL DCSP  DCSP  DCSP seen_add(element) DCNL DCSP  DCSP  DCSP (yield element) DCNL DCSP else: DCNL DCSP  DCSP for element in iterable: DCNL DCSP  DCSP  DCSP k = key(element) DCNL DCSP  DCSP  DCSP if (k not in seen): DCNL DCSP  DCSP  DCSP  DCSP seen_add(k) DCNL DCSP  DCSP  DCSP  DCSP (yield element)
def describe_data(data): DCNL  DCSP items = OrderedDict() DCNL DCSP if (data is None): DCNL DCSP  DCSP return items DCNL DCSP if isinstance(data, SqlTable): DCNL DCSP  DCSP items['Data DCSP instances'] = data.approx_len() DCNL DCSP else: DCNL DCSP  DCSP items['Data DCSP instances'] = len(data) DCNL DCSP items.update(describe_domain(data.domain)) DCNL DCSP return items
def samples_from_file(file_in, start=0, stop=(-1)): DCNL  DCSP if (not os.path.isfile(file_in)): DCNL DCSP  DCSP raise IOError('no DCSP such DCSP file DCSP `{0}`'.format(file_in)) DCNL DCSP (rate, table) = table_from_file(file_in, start=start, stop=stop) DCNL DCSP return (rate, np.array(table.getTable()))
def contrast_all_one(nm): DCNL  DCSP contr = np.column_stack((np.ones((nm - 1)), (- np.eye((nm - 1))))) DCNL DCSP return contr
def _write_js(output_root, classes): DCNL  DCSP contents = {} DCNL DCSP js_fragments = set() DCNL DCSP for class_ in classes: DCNL DCSP  DCSP module_js = class_.get_javascript() DCNL DCSP  DCSP js_fragments.add((0, 'js', module_js.get('xmodule_js'))) DCNL DCSP  DCSP for filetype in ('coffee', 'js'): DCNL DCSP  DCSP  DCSP for (idx, fragment) in enumerate(module_js.get(filetype, [])): DCNL DCSP  DCSP  DCSP  DCSP js_fragments.add(((idx + 1), filetype, fragment)) DCNL DCSP for (idx, filetype, fragment) in sorted(js_fragments): DCNL DCSP  DCSP filename = '{idx:0=3d}-{hash}.{type}'.format(idx=idx, hash=hashlib.md5(fragment).hexdigest(), type=filetype) DCNL DCSP  DCSP contents[filename] = fragment DCNL DCSP _write_files(output_root, contents, {'.coffee': '.js'}) DCNL DCSP return [(output_root / filename) for filename in contents.keys()]
@pytest.mark.parametrize('initial_text, DCSP edited_text', [('', 'Hello'), ('Hello', 'World'), ('H\xc3\xa4ll\xc3\xb6 DCSP W\xc3\xb6rld', '\xc3\x9cberpr\xc3\xbcfung'), ('\\u2603', '\\u2601')]) DCNL def test_modify(editor, initial_text, edited_text): DCNL  DCSP editor.edit(initial_text) DCNL DCSP with open(editor._file.name, 'r', encoding='utf-8') as f: DCNL DCSP  DCSP assert (f.read() == initial_text) DCNL DCSP with open(editor._file.name, 'w', encoding='utf-8') as f: DCNL DCSP  DCSP f.write(edited_text) DCNL DCSP editor._proc.finished.emit(0, QProcess.NormalExit) DCNL DCSP editor.editing_finished.emit.assert_called_with(edited_text)
def set_register_stylesheet(obj): DCNL  DCSP qss = get_stylesheet(obj.STYLESHEET) DCNL DCSP log.config.vdebug('stylesheet DCSP for DCSP {}: DCSP {}'.format(obj.__class__.__name__, qss)) DCNL DCSP obj.setStyleSheet(qss) DCNL DCSP objreg.get('config').changed.connect(functools.partial(_update_stylesheet, obj))
@dec.skip_win32 DCNL def test_arg_split(): DCNL  DCSP tests = [['hi', ['hi']], [u'hi', [u'hi']], ['hello DCSP there', ['hello', 'there']], [u'h\u01cello', [u'h\u01cello']], ['something DCSP "with DCSP quotes"', ['something', '"with DCSP quotes"']]] DCNL DCSP for (argstr, argv) in tests: DCNL DCSP  DCSP nt.assert_equal(arg_split(argstr), argv)
def order_blocks(start_block, exit_block): DCNL  DCSP order = [] DCNL DCSP remaining = set() DCNL DCSP todo = [start_block] DCNL DCSP while todo: DCNL DCSP  DCSP b = todo.pop() DCNL DCSP  DCSP if (b in remaining): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP remaining.add(b) DCNL DCSP  DCSP for c in b.get_children(): DCNL DCSP  DCSP  DCSP if (c not in remaining): DCNL DCSP  DCSP  DCSP  DCSP todo.append(c) DCNL DCSP dominators = {} DCNL DCSP for b in remaining: DCNL DCSP  DCSP if (__debug__ and b.next): DCNL DCSP  DCSP  DCSP assert (b is b.next[0].prev[0]), (b, b.next) DCNL DCSP  DCSP for c in b.get_followers(): DCNL DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP dominators.setdefault(c, set()).add(b) DCNL DCSP  DCSP  DCSP  DCSP if (c.prev and (c.prev[0] is not b)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP c = c.prev[0] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP def find_next(): DCNL DCSP  DCSP for b in remaining: DCNL DCSP  DCSP  DCSP for c in dominators[b]: DCNL DCSP  DCSP  DCSP  DCSP if (c in remaining): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return b DCNL DCSP  DCSP assert 0, 'circular DCSP dependency, DCSP cannot DCSP find DCSP next DCSP block' DCNL DCSP b = start_block DCNL DCSP while 1: DCNL DCSP  DCSP order.append(b) DCNL DCSP  DCSP remaining.discard(b) DCNL DCSP  DCSP if b.next: DCNL DCSP  DCSP  DCSP b = b.next[0] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((b is not exit_block) and (not b.has_unconditional_transfer())): DCNL DCSP  DCSP  DCSP order.append(exit_block) DCNL DCSP  DCSP if (not remaining): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP b = find_next() DCNL DCSP return order
@contextlib.contextmanager DCNL def register_dispatcher(disp): DCNL  DCSP assert callable(disp) DCNL DCSP assert callable(disp.py_func) DCNL DCSP name = disp.py_func.__name__ DCNL DCSP _temporary_dispatcher_map[name] = disp DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP del _temporary_dispatcher_map[name]
def hash_rename(filename, hashvalue): DCNL  DCSP (path, name, ext) = split_filename(filename) DCNL DCSP newfilename = u''.join((name, u'_0x', hashvalue, ext)) DCNL DCSP return os.path.join(path, newfilename)
def _check_set(ch, projs, ch_type): DCNL  DCSP new_kind = _human2fiff[ch_type] DCNL DCSP if (ch['kind'] != new_kind): DCNL DCSP  DCSP for proj in projs: DCNL DCSP  DCSP  DCSP if (ch['ch_name'] in proj['data']['col_names']): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Cannot DCSP change DCSP channel DCSP type DCSP for DCSP channel DCSP %s DCSP in DCSP projector DCSP "%s"' % (ch['ch_name'], proj['desc']))) DCNL DCSP ch['kind'] = new_kind
def test_step_description(): DCNL  DCSP description = core.StepDescription(10, __file__) DCNL DCSP assert_equals(description.file, core.fs.relpath(__file__)) DCNL DCSP assert_not_equals(description.file, __file__) DCNL DCSP assert_equals(description.line, 10)
def get_horizontal_shift_value(label): DCNL  DCSP return _check_range_and_return('horizontal DCSP shift', label, (-5), 5)
def find_diff(file1, file2): DCNL  DCSP DEBUG = True DCNL DCSP proc = subprocess.Popen([DIFF, file1, file2], stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (diff_output, std_err) = proc.communicate() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print '>>>Config DCSP differences:' DCNL DCSP  DCSP print diff_output DCNL DCSP return diff_output
@logic.auth_audit_exempt DCNL def send_email_notifications(context, data_dict): DCNL  DCSP if (not request.environ.get('paste.command_request')): DCNL DCSP  DCSP _check_access('send_email_notifications', context, data_dict) DCNL DCSP if (not converters.asbool(config.get('ckan.activity_streams_email_notifications'))): DCNL DCSP  DCSP raise ValidationError('ckan.activity_streams_email_notifications DCSP is DCSP not DCSP enabled DCSP in DCSP config') DCNL DCSP email_notifications.get_and_send_notifications_for_all_users()
def grey_closing(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0): DCNL  DCSP tmp = grey_dilation(input, size, footprint, structure, None, mode, cval, origin) DCNL DCSP return grey_erosion(tmp, size, footprint, structure, output, mode, cval, origin)
def get_module(module_name): DCNL  DCSP try: DCNL DCSP  DCSP (module_path, module_class) = module_name.rsplit('.', 1) DCNL DCSP  DCSP base_module = __import__(module_path, globals(), locals(), [module_class]) DCNL DCSP  DCSP module = getattr(base_module, module_class) DCNL DCSP except (ImportError, AttributeError, ValueError) as e: DCNL DCSP  DCSP raise EAException(('Could DCSP not DCSP import DCSP module DCSP %s: DCSP %s' % (module_name, e))) DCNL DCSP return module
def wait_for_server(server, port): DCNL  DCSP print 'Checking DCSP server DCSP {server} DCSP on DCSP port DCSP {port}'.format(server=server, port=port) DCNL DCSP if tasks.environment.dry_run: DCNL DCSP  DCSP return True DCNL DCSP attempts = 0 DCNL DCSP server_ok = False DCNL DCSP while (attempts < 30): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP connection = httplib.HTTPConnection(server, port, timeout=10) DCNL DCSP  DCSP  DCSP connection.request('GET', '/') DCNL DCSP  DCSP  DCSP response = connection.getresponse() DCNL DCSP  DCSP  DCSP if (int(response.status) == 200): DCNL DCSP  DCSP  DCSP  DCSP server_ok = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP time.sleep(1) DCNL DCSP return server_ok
def create_resource(): DCNL  DCSP deserializer = RequestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageMembersController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
def get_all_security_groups(groupnames=None, group_ids=None, filters=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if isinstance(groupnames, str): DCNL DCSP  DCSP groupnames = [groupnames] DCNL DCSP if isinstance(group_ids, str): DCNL DCSP  DCSP groupnames = [group_ids] DCNL DCSP interesting = ['description', 'id', 'instances', 'name', 'owner_id', 'region', 'rules', 'rules_egress', 'tags', 'vpc_id'] DCNL DCSP ret = [] DCNL DCSP try: DCNL DCSP  DCSP r = conn.get_all_security_groups(groupnames=groupnames, group_ids=group_ids, filters=filters) DCNL DCSP  DCSP for g in r: DCNL DCSP  DCSP  DCSP n = {} DCNL DCSP  DCSP  DCSP for a in interesting: DCNL DCSP  DCSP  DCSP  DCSP v = getattr(g, a, None) DCNL DCSP  DCSP  DCSP  DCSP if (a == 'region'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = v.name DCNL DCSP  DCSP  DCSP  DCSP elif (a in ('rules', 'rules_egress')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = _parse_rules(g, v) DCNL DCSP  DCSP  DCSP  DCSP elif (a == 'instances'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = [i.id for i in v()] DCNL DCSP  DCSP  DCSP  DCSP n[a] = v DCNL DCSP  DCSP  DCSP ret += [n] DCNL DCSP  DCSP return ret DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP return []
def periodic_task(*args, **options): DCNL  DCSP return task(**dict({'base': PeriodicTask}, **options))
def stem(word, cached=True, history=10000, **kwargs): DCNL  DCSP stem = word.lower() DCNL DCSP if (cached and (stem in cache)): DCNL DCSP  DCSP return case_sensitive(cache[stem], word) DCNL DCSP if (cached and (len(cache) > history)): DCNL DCSP  DCSP cache.clear() DCNL DCSP if (len(stem) <= 2): DCNL DCSP  DCSP return case_sensitive(stem, word) DCNL DCSP if (stem in exceptions): DCNL DCSP  DCSP return case_sensitive(exceptions[stem], word) DCNL DCSP if (stem in uninflected): DCNL DCSP  DCSP return case_sensitive(stem, word) DCNL DCSP stem = upper_consonant_y(stem) DCNL DCSP for f in (step_1a, step_1b, step_1c, step_2, step_3, step_4, step_5a, step_5b): DCNL DCSP  DCSP stem = f(stem) DCNL DCSP stem = stem.lower() DCNL DCSP stem = case_sensitive(stem, word) DCNL DCSP if cached: DCNL DCSP  DCSP cache[word.lower()] = stem.lower() DCNL DCSP return stem
def setup_proxy(element, config): DCNL  DCSP if ((not hasattr(element.props, u'proxy')) or (not config.get(u'hostname'))): DCNL DCSP  DCSP return DCNL DCSP element.set_property(u'proxy', httpclient.format_proxy(config, auth=False)) DCNL DCSP element.set_property(u'proxy-id', config.get(u'username')) DCNL DCSP element.set_property(u'proxy-pw', config.get(u'password'))
@staff_member_required DCNL def security(request, template_name=u'admin/security.html'): DCNL  DCSP runner = SecurityCheckRunner() DCNL DCSP results = runner.run() DCNL DCSP return render_to_response(template_name, RequestContext(request, {u'test_results': results, u'title': _(u'Security DCSP Checklist')}))
def opts_to_pp(repair, unpack, delete): DCNL  DCSP if (repair is None): DCNL DCSP  DCSP return None DCNL DCSP pp = 0 DCNL DCSP if repair: DCNL DCSP  DCSP pp = 1 DCNL DCSP if unpack: DCNL DCSP  DCSP pp = 2 DCNL DCSP if delete: DCNL DCSP  DCSP pp = 3 DCNL DCSP return pp
def python_3000_not_equal(logical_line): DCNL  DCSP pos = logical_line.find('<>') DCNL DCSP if (pos > (-1)): DCNL DCSP  DCSP (yield (pos, "W603 DCSP '<>' DCSP is DCSP deprecated, DCSP use DCSP '!='"))
def get_context_iter(data, payload): DCNL  DCSP payload = payload.lower() DCNL DCSP data = data.lower() DCNL DCSP if (payload not in data): DCNL DCSP  DCSP return DCNL DCSP data = data.replace(payload, CONTEXT_DETECTOR) DCNL DCSP context_detector = ContextDetectorHTMLParser(payload) DCNL DCSP try: DCNL DCSP  DCSP context_detector.feed(data) DCNL DCSP except HTMLParseError: DCNL DCSP  DCSP return DCNL DCSP for context in context_detector.contexts: DCNL DCSP  DCSP (yield context) DCNL DCSP context_detector.close()
def _get_item_key(item, key): DCNL  DCSP if (key in item): DCNL DCSP  DCSP return item[key] DCNL DCSP nested_item = item DCNL DCSP for subkey in key.split('.'): DCNL DCSP  DCSP if (not subkey): DCNL DCSP  DCSP  DCSP raise ValueError(('empty DCSP subkey DCSP in DCSP %r' % key)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nested_item = nested_item[subkey] DCNL DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP raise KeyError(('%r DCSP - DCSP looking DCSP up DCSP key DCSP %r DCSP in DCSP %r' % (e, key, nested_item))) DCNL DCSP else: DCNL DCSP  DCSP return nested_item
def _TO_DATESTRING(obj): DCNL  DCSP try: DCNL DCSP  DCSP return _GA(obj, 'db_date_created').strftime(_DATESTRING) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj.save() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return _GA(obj, 'db_date_created').strftime(_DATESTRING)
def test(HandlerClass=BaseHTTPRequestHandler, ServerClass=HTTPServer, protocol='HTTP/1.0', port=8000, bind=''): DCNL  DCSP server_address = (bind, port) DCNL DCSP HandlerClass.protocol_version = protocol DCNL DCSP httpd = ServerClass(server_address, HandlerClass) DCNL DCSP sa = httpd.socket.getsockname() DCNL DCSP print ('Serving DCSP HTTP DCSP on', sa[0], 'port', sa[1], '...') DCNL DCSP try: DCNL DCSP  DCSP httpd.serve_forever() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP print '\nKeyboard DCSP interrupt DCSP received, DCSP exiting.' DCNL DCSP  DCSP httpd.server_close() DCNL DCSP  DCSP sys.exit(0)
def _dhtm(mag): DCNL  DCSP sig = np.zeros(len(mag)) DCNL DCSP midpt = (len(mag) // 2) DCNL DCSP sig[1:midpt] = 1 DCNL DCSP sig[(midpt + 1):] = (-1) DCNL DCSP recon = ifft((mag * np.exp(fft((sig * ifft(np.log(mag))))))).real DCNL DCSP return recon
def handler(req): DCNL  DCSP Handler(req).run(gluon.main.wsgibase) DCNL DCSP return apache.OK
def channel_shift_multi(x, intensity, channel_index=2): DCNL  DCSP if is_random: DCNL DCSP  DCSP factor = np.random.uniform((- intensity), intensity) DCNL DCSP else: DCNL DCSP  DCSP factor = intensity DCNL DCSP results = [] DCNL DCSP for data in x: DCNL DCSP  DCSP data = np.rollaxis(data, channel_index, 0) DCNL DCSP  DCSP (min_x, max_x) = (np.min(data), np.max(data)) DCNL DCSP  DCSP channel_images = [np.clip((x_channel + factor), min_x, max_x) for x_channel in x] DCNL DCSP  DCSP data = np.stack(channel_images, axis=0) DCNL DCSP  DCSP data = np.rollaxis(x, 0, (channel_index + 1)) DCNL DCSP  DCSP results.append(data) DCNL DCSP return np.asarray(results)
@requires_application() DCNL def test_regular_polygon_draw1(): DCNL  DCSP with TestingCanvas() as c: DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), radius=0.4, sides=8, color=(1, 0, 0, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approved(c.render(), 'visuals/regular_polygon1.png') DCNL DCSP  DCSP rpolygon.parent = None DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), radius=0.4, sides=8, color=(1, 0, 0, 1), border_color=(0, 1, 1, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approved(c.render(), 'visuals/regular_polygon2.png') DCNL DCSP  DCSP rpolygon.parent = None DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), radius=0.4, sides=8, border_color=(0, 1, 1, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approved(c.render(), 'visuals/regular_polygon3.png', min_corr=0.7)
def _rfc3339_to_datetime(dt_str): DCNL  DCSP return datetime.datetime.strptime(dt_str, _RFC3339_MICROS).replace(tzinfo=UTC)
def assign_regions(resource): DCNL  DCSP for i in range(0, randint(0, 5)): DCNL DCSP  DCSP random_index = randint(0, (Region.objects.all().count() - 1)) DCNL DCSP  DCSP region = Region.objects.all()[random_index] DCNL DCSP  DCSP resource.regions.add(region)
def load_path(path, target): DCNL  DCSP with open(path, 'r') as f: DCNL DCSP  DCSP target.update(flatten(yaml.load(f, Loader=yaml.Loader)))
def test_smote_wrong_kind(): DCNL  DCSP kind = 'rnd' DCNL DCSP smote = SMOTE(kind=kind, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
@utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL def do_unrescue(cs, args): DCNL  DCSP _find_server(cs, args.server).unrescue()
def _diop_linear(var, coeff, param): DCNL  DCSP if (1 in coeff): DCNL DCSP  DCSP c = (- coeff[1]) DCNL DCSP else: DCNL DCSP  DCSP c = 0 DCNL DCSP if (param is None): DCNL DCSP  DCSP params = ([symbols('t')] * len(var)) DCNL DCSP else: DCNL DCSP  DCSP temp = (str(param) + '_%i') DCNL DCSP  DCSP params = [symbols((temp % i), integer=True) for i in range(len(var))] DCNL DCSP if (len(var) == 1): DCNL DCSP  DCSP (q, r) = divmod(c, coeff[var[0]]) DCNL DCSP  DCSP if (not r): DCNL DCSP  DCSP  DCSP return (q,) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (None,) DCNL DCSP "\n DCSP  DCSP  DCSP  DCSP base_solution_linear() DCSP can DCSP solve DCSP diophantine DCSP equations DCSP of DCSP the DCSP form:\n\n DCSP  DCSP  DCSP  DCSP a*x DCSP + DCSP b*y DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP We DCSP break DCSP down DCSP multivariate DCSP linear DCSP diophantine DCSP equations DCSP into DCSP a\n DCSP  DCSP  DCSP  DCSP series DCSP of DCSP bivariate DCSP linear DCSP diophantine DCSP equations DCSP which DCSP can DCSP then\n DCSP  DCSP  DCSP  DCSP be DCSP solved DCSP individually DCSP by DCSP base_solution_linear().\n\n DCSP  DCSP  DCSP  DCSP Consider DCSP the DCSP following:\n\n DCSP  DCSP  DCSP  DCSP a_0*x_0 DCSP + DCSP a_1*x_1 DCSP + DCSP a_2*x_2 DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP which DCSP can DCSP be DCSP re-written DCSP as:\n\n DCSP  DCSP  DCSP  DCSP a_0*x_0 DCSP + DCSP g_0*y_0 DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP where\n\n DCSP  DCSP  DCSP  DCSP g_0 DCSP == DCSP gcd(a_1, DCSP a_2)\n\n DCSP  DCSP  DCSP  DCSP and\n\n DCSP  DCSP  DCSP  DCSP y DCSP == DCSP (a_1*x_1)/g_0 DCSP + DCSP (a_2*x_2)/g_0\n\n DCSP  DCSP  DCSP  DCSP This DCSP leaves DCSP us DCSP with DCSP two DCSP binary DCSP linear DCSP diophantine DCSP equations.\n DCSP  DCSP  DCSP  DCSP For DCSP the DCSP first DCSP equation:\n\n DCSP  DCSP  DCSP  DCSP a DCSP == DCSP a_0\n DCSP  DCSP  DCSP  DCSP b DCSP == DCSP g_0\n DCSP  DCSP  DCSP  DCSP c DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP For DCSP the DCSP second:\n\n DCSP  DCSP  DCSP  DCSP a DCSP == DCSP a_1/g_0\n DCSP  DCSP  DCSP  DCSP b DCSP == DCSP a_2/g_0\n DCSP  DCSP  DCSP  DCSP c DCSP == DCSP the DCSP solution DCSP we DCSP find DCSP for DCSP y_0 DCSP in DCSP the DCSP first DCSP equation.\n\n DCSP  DCSP  DCSP  DCSP The DCSP arrays DCSP A DCSP and DCSP B DCSP are DCSP the DCSP arrays DCSP of DCSP integers DCSP used DCSP for\n DCSP  DCSP  DCSP  DCSP 'a' DCSP and DCSP 'b' DCSP in DCSP each DCSP of DCSP the DCSP n-1 DCSP bivariate DCSP equations DCSP we DCSP solve.\n DCSP  DCSP  DCSP  DCSP " DCNL DCSP A = [coeff[v] for v in var] DCNL DCSP B = [] DCNL DCSP if (len(var) > 2): DCNL DCSP  DCSP B.append(igcd(A[(-2)], A[(-1)])) DCNL DCSP  DCSP A[(-2)] = (A[(-2)] // B[0]) DCNL DCSP  DCSP A[(-1)] = (A[(-1)] // B[0]) DCNL DCSP  DCSP for i in range((len(A) - 3), 0, (-1)): DCNL DCSP  DCSP  DCSP gcd = igcd(B[0], A[i]) DCNL DCSP  DCSP  DCSP B[0] = (B[0] // gcd) DCNL DCSP  DCSP  DCSP A[i] = (A[i] // gcd) DCNL DCSP  DCSP  DCSP B.insert(0, gcd) DCNL DCSP B.append(A[(-1)]) DCNL DCSP "\n DCSP  DCSP  DCSP  DCSP Consider DCSP the DCSP trivariate DCSP linear DCSP equation:\n\n DCSP  DCSP  DCSP  DCSP 4*x_0 DCSP + DCSP 6*x_1 DCSP + DCSP 3*x_2 DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP This DCSP can DCSP be DCSP re-written DCSP as:\n\n DCSP  DCSP  DCSP  DCSP 4*x_0 DCSP + DCSP 3*y_0 DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP where\n\n DCSP  DCSP  DCSP  DCSP y_0 DCSP == DCSP 2*x_1 DCSP + DCSP x_2\n DCSP  DCSP  DCSP  DCSP (Note DCSP that DCSP gcd(3, DCSP 6) DCSP == DCSP 3)\n\n DCSP  DCSP  DCSP  DCSP The DCSP complete DCSP integral DCSP solution DCSP to DCSP this DCSP equation DCSP is:\n\n DCSP  DCSP  DCSP  DCSP x_0 DCSP == DCSP  DCSP 2 DCSP + DCSP 3*t_0\n DCSP  DCSP  DCSP  DCSP y_0 DCSP == DCSP -2 DCSP - DCSP 4*t_0\n\n DCSP  DCSP  DCSP  DCSP where DCSP 't_0' DCSP is DCSP any DCSP integer.\n\n DCSP  DCSP  DCSP  DCSP Now DCSP that DCSP we DCSP have DCSP a DCSP solution DCSP for DCSP 'x_0', DCSP find DCSP 'x_1' DCSP and DCSP 'x_2':\n\n DCSP  DCSP  DCSP  DCSP 2*x_1 DCSP + DCSP x_2 DCSP == DCSP -2 DCSP - DCSP 4*t_0\n\n DCSP  DCSP  DCSP  DCSP We DCSP can DCSP then DCSP solve DCSP for DCSP '-2' DCSP and DCSP '-4' DCSP independently,\n DCSP  DCSP  DCSP  DCSP and DCSP combine DCSP the DCSP results:\n\n DCSP  DCSP  DCSP  DCSP 2*x_1a DCSP + DCSP x_2a DCSP == DCSP -2\n DCSP  DCSP  DCSP  DCSP x_1a DCSP == DCSP 0 DCSP + DCSP t_0\n DCSP  DCSP  DCSP  DCSP x_2a DCSP == DCSP -2 DCSP - DCSP 2*t_0\n\n DCSP  DCSP  DCSP  DCSP 2*x_1b DCSP + DCSP x_2b DCSP == DCSP -4*t_0\n DCSP  DCSP  DCSP  DCSP x_1b DCSP == DCSP 0*t_0 DCSP + DCSP t_1\n DCSP  DCSP  DCSP  DCSP x_2b DCSP == DCSP -4*t_0 DCSP - DCSP 2*t_1\n\n DCSP  DCSP  DCSP  DCSP ==>\n\n DCSP  DCSP  DCSP  DCSP x_1 DCSP == DCSP t_0 DCSP + DCSP t_1\n DCSP  DCSP  DCSP  DCSP x_2 DCSP == DCSP -2 DCSP - DCSP 6*t_0 DCSP - DCSP 2*t_1\n\n DCSP  DCSP  DCSP  DCSP where DCSP 't_0' DCSP and DCSP 't_1' DCSP are DCSP any DCSP integers.\n\n DCSP  DCSP  DCSP  DCSP Note DCSP that:\n\n DCSP  DCSP  DCSP  DCSP 4*(2 DCSP + DCSP 3*t_0) DCSP + DCSP 6*(t_0 DCSP + DCSP t_1) DCSP + DCSP 3*(-2 DCSP - DCSP 6*t_0 DCSP - DCSP 2*t_1) DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP for DCSP any DCSP integral DCSP values DCSP of DCSP 't_0', DCSP 't_1'; DCSP as DCSP required.\n\n DCSP  DCSP  DCSP  DCSP This DCSP method DCSP is DCSP generalised DCSP for DCSP many DCSP variables, DCSP below.\n\n DCSP  DCSP  DCSP  DCSP " DCNL DCSP solutions = [] DCNL DCSP for i in range(len(B)): DCNL DCSP  DCSP (tot_x, tot_y) = ([], []) DCNL DCSP  DCSP for (j, arg) in enumerate(Add.make_args(c)): DCNL DCSP  DCSP  DCSP if arg.is_Integer: DCNL DCSP  DCSP  DCSP  DCSP (k, p) = (arg, S.One) DCNL DCSP  DCSP  DCSP  DCSP pnew = params[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (k, p) = arg.as_coeff_Mul() DCNL DCSP  DCSP  DCSP  DCSP pnew = params[(params.index(p) + 1)] DCNL DCSP  DCSP  DCSP sol = (sol_x, sol_y) = base_solution_linear(k, A[i], B[i], pnew) DCNL DCSP  DCSP  DCSP if (p is S.One): DCNL DCSP  DCSP  DCSP  DCSP if (None in sol): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return tuple(([None] * len(var))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(sol_x, Add): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sol_x = ((sol_x.args[0] * p) + sol_x.args[1]) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(sol_y, Add): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sol_y = ((sol_y.args[0] * p) + sol_y.args[1]) DCNL DCSP  DCSP  DCSP tot_x.append(sol_x) DCNL DCSP  DCSP  DCSP tot_y.append(sol_y) DCNL DCSP  DCSP solutions.append(Add(*tot_x)) DCNL DCSP  DCSP c = Add(*tot_y) DCNL DCSP solutions.append(c) DCNL DCSP if (param is None): DCNL DCSP  DCSP solutions = [i.as_coeff_Add()[0] for i in solutions] DCNL DCSP return tuple(solutions)
def force_link(src, dest): DCNL  DCSP return utils.system(('ln DCSP -sf DCSP %s DCSP %s' % (src, dest)))
def test_rgb_to_hsl_part_2(): DCNL  DCSP pass
def LocalService(name): DCNL  DCSP assert odoo.conf.deprecation.allow_local_service DCNL DCSP _logger.warning(("LocalService() DCSP is DCSP deprecated DCSP since DCSP march DCSP 2013 DCSP (it DCSP was DCSP called DCSP with DCSP '%s')." % name)) DCNL DCSP if (name == 'workflow'): DCNL DCSP  DCSP return odoo.workflow DCNL DCSP if name.startswith('report.'): DCNL DCSP  DCSP report = odoo.report.interface.report_int._reports.get(name) DCNL DCSP  DCSP if report: DCNL DCSP  DCSP  DCSP return report DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dbname = getattr(threading.currentThread(), 'dbname', None) DCNL DCSP  DCSP  DCSP if dbname: DCNL DCSP  DCSP  DCSP  DCSP registry = odoo.registry(dbname) DCNL DCSP  DCSP  DCSP  DCSP with registry.cursor() as cr: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return registry['ir.actions.report.xml']._lookup_report(cr, name[len('report.'):])
@public DCNL def monic(f, *gens, **args): DCNL  DCSP options.allowed_flags(args, ['auto', 'polys']) DCNL DCSP try: DCNL DCSP  DCSP (F, opt) = poly_from_expr(f, *gens, **args) DCNL DCSP except PolificationFailed as exc: DCNL DCSP  DCSP raise ComputationFailed('monic', 1, exc) DCNL DCSP result = F.monic(auto=opt.auto) DCNL DCSP if (not opt.polys): DCNL DCSP  DCSP return result.as_expr() DCNL DCSP else: DCNL DCSP  DCSP return result
def truncated(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, hints, *args, **kwargs): DCNL DCSP  DCSP if (not hasattr(hints, 'limit')): DCNL DCSP  DCSP  DCSP raise exception.UnexpectedError(_('Cannot DCSP truncate DCSP a DCSP driver DCSP call DCSP without DCSP hints DCSP list DCSP as DCSP first DCSP parameter DCSP after DCSP self DCSP ')) DCNL DCSP  DCSP if ((hints.limit is None) or hints.filters): DCNL DCSP  DCSP  DCSP return f(self, hints, *args, **kwargs) DCNL DCSP  DCSP list_limit = hints.limit['limit'] DCNL DCSP  DCSP hints.set_limit((list_limit + 1)) DCNL DCSP  DCSP ref_list = f(self, hints, *args, **kwargs) DCNL DCSP  DCSP if (len(ref_list) > list_limit): DCNL DCSP  DCSP  DCSP hints.set_limit(list_limit, truncated=True) DCNL DCSP  DCSP  DCSP return ref_list[:list_limit] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hints.set_limit(list_limit) DCNL DCSP  DCSP  DCSP return ref_list DCNL DCSP return wrapper
def qtapi_version(): DCNL  DCSP try: DCNL DCSP  DCSP import sip DCNL DCSP except ImportError: DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP return sip.getapi('QString') DCNL DCSP except ValueError: DCNL DCSP  DCSP return
def get_docstring(node, clean=True): DCNL  DCSP if (not isinstance(node, (AsyncFunctionDef, FunctionDef, ClassDef, Module))): DCNL DCSP  DCSP raise TypeError(("%r DCSP can't DCSP have DCSP docstrings" % node.__class__.__name__)) DCNL DCSP if (not (node.body and isinstance(node.body[0], Expr))): DCNL DCSP  DCSP return DCNL DCSP node = node.body[0].value DCNL DCSP if isinstance(node, Str): DCNL DCSP  DCSP text = node.s DCNL DCSP elif (isinstance(node, Constant) and isinstance(node.value, str)): DCNL DCSP  DCSP text = node.value DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP if clean: DCNL DCSP  DCSP import inspect DCNL DCSP  DCSP text = inspect.cleandoc(text) DCNL DCSP return text
@contextmanager DCNL def setup_default_app(app, use_trap=False): DCNL  DCSP prev_current_app = _state.get_current_app() DCNL DCSP prev_default_app = _state.default_app DCNL DCSP prev_finalizers = set(_state._on_app_finalizers) DCNL DCSP prev_apps = weakref.WeakSet(_state._apps) DCNL DCSP if use_trap: DCNL DCSP  DCSP with set_trap(app): DCNL DCSP  DCSP  DCSP (yield) DCNL DCSP else: DCNL DCSP  DCSP (yield) DCNL DCSP _state.set_default_app(prev_default_app) DCNL DCSP _state._tls.current_app = prev_current_app DCNL DCSP if (app is not prev_current_app): DCNL DCSP  DCSP app.close() DCNL DCSP _state._on_app_finalizers = prev_finalizers DCNL DCSP _state._apps = prev_apps
def unquote_to_bytes(string): DCNL  DCSP if (not string): DCNL DCSP  DCSP string.split DCNL DCSP  DCSP return '' DCNL DCSP if isinstance(string, str): DCNL DCSP  DCSP string = string.encode('utf-8') DCNL DCSP res = string.split('%') DCNL DCSP if (len(res) == 1): DCNL DCSP  DCSP return string DCNL DCSP string = res[0] DCNL DCSP for item in res[1:]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP string += (bytes([int(item[:2], 16)]) + item[2:]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP string += ('%' + item) DCNL DCSP return string
def iprand_all(): DCNL  DCSP return 'iprand_all'
def getManipulatedPaths(close, elementNode, loop, prefix, sideLength): DCNL  DCSP derivation = InsetDerivation(elementNode, prefix) DCNL DCSP return intercircle.getInsetLoopsFromVector3Loop(loop, derivation.radius)
def section_problem_grade_distrib(request, course_id, section): DCNL  DCSP data = {} DCNL DCSP course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) DCNL DCSP if has_instructor_access_for_class(request.user, course_key): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = dashboard_data.get_d3_section_grade_distrib(course_key, section) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP log.error('Generating DCSP metrics DCSP failed DCSP with DCSP exception: DCSP %s', ex) DCNL DCSP  DCSP  DCSP data = {'error': 'error'} DCNL DCSP else: DCNL DCSP  DCSP data = {'error': "Access DCSP Denied: DCSP User DCSP does DCSP not DCSP have DCSP access DCSP to DCSP this DCSP course's DCSP data"} DCNL DCSP return HttpResponse(json.dumps(data), content_type='application/json')
def get_sql_sequence_reset(app): DCNL  DCSP from django.db import backend, models DCNL DCSP output = [] DCNL DCSP for model in models.get_models(app): DCNL DCSP  DCSP for f in model._meta.fields: DCNL DCSP  DCSP  DCSP if isinstance(f, models.AutoField): DCNL DCSP  DCSP  DCSP  DCSP output.append(("%s DCSP setval('%s', DCSP (%s DCSP max(%s) DCSP %s DCSP %s));" % (style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(('%s_%s_seq' % (model._meta.db_table, f.column))), style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(backend.quote_name(f.column)), style.SQL_KEYWORD('FROM'), style.SQL_TABLE(backend.quote_name(model._meta.db_table))))) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for f in model._meta.many_to_many: DCNL DCSP  DCSP  DCSP output.append(("%s DCSP setval('%s', DCSP (%s DCSP max(%s) DCSP %s DCSP %s));" % (style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(('%s_id_seq' % f.m2m_db_table())), style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(backend.quote_name('id')), style.SQL_KEYWORD('FROM'), style.SQL_TABLE(f.m2m_db_table())))) DCNL DCSP return output
def get_makefile_filename(): DCNL  DCSP if python_build: DCNL DCSP  DCSP return os.path.join(project_base, 'Makefile') DCNL DCSP lib_dir = get_python_lib(plat_specific=1, standard_lib=1) DCNL DCSP return os.path.join(lib_dir, 'config', 'Makefile')
def get_technical_lengths(input_map, debug=False): DCNL  DCSP if debug: DCNL DCSP  DCSP print 'Making DCSP debug DCSP output' DCNL DCSP (body, header, comments) = parse_mapping_file(input_map) DCNL DCSP if debug: DCNL DCSP  DCSP print 'HEADER:', header DCNL DCSP key_index = header.index('KEY_SEQ') DCNL DCSP bc_index = header.index('BARCODE') DCNL DCSP if ('LINKER' in header): DCNL DCSP  DCSP linker_index = header.index('LINKER') DCNL DCSP else: DCNL DCSP  DCSP linker_index = None DCNL DCSP primer_index = header.index('PRIMER') DCNL DCSP technical_lengths = {} DCNL DCSP for fields in body: DCNL DCSP  DCSP curr_tech_len = ((len(fields[key_index]) + len(fields[bc_index])) + len(fields[primer_index])) DCNL DCSP  DCSP if (linker_index is not None): DCNL DCSP  DCSP  DCSP curr_tech_len += len(fields[linker_index]) DCNL DCSP  DCSP technical_lengths[fields[0]] = curr_tech_len DCNL DCSP if debug: DCNL DCSP  DCSP print 'Technical DCSP lengths:' DCNL DCSP  DCSP print technical_lengths DCNL DCSP return technical_lengths
def fixup_simple_stmt(parent, i, stmt_node): DCNL  DCSP for (semi_ind, node) in enumerate(stmt_node.children): DCNL DCSP  DCSP if (node.type == token.SEMI): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP node.remove() DCNL DCSP new_expr = Node(syms.expr_stmt, []) DCNL DCSP new_stmt = Node(syms.simple_stmt, [new_expr]) DCNL DCSP while stmt_node.children[semi_ind:]: DCNL DCSP  DCSP move_node = stmt_node.children[semi_ind] DCNL DCSP  DCSP new_expr.append_child(move_node.clone()) DCNL DCSP  DCSP move_node.remove() DCNL DCSP parent.insert_child(i, new_stmt) DCNL DCSP new_leaf1 = new_stmt.children[0].children[0] DCNL DCSP old_leaf1 = stmt_node.children[0].children[0] DCNL DCSP new_leaf1.set_prefix(old_leaf1.get_prefix())
def parse(handle, format, alphabet=None): DCNL  DCSP from Bio import AlignIO DCNL DCSP if (format in _BinaryFormats): DCNL DCSP  DCSP mode = 'rb' DCNL DCSP else: DCNL DCSP  DCSP mode = 'rU' DCNL DCSP if (not isinstance(format, basestring)): DCNL DCSP  DCSP raise TypeError('Need DCSP a DCSP string DCSP for DCSP the DCSP file DCSP format DCSP (lower DCSP case)') DCNL DCSP if (not format): DCNL DCSP  DCSP raise ValueError('Format DCSP required DCSP (lower DCSP case DCSP string)') DCNL DCSP if (format != format.lower()): DCNL DCSP  DCSP raise ValueError(("Format DCSP string DCSP '%s' DCSP should DCSP be DCSP lower DCSP case" % format)) DCNL DCSP if ((alphabet is not None) and (not (isinstance(alphabet, Alphabet) or isinstance(alphabet, AlphabetEncoder)))): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP alphabet, DCSP %r' % alphabet)) DCNL DCSP with as_handle(handle, mode) as fp: DCNL DCSP  DCSP if (format in _FormatToIterator): DCNL DCSP  DCSP  DCSP iterator_generator = _FormatToIterator[format] DCNL DCSP  DCSP  DCSP if (alphabet is None): DCNL DCSP  DCSP  DCSP  DCSP i = iterator_generator(fp) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP i = iterator_generator(fp, alphabet=alphabet) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP i = _force_alphabet(iterator_generator(fp), alphabet) DCNL DCSP  DCSP elif (format in AlignIO._FormatToIterator): DCNL DCSP  DCSP  DCSP i = (r for alignment in AlignIO.parse(fp, format, alphabet=alphabet) for r in alignment) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(("Unknown DCSP format DCSP '%s'" % format)) DCNL DCSP  DCSP for r in i: DCNL DCSP  DCSP  DCSP (yield r)
def _send_message(room_id, message, from_name, api_key=None, api_version=None, api_url=None, color=None, notify=False): DCNL  DCSP parameters = dict() DCNL DCSP parameters['room_id'] = room_id DCNL DCSP parameters['from'] = from_name[:15] DCNL DCSP parameters['message'] = message[:10000] DCNL DCSP parameters['message_format'] = 'text' DCNL DCSP parameters['color'] = color DCNL DCSP parameters['notify'] = notify DCNL DCSP result = _query(function='message', api_key=api_key, api_version=api_version, room_id=room_id, api_url=api_url, method='POST', data=parameters) DCNL DCSP if result: DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
def get_language_from_request(request): DCNL  DCSP global _accepted DCNL DCSP from django.conf import settings DCNL DCSP supported = dict(settings.LANGUAGES) DCNL DCSP if hasattr(request, 'session'): DCNL DCSP  DCSP lang_code = request.session.get('django_language', None) DCNL DCSP  DCSP if ((lang_code in supported) and (lang_code is not None) and check_for_language(lang_code)): DCNL DCSP  DCSP  DCSP return lang_code DCNL DCSP lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME) DCNL DCSP if (lang_code and (lang_code not in supported)): DCNL DCSP  DCSP lang_code = lang_code.split('-')[0] DCNL DCSP if (lang_code and (lang_code in supported) and check_for_language(lang_code)): DCNL DCSP  DCSP return lang_code DCNL DCSP accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '') DCNL DCSP for (accept_lang, unused) in parse_accept_lang_header(accept): DCNL DCSP  DCSP if (accept_lang == '*'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP normalized = locale.locale_alias.get(to_locale(accept_lang, True)) DCNL DCSP  DCSP if (not normalized): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP normalized = normalized.split('.')[0] DCNL DCSP  DCSP if (normalized in _accepted): DCNL DCSP  DCSP  DCSP return _accepted[normalized] DCNL DCSP  DCSP for (lang, dirname) in ((accept_lang, normalized), (accept_lang.split('-')[0], normalized.split('_')[0])): DCNL DCSP  DCSP  DCSP if (lang.lower() not in supported): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for path in all_locale_paths(): DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(os.path.join(path, dirname, 'LC_MESSAGES', 'django.mo')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _accepted[normalized] = lang DCNL DCSP  DCSP  DCSP  DCSP  DCSP return lang DCNL DCSP return settings.LANGUAGE_CODE
def create(context, entity_id, traversal_id, is_update, stack_id): DCNL  DCSP values = {'entity_id': entity_id, 'traversal_id': traversal_id, 'is_update': is_update, 'atomic_key': 0, 'stack_id': stack_id, 'input_data': {}} DCNL DCSP return sync_point_object.SyncPoint.create(context, values)
def freqs_zpk(z, p, k, worN=None): DCNL  DCSP k = np.asarray(k) DCNL DCSP if (k.size > 1): DCNL DCSP  DCSP raise ValueError('k DCSP must DCSP be DCSP a DCSP single DCSP scalar DCSP gain') DCNL DCSP if (worN is None): DCNL DCSP  DCSP w = findfreqs(z, p, 200, kind='zp') DCNL DCSP elif isinstance(worN, int): DCNL DCSP  DCSP N = worN DCNL DCSP  DCSP w = findfreqs(z, p, N, kind='zp') DCNL DCSP else: DCNL DCSP  DCSP w = worN DCNL DCSP w = atleast_1d(w) DCNL DCSP s = (1j * w) DCNL DCSP num = polyvalfromroots(s, z) DCNL DCSP den = polyvalfromroots(s, p) DCNL DCSP h = ((k * num) / den) DCNL DCSP return (w, h)
def validate_title(value): DCNL  DCSP if ((value is None) or (not value.strip())): DCNL DCSP  DCSP raise ValidationValueError('Title DCSP cannot DCSP be DCSP blank.') DCNL DCSP value = strip_html(value) DCNL DCSP if ((value is None) or (not value.strip())): DCNL DCSP  DCSP raise ValidationValueError('Invalid DCSP title.') DCNL DCSP if (len(value) > 200): DCNL DCSP  DCSP raise ValidationValueError('Title DCSP cannot DCSP exceed DCSP 200 DCSP characters.') DCNL DCSP return True
def search_explorations(query, limit, sort=None, cursor=None): DCNL  DCSP return search_services.search(query, SEARCH_INDEX_EXPLORATIONS, cursor, limit, sort, ids_only=True)
def captured_stdout(): DCNL  DCSP return captured_output('stdout')
def register_mimetype_handler(handler): DCNL  DCSP if (not issubclass(handler, MimetypeHandler)): DCNL DCSP  DCSP raise TypeError(u'Only DCSP MimetypeHandler DCSP subclasses DCSP can DCSP be DCSP registered') DCNL DCSP _registered_mimetype_handlers.append(handler)
def purge_deleted_rows(context, age_in_days, max_rows, session=None): DCNL  DCSP _validate_db_int(max_rows=max_rows) DCNL DCSP session = (session or get_session()) DCNL DCSP metadata = MetaData(get_engine()) DCNL DCSP deleted_age = (timeutils.utcnow() - datetime.timedelta(days=age_in_days)) DCNL DCSP tables = [] DCNL DCSP for model_class in models.__dict__.values(): DCNL DCSP  DCSP if (not hasattr(model_class, '__tablename__')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if hasattr(model_class, 'deleted'): DCNL DCSP  DCSP  DCSP tables.append(model_class.__tablename__) DCNL DCSP for tbl in ('images', 'tasks'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tables.remove(tbl) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP LOG.warning(_LW('Expected DCSP table DCSP %(tbl)s DCSP was DCSP not DCSP found DCSP in DCSP DB.'), {'tbl': tbl}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tables.append(tbl) DCNL DCSP for tbl in tables: DCNL DCSP  DCSP tab = Table(tbl, metadata, autoload=True) DCNL DCSP  DCSP LOG.info(_LI('Purging DCSP deleted DCSP rows DCSP older DCSP than DCSP %(age_in_days)d DCSP day(s) DCSP from DCSP table DCSP %(tbl)s'), {'age_in_days': age_in_days, 'tbl': tbl}) DCNL DCSP  DCSP column = tab.c.id DCNL DCSP  DCSP deleted_at_column = tab.c.deleted_at DCNL DCSP  DCSP query_delete = sql.select([column], (deleted_at_column < deleted_age)).order_by(deleted_at_column).limit(max_rows) DCNL DCSP  DCSP delete_statement = DeleteFromSelect(tab, query_delete, column) DCNL DCSP  DCSP with session.begin(): DCNL DCSP  DCSP  DCSP result = session.execute(delete_statement) DCNL DCSP  DCSP rows = result.rowcount DCNL DCSP  DCSP LOG.info(_LI('Deleted DCSP %(rows)d DCSP row(s) DCSP from DCSP table DCSP %(tbl)s'), {'rows': rows, 'tbl': tbl})
def test_bti2fiff(): DCNL  DCSP check_usage(mne_bti2fiff)
def reloaded(manager, containers, count, name): DCNL  DCSP containers.refresh() DCNL DCSP for container in manager.get_differing_containers(): DCNL DCSP  DCSP manager.stop_containers([container]) DCNL DCSP  DCSP manager.remove_containers([container]) DCNL DCSP started(manager, containers, count, name)
def build_pool(test_case): DCNL  DCSP return StoragePool(reactor, create_zfs_pool(test_case), FilePath(test_case.mktemp()))
def _fire_score_changed_for_block(course_id, student, block, module_state_key): DCNL  DCSP if (block and block.has_score): DCNL DCSP  DCSP max_score = block.max_score() DCNL DCSP  DCSP if (max_score is not None): DCNL DCSP  DCSP  DCSP PROBLEM_RAW_SCORE_CHANGED.send(sender=None, raw_earned=0, raw_possible=max_score, weight=getattr(block, 'weight', None), user_id=student.id, course_id=unicode(course_id), usage_id=unicode(module_state_key), score_deleted=True, only_if_higher=False, modified=datetime.now().replace(tzinfo=pytz.UTC), score_db_table=ScoreDatabaseTableEnum.courseware_student_module)
@login_required DCNL @ensure_valid_course_key DCNL def submission_history(request, course_id, student_username, location): DCNL  DCSP course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) DCNL DCSP try: DCNL DCSP  DCSP usage_key = course_key.make_usage_key_from_deprecated_string(location) DCNL DCSP except (InvalidKeyError, AssertionError): DCNL DCSP  DCSP return HttpResponse(escape(_(u'Invalid DCSP location.'))) DCNL DCSP course = get_course_overview_with_access(request.user, 'load', course_key) DCNL DCSP staff_access = bool(has_access(request.user, 'staff', course)) DCNL DCSP if ((student_username != request.user.username) and (not staff_access)): DCNL DCSP  DCSP raise PermissionDenied DCNL DCSP user_state_client = DjangoXBlockUserStateClient() DCNL DCSP try: DCNL DCSP  DCSP history_entries = list(user_state_client.get_history(student_username, usage_key)) DCNL DCSP except DjangoXBlockUserStateClient.DoesNotExist: DCNL DCSP  DCSP return HttpResponse(escape(_(u'User DCSP {username} DCSP has DCSP never DCSP accessed DCSP problem DCSP {location}').format(username=student_username, location=location))) DCNL DCSP csm = StudentModule.objects.filter(module_state_key=usage_key, student__username=student_username, course_id=course_key) DCNL DCSP scores = BaseStudentModuleHistory.get_history(csm) DCNL DCSP if (len(scores) != len(history_entries)): DCNL DCSP  DCSP log.warning('Mismatch DCSP when DCSP fetching DCSP scores DCSP for DCSP student DCSP history DCSP for DCSP course DCSP %s, DCSP user DCSP %s, DCSP xblock DCSP %s. DCSP %d DCSP scores DCSP were DCSP found, DCSP and DCSP %d DCSP history DCSP entries DCSP were DCSP found. DCSP Matching DCSP scores DCSP to DCSP history DCSP entries DCSP by DCSP date DCSP for DCSP display.', course_id, student_username, location, len(scores), len(history_entries)) DCNL DCSP  DCSP scores_by_date = {score.created: score for score in scores} DCNL DCSP  DCSP scores = [scores_by_date[history.updated] for history in history_entries] DCNL DCSP context = {'history_entries': history_entries, 'scores': scores, 'username': student_username, 'location': location, 'course_id': course_key.to_deprecated_string()} DCNL DCSP return render_to_response('courseware/submission_history.html', context)
def _readmailcapfile(fp, lineno): DCNL  DCSP caps = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fp.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((line[0] == '#') or (line.strip() == '')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP nextline = line DCNL DCSP  DCSP while (nextline[(-2):] == '\\\n'): DCNL DCSP  DCSP  DCSP nextline = fp.readline() DCNL DCSP  DCSP  DCSP if (not nextline): DCNL DCSP  DCSP  DCSP  DCSP nextline = '\n' DCNL DCSP  DCSP  DCSP line = (line[:(-2)] + nextline) DCNL DCSP  DCSP (key, fields) = parseline(line) DCNL DCSP  DCSP if (not (key and fields)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (lineno is not None): DCNL DCSP  DCSP  DCSP fields['lineno'] = lineno DCNL DCSP  DCSP  DCSP lineno += 1 DCNL DCSP  DCSP types = key.split('/') DCNL DCSP  DCSP for j in range(len(types)): DCNL DCSP  DCSP  DCSP types[j] = types[j].strip() DCNL DCSP  DCSP key = '/'.join(types).lower() DCNL DCSP  DCSP if (key in caps): DCNL DCSP  DCSP  DCSP caps[key].append(fields) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP caps[key] = [fields] DCNL DCSP return (caps, lineno)
def timeuntil(d, now=None): DCNL  DCSP return timesince(d, now, reversed=True)
def run_job(tasks): DCNL  DCSP log.debug(u'executing DCSP tasks: DCSP %s', tasks) DCNL DCSP finished_events = manager.execute(options={u'tasks': tasks, u'cron': True, u'allow_manual': False}, priority=5) DCNL DCSP for (_, task_name, event_) in finished_events: DCNL DCSP  DCSP log.debug(u'task DCSP finished DCSP executing: DCSP %s', task_name) DCNL DCSP  DCSP event_.wait() DCNL DCSP log.debug(u'all DCSP tasks DCSP in DCSP schedule DCSP finished DCSP executing')
@contextmanager DCNL def assuming(*assumptions): DCNL  DCSP old_global_assumptions = global_assumptions.copy() DCNL DCSP global_assumptions.update(assumptions) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP global_assumptions.clear() DCNL DCSP  DCSP global_assumptions.update(old_global_assumptions)
def double_redirect_view(request): DCNL  DCSP return HttpResponseRedirect('/test_client/permanent_redirect_view/')
@hooks.register(u'before_serve_page') DCNL def check_view_restrictions(page, request, serve_args, serve_kwargs): DCNL  DCSP for restriction in page.get_view_restrictions(): DCNL DCSP  DCSP if (not restriction.accept_request(request)): DCNL DCSP  DCSP  DCSP if (restriction.restriction_type == PageViewRestriction.PASSWORD): DCNL DCSP  DCSP  DCSP  DCSP from wagtail.wagtailcore.forms import PasswordPageViewRestrictionForm DCNL DCSP  DCSP  DCSP  DCSP form = PasswordPageViewRestrictionForm(instance=restriction, initial={u'return_url': request.get_full_path()}) DCNL DCSP  DCSP  DCSP  DCSP action_url = reverse(u'wagtailcore_authenticate_with_password', args=[restriction.id, page.id]) DCNL DCSP  DCSP  DCSP  DCSP return page.serve_password_required_response(request, form, action_url) DCNL DCSP  DCSP  DCSP elif (restriction.restriction_type in [PageViewRestriction.LOGIN, PageViewRestriction.GROUPS]): DCNL DCSP  DCSP  DCSP  DCSP return require_wagtail_login(next=request.get_full_path())
def close_all_open_files(exclude=set()): DCNL  DCSP maxfd = get_maximum_file_descriptors() DCNL DCSP for fd in reversed(range(maxfd)): DCNL DCSP  DCSP if (fd not in exclude): DCNL DCSP  DCSP  DCSP close_file_descriptor_if_open(fd)
def getstatementrange_old(lineno, source, assertion=False): DCNL  DCSP from codeop import compile_command DCNL DCSP for start in range(lineno, (-1), (-1)): DCNL DCSP  DCSP if assertion: DCNL DCSP  DCSP  DCSP line = source.lines[start] DCNL DCSP  DCSP  DCSP if (('super' in line) and ('self' in line) and ('__init__' in line)): DCNL DCSP  DCSP  DCSP  DCSP raise IndexError('likely DCSP a DCSP subclass') DCNL DCSP  DCSP  DCSP if (('assert' not in line) and ('raise' not in line)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP trylines = source.lines[start:(lineno + 1)] DCNL DCSP  DCSP trylines.insert(0, 'def DCSP xxx():') DCNL DCSP  DCSP trysource = '\n DCSP '.join(trylines) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP compile_command(trysource) DCNL DCSP  DCSP except (SyntaxError, OverflowError, ValueError): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for end in range((lineno + 1), (len(source) + 1)): DCNL DCSP  DCSP  DCSP trysource = source[start:end] DCNL DCSP  DCSP  DCSP if trysource.isparseable(): DCNL DCSP  DCSP  DCSP  DCSP return (start, end) DCNL DCSP raise SyntaxError(('no DCSP valid DCSP source DCSP range DCSP around DCSP line DCSP %d DCSP ' % (lineno,)))
def get_engine(hass, config): DCNL  DCSP return DemoProvider(config[CONF_LANG])
def replaceInFile(filename, oldToNew): DCNL  DCSP os.rename(filename, (filename + '.bak')) DCNL DCSP f = open((filename + '.bak')) DCNL DCSP d = f.read() DCNL DCSP f.close() DCNL DCSP for (k, v) in oldToNew.items(): DCNL DCSP  DCSP d = d.replace(k, v) DCNL DCSP f = open((filename + '.new'), 'w') DCNL DCSP f.write(d) DCNL DCSP f.close() DCNL DCSP os.rename((filename + '.new'), filename) DCNL DCSP os.unlink((filename + '.bak'))
def oversample(images, crop_dims): DCNL  DCSP (channels, src_h, src_w) = images[0].shape DCNL DCSP (cy, cx) = ((src_h / 2.0), (src_w / 2.0)) DCNL DCSP (dst_h, dst_w) = crop_dims DCNL DCSP crops_ix = numpy.empty((5, 4), dtype=int) DCNL DCSP crops_ix[0, :2] = [0, 0] DCNL DCSP crops_ix[1, :2] = [0, (src_w - dst_w)] DCNL DCSP crops_ix[2, :2] = [(src_h - dst_h), 0] DCNL DCSP crops_ix[3, :2] = [(src_h - dst_h), (src_w - dst_w)] DCNL DCSP crops_ix[4, :2] = [int((cy - (dst_h / 2.0))), int((cx - (dst_w / 2.0)))] DCNL DCSP crops_ix[:, 2] = (crops_ix[:, 0] + dst_h) DCNL DCSP crops_ix[:, 3] = (crops_ix[:, 1] + dst_w) DCNL DCSP crops = numpy.empty(((10 * len(images)), channels, dst_h, dst_w), dtype=images[0].dtype) DCNL DCSP ix = 0 DCNL DCSP for img in images: DCNL DCSP  DCSP for crop in crops_ix: DCNL DCSP  DCSP  DCSP crops[ix] = img[:, crop[0]:crop[2], crop[1]:crop[3]] DCNL DCSP  DCSP  DCSP ix += 1 DCNL DCSP  DCSP crops[ix:(ix + 5)] = crops[(ix - 5):ix, :, :, ::(-1)] DCNL DCSP  DCSP ix += 5 DCNL DCSP return crops
@context.quietfunc DCNL @with_device DCNL def exists(path): DCNL  DCSP with AdbClient() as c: DCNL DCSP  DCSP return bool(c.stat(path))
def decode_wanted(parts): DCNL  DCSP wanted = {} DCNL DCSP key_map = dict(d='data', m='meta') DCNL DCSP if parts: DCNL DCSP  DCSP for k in key_map: DCNL DCSP  DCSP  DCSP if (k in parts[0]): DCNL DCSP  DCSP  DCSP  DCSP wanted[key_map[k]] = True DCNL DCSP if (not wanted): DCNL DCSP  DCSP wanted['data'] = True DCNL DCSP return wanted
def random_all(): DCNL  DCSP pass
def read_headers(rfile, hdict=None): DCNL  DCSP if (hdict is None): DCNL DCSP  DCSP hdict = {} DCNL DCSP while True: DCNL DCSP  DCSP line = rfile.readline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP raise ValueError('Illegal DCSP end DCSP of DCSP headers.') DCNL DCSP  DCSP if (line == CRLF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not line.endswith(CRLF)): DCNL DCSP  DCSP  DCSP raise ValueError('HTTP DCSP requires DCSP CRLF DCSP terminators') DCNL DCSP  DCSP if (line[0] in ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP v = line.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (k, v) = line.split(':', 1) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Illegal DCSP header DCSP line.') DCNL DCSP  DCSP  DCSP k = k.strip().title() DCNL DCSP  DCSP  DCSP v = v.strip() DCNL DCSP  DCSP  DCSP hname = k DCNL DCSP  DCSP if (k in comma_separated_headers): DCNL DCSP  DCSP  DCSP existing = hdict.get(hname) DCNL DCSP  DCSP  DCSP if existing: DCNL DCSP  DCSP  DCSP  DCSP v = ', DCSP '.join((existing, v)) DCNL DCSP  DCSP hdict[hname] = v DCNL DCSP return hdict
def get_service(hass, config, discovery_info=None): DCNL  DCSP from pylgtv import WebOsClient DCNL DCSP from pylgtv import PyLGTVPairException DCNL DCSP client = WebOsClient(config.get(CONF_HOST)) DCNL DCSP try: DCNL DCSP  DCSP client.register() DCNL DCSP except PyLGTVPairException: DCNL DCSP  DCSP _LOGGER.error('Pairing DCSP with DCSP TV DCSP failed') DCNL DCSP  DCSP return None DCNL DCSP except OSError: DCNL DCSP  DCSP _LOGGER.error('TV DCSP unreachable') DCNL DCSP  DCSP return None DCNL DCSP return LgWebOSNotificationService(client)
def linkage(y, method='single', metric='euclidean'): DCNL  DCSP if (method not in _LINKAGE_METHODS): DCNL DCSP  DCSP raise ValueError('Invalid DCSP method: DCSP {0}'.format(method)) DCNL DCSP y = _convert_to_double(np.asarray(y, order='c')) DCNL DCSP if (y.ndim == 1): DCNL DCSP  DCSP distance.is_valid_y(y, throw=True, name='y') DCNL DCSP  DCSP [y] = _copy_arrays_if_base_present([y]) DCNL DCSP elif (y.ndim == 2): DCNL DCSP  DCSP if ((method in _EUCLIDEAN_METHODS) and (metric != 'euclidean')): DCNL DCSP  DCSP  DCSP raise ValueError("Method DCSP '{0}' DCSP requires DCSP the DCSP distance DCSP metric DCSP to DCSP be DCSP Euclidean".format(method)) DCNL DCSP  DCSP if ((y.shape[0] == y.shape[1]) and np.allclose(np.diag(y), 0)): DCNL DCSP  DCSP  DCSP if (np.all((y >= 0)) and np.allclose(y, y.T)): DCNL DCSP  DCSP  DCSP  DCSP _warning('The DCSP symmetric DCSP non-negative DCSP hollow DCSP observation DCSP matrix DCSP looks DCSP suspiciously DCSP like DCSP an DCSP uncondensed DCSP distance DCSP matrix') DCNL DCSP  DCSP y = distance.pdist(y, metric) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('`y` DCSP must DCSP be DCSP 1 DCSP or DCSP 2 DCSP dimensional.') DCNL DCSP if (not np.all(np.isfinite(y))): DCNL DCSP  DCSP raise ValueError('The DCSP condensed DCSP distance DCSP matrix DCSP must DCSP contain DCSP only DCSP finite DCSP values.') DCNL DCSP n = int(distance.num_obs_y(y)) DCNL DCSP method_code = _LINKAGE_METHODS[method] DCNL DCSP if (method == 'single'): DCNL DCSP  DCSP return _hierarchy.mst_single_linkage(y, n) DCNL DCSP elif (method in ['complete', 'average', 'weighted', 'ward']): DCNL DCSP  DCSP return _hierarchy.nn_chain(y, n, method_code) DCNL DCSP else: DCNL DCSP  DCSP return _hierarchy.fast_linkage(y, n, method_code)
@handle_response_format DCNL @treeio_login_required DCNL def account_edit(request, response_format='html'): DCNL  DCSP profile = request.user.profile DCNL DCSP if request.POST: DCNL DCSP  DCSP form = AccountForm(request.POST, instance=profile) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('account_view')) DCNL DCSP else: DCNL DCSP  DCSP form = AccountForm(instance=profile) DCNL DCSP return render_to_response('account/account_edit', {'profile': profile, 'form': Markup(form.as_ul())}, context_instance=RequestContext(request), response_format=response_format)
def people_type(): DCNL  DCSP return s3_rest_controller()
def captured_stdout(): DCNL  DCSP return captured_output('stdout')
@Profiler.profile DCNL def test_flush_pk_given(n): DCNL  DCSP session = Session(bind=engine) DCNL DCSP for chunk in range(0, n, 1000): DCNL DCSP  DCSP session.add_all([Customer(id=(i + 1), name=('customer DCSP name DCSP %d' % i), description=('customer DCSP description DCSP %d' % i)) for i in range(chunk, (chunk + 1000))]) DCNL DCSP  DCSP session.flush() DCNL DCSP session.commit()
@api_wrapper DCNL def get_export(module, filesystem, system): DCNL  DCSP export = None DCNL DCSP exports_to_list = system.exports.to_list() DCNL DCSP for e in exports_to_list: DCNL DCSP  DCSP if (e.get_export_path() == module.params['name']): DCNL DCSP  DCSP  DCSP export = e DCNL DCSP  DCSP  DCSP break DCNL DCSP return export
@login_required DCNL @permission_required('flagit.can_moderate') DCNL def queue(request, content_type=None): DCNL  DCSP return render(request, 'flagit/queue.html', {'objects': FlaggedObject.objects.pending()})
@ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revalidate=True) DCNL @require_level('staff') DCNL def get_anon_ids(request, course_id): DCNL  DCSP course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id) DCNL DCSP def csv_response(filename, header, rows): DCNL DCSP  DCSP 'Returns DCSP a DCSP CSV DCSP http DCSP response DCSP for DCSP the DCSP given DCSP header DCSP and DCSP rows DCSP (excel/utf-8).' DCNL DCSP  DCSP response = HttpResponse(content_type='text/csv') DCNL DCSP  DCSP response['Content-Disposition'] = 'attachment; DCSP filename={0}'.format(unicode(filename).encode('utf-8')) DCNL DCSP  DCSP writer = csv.writer(response, dialect='excel', quotechar='"', quoting=csv.QUOTE_ALL) DCNL DCSP  DCSP encoded = [unicode(s).encode('utf-8') for s in header] DCNL DCSP  DCSP writer.writerow(encoded) DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP encoded = [unicode(s).encode('utf-8') for s in row] DCNL DCSP  DCSP  DCSP writer.writerow(encoded) DCNL DCSP  DCSP return response DCNL DCSP students = User.objects.filter(courseenrollment__course_id=course_id).order_by('id') DCNL DCSP header = ['User DCSP ID', 'Anonymized DCSP User DCSP ID', 'Course DCSP Specific DCSP Anonymized DCSP User DCSP ID'] DCNL DCSP rows = [[s.id, unique_id_for_user(s, save=False), anonymous_id_for_user(s, course_id, save=False)] for s in students] DCNL DCSP return csv_response((course_id.to_deprecated_string().replace('/', '-') + '-anon-ids.csv'), header, rows)
def rte_classifier(trainer, features=rte_features): DCNL  DCSP train = ((pair, pair.value) for pair in nltk.corpus.rte.pairs(['rte1_dev.xml', 'rte2_dev.xml', 'rte3_dev.xml'])) DCNL DCSP test = ((pair, pair.value) for pair in nltk.corpus.rte.pairs(['rte1_test.xml', 'rte2_test.xml', 'rte3_test.xml'])) DCNL DCSP print('Training DCSP classifier...') DCNL DCSP classifier = trainer([(features(pair), label) for (pair, label) in train]) DCNL DCSP print('Testing DCSP classifier...') DCNL DCSP acc = accuracy(classifier, [(features(pair), label) for (pair, label) in test]) DCNL DCSP print(('Accuracy: DCSP %6.4f' % acc)) DCNL DCSP return classifier
def main(sys_argv): DCNL  DCSP print ('pystache: DCSP running DCSP tests: DCSP argv: DCSP %s' % repr(sys_argv)) DCNL DCSP should_source_exist = False DCNL DCSP spec_test_dir = None DCNL DCSP project_dir = None DCNL DCSP if ((len(sys_argv) > 1) and (sys_argv[1] == FROM_SOURCE_OPTION)): DCNL DCSP  DCSP should_source_exist = True DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP try: DCNL DCSP  DCSP project_dir = sys_argv[1] DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP except IndexError: DCNL DCSP  DCSP if should_source_exist: DCNL DCSP  DCSP  DCSP project_dir = PROJECT_DIR DCNL DCSP try: DCNL DCSP  DCSP spec_test_dir = sys_argv[1] DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP except IndexError: DCNL DCSP  DCSP if (project_dir is not None): DCNL DCSP  DCSP  DCSP _spec_test_dir = get_spec_test_dir(project_dir) DCNL DCSP  DCSP  DCSP if (not os.path.exists(_spec_test_dir)): DCNL DCSP  DCSP  DCSP  DCSP print 'pystache: DCSP skipping DCSP spec DCSP tests: DCSP spec DCSP test DCSP directory DCSP not DCSP found' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP spec_test_dir = _spec_test_dir DCNL DCSP if ((len(sys_argv) <= 1) or sys_argv[(-1)].startswith('-')): DCNL DCSP  DCSP module_names = _discover_test_modules(PACKAGE_DIR) DCNL DCSP  DCSP sys_argv.extend(module_names) DCNL DCSP  DCSP if (project_dir is not None): DCNL DCSP  DCSP  DCSP sys_argv.append(__name__) DCNL DCSP SetupTests.project_dir = project_dir DCNL DCSP extra_tests = make_extra_tests(project_dir, spec_test_dir) DCNL DCSP test_program_class = make_test_program_class(extra_tests) DCNL DCSP test_program_class(argv=sys_argv, module=None)
def config(settings): DCNL  DCSP T = current.T DCNL DCSP settings.base.system_name = T('IMS') DCNL DCSP settings.base.system_name_short = T('IMS') DCNL DCSP settings.base.prepopulate += ('SCPHIMS', 'SCPHIMS/Demo', 'default/users') DCNL DCSP settings.base.theme = 'SCPHIMS' DCNL DCSP settings.security.self_registration = False DCNL DCSP settings.mail.approver = 'ADMIN' DCNL DCSP settings.gis.countries = ('PH',) DCNL DCSP settings.gis.legend = 'float' DCNL DCSP settings.gis.postcode_selector = False DCNL DCSP settings.gis.lookup_code = 'PSGC' DCNL DCSP settings.L10n.languages = OrderedDict([('en', 'English')]) DCNL DCSP settings.L10n.display_toolbar = False DCNL DCSP settings.L10n.utc_offset = '+0800' DCNL DCSP settings.L10n.decimal_separator = '.' DCNL DCSP settings.L10n.thousands_separator = ',' DCNL DCSP settings.fin.currencies = {'EUR': 'Euros', 'PHP': 'Philippine DCSP Pesos', 'USD': 'United DCSP States DCSP Dollars'} DCNL DCSP settings.fin.currency_default = 'PHP' DCNL DCSP settings.security.policy = 5 DCNL DCSP settings.auth.password_changes = False DCNL DCSP settings.auth.office365_domains = ['savethechildren.org'] DCNL DCSP settings.mobile.forms = [('Beneficiaries', 'pr_person', {'c': 'dvr'})] DCNL DCSP settings.cms.richtext = True DCNL DCSP def customise_cms_post_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP standard_prep = s3.prep DCNL DCSP  DCSP def custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(standard_prep): DCNL DCSP  DCSP  DCSP  DCSP if (not standard_prep(r)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP if (r.method == 'calendar'): DCNL DCSP  DCSP  DCSP  DCSP from s3 import FS DCNL DCSP  DCSP  DCSP  DCSP r.resource.add_filter(FS('post_module.module').belongs(('project', 'dc'))) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_cms_post_controller = customise_cms_post_controller DCNL DCSP def dc_target_onaccept(form): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Add/Update DCSP entry DCSP to DCSP calendar\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP target_id = form.vars.id DCNL DCSP  DCSP  DCSP delete = False DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP target_id = form.id DCNL DCSP  DCSP  DCSP delete = True DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.cms_post DCNL DCSP  DCSP ltable = s3db.cms_post_module DCNL DCSP  DCSP query = (((ltable.module == 'dc') & (ltable.resource == 'target')) & (ltable.record == target_id)) DCNL DCSP  DCSP link = db(query).select(ltable.post_id, limitby=(0, 1)).first() DCNL DCSP  DCSP if delete: DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP db((table.id == link.post_id)).delete() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ttable = db.dc_target DCNL DCSP  DCSP  DCSP record = db((ttable.id == target_id)).select(ttable.template_id, ttable.location_id, ttable.date, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP body = ttable.template_id.represent(record.template_id) DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP db((table.id == link.post_id)).update(body=body, location_id=record.location_id, date=record.date) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP post_id = table.insert(body=body, location_id=record.location_id, date=record.date) DCNL DCSP  DCSP  DCSP  DCSP ltable.insert(post_id=post_id, module='dc', resource='target', record=target_id) DCNL DCSP def customise_dc_target_resource(r, tablename): DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.dc_target DCNL DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP table.location_id.widget = S3LocationSelector(levels=('L1', 'L2', 'L3'), show_map=False) DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP if (has_role('ERT_LEADER') or has_role('HUM_MANAGER')): DCNL DCSP  DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP  DCSP ttable = s3db.dc_template DCNL DCSP  DCSP  DCSP RAPID = current.db((ttable.name == 'Rapid DCSP Assessment')).select(ttable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP table.template_id.default = RAPID.id DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.warning('Cannot DCSP default DCSP Targets DCSP to DCSP Rapid DCSP Assessment DCSP form') DCNL DCSP  DCSP onaccept = dc_target_onaccept DCNL DCSP  DCSP s3db.configure('dc_target', onaccept=onaccept, ondelete=onaccept) DCNL DCSP settings.customise_dc_target_resource = customise_dc_target_resource DCNL DCSP def customise_dc_collection_resource(r, tablename): DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.dc_collection DCNL DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP table.location_id.widget = S3LocationSelector(levels=('L1', 'L2', 'L3', 'L4')) DCNL DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP org = db((otable.name == SAVE)).select(otable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.id DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP done?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_id DCNL DCSP  DCSP  DCSP f.default = SCI DCNL DCSP  DCSP  DCSP f.readable = f.writable = False DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP if (has_role('ERT_LEADER') or has_role('HUM_MANAGER')): DCNL DCSP  DCSP  DCSP ttable = s3db.dc_template DCNL DCSP  DCSP  DCSP RAPID = db((ttable.name == 'Rapid DCSP Assessment')).select(ttable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP table.template_id.default = RAPID.id DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.warning('Cannot DCSP default DCSP Targets DCSP to DCSP Rapid DCSP Assessment DCSP form') DCNL DCSP settings.customise_dc_collection_resource = customise_dc_collection_resource DCNL DCSP def customise_doc_document_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.doc_document DCNL DCSP  DCSP table.organisation_id.readable = table.organisation_id.writable = True DCNL DCSP  DCSP f = table.location_id DCNL DCSP  DCSP f.readable = f.writable = True DCNL DCSP  DCSP f.widget = S3LocationSelector() DCNL DCSP  DCSP s3db.add_components('doc_document', event_event='doc_id') DCNL DCSP  DCSP crud_form = S3SQLCustomForm('file', 'name', 'url', 'date', 'organisation_id', 'location_id', 'comments') DCNL DCSP  DCSP from s3 import S3DateFilter, S3LocationFilter, S3OptionsFilter, S3TextFilter DCNL DCSP  DCSP filter_widgets = [S3TextFilter(['name', 'comments'], label=T('Search'), comment=T('Search DCSP by DCSP disaster DCSP name DCSP or DCSP comments. DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wildcard.')), S3OptionsFilter('event.name', label=T('Disaster')), S3LocationFilter('location_id'), S3OptionsFilter('organisation_id'), S3DateFilter('date')] DCNL DCSP  DCSP list_fields = ['location_id$L1', 'location_id$L2', 'location_id$L3', 'location_id$L4'] DCNL DCSP  DCSP if (r.controller == 'doc'): DCNL DCSP  DCSP  DCSP list_fields += ((T('Disaster'), 'event.name'), 'organisation_id') DCNL DCSP  DCSP elif (r.controller == 'event'): DCNL DCSP  DCSP  DCSP list_fields.append('organisation_id') DCNL DCSP  DCSP list_fields += ['date', 'name'] DCNL DCSP  DCSP s3db.configure('doc_document', crud_form=crud_form, filter_widgets=filter_widgets, list_fields=list_fields) DCNL DCSP settings.customise_doc_document_resource = customise_doc_document_resource DCNL DCSP def customise_doc_image_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.doc_image DCNL DCSP  DCSP table.location_id.widget = S3LocationSelector() DCNL DCSP  DCSP s3db.add_components('doc_image', event_event='doc_id') DCNL DCSP  DCSP crud_form = S3SQLCustomForm('file', 'name', 'url', 'date', 'organisation_id', 'location_id', 'comments') DCNL DCSP  DCSP from s3 import S3DateFilter, S3LocationFilter, S3OptionsFilter, S3TextFilter DCNL DCSP  DCSP filter_widgets = [S3TextFilter(['name', 'comments'], label=T('Search'), comment=T('Search DCSP by DCSP disaster DCSP name DCSP or DCSP comments. DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wildcard.')), S3OptionsFilter('event.name', label=T('Disaster')), S3LocationFilter('location_id'), S3OptionsFilter('organisation_id'), S3DateFilter('date')] DCNL DCSP  DCSP list_fields = ['location_id$L1', 'location_id$L2', 'location_id$L3', 'location_id$L4'] DCNL DCSP  DCSP if (r.controller != 'event'): DCNL DCSP  DCSP  DCSP list_fields.append((T('Disaster'), 'event.name')) DCNL DCSP  DCSP list_fields += ['organisation_id', 'date', 'name'] DCNL DCSP  DCSP s3db.configure('doc_image', crud_form=crud_form, filter_widgets=filter_widgets, list_fields=list_fields) DCNL DCSP settings.customise_doc_image_resource = customise_doc_image_resource DCNL DCSP def customise_doc_sitrep_resource(r, tablename): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP All DCSP SitReps DCSP are DCSP SAVE\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP All DCSP SitReps DCSP are DCSP National DCSP in DCSP scope\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP from s3 import S3DateFilter, S3OptionsFilter, S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.doc_sitrep DCNL DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP org = db((otable.name == SAVE)).select(otable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.id DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP done?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_id DCNL DCSP  DCSP  DCSP f.default = SCI DCNL DCSP  DCSP PH = 'Philippines' DCNL DCSP  DCSP gtable = s3db.gis_location DCNL DCSP  DCSP loc = db(((gtable.name == PH) & (gtable.level == 'L0'))).select(gtable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP PH = loc.id DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP loc DCSP %s DCSP - DCSP prepop DCSP not DCSP done?' % PH)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.location_id DCNL DCSP  DCSP  DCSP f.default = PH DCNL DCSP  DCSP s3db.event_sitrep.event_id.default = current.session.s3.event DCNL DCSP  DCSP crud_form = S3SQLCustomForm(S3SQLInlineComponent('event_sitrep', label=T('Disaster'), fields=[('', 'event_id')], multiple=False, required=True), 'date', 'name', 'description', 'comments') DCNL DCSP  DCSP filter_widgets = [S3OptionsFilter('event_sitrep.event_id'), S3DateFilter('date')] DCNL DCSP  DCSP list_fields = ['event_sitrep.event_id', 'date', 'name', 'comments'] DCNL DCSP  DCSP s3db.configure('doc_sitrep', crud_form=crud_form, filter_widgets=filter_widgets, list_fields=list_fields) DCNL DCSP settings.customise_doc_sitrep_resource = customise_doc_sitrep_resource DCNL DCSP def customise_doc_sitrep_controller(**attr): DCNL DCSP  DCSP etable = current.s3db.event_event DCNL DCSP  DCSP query = ((etable.closed == False) & (etable.deleted == False)) DCNL DCSP  DCSP open = current.db(query).select(etable.id, etable.name) DCNL DCSP  DCSP len_open = len(open) DCNL DCSP  DCSP if len_open: DCNL DCSP  DCSP  DCSP if (len_open == 1): DCNL DCSP  DCSP  DCSP  DCSP current.session.s3.event = open.first().id DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current.session.s3.event = None DCNL DCSP  DCSP  DCSP open = {row.id: row.name for row in open} DCNL DCSP  DCSP  DCSP from s3 import s3_set_default_filter DCNL DCSP  DCSP  DCSP s3_set_default_filter('event_sitrep.event_id', open, tablename='doc_sitrep') DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_doc_sitrep_controller = customise_doc_sitrep_controller DCNL DCSP settings.dvr.label = 'Beneficiary' DCNL DCSP settings.hrm.email_required = False DCNL DCSP def customise_dvr_case_resource(r, tablename): DCNL DCSP  DCSP current.s3db.configure('dvr_case', list_fields=['person_id', 'reference', 'person_id$location_id', (T('Phone'), 'person_id$phone.value'), 'comments']) DCNL DCSP settings.customise_dvr_case_resource = customise_dvr_case_resource DCNL DCSP def customise_pr_person_resource(r, tablename): DCNL DCSP  DCSP if (r.function != 'distribution'): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (r.tablename == 'project_activity'): DCNL DCSP  DCSP  DCSP activity_id = r.id DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP activity_id = None DCNL DCSP  DCSP current.response.s3.crud_strings['pr_person'] = Storage(label_create=T('Add DCSP Beneficiary'), title_display=T('Beneficiary DCSP Details'), title_list=T('Beneficiaries'), title_update=T('Edit DCSP Beneficiary'), title_report=T('Beneficiary DCSP Report'), label_list_button=T('List DCSP Beneficiaries'), msg_record_created=T('Beneficiary DCSP Added'), msg_record_modified=T('Beneficiary DCSP Updated'), msg_record_deleted=T('Beneficiary DCSP Deleted'), msg_list_empty=T('No DCSP Beneficiaries DCSP Found')) DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP mobile_list_fields = ['first_name', 'middle_name', 'last_name', 'date_of_birth', 'gender', 'person_details.disabled', 'phone.value', 'address.location_id$parent', 'address.location_id$addr_street', 'household_member.age', 'household_member.gender', 'household_member.disabled', 'household_member.comments', 'dvr_case.comments'] DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP crud_fields = ['first_name', 'middle_name', 'last_name', 'date_of_birth', 'gender', 'person_details.disabled', S3SQLInlineComponent('phone', fields=[('', 'value')], label=T('Mobile DCSP Phone'), multiple=True), S3SQLInlineComponent('address', label=T('Current DCSP Address'), fields=[('', 'location_id')], filterby={'field': 'type', 'options': '1'}, link=False, multiple=False), S3SQLInlineComponent('household_member', fields=['age', 'gender', 'disabled', 'comments'], label=T('Household DCSP Members')), 'dvr_case.comments'] DCNL DCSP  DCSP if (r.representation == 'mdata'): DCNL DCSP  DCSP  DCSP crud_fields.insert(0, 'dvr_case.reference') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP db = current.db DCNL DCSP  DCSP  DCSP atable = s3db.pr_address DCNL DCSP  DCSP  DCSP ctable = s3db.dvr_case DCNL DCSP  DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP  DCSP org = db((otable.name == SAVE)).select(otable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP SCI = org.id DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP done?' % SAVE)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctable.organisation_id.default = SCI DCNL DCSP  DCSP  DCSP if activity_id: DCNL DCSP  DCSP  DCSP  DCSP patable = s3db.project_activity DCNL DCSP  DCSP  DCSP  DCSP gtable = s3db.gis_location DCNL DCSP  DCSP  DCSP  DCSP query = ((patable.id == activity_id) & (patable.location_id == gtable.id)) DCNL DCSP  DCSP  DCSP  DCSP activity = db(query).select(gtable.parent, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable.location_id.default = activity.parent DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP Activity DCSP %s' % activity_id)) DCNL DCSP  DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP  DCSP atable.location_id.widget = S3LocationSelector(show_address=True, show_map=False) DCNL DCSP  DCSP  DCSP ctable.reference.label = T('Barcode') DCNL DCSP  DCSP  DCSP if (r.method in ('read', 'update')): DCNL DCSP  DCSP  DCSP  DCSP crud_fields.insert(0, 'dvr_case.reference') DCNL DCSP  DCSP s3db.configure('pr_person', crud_form=S3SQLCustomForm(postprocess=(lambda form: pr_person_postprocess(form, activity_id)), *crud_fields), list_fields=['first_name', 'middle_name', 'last_name', 'age', 'gender', (T('Phone'), 'phone.value'), 'address.location_id', 'dvr_case.reference', 'dvr_case.comments'], mobile_list_fields=mobile_list_fields) DCNL DCSP settings.customise_pr_person_resource = customise_pr_person_resource DCNL DCSP def pr_person_postprocess(form, activity_id): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP onaccept DCSP for DCSP the DCSP Custom DCSP Form:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP link DCSP Beneficiaries DCSP to DCSP the DCSP Distribution\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP person_id = form.vars.get('id') DCNL DCSP  DCSP current.s3db.project_activity_person.insert(activity_id=activity_id, person_id=person_id) DCNL DCSP def dvr_rheader(r, tabs=[]): DCNL DCSP  DCSP if (r.representation != 'html'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP from s3 import s3_rheader_resource, s3_rheader_tabs DCNL DCSP  DCSP (tablename, record) = s3_rheader_resource(r) DCNL DCSP  DCSP if (not record): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP rheader = None DCNL DCSP  DCSP if (tablename == 'pr_person'): DCNL DCSP  DCSP  DCSP T = current.T DCNL DCSP  DCSP  DCSP db = current.db DCNL DCSP  DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP  DCSP if (not tabs): DCNL DCSP  DCSP  DCSP  DCSP tabs = [(T('Basic DCSP Details'), None), (T('Household DCSP Members'), 'household_member'), (T('Activities'), 'activity_person')] DCNL DCSP  DCSP  DCSP rheader_tabs = s3_rheader_tabs(r, tabs) DCNL DCSP  DCSP  DCSP record_id = record.id DCNL DCSP  DCSP  DCSP ctable = s3db.dvr_case DCNL DCSP  DCSP  DCSP case = db((ctable.person_id == record_id)).select(ctable.reference, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if case: DCNL DCSP  DCSP  DCSP  DCSP reference = (case.reference or current.messages['NONE']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reference = None DCNL DCSP  DCSP  DCSP from gluon import A, DIV, TABLE, TR, TH, URL DCNL DCSP  DCSP  DCSP from s3 import s3_fullname, s3_avatar_represent DCNL DCSP  DCSP  DCSP rheader = DIV(A(s3_avatar_represent(record_id, 'pr_person', _class='rheader-avatar'), _href=URL(f='person', args=[record_id, 'image'], vars=r.get_vars)), TABLE(TR(TH(('%s: DCSP ' % T('Name'))), s3_fullname(record), TH(('%s: DCSP ' % T('Barcode'))), reference), TR(TH(('%s: DCSP ' % T('Date DCSP of DCSP Birth'))), ('%s' % (record.date_of_birth or T('unknown'))), TH(('%s: DCSP ' % T('Gender'))), ('%s' % s3db.pr_gender_opts.get(record.gender, T('unknown'))))), rheader_tabs) DCNL DCSP  DCSP return rheader DCNL DCSP def customise_pr_person_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP standard_prep = s3.prep DCNL DCSP  DCSP def custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(standard_prep): DCNL DCSP  DCSP  DCSP  DCSP if (not standard_prep(r)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP if (r.controller == 'dvr'): DCNL DCSP  DCSP  DCSP  DCSP r.resource.configure(insertable=False) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP if (current.request.controller == 'dvr'): DCNL DCSP  DCSP  DCSP attr['rheader'] = dvr_rheader DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_pr_person_controller = customise_pr_person_controller DCNL DCSP settings.event.label = 'Disaster' DCNL DCSP def response_locations(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Called DCSP onaccept/ondelete DCSP from DCSP events DCSP & DCSP activities\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP calculates DCSP which DCSP L3 DCSP locations DCSP have DCSP SC DCSP activities DCSP linked DCSP to DCSP open DCSP events DCSP & DCSP sets DCSP their DCSP Sectors DCSP tag\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP gtable = s3db.gis_location DCNL DCSP  DCSP ttable = s3db.gis_location_tag DCNL DCSP  DCSP etable = s3db.event_event DCNL DCSP  DCSP ltable = s3db.event_activity DCNL DCSP  DCSP atable = s3db.project_activity DCNL DCSP  DCSP aotable = s3db.project_activity_organisation DCNL DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP stable = s3db.org_sector DCNL DCSP  DCSP satable = s3db.project_sector_activity DCNL DCSP  DCSP db((ttable.tag == 'sectors')).delete() DCNL DCSP  DCSP query = (((((((((gtable.id == atable.location_id) & (atable.deleted == False)) & (atable.id == aotable.activity_id)) & (aotable.organisation_id == otable.id)) & (otable.name == SAVE)) & (atable.id == ltable.activity_id)) & (ltable.event_id == etable.id)) & (etable.closed == False)) & (etable.deleted == False)) DCNL DCSP  DCSP left = stable.on(((stable.id == satable.sector_id) & (satable.activity_id == atable.id))) DCNL DCSP  DCSP L4s = db(query).select(gtable.parent, stable.name, left=left) DCNL DCSP  DCSP L3s = {} DCNL DCSP  DCSP for L4 in L4s: DCNL DCSP  DCSP  DCSP sector = L4['org_sector.name'] DCNL DCSP  DCSP  DCSP if sector: DCNL DCSP  DCSP  DCSP  DCSP L3 = L4['gis_location.parent'] DCNL DCSP  DCSP  DCSP  DCSP if (L3 in L3s): DCNL DCSP  DCSP  DCSP  DCSP  DCSP L3s[L3].append(sector) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP L3s[L3] = [sector] DCNL DCSP  DCSP for L3 in L3s: DCNL DCSP  DCSP  DCSP ttable.insert(location_id=L3, tag='sectors', value=', DCSP '.join(set(L3s[L3]))) DCNL DCSP def customise_event_event_controller(**attr): DCNL DCSP  DCSP from s3 import s3_set_default_filter DCNL DCSP  DCSP s3_set_default_filter('~.closed', False, tablename='event_event') DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_event_event_controller = customise_event_event_controller DCNL DCSP def customise_event_event_resource(r, tablename): DCNL DCSP  DCSP from gluon import IS_EMPTY_OR, IS_INT_IN_RANGE DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP s3db.event_event_location.location_id.widget = S3LocationSelector(levels=('L1', 'L2')) DCNL DCSP  DCSP s3db.event_event_tag.value.requires = IS_EMPTY_OR(IS_INT_IN_RANGE(1, 5)) DCNL DCSP  DCSP crud_form = S3SQLCustomForm('name', 'event_type_id', 'start_date', S3SQLInlineComponent('tag', fields=[('', 'value')], filterby={'field': 'tag', 'options': 'category'}, label=T('Category'), multiple=False), 'closed', 'comments') DCNL DCSP  DCSP list_fields = ['name', 'event_type_id', 'start_date', (T('Category'), 'tag.value'), 'closed', 'comments'] DCNL DCSP  DCSP onaccept = (lambda form: response_locations()) DCNL DCSP  DCSP update_onaccept = s3db.get_config('event_event', 'update_onaccept') DCNL DCSP  DCSP update_onaccept = [update_onaccept, onaccept] DCNL DCSP  DCSP s3db.configure('event_event', crud_form=crud_form, list_fields=list_fields, onaccept=onaccept, ondelete=onaccept, update_onaccept=update_onaccept) DCNL DCSP settings.customise_event_event_resource = customise_event_event_resource DCNL DCSP settings.project.mode_3w = True DCNL DCSP settings.project.mode_drr = True DCNL DCSP settings.project.activities = True DCNL DCSP settings.project.activity_sectors = True DCNL DCSP settings.project.activity_types = True DCNL DCSP settings.project.codes = True DCNL DCSP settings.project.event_activities = True DCNL DCSP settings.project.event_projects = True DCNL DCSP settings.project.hazards = False DCNL DCSP settings.project.hfa = False DCNL DCSP settings.project.programmes = True DCNL DCSP settings.project.programme_budget = True DCNL DCSP settings.project.sectors = False DCNL DCSP settings.project.themes = False DCNL DCSP settings.project.multiple_organisations = True DCNL DCSP settings.project.organisation_roles = {1: T('Implementing DCSP Organization'), 2: T('Partner DCSP Organization'), 3: T('Donor')} DCNL DCSP def project_activity_onaccept(form): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Add/Update DCSP entry DCSP to DCSP calendar\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Update DCSP response_locations\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP activity_id = form.vars.id DCNL DCSP  DCSP  DCSP delete = False DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP activity_id = form.id DCNL DCSP  DCSP  DCSP delete = True DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.cms_post DCNL DCSP  DCSP ltable = s3db.cms_post_module DCNL DCSP  DCSP query = (((ltable.module == 'project') & (ltable.resource == 'activity')) & (ltable.record == activity_id)) DCNL DCSP  DCSP link = db(query).select(ltable.post_id, limitby=(0, 1)).first() DCNL DCSP  DCSP if delete: DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP db((table.id == link.post_id)).delete() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP atable = db.project_activity DCNL DCSP  DCSP  DCSP record = db((atable.id == activity_id)).select(atable.name, atable.location_id, atable.date, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP db((table.id == link.post_id)).update(body=record.name, location_id=record.location_id, date=record.date) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP post_id = table.insert(body=record.name, location_id=record.location_id, date=record.date) DCNL DCSP  DCSP  DCSP  DCSP ltable.insert(post_id=post_id, module='project', resource='activity', record=activity_id) DCNL DCSP  DCSP response_locations() DCNL DCSP def customise_project_activity_resource(r, tablename): DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP s3db.gis_location.addr_street.label = T('Precise DCSP Location') DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP crud_fields = ['name', 'date', 'status_id', S3SQLInlineComponent('sector_activity', label=T('Sectors'), fields=[('', 'sector_id')]), S3SQLInlineComponent('activity_activity_type', label=T('Activity DCSP Types'), fields=[('', 'activity_type_id')]), 'location_id', 'comments'] DCNL DCSP  DCSP if current.auth.s3_logged_in(): DCNL DCSP  DCSP  DCSP crud_fields.insert(0, 'project_id') DCNL DCSP  DCSP crud_form = S3SQLCustomForm(*crud_fields) DCNL DCSP  DCSP list_fields = ['name', 'date', 'status_id', (T('Sectors'), 'sector_activity.sector_id'), (T('Activity DCSP Types'), 'activity_activity_type.activity_type_id'), (T('Items'), 'distribution.parameter_id'), 'location_id$L1', 'location_id$L2', 'location_id$L3', 'location_id$L4'] DCNL DCSP  DCSP onaccept = project_activity_onaccept DCNL DCSP  DCSP s3db.configure('project_activity', crud_form=crud_form, list_fields=list_fields, onaccept=onaccept, ondelete=onaccept) DCNL DCSP settings.customise_project_activity_resource = customise_project_activity_resource DCNL DCSP def customise_project_activity_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP standard_postp = s3.postp DCNL DCSP  DCSP def custom_postp(r, output): DCNL DCSP  DCSP  DCSP if callable(standard_postp): DCNL DCSP  DCSP  DCSP  DCSP output = standard_postp(r, output) DCNL DCSP  DCSP  DCSP if (r.interactive and (r.component_name == 'case')): DCNL DCSP  DCSP  DCSP  DCSP if ('showadd_btn' in output): DCNL DCSP  DCSP  DCSP  DCSP  DCSP from gluon import URL DCNL DCSP  DCSP  DCSP  DCSP  DCSP from s3 import S3CRUD DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['form'] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['showadd_btn'] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c='dvr', f='person', args='create', vars={'activity_id': r.id}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP add_btn = S3CRUD.crud_button(tablename='dvr_case', name='label_create', icon='add', _id='add-btn', _href=url) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['buttons'] = {'add_btn': add_btn} DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP s3.postp = custom_postp DCNL DCSP  DCSP return attr DCNL DCSP def customise_project_programme_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP crud_form = S3SQLCustomForm('name', (T('Project DCSP Code'), 'code'), (T('Master DCSP Budget'), 'budget'), 'currency', S3SQLInlineComponent('document', label=T('Response DCSP Plan'), fields=['file'], multiple=False), 'comments') DCNL DCSP  DCSP current.s3db.configure(tablename, crud_form=crud_form) DCNL DCSP settings.customise_project_programme_resource = customise_project_programme_resource DCNL DCSP def customise_project_project_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3Represent, S3TextFilter, S3OptionsFilter, S3LocationFilter DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP table = s3db.project_project DCNL DCSP  DCSP table.code.label = 'SOF' DCNL DCSP  DCSP s3db.project_location.location_id.widget = S3LocationSelector(levels=('L1', 'L2', 'L3'), show_map=False) DCNL DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP org = current.db((otable.name == SAVE)).select(otable.id, cache=s3db.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.id DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP find DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP done?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_id DCNL DCSP  DCSP  DCSP f.default = SCI DCNL DCSP  DCSP org_represent = s3db.org_OrganisationRepresent(acronym=False, show_link=True) DCNL DCSP  DCSP s3db.project_organisation.organisation_id.represent = org_represent DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s3db.project_donor_organisation.organisation_id.represent = org_represent DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent, S3SQLInlineLink DCNL DCSP  DCSP crud_form = S3SQLCustomForm(S3SQLInlineLink('programme', label=T('Program'), field='programme_id', multiple=False), 'name', 'code', 'status_id', 'start_date', 'end_date', 'budget', 'currency', S3SQLInlineComponent('location', label=T('Locations'), fields=['location_id']), S3SQLInlineComponent('organisation', name='donor', label=T('Donor(s)'), fields=['organisation_id']), S3SQLInlineComponent('document', name='concept_note', label=T('Concept DCSP Note'), fields=['file'], multiple=False), 'comments') DCNL DCSP  DCSP filter_widgets = [S3TextFilter(['name', 'code'], label=T('Search'), comment=T('Search DCSP for DCSP a DCSP Project DCSP by DCSP name DCSP or DCSP code')), S3OptionsFilter('status_id', label=T('Status'), cols=3), S3OptionsFilter('donor.organisation_id', label=T('Donor'), hidden=True), S3LocationFilter('location.location_id', levels=('L1', 'L2', 'L3'), hidden=True), S3OptionsFilter('programme_project.programme_id', label=T('Program'), hidden=True)] DCNL DCSP  DCSP list_fields = ['status_id', 'code', 'name', (T('Donors'), 'donor.organisation_id'), (T('Locations'), 'location.location_id'), 'start_date', 'end_date', 'budget', 'currency', (T('Program'), 'programme.name')] DCNL DCSP  DCSP s3db.configure('project_project', crud_form=crud_form, filter_widgets=filter_widgets, list_fields=list_fields) DCNL DCSP settings.customise_project_project_resource = customise_project_project_resource DCNL DCSP def project_rheader(r, ert=False): DCNL DCSP  DCSP if ert: DCNL DCSP  DCSP  DCSP from s3 import S3ResourceHeader DCNL DCSP  DCSP  DCSP rheader_fields = [['name'], ['code'], [(T('Donors'), 'donor.organisation_id')], [(T('Locations'), 'location.location_id')], ['start_date'], ['end_date']] DCNL DCSP  DCSP  DCSP rheader = S3ResourceHeader(rheader_fields, tabs=[])(r) DCNL DCSP  DCSP  DCSP return rheader DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return current.s3db.project_rheader(r) DCNL DCSP def customise_project_project_controller(**attr): DCNL DCSP  DCSP stable = current.s3db.project_status DCNL DCSP  DCSP active = current.db(stable.name.belongs('Active', 'Proposed')).select(stable.id, stable.name) DCNL DCSP  DCSP active = {row.id: row.name for row in active} DCNL DCSP  DCSP from s3 import s3_set_default_filter DCNL DCSP  DCSP s3_set_default_filter('~.status_id', active, tablename='project_project') DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP ERT_LEADER = (has_role('ERT_LEADER') and (not has_role('ADMIN'))) DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP standard_postp = s3.postp DCNL DCSP  DCSP def custom_postp(r, output): DCNL DCSP  DCSP  DCSP if callable(standard_postp): DCNL DCSP  DCSP  DCSP  DCSP output = standard_postp(r, output) DCNL DCSP  DCSP  DCSP if ERT_LEADER: DCNL DCSP  DCSP  DCSP  DCSP from gluon import URL DCNL DCSP  DCSP  DCSP  DCSP from s3 import s3_str DCNL DCSP  DCSP  DCSP  DCSP s3.actions = [dict(label=s3_str(T('Open')), _class='action-btn', url=URL(args=['[id]', 'activity']))] DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP s3.postp = custom_postp DCNL DCSP  DCSP if ERT_LEADER: DCNL DCSP  DCSP  DCSP attr['rheader'] = (lambda r: project_rheader(r, ert=True)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP attr['rheader'] = (lambda r: project_rheader(r, ert=False)) DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_project_project_controller = customise_project_project_controller DCNL DCSP settings.modules = OrderedDict([('default', Storage(name_nice=T('Home'), restricted=False, access=None, module_type=None)), ('admin', Storage(name_nice=T('Administration'), restricted=True, access='|1|', module_type=None)), ('appadmin', Storage(name_nice=T('Administration'), restricted=True, module_type=None)), ('errors', Storage(name_nice=T('Ticket DCSP Viewer'), restricted=False, module_type=None)), ('sync', Storage(name_nice=T('Synchronization'), restricted=True, access='|1|', module_type=None)), ('gis', Storage(name_nice=T('Map'), restricted=True, module_type=6)), ('pr', Storage(name_nice=T('Person DCSP Registry'), restricted=True, access='|1|', module_type=10)), ('org', Storage(name_nice=T('Organizations'), restricted=True, module_type=1)), ('hrm', Storage(name_nice=T('Staff'), restricted=True, module_type=2)), ('cms', Storage(name_nice=T('Content DCSP Management'), restricted=True, module_type=10)), ('doc', Storage(name_nice=T('Documents'), restricted=True, module_type=10)), ('msg', Storage(name_nice=T('Messaging'), restricted=True, module_type=None)), ('supply', Storage(name_nice=T('Distributions'), restricted=True, module_type=10)), ('inv', Storage(name_nice=T('Warehouses'), restricted=True, module_type=4)), ('project', Storage(name_nice=T('4W'), restricted=True, module_type=2)), ('hms', Storage(name_nice=T('Clinics'), restricted=True, module_type=10)), ('dc', Storage(name_nice=T('Assessments'), restricted=True, module_type=10)), ('dvr', Storage(name_nice=T('Beneficiaries'), restricted=True, module_type=10)), ('event', Storage(name_nice=T('Events'), restricted=True, module_type=10)), ('edu', Storage(name_nice=T('Schools'), restricted=True, module_type=10)), ('stats', Storage(name_nice=T('Statistics'), restricted=True, module_type=None))])
def urlquote(val): DCNL  DCSP if (val is None): DCNL DCSP  DCSP return '' DCNL DCSP if (not isinstance(val, unicode)): DCNL DCSP  DCSP val = str(val) DCNL DCSP else: DCNL DCSP  DCSP val = val.encode('utf-8') DCNL DCSP return urllib.quote(val)
def disk_usage(path): DCNL  DCSP try: DCNL DCSP  DCSP st = os.statvfs(path) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP if ((not PY3) and isinstance(path, unicode)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP path = path.encode(sys.getfilesystemencoding()) DCNL DCSP  DCSP  DCSP except UnicodeEncodeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP st = os.statvfs(path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP total = (st.f_blocks * st.f_frsize) DCNL DCSP avail_to_root = (st.f_bfree * st.f_frsize) DCNL DCSP avail_to_user = (st.f_bavail * st.f_frsize) DCNL DCSP used = (total - avail_to_root) DCNL DCSP total_user = (used + avail_to_user) DCNL DCSP usage_percent_user = usage_percent(used, total_user, _round=1) DCNL DCSP return sdiskusage(total=total, used=used, free=avail_to_user, percent=usage_percent_user)
def sql_demo(): DCNL  DCSP print() DCNL DCSP print(u"Using DCSP SQL DCSP to DCSP extract DCSP rows DCSP from DCSP 'city.db' DCSP RDB.") DCNL DCSP for row in sql_query(u'corpora/city_database/city.db', u'SELECT DCSP * DCSP FROM DCSP city_table'): DCNL DCSP  DCSP print(row)
def get_unmounted_partition_list(root_part, job=None, min_blocks=0, filter_func=None, exclude_swap=True, open_func=open): DCNL  DCSP partitions = get_partition_list(job=job, min_blocks=min_blocks, filter_func=filter_func, exclude_swap=exclude_swap, open_func=open_func) DCNL DCSP unmounted = [] DCNL DCSP for part in partitions: DCNL DCSP  DCSP if ((part.device != partname_to_device(root_part)) and (not part.get_mountpoint(open_func=open_func))): DCNL DCSP  DCSP  DCSP unmounted.append(part) DCNL DCSP return unmounted
def get_slug(): DCNL  DCSP list_name = raw_input(light_magenta('Give DCSP me DCSP the DCSP list\'s DCSP name DCSP ("@owner/list_name"): DCSP ', rl=True)) DCNL DCSP try: DCNL DCSP  DCSP (owner, slug) = list_name.split('/') DCNL DCSP  DCSP if slug.startswith('@'): DCNL DCSP  DCSP  DCSP slug = slug[1:] DCNL DCSP  DCSP return (owner, slug) DCNL DCSP except: DCNL DCSP  DCSP printNicely(light_magenta('List DCSP name DCSP should DCSP follow DCSP "@owner/list_name" DCSP format.')) DCNL DCSP  DCSP raise Exception('Wrong DCSP list DCSP name')
@task(base=BaseInstructorTask, routing_key=settings.GRADES_DOWNLOAD_ROUTING_KEY) DCNL def calculate_grades_csv(entry_id, xmodule_instance_args): DCNL  DCSP action_name = ugettext_noop('graded') DCNL DCSP TASK_LOG.info(u'Task: DCSP %s, DCSP InstructorTask DCSP ID: DCSP %s, DCSP Task DCSP type: DCSP %s, DCSP Preparing DCSP for DCSP task DCSP execution', xmodule_instance_args.get('task_id'), entry_id, action_name) DCNL DCSP task_fn = partial(upload_grades_csv, xmodule_instance_args) DCNL DCSP return run_main_task(entry_id, task_fn, action_name)
def do_vcs_install(manifest_in, versionfile_source, ipy): DCNL  DCSP GITS = ['git'] DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP GITS = ['git.cmd', 'git.exe'] DCNL DCSP files = [manifest_in, versionfile_source] DCNL DCSP if ipy: DCNL DCSP  DCSP files.append(ipy) DCNL DCSP try: DCNL DCSP  DCSP me = __file__ DCNL DCSP  DCSP if (me.endswith('.pyc') or me.endswith('.pyo')): DCNL DCSP  DCSP  DCSP me = (os.path.splitext(me)[0] + '.py') DCNL DCSP  DCSP versioneer_file = os.path.relpath(me) DCNL DCSP except NameError: DCNL DCSP  DCSP versioneer_file = 'versioneer.py' DCNL DCSP files.append(versioneer_file) DCNL DCSP present = False DCNL DCSP try: DCNL DCSP  DCSP f = open('.gitattributes', 'r') DCNL DCSP  DCSP for line in f.readlines(): DCNL DCSP  DCSP  DCSP if line.strip().startswith(versionfile_source): DCNL DCSP  DCSP  DCSP  DCSP if ('export-subst' in line.strip().split()[1:]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP present = True DCNL DCSP  DCSP f.close() DCNL DCSP except EnvironmentError: DCNL DCSP  DCSP pass DCNL DCSP if (not present): DCNL DCSP  DCSP f = open('.gitattributes', 'a+') DCNL DCSP  DCSP f.write(('%s DCSP export-subst\n' % versionfile_source)) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP files.append('.gitattributes') DCNL DCSP run_command(GITS, (['add', '--'] + files))
def getGeometryOutputByManipulation(geometryOutput, xmlElement): DCNL  DCSP xmlProcessor = xmlElement.getXMLProcessor() DCNL DCSP matchingPlugins = evaluate.getFromCreationEvaluatorPlugins(xmlProcessor.manipulationEvaluatorDictionary, xmlElement) DCNL DCSP matchingPlugins += evaluate.getMatchingPlugins(xmlProcessor.manipulationShapeDictionary, xmlElement) DCNL DCSP matchingPlugins.sort(evaluate.compareExecutionOrderAscending) DCNL DCSP for matchingPlugin in matchingPlugins: DCNL DCSP  DCSP geometryOutput = matchingPlugin.getManipulatedGeometryOutput(geometryOutput, xmlElement) DCNL DCSP return geometryOutput
def get_patch_verts(patch): DCNL  DCSP trans = patch.get_patch_transform() DCNL DCSP path = patch.get_path() DCNL DCSP polygons = path.to_polygons(trans) DCNL DCSP if len(polygons): DCNL DCSP  DCSP return polygons[0] DCNL DCSP else: DCNL DCSP  DCSP return []
def kegg_find(database, query, option=None): DCNL  DCSP if ((database in ['compound', 'drug']) and (option in ['formula', 'exact_mass', 'mol_weight'])): DCNL DCSP  DCSP resp = _q('find', database, query, option) DCNL DCSP elif option: DCNL DCSP  DCSP raise Exception('Invalid DCSP option DCSP arg DCSP for DCSP kegg DCSP find DCSP request.') DCNL DCSP else: DCNL DCSP  DCSP if isinstance(query, list): DCNL DCSP  DCSP  DCSP query = '+'.join(query) DCNL DCSP  DCSP resp = _q('find', database, query) DCNL DCSP return resp
def CheckInstalledVersion(name, desired, explicit): DCNL  DCSP CallSetAllowedModule(name, desired) DCNL DCSP find_version = PACKAGES[name][0] DCNL DCSP if (name == 'django'): DCNL DCSP  DCSP global _DESIRED_DJANGO_VERSION DCNL DCSP  DCSP _DESIRED_DJANGO_VERSION = ('v' + desired.replace('.', '_')) DCNL DCSP installed_version = find_version() DCNL DCSP try: DCNL DCSP  DCSP desired_version = distutils.version.LooseVersion(desired) DCNL DCSP except AttributeError: DCNL DCSP  DCSP desired_version = LooseVersion.parse(desired) DCNL DCSP if (not EqualVersions(installed_version, desired_version)): DCNL DCSP  DCSP raise UnacceptableVersionError(('%s DCSP %s DCSP was DCSP requested, DCSP but DCSP %s DCSP is DCSP already DCSP in DCSP use' % (name, desired_version, installed_version))) DCNL DCSP installed[name] = (desired, explicit)
@register.inclusion_tag(u'admin/feincms/content_type_selection_widget.html', takes_context=True) DCNL def show_content_type_selection_widget(context, region): DCNL  DCSP user = context[u'request'].user DCNL DCSP types = OrderedDict({None: []}) DCNL DCSP for ct in region._content_types: DCNL DCSP  DCSP opts = ct._meta DCNL DCSP  DCSP perm = ((opts.app_label + u'.') + get_permission_codename(u'add', opts)) DCNL DCSP  DCSP if (not user.has_perm(perm)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP types.setdefault(getattr(ct, u'optgroup', None), []).append((ct.__name__.lower, ct._meta.verbose_name)) DCNL DCSP return {u'types': types}
def restrict(permission): DCNL  DCSP def decorator(fx): DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP UserManager.get().require_permission(extract_context(), permission) DCNL DCSP  DCSP  DCSP return fx(*args, **kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def post(): DCNL  DCSP tablename = 'cms_post' DCNL DCSP s3db.set_method(module, resourcename, method='discuss', action=discuss) DCNL DCSP def prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (r.method in ('create', 'update')): DCNL DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP series = get_vars.get('~.series_id$name', None) DCNL DCSP  DCSP  DCSP  DCSP if series: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stable = db.cms_series DCNL DCSP  DCSP  DCSP  DCSP  DCSP row = db((stable.name == series)).select(stable.id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if row: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field = table.series_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.default = row.id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.readable = field.writable = False DCNL DCSP  DCSP  DCSP  DCSP location_id = get_vars.get('(location)', None) DCNL DCSP  DCSP  DCSP  DCSP if location_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP field = table.location_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.default = location_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.readable = field.writable = False DCNL DCSP  DCSP  DCSP  DCSP page = get_vars.get('page', None) DCNL DCSP  DCSP  DCSP  DCSP url = get_vars.get('url') DCNL DCSP  DCSP  DCSP  DCSP if page: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = page DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.readable = table.name.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud = s3.crud_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud.label_create = T('New DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud.title_update = T('Edit DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c='default', f='index', vars={'page': page}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.configure(tablename, create_next=url, update_next=url) DCNL DCSP  DCSP  DCSP  DCSP _module = get_vars.get('module', None) DCNL DCSP  DCSP  DCSP  DCSP if _module: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.avatar.readable = table.avatar.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.location_id.readable = table.location_id.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.date.readable = table.date.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.expired.readable = table.expired.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.body.widget = s3base.s3_richtext_widget DCNL DCSP  DCSP  DCSP  DCSP  DCSP resource = get_vars.get('resource', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (resource in ('about', 'contact', 'help', 'index')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (resource == 'about'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = 'About DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (resource == 'contact'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = 'Contact DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (resource == 'help'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = 'Help DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = 'Home DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.readable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_module, f=resource) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP record = get_vars.get('record', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if record: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = ('%s DCSP %s DCSP Profile DCSP Page' % (resource, record)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.title.readable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.readable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_module, f=resource, args=[record, 'profile']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif resource: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = ('%s DCSP Summary DCSP Page DCSP Header' % resource) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.title.readable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.readable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_module, f=resource, args='summary') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = ('%s DCSP Home DCSP Page' % _module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _crud = s3.crud_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _crud.label_create = T('New DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _crud.title_update = T('Edit DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_module, f='index') DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.configure(tablename, create_next=url, update_next=url) DCNL DCSP  DCSP  DCSP  DCSP layer_id = get_vars.get('layer_id', None) DCNL DCSP  DCSP  DCSP  DCSP if layer_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = ('Metadata DCSP Page DCSP for DCSP Layer DCSP %s' % layer_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.readable = table.name.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.avatar.readable = table.avatar.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.location_id.readable = table.location_id.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.title.readable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.replies.readable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.date.readable = table.date.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.expired.readable = table.expired.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud = s3.crud_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud.label_create = T('Add DCSP Metadata') DCNL DCSP  DCSP  DCSP  DCSP  DCSP _crud.title_update = T('Edit DCSP Metadata') DCNL DCSP  DCSP  DCSP  DCSP if (r.component_name == 'module'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP _modules = current.deployment_settings.modules DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in _modules: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (module in ('appadmin', 'errors', 'ocr')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modules[module] = _modules[module].name_nice DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.cms_post_module.field.requires = IS_IN_SET_LAZY((lambda : sort_dict_by_values(modules))) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller(rheader=s3db.cms_rheader) DCNL DCSP return output
def logsafe(val): DCNL  DCSP if isinstance(val, six.text_type): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, bytes): DCNL DCSP  DCSP return val.decode('utf-8', 'replace') DCNL DCSP elif isinstance(val, subprocess.CalledProcessError): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return six.text_type(val) DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP return str(val).decode('utf-8', 'replace') DCNL DCSP else: DCNL DCSP  DCSP return val
def cleanRequestURL(url): DCNL  DCSP url.transport = None DCNL DCSP url.maddr = None DCNL DCSP url.ttl = None DCNL DCSP url.headers = {}
def test_cc_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y_single_class)
def _cluster_to_basic_summary(cluster, now=None): DCNL  DCSP if (now is None): DCNL DCSP  DCSP now = datetime.utcnow() DCNL DCSP bcs = {} DCNL DCSP bcs['id'] = getattr(cluster, 'id', None) DCNL DCSP bcs['name'] = getattr(cluster, 'name', None) DCNL DCSP status = getattr(cluster, 'status', None) DCNL DCSP timeline = getattr(status, 'timeline', None) DCNL DCSP bcs['created'] = _to_datetime(getattr(timeline, 'creationdatetime', None)) DCNL DCSP bcs['ready'] = _to_datetime(getattr(timeline, 'readydatetime', None)) DCNL DCSP bcs['end'] = _to_datetime(getattr(timeline, 'enddatetime', None)) DCNL DCSP if bcs['created']: DCNL DCSP  DCSP bcs['ran'] = ((bcs['end'] or now) - bcs['created']) DCNL DCSP else: DCNL DCSP  DCSP bcs['ran'] = timedelta(0) DCNL DCSP bcs['state'] = getattr(status, 'state', None) DCNL DCSP bcs['num_steps'] = len(getattr(cluster, 'steps', ())) DCNL DCSP bcs['pool'] = None DCNL DCSP bootstrap_actions = getattr(cluster, 'bootstrapactions', None) DCNL DCSP if bootstrap_actions: DCNL DCSP  DCSP args = [arg.value for arg in bootstrap_actions[(-1)].args] DCNL DCSP  DCSP if ((len(args) == 2) and args[0].startswith('pool-')): DCNL DCSP  DCSP  DCSP bcs['pool'] = args[1] DCNL DCSP m = _JOB_KEY_RE.match((bcs['name'] or '')) DCNL DCSP if m: DCNL DCSP  DCSP (bcs['label'], bcs['owner']) = (m.group(1), m.group(2)) DCNL DCSP else: DCNL DCSP  DCSP (bcs['label'], bcs['owner']) = (None, None) DCNL DCSP bcs['nih'] = float(getattr(cluster, 'normalizedinstancehours', '0')) DCNL DCSP return bcs
def _auc(y_true, y_score): DCNL  DCSP pos_label = np.unique(y_true)[1] DCNL DCSP pos = y_score[(y_true == pos_label)] DCNL DCSP neg = y_score[(y_true != pos_label)] DCNL DCSP diff_matrix = (pos.reshape(1, (-1)) - neg.reshape((-1), 1)) DCNL DCSP n_correct = np.sum((diff_matrix > 0)) DCNL DCSP return (n_correct / float((len(pos) * len(neg))))
def is_interactive(): DCNL  DCSP return _is_interactive
def get_dataset_toy(): DCNL  DCSP trainset = ToyDataset() DCNL DCSP testset = ToyDataset() DCNL DCSP return (trainset, testset)
def _create_image_html(figure, area_data, plot_info): DCNL  DCSP (png, bbox) = _create_png(figure) DCNL DCSP areas = [(_AREA_TEMPLATE % ((data['left'] - bbox[0]), (data['top'] - bbox[1]), (data['right'] - bbox[0]), (data['bottom'] - bbox[1]), data['title'], data['callback'], _json_encoder.encode(data['callback_arguments']).replace('"', '&quot;'))) for data in area_data] DCNL DCSP map_name = (plot_info.drilldown_callback + '_map') DCNL DCSP return (_HTML_TEMPLATE % (base64.b64encode(png), map_name, map_name, '\n'.join(areas)))
def save_gamestate_to_sgf(gamestate, path, filename, black_player_name='Unknown', white_player_name='Unknown', size=19, komi=7.5): DCNL  DCSP str_list = [] DCNL DCSP str_list.append('(;GM[1]FF[4]CA[UTF-8]') DCNL DCSP str_list.append('SZ[{}]'.format(size)) DCNL DCSP str_list.append('KM[{}]'.format(komi)) DCNL DCSP str_list.append('PB[{}]'.format(black_player_name)) DCNL DCSP str_list.append('PW[{}]'.format(white_player_name)) DCNL DCSP cycle_string = 'BW' DCNL DCSP if (len(gamestate.handicaps) > 0): DCNL DCSP  DCSP cycle_string = 'WB' DCNL DCSP  DCSP str_list.append('HA[{}]'.format(len(gamestate.handicaps))) DCNL DCSP  DCSP str_list.append(';AB') DCNL DCSP  DCSP for handicap in gamestate.handicaps: DCNL DCSP  DCSP  DCSP str_list.append('[{}{}]'.format(LETTERS[handicap[0]].lower(), LETTERS[handicap[1]].lower())) DCNL DCSP for (move, color) in zip(gamestate.history, itertools.cycle(cycle_string)): DCNL DCSP  DCSP str_list.append(';{}'.format(color)) DCNL DCSP  DCSP if (move is None): DCNL DCSP  DCSP  DCSP str_list.append('[tt]') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP str_list.append('[{}{}]'.format(LETTERS[move[0]].lower(), LETTERS[move[1]].lower())) DCNL DCSP str_list.append(')') DCNL DCSP with open(os.path.join(path, filename), 'w') as f: DCNL DCSP  DCSP f.write(''.join(str_list))
@must_have_permission(ADMIN) DCNL @must_be_valid_project DCNL def new_draft_registration(auth, node, *args, **kwargs): DCNL  DCSP if node.is_registration: DCNL DCSP  DCSP raise HTTPError(http.FORBIDDEN, data={'message_short': "Can't DCSP create DCSP draft", 'message_long': 'Creating DCSP draft DCSP registrations DCSP on DCSP registered DCSP projects DCSP is DCSP not DCSP allowed.'}) DCNL DCSP data = request.values DCNL DCSP schema_name = data.get('schema_name') DCNL DCSP if (not schema_name): DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST, data={'message_short': 'Must DCSP specify DCSP a DCSP schema_name', 'message_long': 'Please DCSP specify DCSP a DCSP schema_name'}) DCNL DCSP schema_version = data.get('schema_version', 2) DCNL DCSP meta_schema = get_schema_or_fail((Q('name', 'eq', schema_name) & Q('schema_version', 'eq', int(schema_version)))) DCNL DCSP draft = DraftRegistration.create_from_node(node, user=auth.user, schema=meta_schema, data={}) DCNL DCSP return redirect(node.web_url_for('edit_draft_registration_page', draft_id=draft._id))
def tree_item_iterator(items, ancestors=False): DCNL  DCSP structure = {} DCNL DCSP opts = None DCNL DCSP first_item_level = 0 DCNL DCSP for (previous, current, next_) in previous_current_next(items): DCNL DCSP  DCSP if (opts is None): DCNL DCSP  DCSP  DCSP opts = current._mptt_meta DCNL DCSP  DCSP current_level = getattr(current, opts.level_attr) DCNL DCSP  DCSP if previous: DCNL DCSP  DCSP  DCSP structure[u'new_level'] = (getattr(previous, opts.level_attr) < current_level) DCNL DCSP  DCSP  DCSP if ancestors: DCNL DCSP  DCSP  DCSP  DCSP if structure[u'closed_levels']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP structure[u'ancestors'] = structure[u'ancestors'][:(- len(structure[u'closed_levels']))] DCNL DCSP  DCSP  DCSP  DCSP if structure[u'new_level']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP structure[u'ancestors'].append(text_type(previous)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP structure[u'new_level'] = True DCNL DCSP  DCSP  DCSP if ancestors: DCNL DCSP  DCSP  DCSP  DCSP structure[u'ancestors'] = [] DCNL DCSP  DCSP  DCSP first_item_level = current_level DCNL DCSP  DCSP if next_: DCNL DCSP  DCSP  DCSP structure[u'closed_levels'] = list(range(current_level, getattr(next_, opts.level_attr), (-1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP structure[u'closed_levels'] = list(range(current_level, (first_item_level - 1), (-1))) DCNL DCSP  DCSP (yield (current, copy.deepcopy(structure)))
def ensure_treasury_data(bm_symbol, first_date, last_date, now): DCNL  DCSP (loader_module, filename, source) = INDEX_MAPPING.get(bm_symbol, INDEX_MAPPING['^GSPC']) DCNL DCSP first_date = max(first_date, loader_module.earliest_possible_date()) DCNL DCSP path = get_data_filepath(filename) DCNL DCSP if os.path.exists(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = pd.DataFrame.from_csv(path).tz_localize('UTC') DCNL DCSP  DCSP  DCSP if has_data_for_dates(data, first_date, last_date): DCNL DCSP  DCSP  DCSP  DCSP return data DCNL DCSP  DCSP  DCSP last_download_time = last_modified_time(path) DCNL DCSP  DCSP  DCSP if ((now - last_download_time) <= ONE_HOUR): DCNL DCSP  DCSP  DCSP  DCSP logger.warn(('Refusing DCSP to DCSP download DCSP new DCSP treasury DCSP data DCSP because DCSP a DCSP download DCSP succeeded DCSP at DCSP %s.' % last_download_time)) DCNL DCSP  DCSP  DCSP  DCSP return data DCNL DCSP  DCSP except (OSError, IOError, ValueError) as e: DCNL DCSP  DCSP  DCSP logger.info('Loading DCSP data DCSP for DCSP {path} DCSP failed DCSP with DCSP error DCSP [{error}].'.format(path=path, error=e)) DCNL DCSP try: DCNL DCSP  DCSP data = loader_module.get_treasury_data(first_date, last_date) DCNL DCSP  DCSP data.to_csv(path) DCNL DCSP except (OSError, IOError, HTTPError): DCNL DCSP  DCSP logger.exception('failed DCSP to DCSP cache DCSP treasury DCSP data') DCNL DCSP if (not has_data_for_dates(data, first_date, last_date)): DCNL DCSP  DCSP logger.warn("Still DCSP don't DCSP have DCSP expected DCSP data DCSP after DCSP redownload!") DCNL DCSP return data
def _make_compatible_taxa_summaries(ts1, ts2, sample_id_map=None): DCNL  DCSP if sample_id_map: DCNL DCSP  DCSP for samp_id in (ts1[0] + ts2[0]): DCNL DCSP  DCSP  DCSP if (samp_id not in sample_id_map): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("The DCSP original DCSP sample DCSP ID DCSP '%s' DCSP does DCSP not DCSP have DCSP a DCSP mapping DCSP in DCSP the DCSP sample DCSP ID DCSP map. DCSP All DCSP sample DCSP IDs DCSP must DCSP have DCSP a DCSP mapping." % samp_id)) DCNL DCSP (new_samp_ids1, new_samp_ids2, new_data1, new_data2) = ([], [], [], []) DCNL DCSP for (samp_idx, samp_id) in enumerate(ts1[0]): DCNL DCSP  DCSP matching_samp_id = None DCNL DCSP  DCSP if sample_id_map: DCNL DCSP  DCSP  DCSP new_samp_id = sample_id_map[samp_id] DCNL DCSP  DCSP  DCSP for orig_samp_id in sample_id_map: DCNL DCSP  DCSP  DCSP  DCSP if ((orig_samp_id != samp_id) and (sample_id_map[orig_samp_id] == new_samp_id)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matching_samp_id = orig_samp_id DCNL DCSP  DCSP elif (samp_id in ts2[0]): DCNL DCSP  DCSP  DCSP matching_samp_id = samp_id DCNL DCSP  DCSP if matching_samp_id: DCNL DCSP  DCSP  DCSP new_samp_ids1.append(samp_id) DCNL DCSP  DCSP  DCSP new_samp_ids2.append(matching_samp_id) DCNL DCSP  DCSP  DCSP new_data1.append(ts1[2].T[samp_idx]) DCNL DCSP  DCSP  DCSP new_data2.append(ts2[2].T[ts2[0].index(matching_samp_id)]) DCNL DCSP if (len(new_samp_ids1) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP sample DCSP IDs DCSP matched DCSP between DCSP the DCSP taxa DCSP summaries. DCSP The DCSP taxa DCSP summaries DCSP are DCSP incompatible.') DCNL DCSP return ((new_samp_ids1, ts1[1], array(new_data1).T), (new_samp_ids2, ts2[1], array(new_data2).T))
def setSliceElementZ(decimalPlacesCarried, sliceElement, sliceElementIndex, z): DCNL  DCSP roundedZ = euclidean.getRoundedToPlacesString(decimalPlacesCarried, z) DCNL DCSP idValue = ('z:%s' % roundedZ) DCNL DCSP sliceElement.attributeDictionary['id'] = idValue DCNL DCSP textElement = sliceElement.getFirstChildWithClassName('text') DCNL DCSP textElement.text = ('Layer DCSP %s, DCSP %s' % (sliceElementIndex, idValue))
def format_decimal(number, format=None, locale=LC_NUMERIC): DCNL  DCSP locale = Locale.parse(locale) DCNL DCSP if (not format): DCNL DCSP  DCSP format = locale.decimal_formats.get(format) DCNL DCSP pattern = parse_pattern(format) DCNL DCSP return pattern.apply(number, locale)
def _count1Bits(num): DCNL  DCSP ret = 0 DCNL DCSP while (num > 0): DCNL DCSP  DCSP num = (num >> 1) DCNL DCSP  DCSP ret += 1 DCNL DCSP return ret
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL  DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_disk_gb != None): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = free_disk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_node.current_workload = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_node.running_vms = vms DCNL DCSP return compute_node
def _set_contour_locator(vmin, vmax, contours): DCNL  DCSP locator = None DCNL DCSP if isinstance(contours, int): DCNL DCSP  DCSP from matplotlib import ticker DCNL DCSP  DCSP locator = ticker.MaxNLocator(nbins=(contours + 1)) DCNL DCSP  DCSP contours = locator.tick_values(vmin, vmax) DCNL DCSP return (locator, contours)
def get_instance_type_access_by_flavor_id(flavorid, ctxt=None): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_get_by_flavor_id(ctxt, flavorid)
def holdReject(): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=26) DCNL DCSP c = Cause() DCNL DCSP packet = ((a / b) / c) DCNL DCSP return packet
def customize_config_vars(_config_vars): DCNL  DCSP if (not _supports_universal_builds()): DCNL DCSP  DCSP _remove_universal_flags(_config_vars) DCNL DCSP _override_all_archs(_config_vars) DCNL DCSP _check_for_unavailable_sdk(_config_vars) DCNL DCSP return _config_vars
def test_tanimoto_distances(): DCNL  DCSP X = [['a', 'b', 'c']] DCNL DCSP D = tanimoto_coefficient(X, X) DCNL DCSP assert_array_almost_equal(D, [[1.0]]) DCNL DCSP X = [['a', 'b', 'c']] DCNL DCSP Y = [[]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_equal(D, [[0.0]]) DCNL DCSP X = [[1, 2, 3, 4]] DCNL DCSP Y = [[2, 3]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_equal(D, [[0.5]]) DCNL DCSP X = [['a', 'b', 'c', 'd'], ['e', 'f', 'g']] DCNL DCSP Y = [['a', 'b', 'c', 'k']] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_equal(D, [[0.6], [0.0]]) DCNL DCSP X = [['a', 'b', 'c', 'd'], ['e', 'f', 'g']] DCNL DCSP Y = [['a', 'b', 'c', 'd'], ['e', 'f', 'g']] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_equal(D, [[1.0, 0.0], [0.0, 1.0]]) DCNL DCSP X = [[0, 1], [1, 1]] DCNL DCSP D = tanimoto_coefficient(X, X) DCNL DCSP assert_array_almost_equal(D, [[1.0, 0.33333333], [0.33333333, 0.33333333]]) DCNL DCSP X = [[0, 1], [1, 1]] DCNL DCSP Y = [[0, 0]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_equal(D, [[0.3333333], [0.0]])
def rmtree(path): DCNL  DCSP def onerror(func, path, exc_info): DCNL DCSP  DCSP os.chmod(path, stat.S_IWUSR) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP func(path) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP if HIDE_WINDOWS_KNOWN_ERRORS: DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest('FIXME: DCSP fails DCSP with: DCSP PermissionError\n DCSP  DCSP %s', ex) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return shutil.rmtree(path, False, onerror)
def cc_benchmark(name, deps=[], **kwargs): DCNL  DCSP cc_config = configparse.blade_config.get_config('cc_config') DCNL DCSP benchmark_libs = cc_config['benchmark_libs'] DCNL DCSP benchmark_main_libs = cc_config['benchmark_main_libs'] DCNL DCSP deps = ((var_to_list(deps) + benchmark_libs) + benchmark_main_libs) DCNL DCSP cc_binary(name=name, deps=deps, **kwargs)
def getcfs(key, filename, filter=None): DCNL  DCSP try: DCNL DCSP  DCSP t = stat(filename).st_mtime DCNL DCSP except OSError: DCNL DCSP  DCSP return (filter() if callable(filter) else '') DCNL DCSP cfs_lock.acquire() DCNL DCSP item = cfs.get(key, None) DCNL DCSP cfs_lock.release() DCNL DCSP if (item and (item[0] == t)): DCNL DCSP  DCSP return item[1] DCNL DCSP if (not callable(filter)): DCNL DCSP  DCSP data = read_file(filename) DCNL DCSP else: DCNL DCSP  DCSP data = filter() DCNL DCSP cfs_lock.acquire() DCNL DCSP cfs[key] = (t, data) DCNL DCSP cfs_lock.release() DCNL DCSP return data
def read_dot(path): DCNL  DCSP try: DCNL DCSP  DCSP import pygraphviz DCNL DCSP except ImportError: DCNL DCSP  DCSP raise ImportError('read_dot() DCSP requires DCSP pygraphviz DCSP ', 'http://pygraphviz.github.io/') DCNL DCSP A = pygraphviz.AGraph(file=path) DCNL DCSP return from_agraph(A)
def EvalBinomialPmf(k, n, p): DCNL  DCSP return stats.binom.pmf(k, n, p)
def dict_to_str(args, sep=u'&'): DCNL  DCSP t = [] DCNL DCSP for k in args.keys(): DCNL DCSP  DCSP t.append(((str(k) + u'=') + urllib.quote(str((args[k] or u''))))) DCNL DCSP return sep.join(t)
def unbare_repo(func): DCNL  DCSP @wraps(func) DCNL DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self.repo.bare: DCNL DCSP  DCSP  DCSP raise InvalidGitRepositoryError(("Method DCSP '%s' DCSP cannot DCSP operate DCSP on DCSP bare DCSP repositories" % func.__name__)) DCNL DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapper
def calc_dihedral(v1, v2, v3, v4): DCNL  DCSP ab = (v1 - v2) DCNL DCSP cb = (v3 - v2) DCNL DCSP db = (v4 - v3) DCNL DCSP u = (ab ** cb) DCNL DCSP v = (db ** cb) DCNL DCSP w = (u ** v) DCNL DCSP angle = u.angle(v) DCNL DCSP try: DCNL DCSP  DCSP if (cb.angle(w) > 0.001): DCNL DCSP  DCSP  DCSP angle = (- angle) DCNL DCSP except ZeroDivisionError: DCNL DCSP  DCSP pass DCNL DCSP return angle
def __virtual__(): DCNL  DCSP return True
def search_by_name(service, name, **kwargs): DCNL  DCSP if ('search' in inspect.getargspec(service.list)[0]): DCNL DCSP  DCSP res = service.list(search='name={name}'.format(name=name)) DCNL DCSP else: DCNL DCSP  DCSP res = [e for e in service.list() if (e.name == name)] DCNL DCSP if kwargs: DCNL DCSP  DCSP res = [e for e in service.list() if (len([k for (k, v) in kwargs.items() if (getattr(e, k, None) == v)]) == len(kwargs))] DCNL DCSP res = (res or [None]) DCNL DCSP return res[0]
def blank_lines(logical_line, blank_lines, indent_level, line_number, previous_logical, previous_indent_level): DCNL  DCSP if ((line_number < 3) and (not previous_logical)): DCNL DCSP  DCSP return DCNL DCSP if previous_logical.startswith('@'): DCNL DCSP  DCSP if blank_lines: DCNL DCSP  DCSP  DCSP (yield (0, 'E304 DCSP blank DCSP lines DCSP found DCSP after DCSP function DCSP decorator')) DCNL DCSP elif ((blank_lines > 2) or (indent_level and (blank_lines == 2))): DCNL DCSP  DCSP (yield (0, ('E303 DCSP too DCSP many DCSP blank DCSP lines DCSP (%d)' % blank_lines))) DCNL DCSP elif logical_line.startswith(('def DCSP ', 'class DCSP ', '@')): DCNL DCSP  DCSP if indent_level: DCNL DCSP  DCSP  DCSP if (not (blank_lines or (previous_indent_level < indent_level) or DOCSTRING_REGEX.match(previous_logical))): DCNL DCSP  DCSP  DCSP  DCSP (yield (0, 'E301 DCSP expected DCSP 1 DCSP blank DCSP line, DCSP found DCSP 0')) DCNL DCSP  DCSP elif (blank_lines != 2): DCNL DCSP  DCSP  DCSP (yield (0, ('E302 DCSP expected DCSP 2 DCSP blank DCSP lines, DCSP found DCSP %d' % blank_lines)))
def _deferGenerator(g, deferred): DCNL  DCSP result = None DCNL DCSP waiting = [True, None] DCNL DCSP while 1: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = next(g) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP deferred.callback(result) DCNL DCSP  DCSP  DCSP return deferred DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP deferred.errback() DCNL DCSP  DCSP  DCSP return deferred DCNL DCSP  DCSP if isinstance(result, Deferred): DCNL DCSP  DCSP  DCSP return fail(TypeError('Yield DCSP waitForDeferred(d), DCSP not DCSP d!')) DCNL DCSP  DCSP if isinstance(result, waitForDeferred): DCNL DCSP  DCSP  DCSP def gotResult(r, result=result): DCNL DCSP  DCSP  DCSP  DCSP result.result = r DCNL DCSP  DCSP  DCSP  DCSP if waiting[0]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP waiting[0] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP waiting[1] = r DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _deferGenerator(g, deferred) DCNL DCSP  DCSP  DCSP result.d.addBoth(gotResult) DCNL DCSP  DCSP  DCSP if waiting[0]: DCNL DCSP  DCSP  DCSP  DCSP waiting[0] = False DCNL DCSP  DCSP  DCSP  DCSP return deferred DCNL DCSP  DCSP  DCSP waiting[0] = True DCNL DCSP  DCSP  DCSP waiting[1] = None DCNL DCSP  DCSP  DCSP result = None
@gen.coroutine DCNL def QueryViewpoints(client, obj_store, user_id, device_id, request): DCNL  DCSP @gen.coroutine DCNL DCSP def _QueryFollowers(): DCNL DCSP  DCSP 'Produces DCSP list DCSP of DCSP (followers, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_dict in request['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_dict.get('get_followers', False): DCNL DCSP  DCSP  DCSP  DCSP start_key = vp_dict.get('follower_start_key', None) DCNL DCSP  DCSP  DCSP  DCSP tasks.append(Viewpoint.QueryFollowers(client, vp_dict['viewpoint_id'], excl_start_key=(int(start_key) if (start_key is not None) else None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.append(util.GenConstant(None)) DCNL DCSP  DCSP follower_results = (yield tasks) DCNL DCSP  DCSP raise gen.Return(follower_results) DCNL DCSP @gen.coroutine DCNL DCSP def _QueryActivities(): DCNL DCSP  DCSP 'Produces DCSP list DCSP of DCSP (activities, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_dict in request['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_dict.get('get_activities', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.append(gen.Task(Viewpoint.QueryActivities, client, vp_dict['viewpoint_id'], excl_start_key=vp_dict.get('activity_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.append(util.GenConstant(None)) DCNL DCSP  DCSP activity_results = (yield tasks) DCNL DCSP  DCSP raise gen.Return(activity_results) DCNL DCSP @gen.coroutine DCNL DCSP def _QueryEpisodes(): DCNL DCSP  DCSP 'Produces DCSP list DCSP of DCSP (episodes, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_dict in request['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_dict.get('get_episodes', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.append(gen.Task(Viewpoint.QueryEpisodes, client, vp_dict['viewpoint_id'], excl_start_key=vp_dict.get('episode_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.append(util.GenConstant(None)) DCNL DCSP  DCSP episode_results = (yield tasks) DCNL DCSP  DCSP raise gen.Return(episode_results) DCNL DCSP @gen.coroutine DCNL DCSP def _QueryComments(): DCNL DCSP  DCSP 'Produces DCSP list DCSP of DCSP (comments, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_dict in request['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_dict.get('get_comments', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.append(gen.Task(Viewpoint.QueryComments, client, vp_dict['viewpoint_id'], excl_start_key=vp_dict.get('comment_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.append(util.GenConstant(None)) DCNL DCSP  DCSP comment_results = (yield tasks) DCNL DCSP  DCSP raise gen.Return(comment_results) DCNL DCSP limit = request.get('limit', None) DCNL DCSP viewpoint_keys = [db_client.DBKey(vp_dict['viewpoint_id'], None) for vp_dict in request['viewpoints']] DCNL DCSP follower_keys = [db_client.DBKey(user_id, vp_dict['viewpoint_id']) for vp_dict in request['viewpoints']] DCNL DCSP results = (yield [gen.Task(Viewpoint.BatchQuery, client, viewpoint_keys, None, must_exist=False), gen.Task(Follower.BatchQuery, client, follower_keys, None, must_exist=False), _QueryFollowers(), _QueryActivities(), _QueryEpisodes(), _QueryComments()]) DCNL DCSP (viewpoints, followers, follower_id_results, activity_results, episode_results, comment_results) = results DCNL DCSP zip_list = zip(request['viewpoints'], viewpoints, followers, follower_id_results, activity_results, episode_results, comment_results) DCNL DCSP num_followers = 0 DCNL DCSP num_activities = 0 DCNL DCSP num_episodes = 0 DCNL DCSP num_comments = 0 DCNL DCSP response_vp_dicts = [] DCNL DCSP for (vp_dict, viewpoint, follower, follower_result, activity_result, episode_result, comment_result) in zip_list: DCNL DCSP  DCSP if (follower is not None): DCNL DCSP  DCSP  DCSP response_vp_dict = {'viewpoint_id': viewpoint.viewpoint_id} DCNL DCSP  DCSP  DCSP if vp_dict.get('get_attributes', False): DCNL DCSP  DCSP  DCSP  DCSP response_vp_dict.update(_MakeViewpointMetadataDict(viewpoint, follower, obj_store)) DCNL DCSP  DCSP  DCSP if ((not follower.IsRemoved()) and vp_dict.get('get_followers', False)): DCNL DCSP  DCSP  DCSP  DCSP (followers, last_key) = follower_result DCNL DCSP  DCSP  DCSP  DCSP response_vp_dict['followers'] = [foll.MakeFriendMetadataDict() for foll in followers] DCNL DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['follower_last_key'] = www_util.FormatIntegralLastKey(last_key) DCNL DCSP  DCSP  DCSP  DCSP num_followers += len(followers) DCNL DCSP  DCSP  DCSP if _CanViewViewpointContent(viewpoint, follower): DCNL DCSP  DCSP  DCSP  DCSP if vp_dict.get('get_activities', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (activities, last_key) = activity_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['activities'] = [act.MakeMetadataDict() for act in activities] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['activity_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_activities += len(activities) DCNL DCSP  DCSP  DCSP  DCSP if vp_dict.get('get_episodes', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (episodes, last_key) = episode_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['episodes'] = [ep._asdict() for ep in episodes] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['episode_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_episodes += len(episodes) DCNL DCSP  DCSP  DCSP  DCSP if vp_dict.get('get_comments', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (comments, last_key) = comment_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['comments'] = [co._asdict() for co in comments] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_dict['comment_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_comments += len(comments) DCNL DCSP  DCSP  DCSP response_vp_dicts.append(response_vp_dict) DCNL DCSP logging.info(('QUERY DCSP VIEWPOINTS: DCSP user: DCSP %d, DCSP device: DCSP %d, DCSP %d DCSP viewpoints, DCSP %d DCSP followers, DCSP %d DCSP activities, DCSP %d DCSP episodes, DCSP %d DCSP comments' % (user_id, device_id, len(response_vp_dicts), num_followers, num_activities, num_episodes, num_comments))) DCNL DCSP raise gen.Return({'viewpoints': response_vp_dicts})
def service_mapping(services, registry_path=DEFAULT_REGISTRY_PATH): DCNL  DCSP if isinstance(services, dict): DCNL DCSP  DCSP services = services.iteritems() DCNL DCSP mapping = [] DCNL DCSP registry_map = {} DCNL DCSP if (registry_path is not None): DCNL DCSP  DCSP registry_service = registry.RegistryService.new_factory(registry_map) DCNL DCSP  DCSP services = (list(services) + [(registry_path, registry_service)]) DCNL DCSP  DCSP mapping.append(((registry_path + '/form(?:/)?'), forms.FormsHandler.new_factory(registry_path))) DCNL DCSP  DCSP mapping.append(((registry_path + '/form/(.+)'), forms.ResourceHandler)) DCNL DCSP paths = set() DCNL DCSP for service_item in services: DCNL DCSP  DCSP infer_path = (not isinstance(service_item, (list, tuple))) DCNL DCSP  DCSP if infer_path: DCNL DCSP  DCSP  DCSP service = service_item DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP service = service_item[1] DCNL DCSP  DCSP service_class = getattr(service, 'service_class', service) DCNL DCSP  DCSP if infer_path: DCNL DCSP  DCSP  DCSP path = ('/' + service_class.definition_name().replace('.', '/')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = service_item[0] DCNL DCSP  DCSP if (path in paths): DCNL DCSP  DCSP  DCSP raise ServiceConfigurationError(('Path DCSP %r DCSP is DCSP already DCSP defined DCSP in DCSP service DCSP mapping' % path.encode('utf-8'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP paths.add(path) DCNL DCSP  DCSP new_mapping = ServiceHandlerFactory.default(service).mapping(path) DCNL DCSP  DCSP mapping.append(new_mapping) DCNL DCSP  DCSP registry_map[path] = service_class DCNL DCSP return mapping
@register.filter(name='user_which_groups') DCNL def user_which_group(user, member): DCNL  DCSP member = getattr(user, member) DCNL DCSP names = [members.name for members in member.all()] DCNL DCSP return ','.join(names)
def failure_code(sub): DCNL  DCSP return ('{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(failure_var)s DCSP = DCSP %(id)s;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP (!PyErr_Occurred()) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_RuntimeError,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "Unexpected DCSP error DCSP in DCSP an DCSP Op\'s DCSP C DCSP code. DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "No DCSP Python DCSP exception DCSP was DCSP set.");\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP goto DCSP __label_%(id)i;}' % sub)
def generate_change(branch, old_revno=None, old_revid=None, new_revno=None, new_revid=None, blame_merge_author=False): DCNL  DCSP change = {} DCNL DCSP if (new_revno is None): DCNL DCSP  DCSP new_revno = branch.revno() DCNL DCSP if (new_revid is None): DCNL DCSP  DCSP new_revid = branch.get_rev_id(new_revno) DCNL DCSP if (old_revno is None): DCNL DCSP  DCSP old_revno = (new_revno - 1) DCNL DCSP if (old_revid is None): DCNL DCSP  DCSP old_revid = branch.get_rev_id(old_revno) DCNL DCSP repository = branch.repository DCNL DCSP new_rev = repository.get_revision(new_revid) DCNL DCSP if blame_merge_author: DCNL DCSP  DCSP change['who'] = repository.get_revision(new_rev.parent_ids[(-1)]).get_apparent_authors()[0] DCNL DCSP else: DCNL DCSP  DCSP change['who'] = new_rev.get_apparent_authors()[0] DCNL DCSP change['comments'] = new_rev.message DCNL DCSP change['revision'] = new_revno DCNL DCSP files = change['files'] = [] DCNL DCSP changes = repository.revision_tree(new_revid).changes_from(repository.revision_tree(old_revid)) DCNL DCSP for (collection, name) in ((changes.added, 'ADDED'), (changes.removed, 'REMOVED'), (changes.modified, 'MODIFIED')): DCNL DCSP  DCSP for info in collection: DCNL DCSP  DCSP  DCSP path = info[0] DCNL DCSP  DCSP  DCSP kind = info[2] DCNL DCSP  DCSP  DCSP files.append(' DCSP '.join([path, kind, name])) DCNL DCSP for info in changes.renamed: DCNL DCSP  DCSP (oldpath, newpath, id, kind, text_modified, meta_modified) = info DCNL DCSP  DCSP elements = [oldpath, kind, 'RENAMED', newpath] DCNL DCSP  DCSP if (text_modified or meta_modified): DCNL DCSP  DCSP  DCSP elements.append('MODIFIED') DCNL DCSP  DCSP files.append(' DCSP '.join(elements)) DCNL DCSP return change
def _simplify_variable_coeff(sol, syms, func, funcarg): DCNL  DCSP eta = Symbol('eta') DCNL DCSP if (len(syms) == 1): DCNL DCSP  DCSP sym = syms.pop() DCNL DCSP  DCSP final = sol.subs(sym, func(funcarg)) DCNL DCSP else: DCNL DCSP  DCSP fname = func.__name__ DCNL DCSP  DCSP for (key, sym) in enumerate(syms): DCNL DCSP  DCSP  DCSP tempfun = Function((fname + str(key))) DCNL DCSP  DCSP  DCSP final = sol.subs(sym, func(funcarg)) DCNL DCSP return simplify(final.subs(eta, funcarg))
def ex(e): DCNL  DCSP e_message = u'' DCNL DCSP if ((not e) or (not e.args)): DCNL DCSP  DCSP return e_message DCNL DCSP for arg in e.args: DCNL DCSP  DCSP if (arg is not None): DCNL DCSP  DCSP  DCSP if isinstance(arg, (str, unicode)): DCNL DCSP  DCSP  DCSP  DCSP fixed_arg = fixStupidEncodings(arg, True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed_arg = (u'error DCSP ' + fixStupidEncodings(str(arg), True)) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed_arg = None DCNL DCSP  DCSP  DCSP if fixed_arg: DCNL DCSP  DCSP  DCSP  DCSP if (not e_message): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = fixed_arg DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = ((e_message + ' DCSP : DCSP ') + fixed_arg) DCNL DCSP return e_message
def _compile_from_parse_tree(root_node, *a, **kw): DCNL  DCSP return _CompiledGrammar(root_node, *a, **kw)
def deb_packages(attrs=None, where=None): DCNL  DCSP if (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP return _osquery_cmd(table='deb_packages', attrs=attrs, where=where) DCNL DCSP return {'result': False, 'comment': 'Only DCSP available DCSP on DCSP Debian DCSP based DCSP systems.'}
def setvcpus(vm_, vcpus, config=False): DCNL  DCSP if (vm_state(vm_)[vm_] != 'shutdown'): DCNL DCSP  DCSP return False DCNL DCSP dom = _get_domain(vm_) DCNL DCSP flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM DCNL DCSP if config: DCNL DCSP  DCSP flags = (flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG) DCNL DCSP ret1 = dom.setVcpusFlags(vcpus, flags) DCNL DCSP ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT) DCNL DCSP return (ret1 == ret2 == 0)
def cmd(name, fun=None, arg=(), **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'comment': '', 'result': True} DCNL DCSP if (fun is None): DCNL DCSP  DCSP fun = name DCNL DCSP client = salt.runner.RunnerClient(__opts__) DCNL DCSP low = {'fun': fun, 'arg': arg, 'kwargs': kwargs} DCNL DCSP client.cmd_async(low) DCNL DCSP return ret
def pluralize(word, pos=NOUN, custom={}, classical=True): DCNL  DCSP if (word in custom): DCNL DCSP  DCSP return custom[word] DCNL DCSP if word.endswith(("'", "'s")): DCNL DCSP  DCSP w = word.rstrip("'s") DCNL DCSP  DCSP w = pluralize(w, pos, custom, classical) DCNL DCSP  DCSP if w.endswith('s'): DCNL DCSP  DCSP  DCSP return (w + "'") DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (w + "'s") DCNL DCSP w = word.replace('-', ' DCSP ').split(' DCSP ') DCNL DCSP if (len(w) > 1): DCNL DCSP  DCSP if ((w[1] == 'general') or ((w[1] == 'General') and (w[0] not in plural_categories['general-generals']))): DCNL DCSP  DCSP  DCSP return word.replace(w[0], pluralize(w[0], pos, custom, classical)) DCNL DCSP  DCSP elif (w[1] in plural_prepositions): DCNL DCSP  DCSP  DCSP return word.replace(w[0], pluralize(w[0], pos, custom, classical)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return word.replace(w[(-1)], pluralize(w[(-1)], pos, custom, classical)) DCNL DCSP n = range(len(plural_rules)) DCNL DCSP if pos.startswith(ADJECTIVE): DCNL DCSP  DCSP n = [0, 1] DCNL DCSP for i in n: DCNL DCSP  DCSP for (suffix, inflection, category, classic) in plural_rules[i]: DCNL DCSP  DCSP  DCSP if (category is None): DCNL DCSP  DCSP  DCSP  DCSP if ((not classic) or (classic and classical)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (suffix.search(word) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return suffix.sub(inflection, word) DCNL DCSP  DCSP  DCSP if (category is not None): DCNL DCSP  DCSP  DCSP  DCSP if ((word in plural_categories[category]) and ((not classic) or (classic and classical))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (suffix.search(word) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return suffix.sub(inflection, word) DCNL DCSP return word
def descrFromDoc(obj): DCNL  DCSP if ((obj.__doc__ is None) or obj.__doc__.isspace()): DCNL DCSP  DCSP return None DCNL DCSP lines = [x.strip() for x in obj.__doc__.split('\n') if (x and (not x.isspace()))] DCNL DCSP return ' DCSP '.join(lines)
def _parse_circ_entry(entry): DCNL  DCSP if ('=' in entry): DCNL DCSP  DCSP (fingerprint, nickname) = entry.split('=') DCNL DCSP elif ('~' in entry): DCNL DCSP  DCSP (fingerprint, nickname) = entry.split('~') DCNL DCSP elif (entry[0] == '$'): DCNL DCSP  DCSP (fingerprint, nickname) = (entry, None) DCNL DCSP else: DCNL DCSP  DCSP (fingerprint, nickname) = (None, entry) DCNL DCSP if (fingerprint is not None): DCNL DCSP  DCSP if (not stem.util.tor_tools.is_valid_fingerprint(fingerprint, True)): DCNL DCSP  DCSP  DCSP raise stem.ProtocolError(('Fingerprint DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformed DCSP (%s)' % fingerprint)) DCNL DCSP  DCSP fingerprint = fingerprint[1:] DCNL DCSP if ((nickname is not None) and (not stem.util.tor_tools.is_valid_nickname(nickname))): DCNL DCSP  DCSP raise stem.ProtocolError(('Nickname DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformed DCSP (%s)' % nickname)) DCNL DCSP return (fingerprint, nickname)
def get_interface(iface): DCNL  DCSP adapters = _parse_interfaces() DCNL DCSP if (iface in adapters): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (iface == 'source'): DCNL DCSP  DCSP  DCSP  DCSP template = JINJA.get_template('debian_source.jinja') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP template = JINJA.get_template('debian_eth.jinja') DCNL DCSP  DCSP except jinja2.exceptions.TemplateNotFound: DCNL DCSP  DCSP  DCSP log.error('Could DCSP not DCSP load DCSP template DCSP debian_eth.jinja') DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP ifcfg = template.render({'name': iface, 'data': adapters[iface]}) DCNL DCSP  DCSP return [(item + '\n') for item in ifcfg.split('\n')] DCNL DCSP else: DCNL DCSP  DCSP return []
def test_diagonal_gaussian_conditional_expectation(): DCNL  DCSP mlp = MLP(layers=[Linear(layer_name='h', dim=5, irange=0.01, max_col_norm=0.01)]) DCNL DCSP conditional = DiagonalGaussian(mlp=mlp, name='conditional') DCNL DCSP vae = DummyVAE() DCNL DCSP conditional.set_vae(vae) DCNL DCSP input_space = VectorSpace(dim=5) DCNL DCSP conditional.initialize_parameters(input_space=input_space, ndim=5) DCNL DCSP mu = T.matrix('mu') DCNL DCSP log_sigma = T.matrix('log_sigma') DCNL DCSP conditional.conditional_expectation([mu, log_sigma])
def libvlc_media_set_user_data(p_md, p_new_user_data): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_set_user_data', None) or _Cfunction('libvlc_media_set_user_data', ((1,), (1,)), None, None, Media, ctypes.c_void_p)) DCNL DCSP return f(p_md, p_new_user_data)
@requires_pyopengl() DCNL def test_import_vispy_pyopengl(): DCNL  DCSP allmodnames = loaded_vispy_modules('vispy.gloo.gl.pyopengl2', 2, True) DCNL DCSP assert_in('OpenGL', allmodnames)
def ComputeErrorRate(error_count, truth_count): DCNL  DCSP if (truth_count == 0): DCNL DCSP  DCSP truth_count = 1 DCNL DCSP  DCSP error_count = 1 DCNL DCSP elif (error_count > truth_count): DCNL DCSP  DCSP error_count = truth_count DCNL DCSP return ((error_count * 100.0) / truth_count)
def save_translations(key): DCNL  DCSP if (not hasattr(_to_save, 'translations')): DCNL DCSP  DCSP return DCNL DCSP for trans in _to_save.translations.get(key, []): DCNL DCSP  DCSP is_new = (trans.autoid is None) DCNL DCSP  DCSP trans.save(force_insert=is_new, force_update=(not is_new)) DCNL DCSP if (key in _to_save.translations): DCNL DCSP  DCSP del _to_save.translations[key]
def find_program_variables(code): DCNL  DCSP vars = {} DCNL DCSP lines = code.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP m = re.match((('\\s*' + re_prog_var_declaration) + '\\s*(=|;)'), line) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP (vtype, dtype, names) = m.groups()[:3] DCNL DCSP  DCSP  DCSP for name in names.split(','): DCNL DCSP  DCSP  DCSP  DCSP vars[name.strip()] = (vtype, dtype) DCNL DCSP return vars
@not_implemented_for('directed') DCNL def biconnected_component_edges(G): DCNL  DCSP for comp in _biconnected_dfs(G, components=True): DCNL DCSP  DCSP (yield comp)
def yule_walker(X, order=1, method='unbiased', df=None, inv=False, demean=True): DCNL  DCSP method = str(method).lower() DCNL DCSP if (method not in ['unbiased', 'mle']): DCNL DCSP  DCSP raise ValueError("ACF DCSP estimation DCSP method DCSP must DCSP be DCSP 'unbiased' DCSP or DCSP 'MLE'") DCNL DCSP X = np.array(X, dtype=np.float64) DCNL DCSP if demean: DCNL DCSP  DCSP X -= X.mean() DCNL DCSP n = (df or X.shape[0]) DCNL DCSP if (method == 'unbiased'): DCNL DCSP  DCSP denom = (lambda k: (n - k)) DCNL DCSP else: DCNL DCSP  DCSP denom = (lambda k: n) DCNL DCSP if ((X.ndim > 1) and (X.shape[1] != 1)): DCNL DCSP  DCSP raise ValueError('expecting DCSP a DCSP vector DCSP to DCSP estimate DCSP AR DCSP parameters') DCNL DCSP r = np.zeros((order + 1), np.float64) DCNL DCSP r[0] = ((X ** 2).sum() / denom(0)) DCNL DCSP for k in range(1, (order + 1)): DCNL DCSP  DCSP r[k] = ((X[0:(- k)] * X[k:]).sum() / denom(k)) DCNL DCSP R = toeplitz(r[:(-1)]) DCNL DCSP rho = np.linalg.solve(R, r[1:]) DCNL DCSP sigmasq = (r[0] - (r[1:] * rho).sum()) DCNL DCSP if (inv == True): DCNL DCSP  DCSP return (rho, np.sqrt(sigmasq), np.linalg.inv(R)) DCNL DCSP else: DCNL DCSP  DCSP return (rho, np.sqrt(sigmasq))
def set_logging(log_level, myfilename=None): DCNL  DCSP if (myfilename and ipython_version): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ipython_version.startswith('0.10'): DCNL DCSP  DCSP  DCSP  DCSP __IPYTHON__.set_custom_exc((Exception,), ipython_exception_handler) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ip = get_ipython() DCNL DCSP  DCSP  DCSP  DCSP ip.set_custom_exc((Exception,), ipython_exception_handler) DCNL DCSP  DCSP except NameError: DCNL DCSP  DCSP  DCSP sys.exc_clear() DCNL DCSP level = read_logging_level(log_level) DCNL DCSP if (level and myfilename): DCNL DCSP  DCSP fileHandler = logging.FileHandler(filename=myfilename) DCNL DCSP  DCSP fileHandler.setLevel(level) DCNL DCSP  DCSP fileHandler.setFormatter(formatter) DCNL DCSP  DCSP logger.addHandler(fileHandler) DCNL DCSP  DCSP logger.removeHandler(consoleHandler) DCNL DCSP  DCSP print 'Now DCSP logging DCSP to', myfilename, 'with DCSP level', log_level DCNL DCSP elif level: DCNL DCSP  DCSP print 'Now DCSP logging DCSP with DCSP level', log_level DCNL DCSP logger.setLevel(level)
def class_result(classname): DCNL  DCSP def wrap_errcheck(result, func, arguments): DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return classname(result) DCNL DCSP return wrap_errcheck
def create_private_key(path=None, text=False, bits=2048, passphrase=None, cipher='aes_128_cbc', verbose=True): DCNL  DCSP if ((not path) and (not text)): DCNL DCSP  DCSP raise salt.exceptions.SaltInvocationError('Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specified.') DCNL DCSP if (path and text): DCNL DCSP  DCSP raise salt.exceptions.SaltInvocationError('Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specified, DCSP not DCSP both.') DCNL DCSP if verbose: DCNL DCSP  DCSP _callback_func = M2Crypto.RSA.keygen_callback DCNL DCSP else: DCNL DCSP  DCSP _callback_func = _keygen_callback DCNL DCSP rsa = M2Crypto.RSA.gen_key(bits, M2Crypto.m2.RSA_F4, _callback_func) DCNL DCSP bio = M2Crypto.BIO.MemoryBuffer() DCNL DCSP if (passphrase is None): DCNL DCSP  DCSP cipher = None DCNL DCSP rsa.save_key_bio(bio, cipher=cipher, callback=_passphrase_callback(passphrase)) DCNL DCSP if path: DCNL DCSP  DCSP return write_pem(text=bio.read_all(), path=path, pem_type='RSA DCSP PRIVATE DCSP KEY') DCNL DCSP else: DCNL DCSP  DCSP return bio.read_all()
def tokenize(*args, **kwargs): DCNL  DCSP if kwargs: DCNL DCSP  DCSP args = (args + (kwargs,)) DCNL DCSP return md5(str(tuple(map(normalize_token, args))).encode()).hexdigest()
def compute_node_get(context, compute_id): DCNL  DCSP return IMPL.compute_node_get(context, compute_id)
def _makeGetterFactory(url, factoryFactory, contextFactory=None, *args, **kwargs): DCNL  DCSP uri = URI.fromBytes(url) DCNL DCSP factory = factoryFactory(url, *args, **kwargs) DCNL DCSP if (uri.scheme == 'https'): DCNL DCSP  DCSP from twisted.internet import ssl DCNL DCSP  DCSP if (contextFactory is None): DCNL DCSP  DCSP  DCSP contextFactory = ssl.ClientContextFactory() DCNL DCSP  DCSP reactor.connectSSL(nativeString(uri.host), uri.port, factory, contextFactory) DCNL DCSP else: DCNL DCSP  DCSP reactor.connectTCP(nativeString(uri.host), uri.port, factory) DCNL DCSP return factory
def import_site_function(path, module, funcname, dummy, modulefile=None): DCNL  DCSP return import_site_symbol(path, module, funcname, dummy, modulefile)
def get_route(ip): DCNL  DCSP if (__grains__['kernel'] == 'Linux'): DCNL DCSP  DCSP cmd = 'ip DCSP route DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmd.run'](cmd, python_shell=True) DCNL DCSP  DCSP regexp = re.compile('(via\\s+(?P<gateway>[\\w\\.:]+))?\\s+dev\\s+(?P<interface>[\\w\\.\\:]+)\\s+.*src\\s+(?P<source>[\\w\\.:]+)') DCNL DCSP  DCSP m = regexp.search(out.splitlines()[0]) DCNL DCSP  DCSP ret = {'destination': ip, 'gateway': m.group('gateway'), 'interface': m.group('interface'), 'source': m.group('source')} DCNL DCSP  DCSP return ret DCNL DCSP if (__grains__['kernel'] == 'SunOS'): DCNL DCSP  DCSP cmd = '/usr/sbin/route DCSP -n DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP  DCSP ret = {'destination': ip, 'gateway': None, 'interface': None, 'source': None} DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP line = line.split(':') DCNL DCSP  DCSP  DCSP if ('route DCSP to' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['destination'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('gateway' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['gateway'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('interface' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['interface'] = line[1].strip() DCNL DCSP  DCSP  DCSP  DCSP ret['source'] = salt.utils.network.interface_ip(line[1].strip()) DCNL DCSP  DCSP return ret DCNL DCSP if (__grains__['kernel'] == 'OpenBSD'): DCNL DCSP  DCSP cmd = 'route DCSP -n DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP  DCSP ret = {'destination': ip, 'gateway': None, 'interface': None, 'source': None} DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP line = line.split(':') DCNL DCSP  DCSP  DCSP if ('route DCSP to' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['destination'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('gateway' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['gateway'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('interface' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['interface'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('if DCSP address' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['source'] = line[1].strip() DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP raise CommandExecutionError('Not DCSP yet DCSP supported DCSP on DCSP this DCSP platform')
def mkstemp(suffix=None, prefix=None, dir=None, text=False): DCNL  DCSP (prefix, suffix, dir, output_type) = _sanitize_params(prefix, suffix, dir) DCNL DCSP if text: DCNL DCSP  DCSP flags = _text_openflags DCNL DCSP else: DCNL DCSP  DCSP flags = _bin_openflags DCNL DCSP return _mkstemp_inner(dir, prefix, suffix, flags, output_type)
def define_rate(name, description, unit_seconds=1, manager=counters): DCNL  DCSP counter = _RateCounter(name, description, unit_seconds) DCNL DCSP manager.register(counter) DCNL DCSP return counter
def mail_new_user(user): DCNL  DCSP current_site = Site.objects.get_current() DCNL DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP domain_method = siteconfig.get(u'site_domain_method') DCNL DCSP subject = (u'New DCSP Review DCSP Board DCSP user DCSP registration DCSP for DCSP %s' % user.username) DCNL DCSP from_email = build_email_address_for_user(user) DCNL DCSP context = {u'domain': current_site.domain, u'domain_method': domain_method, u'user': user, u'user_url': reverse(u'admin:auth_user_change', args=(user.id,))} DCNL DCSP text_message = render_to_string(u'notifications/new_user_email.txt', context) DCNL DCSP html_message = render_to_string(u'notifications/new_user_email.html', context) DCNL DCSP message = EmailMessage(subject=subject.strip(), text_body=text_message, html_body=html_message, from_email=settings.SERVER_EMAIL, sender=settings.SERVER_EMAIL, to=[build_email_address(full_name=admin[0], email=admin[1]) for admin in settings.ADMINS]) DCNL DCSP try: DCNL DCSP  DCSP message.send() DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(u"Error DCSP sending DCSP e-mail DCSP notification DCSP with DCSP subject DCSP '%s' DCSP on DCSP behalf DCSP of DCSP '%s' DCSP to DCSP admin: DCSP %s", subject.strip(), from_email, e, exc_info=1)
def review_request_closed_cb(sender, user, review_request, type, **kwargs): DCNL  DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP if siteconfig.get(u'mail_send_review_close_mail'): DCNL DCSP  DCSP mail_review_request(review_request, user, close_type=type)
def load_list_of_roles(ds, play, current_role_path=None, variable_manager=None, loader=None): DCNL  DCSP from ansible.playbook.role.include import RoleInclude DCNL DCSP assert isinstance(ds, list) DCNL DCSP roles = [] DCNL DCSP for role_def in ds: DCNL DCSP  DCSP i = RoleInclude.load(role_def, play=play, current_role_path=current_role_path, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP roles.append(i) DCNL DCSP return roles
def test_seed_diff(): DCNL  DCSP skip_if_no_scipy() DCNL DCSP rng = np.random.RandomState([1, 2, 3]) DCNL DCSP seed = (rng.randint(2147462579) - 1) DCNL DCSP dim = 3 DCNL DCSP mu = rng.randn(dim) DCNL DCSP rank = dim DCNL DCSP X = rng.randn(rank, dim) DCNL DCSP cov = np.dot(X.T, X) DCNL DCSP mnd1 = MND(sigma=cov, mu=mu, seed=seed) DCNL DCSP num_samples = 5 DCNL DCSP rd1 = mnd1.random_design_matrix(num_samples) DCNL DCSP rd1 = function([], rd1)() DCNL DCSP mnd2 = MND(sigma=cov, mu=mu, seed=(seed + 1)) DCNL DCSP rd2 = mnd2.random_design_matrix(num_samples) DCNL DCSP rd2 = function([], rd2)() DCNL DCSP assert np.any((rd1 != rd2))
def find_gwt_dir(): DCNL  DCSP site_gwt = os.path.join(_AUTOTEST_DIR, 'site-packages', 'gwt') DCNL DCSP if os.path.isdir(site_gwt): DCNL DCSP  DCSP return site_gwt DCNL DCSP if (not os.path.isdir(_DEFAULT_GWT_DIR)): DCNL DCSP  DCSP logging.error('Unable DCSP to DCSP find DCSP GWT. DCSP You DCSP can DCSP use DCSP utils/build_externals.py DCSP to DCSP install DCSP it.') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP return _DEFAULT_GWT_DIR
def filter_sff_file(flowgrams, header, filter_list, out_fh): DCNL  DCSP write_sff_header(header, out_fh) DCNL DCSP l = 0 DCNL DCSP for f in flowgrams: DCNL DCSP  DCSP passed = True DCNL DCSP  DCSP for filter in filter_list: DCNL DCSP  DCSP  DCSP passed = (passed and filter(f)) DCNL DCSP  DCSP  DCSP if (not passed): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if passed: DCNL DCSP  DCSP  DCSP out_fh.write((f.createFlowHeader() + '\n')) DCNL DCSP  DCSP  DCSP l += 1 DCNL DCSP return l
def _get_resource_id(resource, name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP _id = _cache_id(name, sub_resource=resource, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if _id: DCNL DCSP  DCSP return _id DCNL DCSP r = _get_resource(resource, name=name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if r: DCNL DCSP  DCSP return r.id
def apply_policy(policy, r, name, sub): DCNL  DCSP if isinstance(policy, (list, tuple)): DCNL DCSP  DCSP ret = '' DCNL DCSP  DCSP for sub_policy in policy: DCNL DCSP  DCSP  DCSP ret += sub_policy(r, name, sub) DCNL DCSP  DCSP return ret DCNL DCSP return policy(r, name, sub)
def FastaM10Iterator(handle, alphabet=single_letter_alphabet): DCNL  DCSP if (alphabet is None): DCNL DCSP  DCSP alphabet = single_letter_alphabet DCNL DCSP state_PREAMBLE = (-1) DCNL DCSP state_NONE = 0 DCNL DCSP state_QUERY_HEADER = 1 DCNL DCSP state_ALIGN_HEADER = 2 DCNL DCSP state_ALIGN_QUERY = 3 DCNL DCSP state_ALIGN_MATCH = 4 DCNL DCSP state_ALIGN_CONS = 5 DCNL DCSP def build_hsp(): DCNL DCSP  DCSP if ((not query_tags) and (not match_tags)): DCNL DCSP  DCSP  DCSP raise ValueError(('No DCSP data DCSP for DCSP query DCSP %r, DCSP match DCSP %r' % (query_id, match_id))) DCNL DCSP  DCSP assert query_tags, query_tags DCNL DCSP  DCSP assert match_tags, match_tags DCNL DCSP  DCSP evalue = align_tags.get('fa_expect') DCNL DCSP  DCSP q = '?' DCNL DCSP  DCSP m = '?' DCNL DCSP  DCSP tool = global_tags.get('tool', '').upper() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP q = _extract_alignment_region(query_seq, query_tags) DCNL DCSP  DCSP  DCSP if ((tool in ['TFASTX']) and (len(match_seq) == len(q))): DCNL DCSP  DCSP  DCSP  DCSP m = match_seq DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP m = _extract_alignment_region(match_seq, match_tags) DCNL DCSP  DCSP  DCSP assert (len(q) == len(m)) DCNL DCSP  DCSP except AssertionError as err: DCNL DCSP  DCSP  DCSP print('Darn... DCSP amino DCSP acids DCSP vs DCSP nucleotide DCSP coordinates?') DCNL DCSP  DCSP  DCSP print(tool) DCNL DCSP  DCSP  DCSP print(query_seq) DCNL DCSP  DCSP  DCSP print(query_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (q, len(q)))) DCNL DCSP  DCSP  DCSP print(match_seq) DCNL DCSP  DCSP  DCSP print(match_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (m, len(m)))) DCNL DCSP  DCSP  DCSP print(handle.name) DCNL DCSP  DCSP  DCSP raise err DCNL DCSP  DCSP assert (alphabet is not None) DCNL DCSP  DCSP alignment = MultipleSeqAlignment([], alphabet) DCNL DCSP  DCSP alignment._annotations = {} DCNL DCSP  DCSP for (key, value) in header_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP for (key, value) in align_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP record = SeqRecord(Seq(q, alphabet), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])}) DCNL DCSP  DCSP record._al_start = int(query_tags['al_start']) DCNL DCSP  DCSP record._al_stop = int(query_tags['al_stop']) DCNL DCSP  DCSP alignment.append(record) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) and ('sq_type' in query_tags)): DCNL DCSP  DCSP  DCSP if (query_tags['sq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_dna DCNL DCSP  DCSP  DCSP elif (query_tags['sq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in q): DCNL DCSP  DCSP  DCSP if (not hasattr(record.seq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = Gapped(record.seq.alphabet, '-') DCNL DCSP  DCSP record = SeqRecord(Seq(m, alphabet), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])}) DCNL DCSP  DCSP record._al_start = int(match_tags['al_start']) DCNL DCSP  DCSP record._al_stop = int(match_tags['al_stop']) DCNL DCSP  DCSP alignment.append(record) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) and ('sq_type' in match_tags)): DCNL DCSP  DCSP  DCSP if (match_tags['sq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_dna DCNL DCSP  DCSP  DCSP elif (match_tags['sq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in m): DCNL DCSP  DCSP  DCSP if (not hasattr(record.seq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = Gapped(record.seq.alphabet, '-') DCNL DCSP  DCSP return alignment DCNL DCSP state = state_PREAMBLE DCNL DCSP query_id = None DCNL DCSP match_id = None DCNL DCSP query_descr = '' DCNL DCSP match_descr = '' DCNL DCSP global_tags = {} DCNL DCSP header_tags = {} DCNL DCSP align_tags = {} DCNL DCSP query_tags = {} DCNL DCSP match_tags = {} DCNL DCSP query_seq = '' DCNL DCSP match_seq = '' DCNL DCSP cons_seq = '' DCNL DCSP for line in handle: DCNL DCSP  DCSP if (('>>>' in line) and (not line.startswith('>>>'))): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP query_descr = line[(line.find('>>>') + 3):].strip() DCNL DCSP  DCSP  DCSP query_id = query_descr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP match_id = None DCNL DCSP  DCSP  DCSP header_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP elif line.startswith('!! DCSP No DCSP '): DCNL DCSP  DCSP  DCSP assert (state == state_NONE) DCNL DCSP  DCSP  DCSP assert (not header_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not query_tags) DCNL DCSP  DCSP  DCSP assert (match_id is None) DCNL DCSP  DCSP  DCSP assert (not query_seq) DCNL DCSP  DCSP  DCSP assert (not match_seq) DCNL DCSP  DCSP  DCSP assert (not cons_seq) DCNL DCSP  DCSP  DCSP query_id = None DCNL DCSP  DCSP elif (line.strip() in ['>>><<<', '>>>///']): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP query_id = None DCNL DCSP  DCSP  DCSP match_id = None DCNL DCSP  DCSP  DCSP header_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP elif line.startswith('>>>'): DCNL DCSP  DCSP  DCSP assert (query_id is not None) DCNL DCSP  DCSP  DCSP assert (line[3:].split(', DCSP ', 1)[0] == query_id), line DCNL DCSP  DCSP  DCSP assert (match_id is None) DCNL DCSP  DCSP  DCSP assert (not header_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not query_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not match_seq) DCNL DCSP  DCSP  DCSP assert (not query_seq) DCNL DCSP  DCSP  DCSP assert (not cons_seq) DCNL DCSP  DCSP  DCSP state = state_QUERY_HEADER DCNL DCSP  DCSP elif line.startswith('>>'): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP  DCSP match_descr = line[2:].strip() DCNL DCSP  DCSP  DCSP match_id = match_descr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>--'): DCNL DCSP  DCSP  DCSP assert (query_id and match_id), line DCNL DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>'): DCNL DCSP  DCSP  DCSP if (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP assert (query_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert query_id.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_QUERY DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP assert (query_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert match_id.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_MATCH DCNL DCSP  DCSP  DCSP elif (state == state_NONE): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('state DCSP %i DCSP got DCSP %r' % (state, line)) DCNL DCSP  DCSP elif line.startswith('; DCSP al_cons'): DCNL DCSP  DCSP  DCSP assert (state == state_ALIGN_MATCH), line DCNL DCSP  DCSP  DCSP state = state_ALIGN_CONS DCNL DCSP  DCSP elif line.startswith('; DCSP '): DCNL DCSP  DCSP  DCSP if (': DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(': DCSP ', 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(('Missing DCSP colon DCSP in DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(' DCSP ', 1)] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Bad DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP if (state == state_QUERY_HEADER): DCNL DCSP  DCSP  DCSP  DCSP header_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP align_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP query_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP  DCSP match_tags[key] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('Unexpected DCSP state DCSP %r, DCSP %r' % (state, line)) DCNL DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP query_seq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP match_seq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_CONS): DCNL DCSP  DCSP  DCSP cons_seq += line.strip('\n') DCNL DCSP  DCSP elif (state == state_PREAMBLE): DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP global_tags['command'] = line[1:].strip() DCNL DCSP  DCSP  DCSP elif line.startswith(' DCSP version DCSP '): DCNL DCSP  DCSP  DCSP  DCSP global_tags['version'] = line[9:].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP compares DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.find(' DCSP compares DCSP a DCSP ')].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP searches DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.find(' DCSP searches DCSP a DCSP ')].strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass
def determine_format(request, serializer, default_format=u'application/json'): DCNL  DCSP if request.GET.get(u'format'): DCNL DCSP  DCSP if (request.GET[u'format'] in serializer.formats): DCNL DCSP  DCSP  DCSP return serializer.get_mime_for_format(request.GET[u'format']) DCNL DCSP if (u'callback' in request.GET): DCNL DCSP  DCSP return serializer.get_mime_for_format(u'jsonp') DCNL DCSP if (request.META.get(u'HTTP_ACCEPT', u'*/*') != u'*/*'): DCNL DCSP  DCSP formats = (list(serializer.supported_formats) or []) DCNL DCSP  DCSP formats.reverse() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP best_format = mimeparse.best_match(formats, request.META[u'HTTP_ACCEPT']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise BadRequest(u'Invalid DCSP Accept DCSP header') DCNL DCSP  DCSP if best_format: DCNL DCSP  DCSP  DCSP return best_format DCNL DCSP return default_format
def _indent(s, indent=4): DCNL  DCSP if isinstance(s, unicode): DCNL DCSP  DCSP s = s.encode(_encoding, 'backslashreplace') DCNL DCSP return re.sub('(?m)^(?!$)', (indent * ' DCSP '), s)
def _StrictParseLogEntry(entry, clean_message=True): DCNL  DCSP (magic, level, timestamp, message) = entry.split(' DCSP ', 3) DCNL DCSP if (magic != 'LOG'): DCNL DCSP  DCSP raise ValueError() DCNL DCSP (timestamp, level) = (int(timestamp), int(level)) DCNL DCSP if (level not in LOG_LEVELS): DCNL DCSP  DCSP raise ValueError() DCNL DCSP return (timestamp, level, _Clean(message), (None if clean_message else message))
def remove_arrays(code, count=1): DCNL  DCSP res = '' DCNL DCSP last = '' DCNL DCSP replacements = {} DCNL DCSP for e in bracket_split(code, ['[]']): DCNL DCSP  DCSP if (e[0] == '['): DCNL DCSP  DCSP  DCSP if is_array(last): DCNL DCSP  DCSP  DCSP  DCSP name = (ARRAY_LVAL % count) DCNL DCSP  DCSP  DCSP  DCSP res += (' DCSP ' + name) DCNL DCSP  DCSP  DCSP  DCSP replacements[name] = e DCNL DCSP  DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (cand, new_replacements, count) = remove_arrays(e[1:(-1)], count) DCNL DCSP  DCSP  DCSP  DCSP res += ('[%s]' % cand) DCNL DCSP  DCSP  DCSP  DCSP replacements.update(new_replacements) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res += e DCNL DCSP  DCSP last = e DCNL DCSP return (res, replacements, count)
def _toCSSname(DOMname): DCNL  DCSP def _doDOMtoCSSname2(m): DCNL DCSP  DCSP return ('-' + m.group(0).lower()) DCNL DCSP return _reDOMtoCSSname.sub(_doDOMtoCSSname2, DOMname)
def plot_decision(features, labels): DCNL  DCSP (y0, y1) = ((features[:, 2].min() * 0.9), (features[:, 2].max() * 1.1)) DCNL DCSP (x0, x1) = ((features[:, 0].min() * 0.9), (features[:, 0].max() * 1.1)) DCNL DCSP X = np.linspace(x0, x1, 100) DCNL DCSP Y = np.linspace(y0, y1, 100) DCNL DCSP (X, Y) = np.meshgrid(X, Y) DCNL DCSP model = fit_model(1, features[:, (0, 2)], np.array(labels)) DCNL DCSP C = predict(model, np.vstack([X.ravel(), Y.ravel()]).T).reshape(X.shape) DCNL DCSP if COLOUR_FIGURE: DCNL DCSP  DCSP cmap = ListedColormap([(1.0, 0.6, 0.6), (0.6, 1.0, 0.6), (0.6, 0.6, 1.0)]) DCNL DCSP else: DCNL DCSP  DCSP cmap = ListedColormap([(1.0, 1.0, 1.0), (0.2, 0.2, 0.2), (0.6, 0.6, 0.6)]) DCNL DCSP (fig, ax) = plt.subplots() DCNL DCSP ax.set_xlim(x0, x1) DCNL DCSP ax.set_ylim(y0, y1) DCNL DCSP ax.set_xlabel(feature_names[0]) DCNL DCSP ax.set_ylabel(feature_names[2]) DCNL DCSP ax.pcolormesh(X, Y, C, cmap=cmap) DCNL DCSP if COLOUR_FIGURE: DCNL DCSP  DCSP cmap = ListedColormap([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]) DCNL DCSP  DCSP ax.scatter(features[:, 0], features[:, 2], c=labels, cmap=cmap) DCNL DCSP else: DCNL DCSP  DCSP for (lab, ma) in zip(range(3), 'Do^'): DCNL DCSP  DCSP  DCSP ax.plot(features[((labels == lab), 0)], features[((labels == lab), 2)], ma, c=(1.0, 1.0, 1.0)) DCNL DCSP return (fig, ax)
def run(*commands, **kwargs): DCNL  DCSP environment = os.environ.copy() DCNL DCSP environment['READTHEDOCS'] = 'True' DCNL DCSP if ('DJANGO_SETTINGS_MODULE' in environment): DCNL DCSP  DCSP del environment['DJANGO_SETTINGS_MODULE'] DCNL DCSP if ('PYTHONPATH' in environment): DCNL DCSP  DCSP del environment['PYTHONPATH'] DCNL DCSP if ('PYTHONHOME' in environment): DCNL DCSP  DCSP del environment['PYTHONHOME'] DCNL DCSP cwd = os.getcwd() DCNL DCSP if (not commands): DCNL DCSP  DCSP raise ValueError('run() DCSP requires DCSP one DCSP or DCSP more DCSP command-line DCSP strings') DCNL DCSP shell = kwargs.get('shell', False) DCNL DCSP for command in commands: DCNL DCSP  DCSP if shell: DCNL DCSP  DCSP  DCSP log.info('Running DCSP commands DCSP in DCSP a DCSP shell') DCNL DCSP  DCSP  DCSP run_command = command DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP run_command = command.split() DCNL DCSP  DCSP log.info("Running: DCSP '%s' DCSP [%s]", command, cwd) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP p = subprocess.Popen(run_command, shell=shell, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=environment) DCNL DCSP  DCSP  DCSP (out, err) = p.communicate() DCNL DCSP  DCSP  DCSP ret = p.returncode DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP out = '' DCNL DCSP  DCSP  DCSP err = traceback.format_exc() DCNL DCSP  DCSP  DCSP ret = (-1) DCNL DCSP  DCSP  DCSP log.error('Command DCSP failed', exc_info=True) DCNL DCSP return (ret, out, err)
def _FormatFirstToken(first_token, indent_depth, prev_uwline, final_lines): DCNL  DCSP first_token.AddWhitespacePrefix(_CalculateNumberOfNewlines(first_token, indent_depth, prev_uwline, final_lines), indent_level=indent_depth)
def fragment6(pkt, fragSize): DCNL  DCSP pkt = pkt.copy() DCNL DCSP s = str(pkt) DCNL DCSP if (len(s) <= fragSize): DCNL DCSP  DCSP return [pkt] DCNL DCSP if (not (IPv6ExtHdrFragment in pkt)): DCNL DCSP  DCSP return [pkt] DCNL DCSP fragPart = pkt[IPv6ExtHdrFragment].payload DCNL DCSP tmp = str((IPv6(src='::1', dst='::1') / fragPart)) DCNL DCSP fragPartLen = (len(tmp) - 40) DCNL DCSP fragPartStr = s[(- fragPartLen):] DCNL DCSP nh = IPv6(tmp[:40]).nh DCNL DCSP fragHeader = pkt[IPv6ExtHdrFragment] DCNL DCSP fragHeader.payload = None DCNL DCSP unfragPartLen = ((len(s) - fragPartLen) - 8) DCNL DCSP unfragPart = pkt DCNL DCSP pkt[IPv6ExtHdrFragment].underlayer.payload = None DCNL DCSP lastFragSize = ((fragSize - unfragPartLen) - 8) DCNL DCSP innerFragSize = (lastFragSize - (lastFragSize % 8)) DCNL DCSP if ((lastFragSize <= 0) or (innerFragSize == 0)): DCNL DCSP  DCSP warning(('Provided DCSP fragment DCSP size DCSP value DCSP is DCSP too DCSP low. DCSP ' + ('Should DCSP be DCSP more DCSP than DCSP %d' % (unfragPartLen + 8)))) DCNL DCSP  DCSP return [((unfragPart / fragHeader) / fragPart)] DCNL DCSP remain = fragPartStr DCNL DCSP res = [] DCNL DCSP fragOffset = 0 DCNL DCSP fragId = random.randint(0, 4294967295) DCNL DCSP if (fragHeader.id is not None): DCNL DCSP  DCSP fragId = fragHeader.id DCNL DCSP fragHeader.m = 1 DCNL DCSP fragHeader.id = fragId DCNL DCSP fragHeader.nh = nh DCNL DCSP while True: DCNL DCSP  DCSP if (len(remain) > lastFragSize): DCNL DCSP  DCSP  DCSP tmp = remain[:innerFragSize] DCNL DCSP  DCSP  DCSP remain = remain[innerFragSize:] DCNL DCSP  DCSP  DCSP fragHeader.offset = fragOffset DCNL DCSP  DCSP  DCSP fragOffset += (innerFragSize / 8) DCNL DCSP  DCSP  DCSP if (IPv6 in unfragPart): DCNL DCSP  DCSP  DCSP  DCSP unfragPart[IPv6].plen = None DCNL DCSP  DCSP  DCSP tempo = ((unfragPart / fragHeader) / Raw(load=tmp)) DCNL DCSP  DCSP  DCSP res.append(tempo) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fragHeader.offset = fragOffset DCNL DCSP  DCSP  DCSP fragHeader.m = 0 DCNL DCSP  DCSP  DCSP if (IPv6 in unfragPart): DCNL DCSP  DCSP  DCSP  DCSP unfragPart[IPv6].plen = None DCNL DCSP  DCSP  DCSP tempo = ((unfragPart / fragHeader) / Raw(load=remain)) DCNL DCSP  DCSP  DCSP res.append(tempo) DCNL DCSP  DCSP  DCSP break DCNL DCSP return res
def to_seconds(time_string): DCNL  DCSP elts = time_string.split(':') DCNL DCSP if (len(elts) == 1): DCNL DCSP  DCSP return time_string DCNL DCSP return str(((int(elts[0]) * 60) + float(elts[1])))
def split_string(text, chars_per_string): DCNL  DCSP return [text[i:(i + chars_per_string)] for i in range(0, len(text), chars_per_string)]
def getTempMarkdownPreviewPath(view): DCNL  DCSP settings = sublime.load_settings('MarkdownPreview.sublime-settings') DCNL DCSP tmp_filename = ('%s.html' % view.id()) DCNL DCSP tmp_dir = tempfile.gettempdir() DCNL DCSP if settings.get('path_tempfile'): DCNL DCSP  DCSP if os.path.isabs(settings.get('path_tempfile')): DCNL DCSP  DCSP  DCSP tmp_dir = settings.get('path_tempfile') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp_dir = os.path.join(os.path.dirname(view.file_name()), settings.get('path_tempfile')) DCNL DCSP if (not os.path.isdir(tmp_dir)): DCNL DCSP  DCSP os.makedirs(tmp_dir) DCNL DCSP tmp_fullpath = os.path.join(tmp_dir, tmp_filename) DCNL DCSP return tmp_fullpath
def timestampUUID60(value): DCNL  DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP or DCSP float DCSP is DCSP required') DCNL DCSP if (value < 0): DCNL DCSP  DCSP raise ValueError('value DCSP have DCSP to DCSP be DCSP a DCSP positive DCSP or DCSP nul DCSP integer') DCNL DCSP try: DCNL DCSP  DCSP return (UUID60_TIMESTAMP_T0 + timedelta(microseconds=(value / 10))) DCNL DCSP except OverflowError: DCNL DCSP  DCSP raise ValueError((_('timestampUUID60() DCSP overflow DCSP (value=%s)') % value))
def svm_read_problem(data_file_name): DCNL  DCSP prob_y = [] DCNL DCSP prob_x = [] DCNL DCSP for line in open(data_file_name): DCNL DCSP  DCSP line = line.split(None, 1) DCNL DCSP  DCSP if (len(line) == 1): DCNL DCSP  DCSP  DCSP line += [''] DCNL DCSP  DCSP (label, features) = line DCNL DCSP  DCSP xi = {} DCNL DCSP  DCSP for e in features.split(): DCNL DCSP  DCSP  DCSP (ind, val) = e.split(':') DCNL DCSP  DCSP  DCSP xi[int(ind)] = float(val) DCNL DCSP  DCSP prob_y += [float(label)] DCNL DCSP  DCSP prob_x += [xi] DCNL DCSP return (prob_y, prob_x)
def boto_supports_associate_public_ip_address(ec2): DCNL  DCSP try: DCNL DCSP  DCSP network_interface = boto.ec2.networkinterface.NetworkInterfaceSpecification() DCNL DCSP  DCSP getattr(network_interface, 'associate_public_ip_address') DCNL DCSP  DCSP return True DCNL DCSP except AttributeError: DCNL DCSP  DCSP return False
def read_config_file(option, opt, value, parser): DCNL  DCSP try: DCNL DCSP  DCSP new_settings = parser.get_config_file_settings(value) DCNL DCSP except ValueError as error: DCNL DCSP  DCSP parser.error(error) DCNL DCSP parser.values.update(new_settings, parser)
def get_suffixes(): DCNL  DCSP extensions = [(s, 'rb', C_EXTENSION) for s in machinery.EXTENSION_SUFFIXES] DCNL DCSP source = [(s, 'r', PY_SOURCE) for s in machinery.SOURCE_SUFFIXES] DCNL DCSP bytecode = [(s, 'rb', PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES] DCNL DCSP return ((extensions + source) + bytecode)
@register.filter DCNL def xssafe(value): DCNL  DCSP return jinja2.Markup(value)
def get_configured_provider(): DCNL  DCSP return config.is_provider_configured(__opts__, (__active_provider_name__ or __virtualname__), ('user', 'tenant', 'identity_url', 'compute_region'))
def delete_instance_profile(name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not instance_profile_exists(name, region, key, keyid, profile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP conn.delete_instance_profile(name) DCNL DCSP  DCSP log.info('Deleted DCSP {0} DCSP instance DCSP profile.'.format(name)) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP delete DCSP {0} DCSP instance DCSP profile.' DCNL DCSP  DCSP log.error(msg.format(name)) DCNL DCSP  DCSP return False DCNL DCSP return True
def version(raises=True): DCNL  DCSP if (not dnn_present()): DCNL DCSP  DCSP if raises: DCNL DCSP  DCSP  DCSP raise RuntimeError("We DCSP can't DCSP determine DCSP the DCSP cudnn DCSP version DCSP as DCSP it DCSP is DCSP not DCSP available", dnn_available.msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP if (version.v is None): DCNL DCSP  DCSP f = theano.function([], DnnVersion()(), theano.Mode(optimizer=None), profile=False) DCNL DCSP  DCSP v = f() DCNL DCSP  DCSP if (v[0] != v[1]): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Mixed DCSP dnn DCSP version. DCSP The DCSP header DCSP is DCSP version DCSP %s DCSP while DCSP the DCSP library DCSP is DCSP version DCSP %s.' % v)) DCNL DCSP  DCSP version.v = v[1] DCNL DCSP return version.v
def get_pymodule_path(modulename, *joins): DCNL  DCSP if (not (u'public' in joins)): DCNL DCSP  DCSP joins = [scrub(part) for part in joins] DCNL DCSP return os.path.join(os.path.dirname(get_module(scrub(modulename)).__file__), *joins)
def iter_first(sequence): DCNL  DCSP it = iter(sequence) DCNL DCSP try: DCNL DCSP  DCSP return next(it) DCNL DCSP except StopIteration: DCNL DCSP  DCSP raise ValueError()
def _CalculateNumberOfNewlines(first_token, indent_depth, prev_uwline, final_lines): DCNL  DCSP if (prev_uwline is None): DCNL DCSP  DCSP if (first_token.newlines is not None): DCNL DCSP  DCSP  DCSP pytree_utils.SetNodeAnnotation(first_token.node, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP return 0 DCNL DCSP if first_token.is_docstring: DCNL DCSP  DCSP return NO_BLANK_LINES DCNL DCSP prev_last_token = prev_uwline.last DCNL DCSP if prev_last_token.is_docstring: DCNL DCSP  DCSP if ((not indent_depth) and (first_token.value in {u'class', u'def', u'async'})): DCNL DCSP  DCSP  DCSP return TWO_BLANK_LINES DCNL DCSP  DCSP if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token, prev_last_token): DCNL DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ONE_BLANK_LINE DCNL DCSP if (first_token.value in {u'class', u'def', u'async', u'@'}): DCNL DCSP  DCSP if (not indent_depth): DCNL DCSP  DCSP  DCSP is_inline_comment = (prev_last_token.whitespace_prefix.count(u'\n') == 0) DCNL DCSP  DCSP  DCSP if ((not prev_uwline.disable) and prev_last_token.is_comment and (not is_inline_comment)): DCNL DCSP  DCSP  DCSP  DCSP if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token, prev_last_token): DCNL DCSP  DCSP  DCSP  DCSP  DCSP index = (len(final_lines) - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (index > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not final_lines[(index - 1)].is_comment): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP index -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (final_lines[(index - 1)].first.value == u'@'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP final_lines[index].first.AdjustNewlinesBefore(NO_BLANK_LINES) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prev_last_token.AdjustNewlinesBefore(TWO_BLANK_LINES) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (first_token.newlines is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pytree_utils.SetNodeAnnotation(first_token.node, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP  DCSP elif (prev_uwline.first.value in {u'class', u'def', u'async'}): DCNL DCSP  DCSP  DCSP if (not style.Get(u'BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF')): DCNL DCSP  DCSP  DCSP  DCSP pytree_utils.SetNodeAnnotation(first_token.node, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP if first_token.is_comment: DCNL DCSP  DCSP first_token_lineno = (first_token.lineno - first_token.value.count(u'\n')) DCNL DCSP else: DCNL DCSP  DCSP first_token_lineno = first_token.lineno DCNL DCSP prev_last_token_lineno = prev_last_token.lineno DCNL DCSP if prev_last_token.is_multiline_string: DCNL DCSP  DCSP prev_last_token_lineno += prev_last_token.value.count(u'\n') DCNL DCSP if ((first_token_lineno - prev_last_token_lineno) > 1): DCNL DCSP  DCSP return ONE_BLANK_LINE DCNL DCSP return NO_BLANK_LINES
def _salt(fun, *args, **kw): DCNL  DCSP try: DCNL DCSP  DCSP poll = kw.pop('salt_job_poll') DCNL DCSP except KeyError: DCNL DCSP  DCSP poll = 0.1 DCNL DCSP try: DCNL DCSP  DCSP target = kw.pop('salt_target') DCNL DCSP except KeyError: DCNL DCSP  DCSP target = None DCNL DCSP try: DCNL DCSP  DCSP timeout = int(kw.pop('salt_timeout')) DCNL DCSP except (KeyError, ValueError): DCNL DCSP  DCSP timeout = __FUN_TIMEOUT.get(fun, 900) DCNL DCSP try: DCNL DCSP  DCSP kwargs = kw.pop('kwargs') DCNL DCSP except KeyError: DCNL DCSP  DCSP kwargs = {} DCNL DCSP if (not target): DCNL DCSP  DCSP infos = get_configured_provider() DCNL DCSP  DCSP if (not infos): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP target = infos['target'] DCNL DCSP laps = time.time() DCNL DCSP cache = False DCNL DCSP if (fun in __CACHED_FUNS): DCNL DCSP  DCSP cache = True DCNL DCSP  DCSP laps = (laps // __CACHED_FUNS[fun]) DCNL DCSP try: DCNL DCSP  DCSP sargs = json.dumps(args) DCNL DCSP except TypeError: DCNL DCSP  DCSP sargs = '' DCNL DCSP try: DCNL DCSP  DCSP skw = json.dumps(kw) DCNL DCSP except TypeError: DCNL DCSP  DCSP skw = '' DCNL DCSP try: DCNL DCSP  DCSP skwargs = json.dumps(kwargs) DCNL DCSP except TypeError: DCNL DCSP  DCSP skwargs = '' DCNL DCSP cache_key = (laps, target, fun, sargs, skw, skwargs) DCNL DCSP if ((not cache) or (cache and (cache_key not in __CACHED_CALLS))): DCNL DCSP  DCSP conn = _client() DCNL DCSP  DCSP runner = _runner() DCNL DCSP  DCSP rkwargs = kwargs.copy() DCNL DCSP  DCSP rkwargs['timeout'] = timeout DCNL DCSP  DCSP rkwargs.setdefault('tgt_type', 'list') DCNL DCSP  DCSP kwargs.setdefault('tgt_type', 'list') DCNL DCSP  DCSP ping_retries = 0 DCNL DCSP  DCSP ping_max_retries = 60 DCNL DCSP  DCSP ping = True DCNL DCSP  DCSP if (fun == 'test.ping'): DCNL DCSP  DCSP  DCSP ping_retries = (ping_max_retries + 1) DCNL DCSP  DCSP while (ping_retries <= ping_max_retries): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (ping_retries > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP pings = conn.cmd(tgt=target, timeout=10, fun='test.ping') DCNL DCSP  DCSP  DCSP  DCSP values = list(pings.values()) DCNL DCSP  DCSP  DCSP  DCSP if (not values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP for v in values: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (v is not True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP if (not ping): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Unreachable') DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP ping_retries += 1 DCNL DCSP  DCSP  DCSP  DCSP log.error('{0} DCSP unreachable, DCSP retrying'.format(target)) DCNL DCSP  DCSP if (not ping): DCNL DCSP  DCSP  DCSP raise SaltCloudSystemExit('Target DCSP {0} DCSP unreachable'.format(target)) DCNL DCSP  DCSP jid = conn.cmd_async(tgt=target, fun=fun, arg=args, kwarg=kw, **rkwargs) DCNL DCSP  DCSP cret = conn.cmd(tgt=target, fun='saltutil.find_job', arg=[jid], timeout=10, **kwargs) DCNL DCSP  DCSP running = bool(cret.get(target, False)) DCNL DCSP  DCSP endto = (time.time() + timeout) DCNL DCSP  DCSP while running: DCNL DCSP  DCSP  DCSP rkwargs = {'tgt': target, 'fun': 'saltutil.find_job', 'arg': [jid], 'timeout': 10} DCNL DCSP  DCSP  DCSP cret = conn.cmd(**rkwargs) DCNL DCSP  DCSP  DCSP running = bool(cret.get(target, False)) DCNL DCSP  DCSP  DCSP if (not running): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (running and (time.time() > endto)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Timeout DCSP {0}s DCSP for DCSP {1} DCSP is DCSP elapsed'.format(timeout, pformat(rkwargs))) DCNL DCSP  DCSP  DCSP time.sleep(poll) DCNL DCSP  DCSP wait_for_res = float({'test.ping': '5'}.get(fun, '120')) DCNL DCSP  DCSP while wait_for_res: DCNL DCSP  DCSP  DCSP wait_for_res -= 0.5 DCNL DCSP  DCSP  DCSP cret = runner.cmd('jobs.lookup_jid', [jid, {'__kwarg__': True}]) DCNL DCSP  DCSP  DCSP if (target in cret): DCNL DCSP  DCSP  DCSP  DCSP ret = cret[target] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (('data' in cret) and ('outputter' in cret)): DCNL DCSP  DCSP  DCSP  DCSP ret = cret['data'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((fun in ['test.ping']) and (not wait_for_res)): DCNL DCSP  DCSP  DCSP  DCSP ret = {'test.ping': False}.get(fun, False) DCNL DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ('is DCSP not DCSP available.' in ret): DCNL DCSP  DCSP  DCSP  DCSP raise SaltCloudSystemExit('module/function DCSP {0} DCSP is DCSP not DCSP available'.format(fun)) DCNL DCSP  DCSP except SaltCloudSystemExit: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if cache: DCNL DCSP  DCSP  DCSP __CACHED_CALLS[cache_key] = ret DCNL DCSP elif (cache and (cache_key in __CACHED_CALLS)): DCNL DCSP  DCSP ret = __CACHED_CALLS[cache_key] DCNL DCSP return ret
def get_configured_hadoop_version(): DCNL  DCSP return hadoopcli().version.lower()
def _replace_conditional(match, string): DCNL  DCSP conditional_match = _CONDITIONAL.search(string) DCNL DCSP while conditional_match: DCNL DCSP  DCSP start = conditional_match.start() DCNL DCSP  DCSP end = _find_closing_brace(string, (start + 4)) DCNL DCSP  DCSP args = _split_conditional(string[(start + 4):(end - 1)]) DCNL DCSP  DCSP rv = '' DCNL DCSP  DCSP if match.group(int(conditional_match.group(1))): DCNL DCSP  DCSP  DCSP rv = unescape(_replace_conditional(match, args[0])) DCNL DCSP  DCSP elif (len(args) > 1): DCNL DCSP  DCSP  DCSP rv = unescape(_replace_conditional(match, args[1])) DCNL DCSP  DCSP string = ((string[:start] + rv) + string[end:]) DCNL DCSP  DCSP conditional_match = _CONDITIONAL.search(string) DCNL DCSP return string
def find_sr_by_uuid(session, sr_uuid): DCNL  DCSP try: DCNL DCSP  DCSP return session.call_xenapi('SR.get_by_uuid', sr_uuid) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP if (exc.details[0] == 'UUID_INVALID'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP raise
def read_xml_config(xml_config_file, svc_params, optional_params): DCNL  DCSP if (not os.access(xml_config_file, os.R_OK)): DCNL DCSP  DCSP msg = (_("Can't DCSP find DCSP HNAS DCSP configurations DCSP on DCSP cinder.conf DCSP neither DCSP on DCSP the DCSP path DCSP %(xml)s.") % {'xml': xml_config_file}) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFound(message=msg) DCNL DCSP else: DCNL DCSP  DCSP LOG.warning(_LW('This DCSP XML DCSP configuration DCSP file DCSP %(xml)s DCSP is DCSP deprecated. DCSP Please, DCSP move DCSP all DCSP the DCSP configurations DCSP to DCSP the DCSP cinder.conf DCSP file. DCSP If DCSP you DCSP keep DCSP both DCSP configuration DCSP files, DCSP the DCSP options DCSP set DCSP on DCSP cinder.conf DCSP will DCSP be DCSP used.'), {'xml': xml_config_file}) DCNL DCSP try: DCNL DCSP  DCSP root = ETree.parse(xml_config_file).getroot() DCNL DCSP except ETree.ParseError: DCNL DCSP  DCSP msg = (_('Error DCSP parsing DCSP config DCSP file: DCSP %(xml_config_file)s') % {'xml_config_file': xml_config_file}) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFound(message=msg) DCNL DCSP config = {} DCNL DCSP arg_prereqs = ['mgmt_ip0', 'username'] DCNL DCSP for req in arg_prereqs: DCNL DCSP  DCSP config[req] = _xml_read(root, req, 'check') DCNL DCSP for req in optional_params: DCNL DCSP  DCSP config[req] = _xml_read(root, req) DCNL DCSP  DCSP if ((config[req] is None) and (HNAS_DEFAULT_CONFIG.get(req) is not None)): DCNL DCSP  DCSP  DCSP config[req] = HNAS_DEFAULT_CONFIG.get(req) DCNL DCSP config['ssh_private_key'] = _xml_read(root, 'ssh_private_key') DCNL DCSP config['password'] = _xml_read(root, 'password') DCNL DCSP if ((config['ssh_private_key'] is None) and (config['password'] is None)): DCNL DCSP  DCSP msg = _('Missing DCSP authentication DCSP option DCSP (passw DCSP or DCSP private DCSP key DCSP file).') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFound(message=msg) DCNL DCSP if (_xml_read(root, 'ssh_port') is not None): DCNL DCSP  DCSP config['ssh_port'] = int(_xml_read(root, 'ssh_port')) DCNL DCSP else: DCNL DCSP  DCSP config['ssh_port'] = HNAS_DEFAULT_CONFIG['ssh_port'] DCNL DCSP config['fs'] = {} DCNL DCSP config['services'] = {} DCNL DCSP for svc in ['svc_0', 'svc_1', 'svc_2', 'svc_3']: DCNL DCSP  DCSP if (_xml_read(root, svc) is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP service = {'label': svc} DCNL DCSP  DCSP for arg in svc_params: DCNL DCSP  DCSP  DCSP service[arg] = _xml_read(root, ((svc + '/') + arg), 'check') DCNL DCSP  DCSP service.setdefault('pool_name', service.pop('volume_type', None)) DCNL DCSP  DCSP config['services'][service['pool_name']] = service DCNL DCSP  DCSP config['fs'][service['hdp']] = service['hdp'] DCNL DCSP if (not config['services'].keys()): DCNL DCSP  DCSP LOG.error(_LE('No DCSP service DCSP found DCSP in DCSP xml DCSP config DCSP file')) DCNL DCSP  DCSP raise exception.ParameterNotFound(param='svc_0') DCNL DCSP return config
def colorize(text='', opts=(), **kwargs): DCNL  DCSP color_names = ('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white') DCNL DCSP foreground = dict([(color_names[x], ('3%s' % x)) for x in range(8)]) DCNL DCSP background = dict([(color_names[x], ('4%s' % x)) for x in range(8)]) DCNL DCSP RESET = '0' DCNL DCSP opt_dict = {'bold': '1', 'underscore': '4', 'blink': '5', 'reverse': '7', 'conceal': '8'} DCNL DCSP text = str(text) DCNL DCSP code_list = [] DCNL DCSP if ((text == '') and (len(opts) == 1) and (opts[0] == 'reset')): DCNL DCSP  DCSP return ('\x1b[%sm' % RESET) DCNL DCSP for (k, v) in kwargs.iteritems(): DCNL DCSP  DCSP if (k == 'fg'): DCNL DCSP  DCSP  DCSP code_list.append(foreground[v]) DCNL DCSP  DCSP elif (k == 'bg'): DCNL DCSP  DCSP  DCSP code_list.append(background[v]) DCNL DCSP for o in opts: DCNL DCSP  DCSP if (o in opt_dict): DCNL DCSP  DCSP  DCSP code_list.append(opt_dict[o]) DCNL DCSP if ('noreset' not in opts): DCNL DCSP  DCSP text = (text + ('\x1b[%sm' % RESET)) DCNL DCSP return (('\x1b[%sm' % ';'.join(code_list)) + text)
def is_image_visible(context, image, status=None): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if (image['visibility'] in ['public', 'community']): DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if ('shared' == image['visibility']): DCNL DCSP  DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner, status=status) DCNL DCSP  DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def assert_similar_pages(first, second, ratio=0.9, msg=None): DCNL  DCSP lines_a = set([l.strip() for l in first.split('\n')]) DCNL DCSP lines_b = set([l.strip() for l in second.split('\n')]) DCNL DCSP common = lines_a.intersection(lines_b) DCNL DCSP similarity = ((1.0 * len(common)) / max(len(lines_a), len(lines_b))) DCNL DCSP nose.tools.assert_true((similarity >= ratio), msg)
@library.filter DCNL def remove(list_, item): DCNL  DCSP return [i for i in list_ if (i != item)]
def run_param(registry, xml_parent, data): DCNL  DCSP pdef = base_param(registry, xml_parent, data, False, 'hudson.model.RunParameterDefinition') DCNL DCSP XML.SubElement(pdef, 'projectName').text = data['project-name']
def create_request(url=None, method=None, body=None): DCNL  DCSP if ((not url) or (not method)): DCNL DCSP  DCSP raise MissingRequestArgs DCNL DCSP return tornado.httpclient.HTTPRequest(url=url, method=method, body=body, validate_cert=False, request_timeout=hermes_constants.REQUEST_TIMEOUT)
def run_cmd(pl, cmd, stdin=None, strip=True): DCNL  DCSP try: DCNL DCSP  DCSP p = Popen(cmd, shell=False, stdout=PIPE, stdin=PIPE) DCNL DCSP except OSError as e: DCNL DCSP  DCSP pl.exception(u'Could DCSP not DCSP execute DCSP command DCSP ({0}): DCSP {1}', e, cmd) DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP (stdout, err) = p.communicate((stdin if (stdin is None) else stdin.encode(get_preferred_output_encoding()))) DCNL DCSP  DCSP stdout = stdout.decode(get_preferred_input_encoding()) DCNL DCSP return (stdout.strip() if strip else stdout)
def check_key_expired(key, node, url): DCNL  DCSP if (key in node.private_link_keys_deleted): DCNL DCSP  DCSP url = furl(url).add({'status': 'expired'}).url DCNL DCSP return url
def search_lxc_bridge(): DCNL  DCSP return search_lxc_bridges()[0]
def is_docstring(physical_line, previous_logical): DCNL  DCSP line = physical_line.lstrip() DCNL DCSP start = max([line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP end = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP if (previous_logical.startswith('def DCSP ') or previous_logical.startswith('class DCSP ')): DCNL DCSP  DCSP if (start is 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (end and (start in ((-1), (len(line) - 4))))
def isPackageDirectory(dirname): DCNL  DCSP for ext in zip(*imp.get_suffixes())[0]: DCNL DCSP  DCSP initFile = ('__init__' + ext) DCNL DCSP  DCSP if os.path.exists(os.path.join(dirname, initFile)): DCNL DCSP  DCSP  DCSP return initFile DCNL DCSP return False
def _generate_cache_key(request, headerlist, key_prefix): DCNL  DCSP ctx = md5.new() DCNL DCSP for header in headerlist: DCNL DCSP  DCSP value = request.META.get(header, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP ctx.update(value) DCNL DCSP return ('views.decorators.cache.cache_page.%s.%s.%s' % (key_prefix, request.path, ctx.hexdigest()))
def already_backported(branch, since_tag=None): DCNL  DCSP if (since_tag is None): DCNL DCSP  DCSP since_tag = check_output(['git', 'describe', branch, '--abbrev=0']).decode('utf8').strip() DCNL DCSP cmd = ['git', 'log', ('%s..%s' % (since_tag, branch)), '--oneline'] DCNL DCSP lines = check_output(cmd).decode('utf8') DCNL DCSP return set((int(num) for num in backport_re.findall(lines)))
def get_location(http_info): DCNL  DCSP assert ('headers' in http_info) DCNL DCSP headers = http_info['headers'] DCNL DCSP assert (len(headers) == 1) DCNL DCSP (header_name, header_value) = headers[0] DCNL DCSP assert (header_name == 'Location') DCNL DCSP return header_value
def lie_heuristic_linear(match, comp=False): DCNL  DCSP xieta = [] DCNL DCSP h = match['h'] DCNL DCSP hx = match['hx'] DCNL DCSP hy = match['hy'] DCNL DCSP func = match['func'] DCNL DCSP hinv = match['hinv'] DCNL DCSP x = func.args[0] DCNL DCSP y = match['y'] DCNL DCSP xi = Function('xi')(x, func) DCNL DCSP eta = Function('eta')(x, func) DCNL DCSP coeffdict = {} DCNL DCSP symbols = numbered_symbols('c', cls=Dummy) DCNL DCSP symlist = [next(symbols) for i in islice(symbols, 6)] DCNL DCSP (C0, C1, C2, C3, C4, C5) = symlist DCNL DCSP pde = ((((C3 + ((C4 - C0) * h)) - ((((C0 * x) + (C1 * y)) + C2) * hx)) - ((((C3 * x) + (C4 * y)) + C5) * hy)) - (C1 * (h ** 2))) DCNL DCSP (pde, denom) = pde.as_numer_denom() DCNL DCSP pde = powsimp(expand(pde)) DCNL DCSP if pde.is_Add: DCNL DCSP  DCSP terms = pde.args DCNL DCSP  DCSP for term in terms: DCNL DCSP  DCSP  DCSP if term.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP rem = Mul(*[m for m in term.args if (not m.has(x, y))]) DCNL DCSP  DCSP  DCSP  DCSP xypart = (term / rem) DCNL DCSP  DCSP  DCSP  DCSP if (xypart not in coeffdict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP coeffdict[xypart] = rem DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP coeffdict[xypart] += rem DCNL DCSP  DCSP  DCSP elif (term not in coeffdict): DCNL DCSP  DCSP  DCSP  DCSP coeffdict[term] = S(1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP coeffdict[term] += S(1) DCNL DCSP sollist = coeffdict.values() DCNL DCSP soldict = solve(sollist, symlist) DCNL DCSP if soldict: DCNL DCSP  DCSP if isinstance(soldict, list): DCNL DCSP  DCSP  DCSP soldict = soldict[0] DCNL DCSP  DCSP subval = soldict.values() DCNL DCSP  DCSP if any((t for t in subval)): DCNL DCSP  DCSP  DCSP onedict = dict(zip(symlist, ([1] * 6))) DCNL DCSP  DCSP  DCSP xival = (((C0 * x) + (C1 * func)) + C2) DCNL DCSP  DCSP  DCSP etaval = (((C3 * x) + (C4 * func)) + C5) DCNL DCSP  DCSP  DCSP xival = xival.subs(soldict) DCNL DCSP  DCSP  DCSP etaval = etaval.subs(soldict) DCNL DCSP  DCSP  DCSP xival = xival.subs(onedict) DCNL DCSP  DCSP  DCSP etaval = etaval.subs(onedict) DCNL DCSP  DCSP  DCSP return [{xi: xival, eta: etaval}]
def _generate_indices(f, values=False): DCNL  DCSP axes = f.axes DCNL DCSP if values: DCNL DCSP  DCSP axes = [lrange(len(a)) for a in axes] DCNL DCSP return itertools.product(*axes)
def read_file_as_root(file_path): DCNL  DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except processutils.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
def demo(): DCNL  DCSP print '---------------------------------------' DCNL DCSP print ('Processing DCSP %d DCSP sequences DCSP from DCSP %d DCSP samples' % (len(DEMO_SEQUENCES), len(DEMO_SAMPLE_MAPPING))) DCNL DCSP print '---------------------------------------' DCNL DCSP for (ix, cur_seq) in enumerate(DEMO_SEQUENCES): DCNL DCSP  DCSP barcode = cur_seq[:8] DCNL DCSP  DCSP seq_read = cur_seq[8:] DCNL DCSP  DCSP print '---> DCSP processing DCSP demo DCSP sequence', ix DCNL DCSP  DCSP print 'read DCSP barcode DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :', barcode DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP corrected_barcode = decode_barcode_8(barcode) DCNL DCSP  DCSP  DCSP orig_sample_id = DEMO_SAMPLE_MAPPING[corrected_barcode] DCNL DCSP  DCSP  DCSP if (corrected_barcode != barcode): DCNL DCSP  DCSP  DCSP  DCSP print '*corrected DCSP barcode:', corrected_barcode DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print '-no DCSP error DCSP  DCSP barcode:', corrected_barcode DCNL DCSP  DCSP  DCSP print 'original DCSP sample DCSP id:', orig_sample_id DCNL DCSP  DCSP  DCSP print 'sequence DCSP read DCSP  DCSP  DCSP  DCSP  DCSP :', seq_read DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP print '!', str(e), 'skipping...' DCNL DCSP  DCSP  DCSP continue
def splev(x, tck, der=0, ext=0): DCNL  DCSP (t, c, k) = tck DCNL DCSP try: DCNL DCSP  DCSP c[0][0] DCNL DCSP  DCSP parametric = True DCNL DCSP except: DCNL DCSP  DCSP parametric = False DCNL DCSP if parametric: DCNL DCSP  DCSP return list(map((lambda c, x=x, t=t, k=k, der=der: splev(x, [t, c, k], der, ext)), c)) DCNL DCSP else: DCNL DCSP  DCSP if (not (0 <= der <= k)): DCNL DCSP  DCSP  DCSP raise ValueError(('0<=der=%d<=k=%d DCSP must DCSP hold' % (der, k))) DCNL DCSP  DCSP if (ext not in (0, 1, 2, 3)): DCNL DCSP  DCSP  DCSP raise ValueError(('ext DCSP = DCSP %s DCSP not DCSP in DCSP (0, DCSP 1, DCSP 2, DCSP 3) DCSP ' % ext)) DCNL DCSP  DCSP x = asarray(x) DCNL DCSP  DCSP shape = x.shape DCNL DCSP  DCSP x = atleast_1d(x).ravel() DCNL DCSP  DCSP (y, ier) = _fitpack._spl_(x, der, t, c, k, ext) DCNL DCSP  DCSP if (ier == 10): DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP input DCSP data') DCNL DCSP  DCSP if (ier == 1): DCNL DCSP  DCSP  DCSP raise ValueError('Found DCSP x DCSP value DCSP not DCSP in DCSP the DCSP domain') DCNL DCSP  DCSP if ier: DCNL DCSP  DCSP  DCSP raise TypeError('An DCSP error DCSP occurred') DCNL DCSP  DCSP return y.reshape(shape)
def fetch_streams_infinite(plugin, interval): DCNL  DCSP try: DCNL DCSP  DCSP streams = fetch_streams(plugin) DCNL DCSP except PluginError as err: DCNL DCSP  DCSP console.logger.error(u'{0}', err) DCNL DCSP  DCSP streams = None DCNL DCSP if (not streams): DCNL DCSP  DCSP console.logger.info('Waiting DCSP for DCSP streams, DCSP retrying DCSP every DCSP {0} DCSP second(s)', args.retry_streams) DCNL DCSP while (not streams): DCNL DCSP  DCSP sleep(args.retry_streams) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP streams = fetch_streams(plugin) DCNL DCSP  DCSP except PluginError as err: DCNL DCSP  DCSP  DCSP console.logger.error(u'{0}', err) DCNL DCSP return streams
def GetDefaultConcurrentLinks(): DCNL  DCSP pool_size = int(os.environ.get('GYP_LINK_CONCURRENCY', 0)) DCNL DCSP if pool_size: DCNL DCSP  DCSP return pool_size DCNL DCSP if (sys.platform in ('win32', 'cygwin')): DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP class MEMORYSTATUSEX(ctypes.Structure, ): DCNL DCSP  DCSP  DCSP _fields_ = [('dwLength', ctypes.c_ulong), ('dwMemoryLoad', ctypes.c_ulong), ('ullTotalPhys', ctypes.c_ulonglong), ('ullAvailPhys', ctypes.c_ulonglong), ('ullTotalPageFile', ctypes.c_ulonglong), ('ullAvailPageFile', ctypes.c_ulonglong), ('ullTotalVirtual', ctypes.c_ulonglong), ('ullAvailVirtual', ctypes.c_ulonglong), ('sullAvailExtendedVirtual', ctypes.c_ulonglong)] DCNL DCSP  DCSP stat = MEMORYSTATUSEX() DCNL DCSP  DCSP stat.dwLength = ctypes.sizeof(stat) DCNL DCSP  DCSP ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat)) DCNL DCSP  DCSP mem_limit = max(1, (stat.ullTotalPhys / (5 * (2 ** 30)))) DCNL DCSP  DCSP hard_cap = max(1, int(os.environ.get('GYP_LINK_CONCURRENCY_MAX', (2 ** 32)))) DCNL DCSP  DCSP return min(mem_limit, hard_cap) DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP if os.path.exists('/proc/meminfo'): DCNL DCSP  DCSP  DCSP with open('/proc/meminfo') as meminfo: DCNL DCSP  DCSP  DCSP  DCSP memtotal_re = re.compile('^MemTotal:\\s*(\\d*)\\s*kB') DCNL DCSP  DCSP  DCSP  DCSP for line in meminfo: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = memtotal_re.match(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP return max(1, (int(match.group(1)) / (8 * (2 ** 20)))) DCNL DCSP  DCSP return 1 DCNL DCSP elif (sys.platform == 'darwin'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP avail_bytes = int(subprocess.check_output(['sysctl', '-n', 'hw.memsize'])) DCNL DCSP  DCSP  DCSP return max(1, (avail_bytes / (4 * (2 ** 30)))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 1
def locale_list(request): DCNL  DCSP locales = Locale.objects.all() DCNL DCSP return render(request, 'wiki/locale_list.html', {'locales': locales})
def patch_vary_headers(response, newheaders): DCNL  DCSP if response.has_header(u'Vary'): DCNL DCSP  DCSP vary_headers = cc_delim_re.split(response[u'Vary']) DCNL DCSP else: DCNL DCSP  DCSP vary_headers = [] DCNL DCSP existing_headers = set([header.lower() for header in vary_headers]) DCNL DCSP additional_headers = [newheader for newheader in newheaders if (newheader.lower() not in existing_headers)] DCNL DCSP response[u'Vary'] = u', DCSP '.join((vary_headers + additional_headers))
def fix_ampersands(value): DCNL  DCSP return unencoded_ampersands_re.sub('&amp;', force_unicode(value))
def set_priority_js(): DCNL  DCSP wptable = s3db.cap_warning_priority DCNL DCSP rows = db(wptable).select(wptable.name, wptable.urgency, wptable.severity, wptable.certainty, wptable.color_code, orderby=wptable.name) DCNL DCSP from gluon.serializers import json as jsons DCNL DCSP from s3 import s3_str DCNL DCSP p_settings = [(s3_str(T(r.name)), r.urgency, r.severity, r.certainty, r.color_code) for r in rows] DCNL DCSP priority_conf = s3_str(('S3.cap_priorities=%s' % jsons(p_settings))) DCNL DCSP js_global = s3.js_global DCNL DCSP if (not (priority_conf in js_global)): DCNL DCSP  DCSP js_global.append(priority_conf) DCNL DCSP return
def _replace_locals(tok): DCNL  DCSP (toknum, tokval) = tok DCNL DCSP if ((toknum == tokenize.OP) and (tokval == '@')): DCNL DCSP  DCSP return (tokenize.OP, _LOCAL_TAG) DCNL DCSP return (toknum, tokval)
def localhost(): DCNL  DCSP global _localhost DCNL DCSP if (_localhost is None): DCNL DCSP  DCSP _localhost = socket.gethostbyname('localhost') DCNL DCSP return _localhost
def sqllist(lst): DCNL  DCSP if isinstance(lst, string_types): DCNL DCSP  DCSP return lst DCNL DCSP else: DCNL DCSP  DCSP return ', DCSP '.join(lst)
def groupby(key, seq): DCNL  DCSP if (not callable(key)): DCNL DCSP  DCSP key = getter(key) DCNL DCSP d = collections.defaultdict((lambda : [].append)) DCNL DCSP for item in seq: DCNL DCSP  DCSP d[key(item)](item) DCNL DCSP rv = {} DCNL DCSP for (k, v) in iteritems(d): DCNL DCSP  DCSP rv[k] = v.__self__ DCNL DCSP return rv
def create(name, profile='splunk', **kwargs): DCNL  DCSP client = _get_splunk(profile) DCNL DCSP search = client.saved_searches.create(name, **kwargs) DCNL DCSP config = __salt__['config.option'](profile) DCNL DCSP url = 'https://{0}:{1}'.format(config.get('host'), config.get('port')) DCNL DCSP auth = (config.get('username'), config.get('password')) DCNL DCSP data = {'owner': config.get('username'), 'sharing': 'app', 'perms.read': '*'} DCNL DCSP _req_url = '{0}/servicesNS/{1}/search/saved/searches/{2}/acl'.format(url, config.get('username'), urllib.quote(name)) DCNL DCSP requests.post(_req_url, auth=auth, verify=True, data=data) DCNL DCSP return _get_splunk_search_props(search)
def filter_re_search(val, pattern): DCNL  DCSP if (not isinstance(val, basestring)): DCNL DCSP  DCSP return val DCNL DCSP result = re.search(pattern, val) DCNL DCSP if result: DCNL DCSP  DCSP return result.group(0) DCNL DCSP return u''
def test_continuous_regression_with_overlap(): DCNL  DCSP signal = np.zeros(100000) DCNL DCSP times = [1000, 2500, 3000, 5000, 5250, 7000, 7250, 8000] DCNL DCSP events = np.zeros((len(times), 3), int) DCNL DCSP events[:, 2] = 1 DCNL DCSP events[:, 0] = times DCNL DCSP signal[events[:, 0]] = 1.0 DCNL DCSP effect = hann(101) DCNL DCSP signal = np.convolve(signal, effect)[:len(signal)] DCNL DCSP raw = RawArray(signal[np.newaxis, :], mne.create_info(1, 100, 'eeg')) DCNL DCSP assert_allclose(effect, linear_regression_raw(raw, events, {1: 1}, tmin=0)[1].data.flatten())
@register.simple_tag() DCNL def product_first_image(product, size, method='crop'): DCNL  DCSP all_images = product.images.all() DCNL DCSP main_image = (all_images[0].image if all_images else None) DCNL DCSP return get_thumbnail(main_image, size, method)
def conlltags2tree(sentence, chunk_types=(u'NP', u'PP', u'VP'), root_label=u'S', strict=False): DCNL  DCSP tree = Tree(root_label, []) DCNL DCSP for (word, postag, chunktag) in sentence: DCNL DCSP  DCSP if (chunktag is None): DCNL DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(u'Bad DCSP conll DCSP tag DCSP sequence') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tree.append((word, postag)) DCNL DCSP  DCSP elif chunktag.startswith(u'B-'): DCNL DCSP  DCSP  DCSP tree.append(Tree(chunktag[2:], [(word, postag)])) DCNL DCSP  DCSP elif chunktag.startswith(u'I-'): DCNL DCSP  DCSP  DCSP if ((len(tree) == 0) or (not isinstance(tree[(-1)], Tree)) or (tree[(-1)].label() != chunktag[2:])): DCNL DCSP  DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(u'Bad DCSP conll DCSP tag DCSP sequence') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tree.append(Tree(chunktag[2:], [(word, postag)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tree[(-1)].append((word, postag)) DCNL DCSP  DCSP elif (chunktag == u'O'): DCNL DCSP  DCSP  DCSP tree.append((word, postag)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(u'Bad DCSP conll DCSP tag DCSP {0!r}'.format(chunktag)) DCNL DCSP return tree
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False): DCNL  DCSP if (not port): DCNL DCSP  DCSP port = (443 if ssl else 80) DCNL DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP else: DCNL DCSP  DCSP conn = BufferedHTTPConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP if query_string: DCNL DCSP  DCSP path += ('?' + query_string) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest(method, path, skip_host=(headers and ('Host' in headers))) DCNL DCSP if headers: DCNL DCSP  DCSP for (header, value) in headers.items(): DCNL DCSP  DCSP  DCSP conn.putheader(header, str(value)) DCNL DCSP conn.endheaders() DCNL DCSP return conn
def random_game(nums_actions, random_state=None): DCNL  DCSP N = len(nums_actions) DCNL DCSP if (N == 0): DCNL DCSP  DCSP raise ValueError('nums_actions DCSP must DCSP be DCSP non-empty') DCNL DCSP random_state = check_random_state(random_state) DCNL DCSP players = [Player(random_state.random_sample((nums_actions[i:] + nums_actions[:i]))) for i in range(N)] DCNL DCSP g = NormalFormGame(players) DCNL DCSP return g
def vlan_in_use(segmentation_id, namespace=None): DCNL  DCSP ip_wrapper = IPWrapper(namespace=namespace) DCNL DCSP interfaces = ip_wrapper.netns.execute(['ip', '-d', 'link', 'list'], check_exit_code=True) DCNL DCSP return (('802.1Q DCSP id DCSP %s DCSP ' % segmentation_id) in interfaces)
def after_all(context): DCNL  DCSP dbutils.close_cn(context.cn) DCNL DCSP dbutils.drop_db(context.conf[u'host'], context.conf[u'user'], context.conf[u'pass'], context.conf[u'dbname']) DCNL DCSP for (k, v) in context.pgenv.items(): DCNL DCSP  DCSP if ((k in os.environ) and (v is None)): DCNL DCSP  DCSP  DCSP del os.environ[k] DCNL DCSP  DCSP elif v: DCNL DCSP  DCSP  DCSP os.environ[k] = v
def xml_format(a): DCNL  DCSP if isinstance(a, basestring): DCNL DCSP  DCSP return ('"%s"' % encode_entities(a)) DCNL DCSP if isinstance(a, bool): DCNL DCSP  DCSP return ('"%s"' % ('no', 'yes')[int(a)]) DCNL DCSP if isinstance(a, (int, long)): DCNL DCSP  DCSP return ('"%s"' % a) DCNL DCSP if isinstance(a, float): DCNL DCSP  DCSP return ('"%s"' % round(a, 5)) DCNL DCSP if isinstance(a, type(None)): DCNL DCSP  DCSP return '""' DCNL DCSP if isinstance(a, Date): DCNL DCSP  DCSP return ('"%s"' % str(a)) DCNL DCSP if isinstance(a, datetime.datetime): DCNL DCSP  DCSP return ('"%s"' % str(date(mktime(a.timetuple()))))
def process_all_packages(pkgmgr, client_dir, remove=False): DCNL  DCSP dep_dir = os.path.join(client_dir, 'deps') DCNL DCSP prof_dir = os.path.join(client_dir, 'profilers') DCNL DCSP temp_dir = tempfile.mkdtemp() DCNL DCSP try: DCNL DCSP  DCSP base_packages.check_diskspace(temp_dir) DCNL DCSP except error.RepoDiskFullError as e: DCNL DCSP  DCSP print ('Temp DCSP destination DCSP for DCSP packages DCSP is DCSP full DCSP %s, DCSP aborting DCSP upload: DCSP %s' % (temp_dir, e)) DCNL DCSP  DCSP os.rmdir(temp_dir) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tests_list = get_subdir_list('tests', client_dir) DCNL DCSP tests = ','.join(tests_list) DCNL DCSP site_tests_list = get_subdir_list('site_tests', client_dir) DCNL DCSP site_tests = ','.join(site_tests_list) DCNL DCSP deps_list = get_subdir_list('deps', client_dir) DCNL DCSP deps = ','.join(deps_list) DCNL DCSP profilers_list = get_subdir_list('profilers', client_dir) DCNL DCSP profilers = ','.join(profilers_list) DCNL DCSP if (not remove): DCNL DCSP  DCSP tar_packages(pkgmgr, 'profiler', profilers, prof_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'dep', deps, dep_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', site_tests, client_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', tests, client_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'client', 'autotest', client_dir, temp_dir) DCNL DCSP  DCSP cwd = os.getcwd() DCNL DCSP  DCSP os.chdir(temp_dir) DCNL DCSP  DCSP client_utils.system('md5sum DCSP * DCSP > DCSP packages.checksum') DCNL DCSP  DCSP os.chdir(cwd) DCNL DCSP  DCSP pkgmgr.upload_pkg(temp_dir) DCNL DCSP  DCSP client_utils.run(('rm DCSP -rf DCSP ' + temp_dir)) DCNL DCSP else: DCNL DCSP  DCSP process_packages(pkgmgr, 'test', tests, client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'test', site_tests, client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'client', 'autotest', client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'dep', deps, dep_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'profiler', profilers, prof_dir, remove=remove)
def nn_words(table, wordvecs, query, k=10): DCNL  DCSP keys = table.keys() DCNL DCSP qf = table[query] DCNL DCSP scores = numpy.dot(qf, wordvecs.T).flatten() DCNL DCSP sorted_args = numpy.argsort(scores)[::(-1)] DCNL DCSP words = [keys[a] for a in sorted_args[:k]] DCNL DCSP print ('QUERY: DCSP ' + query) DCNL DCSP print 'NEAREST: DCSP ' DCNL DCSP for (i, w) in enumerate(words): DCNL DCSP  DCSP print w
def check_forhash(filename): DCNL  DCSP if isinstance(filename, list): DCNL DCSP  DCSP filename = filename[0] DCNL DCSP (path, name) = os.path.split(filename) DCNL DCSP if re.search(u'(_0x[a-z0-9]{32})', name): DCNL DCSP  DCSP hashvalue = re.findall(u'(_0x[a-z0-9]{32})', name) DCNL DCSP  DCSP return (True, hashvalue) DCNL DCSP else: DCNL DCSP  DCSP return (False, None)
def is_namespace_property_mutable(context, namespace_property): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP return (namespace_property.namespace.owner == context.owner)
def daemonize(no_close=False, pidfile=None): DCNL  DCSP log = logging.getLogger('grizzled.os.daemon') DCNL DCSP def __fork(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return _os.fork() DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP raise DaemonError, ('Cannot DCSP fork', e.errno, e.strerror) DCNL DCSP def __redirect_file_descriptors(): DCNL DCSP  DCSP import resource DCNL DCSP  DCSP maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1] DCNL DCSP  DCSP if (maxfd == resource.RLIM_INFINITY): DCNL DCSP  DCSP  DCSP maxfd = MAXFD DCNL DCSP  DCSP for fd in range(0, maxfd): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _os.ttyname(fd) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _os.close(fd) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP _os.open(NULL_DEVICE, _os.O_RDWR) DCNL DCSP  DCSP  DCSP _os.dup2(0, 1) DCNL DCSP  DCSP  DCSP _os.dup2(0, 2) DCNL DCSP if (_os.name != 'posix'): DCNL DCSP  DCSP import errno DCNL DCSP  DCSP raise DaemonError, ('daemonize() DCSP is DCSP only DCSP supported DCSP on DCSP Posix-compliant DCSP systems.', errno.ENOSYS, _os.strerror(errno.ENOSYS)) DCNL DCSP try: DCNL DCSP  DCSP log.debug('Forking DCSP first DCSP child.') DCNL DCSP  DCSP pid = __fork() DCNL DCSP  DCSP if (pid != 0): DCNL DCSP  DCSP  DCSP _os._exit(0) DCNL DCSP  DCSP log.debug('Creating DCSP new DCSP session') DCNL DCSP  DCSP _os.setsid() DCNL DCSP  DCSP log.debug('Forking DCSP second DCSP child.') DCNL DCSP  DCSP pid = __fork() DCNL DCSP  DCSP if (pid != 0): DCNL DCSP  DCSP  DCSP _os._exit(0) DCNL DCSP  DCSP log.debug('Setting DCSP umask') DCNL DCSP  DCSP _os.umask(UMASK) DCNL DCSP  DCSP log.debug(('Changing DCSP working DCSP directory DCSP to DCSP "%s"' % WORKDIR)) DCNL DCSP  DCSP _os.chdir(WORKDIR) DCNL DCSP  DCSP if (not no_close): DCNL DCSP  DCSP  DCSP log.debug('Redirecting DCSP file DCSP descriptors') DCNL DCSP  DCSP  DCSP __redirect_file_descriptors() DCNL DCSP  DCSP if pidfile: DCNL DCSP  DCSP  DCSP from string import Template DCNL DCSP  DCSP  DCSP t = Template(pidfile) DCNL DCSP  DCSP  DCSP pidfile = t.safe_substitute(pid=str(_os.getpid())) DCNL DCSP  DCSP  DCSP open(pidfile, 'w').write((str(_os.getpid()) + '\n')) DCNL DCSP except DaemonError: DCNL DCSP  DCSP raise DCNL DCSP except OSError as e: DCNL DCSP  DCSP raise DaemonError, ('Unable DCSP to DCSP daemonize()', e.errno, e.strerror)
@protocol.commands.add(u'listfiles') DCNL def listfiles(context, uri=None): DCNL  DCSP raise exceptions.MpdNotImplemented
def _spg_optim(func, grad, start, project, maxiter=10000.0, M=10, ctol=0.001, maxiter_nmls=200, lam_min=1e-30, lam_max=1e+30, sig1=0.1, sig2=0.9, gam=0.0001): DCNL  DCSP lam = min((10 * lam_min), lam_max) DCNL DCSP params = start.copy() DCNL DCSP gval = grad(params) DCNL DCSP obj_hist = [func(params)] DCNL DCSP for itr in range(int(maxiter)): DCNL DCSP  DCSP df = (params - gval) DCNL DCSP  DCSP project(df) DCNL DCSP  DCSP df -= params DCNL DCSP  DCSP if (np.max(np.abs(df)) < ctol): DCNL DCSP  DCSP  DCSP return Bunch(**{'Converged': True, 'params': params, 'objective_values': obj_hist, 'Message': 'Converged DCSP successfully'}) DCNL DCSP  DCSP d = (params - (lam * gval)) DCNL DCSP  DCSP project(d) DCNL DCSP  DCSP d -= params DCNL DCSP  DCSP (alpha, params1, fval, gval1) = _nmono_linesearch(func, grad, params, d, obj_hist, M=M, sig1=sig1, sig2=sig2, gam=gam, maxiter=maxiter_nmls) DCNL DCSP  DCSP if (alpha is None): DCNL DCSP  DCSP  DCSP return Bunch(**{'Converged': False, 'params': params, 'objective_values': obj_hist, 'Message': 'Failed DCSP in DCSP nmono_linesearch'}) DCNL DCSP  DCSP obj_hist.append(fval) DCNL DCSP  DCSP s = (params1 - params) DCNL DCSP  DCSP y = (gval1 - gval) DCNL DCSP  DCSP sy = (s * y).sum() DCNL DCSP  DCSP if (sy <= 0): DCNL DCSP  DCSP  DCSP lam = lam_max DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ss = (s * s).sum() DCNL DCSP  DCSP  DCSP lam = max(lam_min, min((ss / sy), lam_max)) DCNL DCSP  DCSP params = params1 DCNL DCSP  DCSP gval = gval1 DCNL DCSP return Bunch(**{'Converged': False, 'params': params, 'objective_values': obj_hist, 'Message': 'spg_optim DCSP did DCSP not DCSP converge'})
def get_global_options(): DCNL  DCSP return _global_options
def extents_may_overlap(context, builder, a_start, a_end, b_start, b_end): DCNL  DCSP may_overlap = builder.and_(builder.icmp_unsigned('<', a_start, b_end), builder.icmp_unsigned('<', b_start, a_end)) DCNL DCSP return may_overlap
def check_installed(name, path): DCNL  DCSP try: DCNL DCSP  DCSP return (_read_link(name) == path) DCNL DCSP except OSError: DCNL DCSP  DCSP return False
def unregister_models(engine): DCNL  DCSP models = (ArtifactDependency, ArtifactBlobLocation, ArtifactBlob, ArtifactProperty, ArtifactTag, Artifact) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.drop_all(engine)
@contextlib.contextmanager DCNL def import_state(**kwargs): DCNL  DCSP originals = {} DCNL DCSP try: DCNL DCSP  DCSP for (attr, default) in (('meta_path', []), ('path', []), ('path_hooks', []), ('path_importer_cache', {})): DCNL DCSP  DCSP  DCSP originals[attr] = getattr(sys, attr) DCNL DCSP  DCSP  DCSP if (attr in kwargs): DCNL DCSP  DCSP  DCSP  DCSP new_value = kwargs[attr] DCNL DCSP  DCSP  DCSP  DCSP del kwargs[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_value = default DCNL DCSP  DCSP  DCSP setattr(sys, attr, new_value) DCNL DCSP  DCSP if len(kwargs): DCNL DCSP  DCSP  DCSP raise ValueError('unrecognized DCSP arguments: DCSP {0}'.format(kwargs.keys())) DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, value) in originals.items(): DCNL DCSP  DCSP  DCSP setattr(sys, attr, value)
def find_undeclared_variables(ast): DCNL  DCSP codegen = TrackingCodeGenerator(ast.environment) DCNL DCSP codegen.visit(ast) DCNL DCSP return codegen.undeclared_identifiers
@none_if_empty DCNL def blobproperty_from_base64(value): DCNL  DCSP decoded_value = base64.b64decode(value) DCNL DCSP return datastore_types.Blob(decoded_value)
def _mbcs_to_unicode(instr): DCNL  DCSP if ((instr is None) or isinstance(instr, six.text_type)): DCNL DCSP  DCSP return instr DCNL DCSP else: DCNL DCSP  DCSP return six.text_type(instr, u'mbcs')
def get_order_args(): DCNL  DCSP orders = {} DCNL DCSP for arg in request.args: DCNL DCSP  DCSP re_match = re.findall('_oc_(.*)', arg) DCNL DCSP  DCSP if re_match: DCNL DCSP  DCSP  DCSP orders[re_match[0]] = (request.args.get(arg), request.args.get(('_od_' + re_match[0]))) DCNL DCSP return orders
def human_resource(): DCNL  DCSP if (auth.permission.format != 's3json'): DCNL DCSP  DCSP return '' DCNL DCSP def prep(r): DCNL DCSP  DCSP if (r.method != 'options'): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller('hrm', 'human_resource')
def service_get(context, service_id=None, backend_match_level=None, **filters): DCNL  DCSP return IMPL.service_get(context, service_id, backend_match_level, **filters)
def _control_segment_path(name): DCNL  DCSP server_dir = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP return os.path.join(server_dir, 'control_segments', name)
def save_to_store(content, name, mime_type, location): DCNL  DCSP content_location = Transcript.asset_location(location, name) DCNL DCSP content = StaticContent(content_location, name, mime_type, content) DCNL DCSP contentstore().save(content) DCNL DCSP return content_location
def dbg(*args, **kwds): DCNL  DCSP mkQApp() DCNL DCSP from . import console DCNL DCSP c = console.ConsoleWidget(*args, **kwds) DCNL DCSP c.catchAllExceptions() DCNL DCSP c.show() DCNL DCSP global consoles DCNL DCSP try: DCNL DCSP  DCSP consoles.append(c) DCNL DCSP except NameError: DCNL DCSP  DCSP consoles = [c] DCNL DCSP return c
def autodiscover(): DCNL  DCSP global _RACE_PROTECTION DCNL DCSP if _RACE_PROTECTION: DCNL DCSP  DCSP return DCNL DCSP _RACE_PROTECTION = True DCNL DCSP try: DCNL DCSP  DCSP return filter(None, [find_related_module(app, 'tasks') for app in settings.INSTALLED_APPS]) DCNL DCSP finally: DCNL DCSP  DCSP _RACE_PROTECTION = False
@ffi.callback('int(void* DCSP handle, DCSP int DCSP revents)') DCNL def _python_callback(handle, revents): DCNL  DCSP try: DCNL DCSP  DCSP the_watcher = ffi.from_handle(handle) DCNL DCSP  DCSP args = the_watcher.args DCNL DCSP  DCSP if (args is None): DCNL DCSP  DCSP  DCSP args = _NOARGS DCNL DCSP  DCSP if ((len(args) > 0) and (args[0] == GEVENT_CORE_EVENTS)): DCNL DCSP  DCSP  DCSP args = ((revents,) + args[1:]) DCNL DCSP  DCSP the_watcher.callback(*args) DCNL DCSP except: DCNL DCSP  DCSP the_watcher._exc_info = sys.exc_info() DCNL DCSP  DCSP the_watcher.loop._keepaliveset.add(the_watcher) DCNL DCSP  DCSP return (-1) DCNL DCSP else: DCNL DCSP  DCSP if (the_watcher in the_watcher.loop._keepaliveset): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP return 1
def write_backreferences(seen_backrefs, gallery_conf, target_dir, fname, snippet): DCNL  DCSP example_file = os.path.join(target_dir, fname) DCNL DCSP build_target = os.path.relpath(target_dir, gallery_conf['src_dir']) DCNL DCSP backrefs = scan_used_functions(example_file, gallery_conf) DCNL DCSP for backref in backrefs: DCNL DCSP  DCSP include_path = os.path.join(gallery_conf['src_dir'], gallery_conf['mod_example_dir'], ('%s.examples' % backref)) DCNL DCSP  DCSP seen = (backref in seen_backrefs) DCNL DCSP  DCSP with open(include_path, ('a' if seen else 'w')) as ex_file: DCNL DCSP  DCSP  DCSP if (not seen): DCNL DCSP  DCSP  DCSP  DCSP heading = ('\n\nExamples DCSP using DCSP ``%s``' % backref) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((heading + '\n')) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((('^' * len(heading)) + '\n')) DCNL DCSP  DCSP  DCSP ex_file.write(_thumbnail_div(build_target, fname, snippet, is_backref=True)) DCNL DCSP  DCSP  DCSP seen_backrefs.add(backref)
def unescape_html(text): DCNL  DCSP def fixup(m): DCNL DCSP  DCSP text = m.group(0) DCNL DCSP  DCSP if (text[:2] == '&#'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (text[:3] == '&#x'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unichr(int(text[3:(-1)], 16)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unichr(int(text[2:(-1)])) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = unichr(htmlentitydefs.name2codepoint[text[1:(-1)]]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return text DCNL DCSP return re.sub('&#?\\w+;', fixup, text)
def is_frozen(): DCNL  DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP return False DCNL DCSP return True
def get_keywords(lexer): DCNL  DCSP if (not hasattr(lexer, 'tokens')): DCNL DCSP  DCSP return [] DCNL DCSP if ('keywords' in lexer.tokens): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return lexer.tokens['keywords'][0][0].words DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP keywords = [] DCNL DCSP for vals in lexer.tokens.values(): DCNL DCSP  DCSP for val in vals: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(val[0], words): DCNL DCSP  DCSP  DCSP  DCSP  DCSP keywords.extend(val[0].words) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ini_val = val[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((')\\b' in val[0]) or (')(\\s+)' in val[0])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val = re.sub('\\\\.', '', val[0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val = re.sub('[^0-9a-zA-Z|]+', '', val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('|' in ini_val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keywords.extend(val.split('|')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keywords.append(val) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP return keywords
def factorialk(n, k, exact=True): DCNL  DCSP if exact: DCNL DCSP  DCSP if (n < (1 - k)): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP if (n <= 0): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP val = 1 DCNL DCSP  DCSP for j in xrange(n, 0, (- k)): DCNL DCSP  DCSP  DCSP val = (val * j) DCNL DCSP  DCSP return val DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError
def resolve_model_string(model_string, default_app=None): DCNL  DCSP if isinstance(model_string, string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (app_label, model_name) = model_string.split(u'.') DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (default_app is not None): DCNL DCSP  DCSP  DCSP  DCSP app_label = default_app DCNL DCSP  DCSP  DCSP  DCSP model_name = model_string DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(u'Can DCSP not DCSP resolve DCSP {0!r} DCSP into DCSP a DCSP model. DCSP Model DCSP names DCSP should DCSP be DCSP in DCSP the DCSP form DCSP app_label.model_name'.format(model_string), model_string) DCNL DCSP  DCSP return apps.get_model(app_label, model_name) DCNL DCSP elif (isinstance(model_string, type) and issubclass(model_string, Model)): DCNL DCSP  DCSP return model_string DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u'Can DCSP not DCSP resolve DCSP {0!r} DCSP into DCSP a DCSP model'.format(model_string), model_string)
def restart(name): DCNL  DCSP cmd = '{0} DCSP -f DCSP restart DCSP {1}'.format(_cmd(), name) DCNL DCSP return (not __salt__['cmd.retcode'](cmd))
@pytest.yield_fixture() DCNL def use_vcr(request, monkeypatch): DCNL  DCSP if (VCR_RECORD_MODE == u'off'): DCNL DCSP  DCSP (yield None) DCNL DCSP else: DCNL DCSP  DCSP module = request.module.__name__.split(u'tests.')[(-1)] DCNL DCSP  DCSP class_name = request.cls.__name__ DCNL DCSP  DCSP cassette_name = u'.'.join([module, class_name, request.function.__name__]) DCNL DCSP  DCSP cassette_path = os.path.join(VCR_CASSETTE_DIR, cassette_name) DCNL DCSP  DCSP online = True DCNL DCSP  DCSP if (vcr.record_mode == u'none'): DCNL DCSP  DCSP  DCSP online = False DCNL DCSP  DCSP elif (vcr.record_mode == u'once'): DCNL DCSP  DCSP  DCSP online = (not os.path.exists(cassette_path)) DCNL DCSP  DCSP if (not online): DCNL DCSP  DCSP  DCSP log.debug(u'Disabling DCSP domain DCSP limiters DCSP during DCSP VCR DCSP playback.') DCNL DCSP  DCSP  DCSP monkeypatch.setattr(u'flexget.utils.requests.limit_domains', mock.Mock()) DCNL DCSP  DCSP with vcr.use_cassette(path=cassette_path) as cassette: DCNL DCSP  DCSP  DCSP (yield cassette)
def getManipulatedPaths(close, elementNode, loop, prefix, sideLength): DCNL  DCSP if (len(loop) < 1): DCNL DCSP  DCSP return [[]] DCNL DCSP derivation = BottomDerivation(elementNode, prefix) DCNL DCSP targetMatrix = matrix.getBranchMatrixSetElementNode(elementNode) DCNL DCSP transformedLoop = matrix.getTransformedVector3s(matrix.getIdentityTetragrid(targetMatrix.tetragrid), loop) DCNL DCSP lift = ((derivation.altitude + derivation.getAdditionalPathLift()) - euclidean.getBottomByPath(transformedLoop)) DCNL DCSP for point in loop: DCNL DCSP  DCSP point.z += lift DCNL DCSP return [loop]
def depends(**dependencies): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP @wraps(func) DCNL DCSP  DCSP def wrapper(*a, **explicit): DCNL DCSP  DCSP  DCSP deps = dict([(k, get_dependency_for(k, v)) for (k, v) in dependencies.iteritems() if (k not in explicit)]) DCNL DCSP  DCSP  DCSP return func(*a, **union(deps, explicit)) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def python(registry, xml_parent, data): DCNL  DCSP python = XML.SubElement(xml_parent, 'hudson.plugins.python.Python') DCNL DCSP XML.SubElement(python, 'command').text = data
def read_config(options, args, arglist, parser): DCNL  DCSP config = RawConfigParser() DCNL DCSP cli_conf = options.config DCNL DCSP local_dir = os.curdir DCNL DCSP if (USER_CONFIG and os.path.isfile(USER_CONFIG)): DCNL DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP print ('user DCSP configuration: DCSP %s' % USER_CONFIG) DCNL DCSP  DCSP config.read(USER_CONFIG) DCNL DCSP parent = tail = (args and os.path.abspath(os.path.commonprefix(args))) DCNL DCSP while tail: DCNL DCSP  DCSP if config.read((os.path.join(parent, fn) for fn in PROJECT_CONFIG)): DCNL DCSP  DCSP  DCSP local_dir = parent DCNL DCSP  DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP  DCSP print ('local DCSP configuration: DCSP in DCSP %s' % parent) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (parent, tail) = os.path.split(parent) DCNL DCSP if (cli_conf and os.path.isfile(cli_conf)): DCNL DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP print ('cli DCSP configuration: DCSP %s' % cli_conf) DCNL DCSP  DCSP config.read(cli_conf) DCNL DCSP pep8_section = parser.prog DCNL DCSP if config.has_section(pep8_section): DCNL DCSP  DCSP option_list = dict([(o.dest, (o.type or o.action)) for o in parser.option_list]) DCNL DCSP  DCSP (new_options, __) = parser.parse_args([]) DCNL DCSP  DCSP for opt in config.options(pep8_section): DCNL DCSP  DCSP  DCSP if (opt.replace('_', '-') not in parser.config_options): DCNL DCSP  DCSP  DCSP  DCSP print (" DCSP  DCSP unknown DCSP option DCSP '%s' DCSP ignored" % opt) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (options.verbose > 1): DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP %s DCSP = DCSP %s' % (opt, config.get(pep8_section, opt))) DCNL DCSP  DCSP  DCSP normalized_opt = opt.replace('-', '_') DCNL DCSP  DCSP  DCSP opt_type = option_list[normalized_opt] DCNL DCSP  DCSP  DCSP if (opt_type in ('int', 'count')): DCNL DCSP  DCSP  DCSP  DCSP value = config.getint(pep8_section, opt) DCNL DCSP  DCSP  DCSP elif (opt_type == 'string'): DCNL DCSP  DCSP  DCSP  DCSP value = config.get(pep8_section, opt) DCNL DCSP  DCSP  DCSP  DCSP if (normalized_opt == 'exclude'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = normalize_paths(value, local_dir) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (opt_type in ('store_true', 'store_false')) DCNL DCSP  DCSP  DCSP  DCSP value = config.getboolean(pep8_section, opt) DCNL DCSP  DCSP  DCSP setattr(new_options, normalized_opt, value) DCNL DCSP  DCSP (options, __) = parser.parse_args(arglist, values=new_options) DCNL DCSP options.doctest = options.testsuite = False DCNL DCSP return options
def isAquaTk(): DCNL  DCSP if (not _tk_type): DCNL DCSP  DCSP _init_tk_type() DCNL DCSP return ((_tk_type == 'cocoa') or (_tk_type == 'carbon'))
def _operation_complete(result): DCNL  DCSP return result
def _uninstall_flocker_ubuntu1604(): DCNL  DCSP return sequence((_disable_flocker_systemd() + [_uninstall_flocker_ubuntu()]))
def get_resource_and_action(action): DCNL  DCSP data = action.split(':', 1)[0].split('_', 1) DCNL DCSP return (('%ss' % data[(-1)]), (data[0] != 'get'))
def freeze(bin_env=None, user=None, cwd=None, use_vt=False): DCNL  DCSP pip_bin = _get_pip_bin(bin_env) DCNL DCSP cmd = [pip_bin, 'freeze'] DCNL DCSP min_version = '8.0.3' DCNL DCSP cur_version = version(bin_env) DCNL DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP logger.warning('The DCSP version DCSP of DCSP pip DCSP installed DCSP is DCSP {0}, DCSP which DCSP is DCSP older DCSP than DCSP {1}. DCSP The DCSP packages DCSP pip, DCSP wheel, DCSP setuptools, DCSP and DCSP distribute DCSP will DCSP not DCSP be DCSP included DCSP in DCSP the DCSP output DCSP of DCSP pip.freeze'.format(cur_version, min_version)) DCNL DCSP else: DCNL DCSP  DCSP cmd.append('--all') DCNL DCSP cmd_kwargs = dict(runas=user, cwd=cwd, use_vt=use_vt, python_shell=False) DCNL DCSP if (bin_env and os.path.isdir(bin_env)): DCNL DCSP  DCSP cmd_kwargs['env'] = {'VIRTUAL_ENV': bin_env} DCNL DCSP result = __salt__['cmd.run_all'](cmd, **cmd_kwargs) DCNL DCSP if (result['retcode'] > 0): DCNL DCSP  DCSP raise CommandExecutionError(result['stderr']) DCNL DCSP return result['stdout'].splitlines()
def parse_query_part(part, query_classes={}, prefixes={}, default_class=query.SubstringQuery): DCNL  DCSP part = part.strip() DCNL DCSP match = PARSE_QUERY_PART_REGEX.match(part) DCNL DCSP assert match DCNL DCSP negate = bool(match.group(1)) DCNL DCSP key = match.group(2) DCNL DCSP term = match.group(3).replace('\\:', ':') DCNL DCSP for (pre, query_class) in prefixes.items(): DCNL DCSP  DCSP if term.startswith(pre): DCNL DCSP  DCSP  DCSP return (key, term[len(pre):], query_class, negate) DCNL DCSP query_class = query_classes.get(key, default_class) DCNL DCSP return (key, term, query_class, negate)
def setLoggerClass(klass): DCNL  DCSP if (klass != Logger): DCNL DCSP  DCSP if (not issubclass(klass, Logger)): DCNL DCSP  DCSP  DCSP raise TypeError(('logger DCSP not DCSP derived DCSP from DCSP logging.Logger: DCSP ' + klass.__name__)) DCNL DCSP global _loggerClass DCNL DCSP _loggerClass = klass
@utils.arg('pool', metavar='<floating-ip-pool>', help=_('Name DCSP of DCSP Floating DCSP IP DCSP Pool. DCSP (Optional)'), nargs='?', default=None) DCNL @deprecated_network DCNL def do_floating_ip_create(cs, args): DCNL  DCSP _print_floating_ip_list([cs.floating_ips.create(pool=args.pool)])
@snippet DCNL def client_list_datasets(client, _): DCNL  DCSP def do_something_with(_): DCNL DCSP  DCSP pass DCNL DCSP for dataset in client.list_datasets(): DCNL DCSP  DCSP do_something_with(dataset)
def cppcheck(registry, xml_parent, data): DCNL  DCSP cppextbase = XML.SubElement(xml_parent, 'org.jenkinsci.plugins.cppcheck.CppcheckPublisher') DCNL DCSP cppextbase.set('plugin', 'cppcheck') DCNL DCSP cppext = XML.SubElement(cppextbase, 'cppcheckConfig') DCNL DCSP mappings = [('pattern', 'pattern', None), ('ignoreblankfiles', 'ignoreBlankFiles', False), ('allow-no-report', 'allowNoReport', False)] DCNL DCSP helpers.convert_mapping_to_xml(cppext, data, mappings, fail_required=True) DCNL DCSP csev = XML.SubElement(cppext, 'configSeverityEvaluation') DCNL DCSP thrsh = data.get('thresholds', {}) DCNL DCSP thrsh_mappings = [('unstable', 'threshold', ''), ('new-unstable', 'newThreshold', ''), ('failure', 'failureThreshold', ''), ('new-failure', 'newFailureThreshold', ''), ('healthy', 'healthy', ''), ('unhealthy', 'unHealthy', '')] DCNL DCSP helpers.convert_mapping_to_xml(csev, thrsh, thrsh_mappings, fail_required=True) DCNL DCSP sev = thrsh.get('severity', {}) DCNL DCSP sev_mappings = [('error', 'severityError', True), ('warning', 'severityWarning', True), ('style', 'severityStyle', True), ('performance', 'severityPerformance', True), ('information', 'severityInformation', True), ('nocategory', 'severityNoCategory', True), ('portability', 'severityPortability', True)] DCNL DCSP helpers.convert_mapping_to_xml(csev, sev, sev_mappings, fail_required=True) DCNL DCSP graph = data.get('graph', {}) DCNL DCSP cgraph = XML.SubElement(cppext, 'configGraph') DCNL DCSP (x, y) = graph.get('xysize', [500, 200]) DCNL DCSP XML.SubElement(cgraph, 'xSize').text = str(x) DCNL DCSP XML.SubElement(cgraph, 'ySize').text = str(y) DCNL DCSP graph_mapping = [('num-builds-in-graph', 'numBuildsInGraph', 0)] DCNL DCSP helpers.convert_mapping_to_xml(cgraph, graph, graph_mapping, fail_required=True) DCNL DCSP gdisplay = graph.get('display', {}) DCNL DCSP gdisplay_mappings = [('sum', 'displayAllErrors', True), ('error', 'displayErrorSeverity', False), ('warning', 'displayWarningSeverity', False), ('style', 'displayStyleSeverity', False), ('performance', 'displayPerformanceSeverity', False), ('information', 'displayInformationSeverity', False), ('nocategory', 'displayNoCategorySeverity', False), ('portability', 'displayPortabilitySeverity', False)] DCNL DCSP helpers.convert_mapping_to_xml(cgraph, gdisplay, gdisplay_mappings, fail_required=True)
def _get_task_statuses(task_ids): DCNL  DCSP response = client.describe_tasks(tasks=task_ids) DCNL DCSP if (response['failures'] != []): DCNL DCSP  DCSP raise Exception('There DCSP were DCSP some DCSP failures:\n{0}'.format(response['failures'])) DCNL DCSP status_code = response['ResponseMetadata']['HTTPStatusCode'] DCNL DCSP if (status_code != 200): DCNL DCSP  DCSP msg = 'Task DCSP status DCSP request DCSP received DCSP status DCSP code DCSP {0}:\n{1}' DCNL DCSP  DCSP raise Exception(msg.format(status_code, response)) DCNL DCSP return [t['lastStatus'] for t in response['tasks']]
def test_special_bindings(keyhint, key_config_stub): DCNL  DCSP key_config_stub.set_bindings_for('normal', OrderedDict([('<a', 'cmd-<a'), ('<b', 'cmd-<b'), ('<ctrl-a>', 'cmd-ctrla')])) DCNL DCSP keyhint.update_keyhint('normal', '<') DCNL DCSP assert (keyhint.text() == expected_text(('&lt;', 'yellow', 'a', 'cmd-&lt;a'), ('&lt;', 'yellow', 'b', 'cmd-&lt;b')))
def fnpickle(object, fileorname, usecPickle=True, protocol=None, append=False): DCNL  DCSP if (usecPickle and six.PY2): DCNL DCSP  DCSP import cPickle as pickle DCNL DCSP else: DCNL DCSP  DCSP import pickle DCNL DCSP if (protocol is None): DCNL DCSP  DCSP protocol = pickle.HIGHEST_PROTOCOL DCNL DCSP if isinstance(fileorname, six.string_types): DCNL DCSP  DCSP f = open(fileorname, (u'ab' if append else u'wb')) DCNL DCSP  DCSP close = True DCNL DCSP else: DCNL DCSP  DCSP f = fileorname DCNL DCSP  DCSP close = False DCNL DCSP try: DCNL DCSP  DCSP pickle.dump(object, f, protocol=protocol) DCNL DCSP finally: DCNL DCSP  DCSP if close: DCNL DCSP  DCSP  DCSP f.close()
def annotate_webext_incompatibilities(results, file_, addon, version_string, channel): DCNL  DCSP from .utils import find_previous_version DCNL DCSP previous_version = find_previous_version(addon, file_, version_string, channel) DCNL DCSP if (not previous_version): DCNL DCSP  DCSP return results DCNL DCSP is_webextension = results['metadata'].get('is_webextension', False) DCNL DCSP was_webextension = (previous_version and previous_version.is_webextension) DCNL DCSP if (is_webextension and (not was_webextension)): DCNL DCSP  DCSP results['is_upgrade_to_webextension'] = True DCNL DCSP  DCSP msg = _('We DCSP allow DCSP and DCSP encourage DCSP an DCSP upgrade DCSP but DCSP you DCSP cannot DCSP reverse DCSP this DCSP process. DCSP Once DCSP your DCSP users DCSP have DCSP the DCSP WebExtension DCSP installed, DCSP they DCSP will DCSP not DCSP be DCSP able DCSP to DCSP install DCSP a DCSP legacy DCSP add-on.') DCNL DCSP  DCSP messages = results['messages'] DCNL DCSP  DCSP messages.insert(0, {'tier': 1, 'type': 'warning', 'id': ['validation', 'messages', 'webext_upgrade'], 'message': msg, 'description': [], 'compatibility_type': None}) DCNL DCSP  DCSP results['warnings'] += 1 DCNL DCSP elif (was_webextension and (not is_webextension)): DCNL DCSP  DCSP msg = _('You DCSP cannot DCSP update DCSP a DCSP WebExtensions DCSP add-on DCSP with DCSP a DCSP legacy DCSP add-on. DCSP Your DCSP users DCSP would DCSP not DCSP be DCSP able DCSP to DCSP use DCSP your DCSP new DCSP version DCSP because DCSP Firefox DCSP does DCSP not DCSP support DCSP this DCSP type DCSP of DCSP update.') DCNL DCSP  DCSP messages = results['messages'] DCNL DCSP  DCSP messages.insert(0, {'tier': 1, 'type': ('error' if (channel == amo.RELEASE_CHANNEL_LISTED) else 'warning'), 'id': ['validation', 'messages', 'webext_downgrade'], 'message': msg, 'description': [], 'compatibility_type': None}) DCNL DCSP  DCSP results['errors'] += 1 DCNL DCSP return results
def monkeypatch(klass, methodname=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP name = (methodname or func.__name__) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError(('%s DCSP has DCSP no DCSP __name__ DCSP attribute: DCSP you DCSP should DCSP provide DCSP an DCSP explicit DCSP `methodname`' % func)) DCNL DCSP  DCSP setattr(klass, name, func) DCNL DCSP  DCSP return func DCNL DCSP return decorator
@pytest.mark.network DCNL def test_download_if_requested(script): DCNL  DCSP result = script.pip('install', 'INITools==0.1', '-d', '.', expect_error=True) DCNL DCSP assert ((Path('scratch') / 'INITools-0.1.tar.gz') in result.files_created) DCNL DCSP assert ((script.site_packages / 'initools') not in result.files_created)
def get_cpu_percentage(function, *args, **dargs): DCNL  DCSP child_pre = resource.getrusage(resource.RUSAGE_CHILDREN) DCNL DCSP self_pre = resource.getrusage(resource.RUSAGE_SELF) DCNL DCSP start = time.time() DCNL DCSP to_return = function(*args, **dargs) DCNL DCSP elapsed = (time.time() - start) DCNL DCSP self_post = resource.getrusage(resource.RUSAGE_SELF) DCNL DCSP child_post = resource.getrusage(resource.RUSAGE_CHILDREN) DCNL DCSP (s_user, s_system) = [(a - b) for (a, b) in zip(self_post, self_pre)[:2]] DCNL DCSP (c_user, c_system) = [(a - b) for (a, b) in zip(child_post, child_pre)[:2]] DCNL DCSP cpu_percent = ((((s_user + c_user) + s_system) + c_system) / elapsed) DCNL DCSP return (cpu_percent, to_return)
def test_evoked_arithmetic(): DCNL  DCSP (raw, events, picks) = _get_data() DCNL DCSP epochs1 = Epochs(raw, events[:4], event_id, tmin, tmax, picks=picks) DCNL DCSP evoked1 = epochs1.average() DCNL DCSP epochs2 = Epochs(raw, events[4:8], event_id, tmin, tmax, picks=picks) DCNL DCSP evoked2 = epochs2.average() DCNL DCSP epochs = Epochs(raw, events[:8], event_id, tmin, tmax, picks=picks) DCNL DCSP evoked = epochs.average() DCNL DCSP evoked_sum = combine_evoked([evoked1, evoked2], weights='nave') DCNL DCSP assert_array_equal(evoked.data, evoked_sum.data) DCNL DCSP assert_array_equal(evoked.times, evoked_sum.times) DCNL DCSP assert_equal(evoked_sum.nave, (evoked1.nave + evoked2.nave)) DCNL DCSP evoked_diff = combine_evoked([evoked1, evoked1], weights=[1, (-1)]) DCNL DCSP assert_array_equal(np.zeros_like(evoked.data), evoked_diff.data)
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def check_password(environ, username, password): DCNL  DCSP UserModel = auth.get_user_model() DCNL DCSP db.reset_queries() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = UserModel._default_manager.get_by_natural_key(username) DCNL DCSP  DCSP except UserModel.DoesNotExist: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (not user.is_active): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return user.check_password(password) DCNL DCSP finally: DCNL DCSP  DCSP db.close_old_connections()
def build_parser(): DCNL  DCSP parser = optparse.OptionParser(add_help_option=False) DCNL DCSP option_factories = (SUPPORTED_OPTIONS + SUPPORTED_OPTIONS_REQ) DCNL DCSP for option_factory in option_factories: DCNL DCSP  DCSP option = option_factory() DCNL DCSP  DCSP parser.add_option(option) DCNL DCSP def parser_exit(self, msg): DCNL DCSP  DCSP raise RequirementsFileParseError(msg) DCNL DCSP parser.exit = parser_exit DCNL DCSP return parser
def make_dependence_cmp(): DCNL  DCSP depends = make_depends() DCNL DCSP def dependence(a, b): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP cmp DCSP function DCSP for DCSP nodes DCSP in DCSP a DCSP graph DCSP - DCSP does DCSP a DCSP depend DCSP on DCSP b?\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP -------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Positive DCSP number DCSP if DCSP a DCSP depends DCSP on DCSP b, DCSP negative DCSP number\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP b DCSP depends DCSP on DCSP a, DCSP 0 DCSP otherwise.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if depends((a, b)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP if depends((b, a)): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP return 0 DCNL DCSP return dependence
def iplayer_from_raw(raw, linktype=1): DCNL  DCSP if (linktype == 1): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pkt = dpkt.ethernet.Ethernet(raw) DCNL DCSP  DCSP  DCSP return pkt.data DCNL DCSP  DCSP except dpkt.NeedData: DCNL DCSP  DCSP  DCSP pass DCNL DCSP elif (linktype == 101): DCNL DCSP  DCSP return dpkt.ip.IP(raw) DCNL DCSP else: DCNL DCSP  DCSP raise CuckooProcessingError('unknown DCSP PCAP DCSP linktype')
def measure_mem_leakage(f, numsamples=(2 ** 7), iterspersample=(2 ** 4), *args, **kwargs): DCNL  DCSP precondition((numsamples > 0), 'numsamples DCSP is DCSP required DCSP to DCSP be DCSP positive.', numsamples) DCNL DCSP precondition((iterspersample > 0), 'iterspersample DCSP is DCSP required DCSP to DCSP be DCSP positive.', iterspersample) DCNL DCSP resiters = ([None] * numsamples) DCNL DCSP resmemusage = ([None] * numsamples) DCNL DCSP totaliters = 0 DCNL DCSP for i in range(numsamples): DCNL DCSP  DCSP for j in range(iterspersample): DCNL DCSP  DCSP  DCSP f(*args, **kwargs) DCNL DCSP  DCSP totaliters = (totaliters + iterspersample) DCNL DCSP  DCSP resiters[i] = totaliters DCNL DCSP  DCSP gc.collect() DCNL DCSP  DCSP resmemusage[i] = get_mem_used_res() DCNL DCSP avex = (float(reduce(operator.__add__, resiters)) / len(resiters)) DCNL DCSP avey = (float(reduce(operator.__add__, resmemusage)) / len(resmemusage)) DCNL DCSP sxy = reduce(operator.__add__, map((lambda a, avex=avex, avey=avey: ((a[0] - avex) * (a[1] - avey))), zip(resiters, resmemusage))) DCNL DCSP sxx = reduce(operator.__add__, map((lambda a, avex=avex: ((a - avex) ** 2)), resiters)) DCNL DCSP if (sxx == 0): DCNL DCSP  DCSP return None DCNL DCSP return (sxy / sxx)
def generate_range(start=None, end=None, periods=None, offset=BDay(), time_rule=None): DCNL  DCSP if (time_rule is not None): DCNL DCSP  DCSP from pandas.tseries.frequencies import get_offset DCNL DCSP  DCSP offset = get_offset(time_rule) DCNL DCSP start = to_datetime(start) DCNL DCSP end = to_datetime(end) DCNL DCSP if (start and (not offset.onOffset(start))): DCNL DCSP  DCSP start = offset.rollforward(start) DCNL DCSP elif (end and (not offset.onOffset(end))): DCNL DCSP  DCSP end = offset.rollback(end) DCNL DCSP if ((periods is None) and (end < start)): DCNL DCSP  DCSP end = None DCNL DCSP  DCSP periods = 0 DCNL DCSP if (end is None): DCNL DCSP  DCSP end = (start + ((periods - 1) * offset)) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = (end - ((periods - 1) * offset)) DCNL DCSP cur = start DCNL DCSP if (offset.n >= 0): DCNL DCSP  DCSP while (cur <= end): DCNL DCSP  DCSP  DCSP (yield cur) DCNL DCSP  DCSP  DCSP next_date = offset.apply(cur) DCNL DCSP  DCSP  DCSP if (next_date <= cur): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Offset DCSP %s DCSP did DCSP not DCSP increment DCSP date' % offset)) DCNL DCSP  DCSP  DCSP cur = next_date DCNL DCSP else: DCNL DCSP  DCSP while (cur >= end): DCNL DCSP  DCSP  DCSP (yield cur) DCNL DCSP  DCSP  DCSP next_date = offset.apply(cur) DCNL DCSP  DCSP  DCSP if (next_date >= cur): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Offset DCSP %s DCSP did DCSP not DCSP decrement DCSP date' % offset)) DCNL DCSP  DCSP  DCSP cur = next_date
def render_record(response, record, file_url=None, extra_data=None): DCNL  DCSP data = {} DCNL DCSP if (extra_data is not None): DCNL DCSP  DCSP data.update(extra_data) DCNL DCSP if (record is None): DCNL DCSP  DCSP if (extra_data is None): DCNL DCSP  DCSP  DCSP response.set_status(404) DCNL DCSP  DCSP response.out.write(render('details.html', data)) DCNL DCSP  DCSP return DCNL DCSP data.update(get_details_data(record, file_url)) DCNL DCSP response.out.write(render('details.html', data))
def _get_proc_create_time(proc): DCNL  DCSP try: DCNL DCSP  DCSP return (proc.create_time() if PSUTIL2 else proc.create_time) DCNL DCSP except (psutil.NoSuchProcess, psutil.AccessDenied): DCNL DCSP  DCSP return None
@context.quietfunc DCNL def packages(): DCNL  DCSP packages = process(['pm', 'list', 'packages']).recvall() DCNL DCSP return [line.split('package:', 1)[(-1)] for line in packages.splitlines()]
def get_disk_bus_for_device_type(virt_type, image_meta=None, device_type='disk'): DCNL  DCSP if image_meta: DCNL DCSP  DCSP key = (('hw_' + device_type) + '_bus') DCNL DCSP  DCSP disk_bus = image_meta.get('properties', {}).get(key) DCNL DCSP  DCSP if (disk_bus is not None): DCNL DCSP  DCSP  DCSP if (not is_disk_bus_valid_for_virt(virt_type, disk_bus)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupportedHardware(model=disk_bus, virt=virt_type) DCNL DCSP  DCSP  DCSP return disk_bus DCNL DCSP if (virt_type == 'uml'): DCNL DCSP  DCSP if (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'uml' DCNL DCSP elif (virt_type == 'lxc'): DCNL DCSP  DCSP return 'lxc' DCNL DCSP elif (virt_type == 'xen'): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP elif (virt_type in ('qemu', 'kvm')): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'virtio' DCNL DCSP return None
def version(proxy): DCNL  DCSP if proxy: DCNL DCSP  DCSP return {'version': _get_grain(proxy, 'os_version')}
@require_context DCNL def virtual_interface_get_by_uuid(context, vif_uuid): DCNL  DCSP vif_ref = _virtual_interface_query(context).filter_by(uuid=vif_uuid).first() DCNL DCSP return vif_ref
def spawn(coro): DCNL  DCSP if (not isinstance(coro, types.GeneratorType)): DCNL DCSP  DCSP raise ValueError((u'%s DCSP is DCSP not DCSP a DCSP coroutine' % coro)) DCNL DCSP return SpawnEvent(coro)
def test_raw_unicode_escape_dashes(): DCNL  DCSP ok = True DCNL DCSP try: DCNL DCSP  DCSP unicode('hey', 'raw_unicode-escape') DCNL DCSP except LookupError: DCNL DCSP  DCSP ok = False DCNL DCSP Assert(ok, 'dashes DCSP and DCSP underscores DCSP should DCSP be DCSP interchangable')
def implements(obj, interface): DCNL  DCSP kimplements = getattr(obj, '__implements__', ()) DCNL DCSP if (not isinstance(kimplements, (list, tuple))): DCNL DCSP  DCSP kimplements = (kimplements,) DCNL DCSP for implementedinterface in kimplements: DCNL DCSP  DCSP if issubclass(implementedinterface, interface): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@with_setup(prepare_stdout) DCNL def test_output_outlines_success_colorless(): DCNL  DCSP runner = Runner(join_path('ru', 'success', 'outlines.feature'), verbosity=3, no_color=True) DCNL DCSP runner.run() DCNL DCSP assert_stdout_lines(u'\n\u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b: DCSP \u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c DCSP \u0432\u044b\u0432\u043e\u0434 DCSP \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043d\u043e\u0433\u043e DCSP \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u044f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:3\n DCSP  DCSP \u041a\u0430\u043a DCSP \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0441\u0442 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:4\n DCSP  DCSP \u0414\u043b\u044f DCSP \u0442\u043e\u0433\u043e DCSP \u0447\u043e\u0431\u044b DCSP lettuce DCSP \u0431\u044b\u043b DCSP \u043d\u0430\u0434\u0435\u0436\u043d\u044b\u043c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:5\n DCSP  DCSP \u042f DCSP \u0445\u043e\u0447\u0443, DCSP \u0447\u0442\u043e DCSP \u0431\u044b DCSP \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0438 DCSP \u0441\u043e DCSP \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 DCSP \u0440\u0430\u0431\u043e\u0442\u0430\u043b\u0438 DCSP \u043d\u0430 DCSP \u0440\u0443\u0441\u0441\u043a\u043e\u043c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:6\n\n DCSP  DCSP \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 DCSP \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u044f: DCSP \u0417\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c DCSP \u0444\u043e\u0440\u043c\u0443 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:8\n DCSP  DCSP  DCSP  DCSP \u041f\u0443\u0441\u043a\u0430\u0439 DCSP \u044f DCSP \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u044e DCSP \u0432 DCSP \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 DCSP  DCSP "http://sona-studio.com/contacts/" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:12\n DCSP  DCSP  DCSP  DCSP \u041a\u043e\u0433\u0434\u0430 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "\u0418\u043c\u044f" DCSP "<\u0438\u043c\u044f>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:16\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "Email" DCSP "<email>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:24\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435" DCSP "<\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:32\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u043d\u0430\u0436\u0438\u043c\u0430\u044e DCSP "\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:40\n DCSP  DCSP  DCSP  DCSP \u0422\u043e\u0433\u0434\u0430 DCSP \u044f DCSP \u043f\u043e\u043b\u0443\u0447\u0430\u044e DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 DCSP "\u0421\u043f\u0430\u0441\u0438\u0431\u043e DCSP \u0437\u0430 DCSP \u0432\u0430\u0448\u0435 DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:43\n\n DCSP  DCSP \u041f\u0440\u0438\u043c\u0435\u0440\u044b:\n DCSP  DCSP  DCSP  DCSP | DCSP \u0438\u043c\u044f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP email DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP |\n DCSP  DCSP  DCSP  DCSP | DCSP \u0412\u0438\u0442\u0430\u043b\u0438\u0439 DCSP \u0418\u0433\u043e\u0440\u0435\u0432\u0438\u0447 DCSP | DCSP john@gmail.org DCSP | DCSP \u0415\u0441\u0442\u044c DCSP \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043d\u044b\u0439 DCSP \u043f\u0440\u043e\u0435\u043a\u0442, DCSP \u043d\u0443\u0436\u043d\u043e DCSP \u043e\u0431\u0441\u0443\u0434\u0438\u0442\u044c DCSP |\n DCSP  DCSP  DCSP  DCSP | DCSP \u041c\u0430\u0440\u0438\u043d\u0430 DCSP \u0411\u0430\u043d\u0440\u0430\u0443\u043b DCSP  DCSP  DCSP | DCSP mary@email.com DCSP | DCSP \u041c\u043d\u0435 DCSP \u043d\u0440\u0430\u0432\u044f\u0442\u0441\u044f DCSP \u0432\u0430\u0448\u0438 DCSP \u0434\u0438\u0437\u0430\u0439\u043d\u044b, DCSP \u0445\u043e\u0447\u0443 DCSP \u0441\u0430\u0439\u0442 DCSP  DCSP  DCSP |\n\n1 DCSP feature DCSP (1 DCSP passed)\n2 DCSP scenarios DCSP (2 DCSP passed)\n12 DCSP steps DCSP (12 DCSP passed)\n')
def test_missing_data_pandas(): DCNL  DCSP X = np.random.random((10, 5)) DCNL DCSP X[(1, 2)] = np.nan DCNL DCSP df = pandas.DataFrame(X) DCNL DCSP (vals, cnames, rnames) = data.interpret_data(df) DCNL DCSP np.testing.assert_equal(rnames.tolist(), [0, 2, 3, 4, 5, 6, 7, 8, 9])
def URL(a=None, c=None, f=None, r=None, args=None, vars=None, anchor='', extension=None, env=None, hmac_key=None, hash_vars=True, salt=None, user_signature=None, scheme=None, host=None, port=None, encode_embedded_slash=False, url_encode=True, language=None): DCNL  DCSP from gluon.rewrite import url_out DCNL DCSP if (args in (None, [])): DCNL DCSP  DCSP args = [] DCNL DCSP vars = (vars or {}) DCNL DCSP application = None DCNL DCSP controller = None DCNL DCSP function = None DCNL DCSP if (not isinstance(args, (list, tuple))): DCNL DCSP  DCSP args = [args] DCNL DCSP if (not r): DCNL DCSP  DCSP if (a and (not c) and (not f)): DCNL DCSP  DCSP  DCSP (f, a, c) = (a, c, f) DCNL DCSP  DCSP elif (a and c and (not f)): DCNL DCSP  DCSP  DCSP (c, f, a) = (a, c, f) DCNL DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP if hasattr(current, 'request'): DCNL DCSP  DCSP  DCSP r = current.request DCNL DCSP if r: DCNL DCSP  DCSP application = r.application DCNL DCSP  DCSP controller = r.controller DCNL DCSP  DCSP function = r.function DCNL DCSP  DCSP env = r.env DCNL DCSP  DCSP if ((extension is None) and (r.extension != 'html')): DCNL DCSP  DCSP  DCSP extension = r.extension DCNL DCSP if a: DCNL DCSP  DCSP application = a DCNL DCSP if c: DCNL DCSP  DCSP controller = c DCNL DCSP if f: DCNL DCSP  DCSP if (not isinstance(f, str)): DCNL DCSP  DCSP  DCSP if hasattr(f, '__name__'): DCNL DCSP  DCSP  DCSP  DCSP function = f.__name__ DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SyntaxError('when DCSP calling DCSP URL, DCSP function DCSP or DCSP function DCSP name DCSP required') DCNL DCSP  DCSP elif ('/' in f): DCNL DCSP  DCSP  DCSP if f.startswith('/'): DCNL DCSP  DCSP  DCSP  DCSP f = f[1:] DCNL DCSP  DCSP  DCSP items = f.split('/') DCNL DCSP  DCSP  DCSP function = f = items[0] DCNL DCSP  DCSP  DCSP args = (items[1:] + args) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP function = f DCNL DCSP  DCSP if (controller == 'static'): DCNL DCSP  DCSP  DCSP extension = None DCNL DCSP  DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP  DCSP if hasattr(current, 'response'): DCNL DCSP  DCSP  DCSP  DCSP response = current.response DCNL DCSP  DCSP  DCSP  DCSP if (response.static_version and response.static_version_urls): DCNL DCSP  DCSP  DCSP  DCSP  DCSP args = ([function] + args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP function = ('_' + str(response.static_version)) DCNL DCSP  DCSP if ('.' in function): DCNL DCSP  DCSP  DCSP (function, extension) = function.rsplit('.', 1) DCNL DCSP function2 = ('%s.%s' % (function, (extension or 'html'))) DCNL DCSP if (not (application and controller and function)): DCNL DCSP  DCSP raise SyntaxError(('not DCSP enough DCSP information DCSP to DCSP build DCSP the DCSP url DCSP (%s DCSP %s DCSP %s)' % (application, controller, function))) DCNL DCSP if args: DCNL DCSP  DCSP if url_encode: DCNL DCSP  DCSP  DCSP if encode_embedded_slash: DCNL DCSP  DCSP  DCSP  DCSP other = ('/' + '/'.join([urllib_quote(str(x), '') for x in args])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP other = (args and urllib_quote(('/' + '/'.join([str(x) for x in args])))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other = (args and ('/' + '/'.join([str(x) for x in args]))) DCNL DCSP else: DCNL DCSP  DCSP other = '' DCNL DCSP if other.endswith('/'): DCNL DCSP  DCSP other += '/' DCNL DCSP list_vars = [] DCNL DCSP for (key, vals) in sorted(vars.items()): DCNL DCSP  DCSP if (key == '_signature'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not isinstance(vals, (list, tuple))): DCNL DCSP  DCSP  DCSP vals = [vals] DCNL DCSP  DCSP for val in vals: DCNL DCSP  DCSP  DCSP list_vars.append((key, val)) DCNL DCSP if user_signature: DCNL DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP if current.session.auth: DCNL DCSP  DCSP  DCSP hmac_key = current.session.auth.hmac_key DCNL DCSP if hmac_key: DCNL DCSP  DCSP h_args = ('/%s/%s/%s%s' % (application, controller, function2, other)) DCNL DCSP  DCSP if (hash_vars is True): DCNL DCSP  DCSP  DCSP h_vars = list_vars DCNL DCSP  DCSP elif (hash_vars is False): DCNL DCSP  DCSP  DCSP h_vars = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (hash_vars and (not isinstance(hash_vars, (list, tuple)))): DCNL DCSP  DCSP  DCSP  DCSP hash_vars = [hash_vars] DCNL DCSP  DCSP  DCSP h_vars = [(k, v) for (k, v) in list_vars if (k in hash_vars)] DCNL DCSP  DCSP message = ((h_args + '?') + urlencode(sorted(h_vars))) DCNL DCSP  DCSP sig = simple_hash(message, (hmac_key or ''), (salt or ''), digest_alg='sha1') DCNL DCSP  DCSP list_vars.append(('_signature', sig)) DCNL DCSP if list_vars: DCNL DCSP  DCSP if url_encode: DCNL DCSP  DCSP  DCSP other += ('?%s' % urlencode(list_vars)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other += ('?%s' % '&'.join([('%s=%s' % var[:2]) for var in list_vars])) DCNL DCSP if anchor: DCNL DCSP  DCSP if url_encode: DCNL DCSP  DCSP  DCSP other += ('#' + urllib_quote(str(anchor))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other += ('#' + str(anchor)) DCNL DCSP if extension: DCNL DCSP  DCSP function += ('.' + extension) DCNL DCSP if regex_crlf.search(join([application, controller, function, other])): DCNL DCSP  DCSP raise SyntaxError('CRLF DCSP Injection DCSP Detected') DCNL DCSP url = url_out(r, env, application, controller, function, args, other, scheme, host, port, language=language) DCNL DCSP return url
@core_helper DCNL @maintain.deprecated('h.subnav_named_route DCSP is DCSP deprecated DCSP please DCSP use DCSP h.nav_link\nNOTE: DCSP you DCSP will DCSP need DCSP to DCSP pass DCSP the DCSP route_name DCSP as DCSP a DCSP named DCSP parameter') DCNL def subnav_named_route(text, named_route, **kwargs): DCNL  DCSP return nav_link(text, named_route=named_route, **kwargs)
def direct_get_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, headers={}): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, headers=headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP if resp_chunk_size: DCNL DCSP  DCSP def _object_body(): DCNL DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP  DCSP while buf: DCNL DCSP  DCSP  DCSP  DCSP (yield buf) DCNL DCSP  DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP object_body = _object_body() DCNL DCSP else: DCNL DCSP  DCSP object_body = resp.read() DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return (resp_headers, object_body)
def residue_reduce_to_basic(H, DE, z): DCNL  DCSP i = Dummy('i') DCNL DCSP s = list(zip(reversed(DE.T), reversed([f(DE.x) for f in DE.Tfuncs]))) DCNL DCSP return sum((RootSum(a[0].as_poly(z), Lambda(i, (i * log(a[1].as_expr()).subs({z: i}).subs(s)))) for a in H))
def get_sid_string(principal): DCNL  DCSP try: DCNL DCSP  DCSP return win32security.ConvertSidToStringSid(principal) DCNL DCSP except TypeError: DCNL DCSP  DCSP principal = get_sid(principal) DCNL DCSP try: DCNL DCSP  DCSP return win32security.ConvertSidToStringSid(principal) DCNL DCSP except pywintypes.error: DCNL DCSP  DCSP raise CommandExecutionError('Invalid DCSP principal DCSP {0}'.format(principal))
def get_bs_object_for_view(request, view, user, object=None): DCNL  DCSP with override_provides('service_provider_admin_form', ['shuup.testing.service_forms.PseudoPaymentProcessorForm', 'shuup.admin.modules.service_providers.forms:CustomCarrierForm', 'shuup.admin.modules.service_providers.forms:CustomPaymentProcessorForm']): DCNL DCSP  DCSP request = apply_all_middleware(request, user=user) DCNL DCSP  DCSP response = view(request, pk=(object.pk if object else None)) DCNL DCSP  DCSP if hasattr(response, 'render'): DCNL DCSP  DCSP  DCSP response.render() DCNL DCSP  DCSP assert (response.status_code in [200, 302]) DCNL DCSP  DCSP return BeautifulSoup(response.content)
def get_ratio(old, new): DCNL  DCSP if (not all([old, new])): DCNL DCSP  DCSP return VERSIONING_RATIO DCNL DCSP return (levenshtein_distance(old, new) / (len(old) / 100.0))
@auth_decorator DCNL def token_authenticated(self): DCNL  DCSP if (self.get_current_user_token() is None): DCNL DCSP  DCSP raise web.HTTPError(403)
def f3(): DCNL  DCSP x = 1.0 DCNL DCSP y = 1 DCNL DCSP z = 123456789123456789 DCNL DCSP s = 'hello DCSP world' DCNL DCSP t = (1.0, 'asdf') DCNL DCSP print sorted(locals().items()) DCNL DCSP print sorted(vars().items())
def create_account_with_params(request, params): DCNL  DCSP params = dict(params.items()) DCNL DCSP extra_fields = configuration_helpers.get_value('REGISTRATION_EXTRA_FIELDS', getattr(settings, 'REGISTRATION_EXTRA_FIELDS', {})) DCNL DCSP should_link_with_social_auth = (third_party_auth.is_enabled() and ('provider' in params)) DCNL DCSP if (should_link_with_social_auth or (third_party_auth.is_enabled() and pipeline.running(request))): DCNL DCSP  DCSP params['password'] = pipeline.make_random_password() DCNL DCSP extra_fields['data_sharing_consent'] = data_sharing_consent_requirement_at_login(request) DCNL DCSP do_external_auth = ('ExternalAuthMap' in request.session) DCNL DCSP if do_external_auth: DCNL DCSP  DCSP eamap = request.session['ExternalAuthMap'] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP validate_email(eamap.external_email) DCNL DCSP  DCSP  DCSP params['email'] = eamap.external_email DCNL DCSP  DCSP except ValidationError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (eamap.external_name.strip() != ''): DCNL DCSP  DCSP  DCSP params['name'] = eamap.external_name DCNL DCSP  DCSP params['password'] = eamap.internal_password DCNL DCSP  DCSP log.debug(u'In DCSP create_account DCSP with DCSP external_auth: DCSP user DCSP = DCSP %s, DCSP email=%s', params['name'], params['email']) DCNL DCSP extended_profile_fields = configuration_helpers.get_value('extended_profile_fields', []) DCNL DCSP enforce_password_policy = (settings.FEATURES.get('ENFORCE_PASSWORD_POLICY', False) and (not do_external_auth)) DCNL DCSP registration_fields = getattr(settings, 'REGISTRATION_EXTRA_FIELDS', {}) DCNL DCSP tos_required = (((registration_fields.get('terms_of_service') != 'hidden') or (registration_fields.get('honor_code') != 'hidden')) and ((not settings.FEATURES.get('AUTH_USE_SHIB')) or (not settings.FEATURES.get('SHIB_DISABLE_TOS')) or (not do_external_auth) or (not eamap.external_domain.startswith(openedx.core.djangoapps.external_auth.views.SHIBBOLETH_DOMAIN_PREFIX)))) DCNL DCSP form = AccountCreationForm(data=params, extra_fields=extra_fields, extended_profile_fields=extended_profile_fields, enforce_username_neq_password=True, enforce_password_policy=enforce_password_policy, tos_required=tos_required) DCNL DCSP custom_form = get_registration_extension_form(data=params) DCNL DCSP with transaction.atomic(): DCNL DCSP  DCSP (user, profile, registration) = _do_create_account(form, custom_form) DCNL DCSP  DCSP if should_link_with_social_auth: DCNL DCSP  DCSP  DCSP backend_name = params['provider'] DCNL DCSP  DCSP  DCSP request.social_strategy = social_utils.load_strategy(request) DCNL DCSP  DCSP  DCSP redirect_uri = reverse('social:complete', args=(backend_name,)) DCNL DCSP  DCSP  DCSP request.backend = social_utils.load_backend(request.social_strategy, backend_name, redirect_uri) DCNL DCSP  DCSP  DCSP social_access_token = params.get('access_token') DCNL DCSP  DCSP  DCSP if (not social_access_token): DCNL DCSP  DCSP  DCSP  DCSP raise ValidationError({'access_token': [_('An DCSP access_token DCSP is DCSP required DCSP when DCSP passing DCSP value DCSP ({}) DCSP for DCSP provider.').format(params['provider'])]}) DCNL DCSP  DCSP  DCSP request.session[pipeline.AUTH_ENTRY_KEY] = pipeline.AUTH_ENTRY_REGISTER_API DCNL DCSP  DCSP  DCSP pipeline_user = None DCNL DCSP  DCSP  DCSP error_message = '' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP pipeline_user = request.backend.do_auth(social_access_token, user=user) DCNL DCSP  DCSP  DCSP except AuthAlreadyAssociated: DCNL DCSP  DCSP  DCSP  DCSP error_message = _('The DCSP provided DCSP access_token DCSP is DCSP already DCSP associated DCSP with DCSP another DCSP user.') DCNL DCSP  DCSP  DCSP except (HTTPError, AuthException): DCNL DCSP  DCSP  DCSP  DCSP error_message = _('The DCSP provided DCSP access_token DCSP is DCSP not DCSP valid.') DCNL DCSP  DCSP  DCSP if ((not pipeline_user) or (not isinstance(pipeline_user, User))): DCNL DCSP  DCSP  DCSP  DCSP request.social_strategy.clean_partial_pipeline() DCNL DCSP  DCSP  DCSP  DCSP raise ValidationError({'access_token': [error_message]}) DCNL DCSP preferences_api.set_user_preference(user, LANGUAGE_KEY, get_language()) DCNL DCSP if settings.FEATURES.get('ENABLE_DISCUSSION_EMAIL_DIGEST'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP enable_notifications(user) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP log.exception('Enable DCSP discussion DCSP notifications DCSP failed DCSP for DCSP user DCSP {id}.'.format(id=user.id)) DCNL DCSP dog_stats_api.increment('common.student.account_created') DCNL DCSP third_party_provider = None DCNL DCSP running_pipeline = None DCNL DCSP if (third_party_auth.is_enabled() and pipeline.running(request)): DCNL DCSP  DCSP running_pipeline = pipeline.get(request) DCNL DCSP  DCSP third_party_provider = provider.Registry.get_from_pipeline(running_pipeline) DCNL DCSP  DCSP running_pipeline['kwargs']['data_sharing_consent'] = form.cleaned_data.get('data_sharing_consent', None) DCNL DCSP if (hasattr(settings, 'LMS_SEGMENT_KEY') and settings.LMS_SEGMENT_KEY): DCNL DCSP  DCSP tracking_context = tracker.get_tracker().resolve_context() DCNL DCSP  DCSP identity_args = [user.id, {'email': user.email, 'username': user.username, 'name': profile.name, 'age': (profile.age or (-1)), 'yearOfBirth': (profile.year_of_birth or datetime.datetime.now(UTC).year), 'education': profile.level_of_education_display, 'address': profile.mailing_address, 'gender': profile.gender_display, 'country': unicode(profile.country)}] DCNL DCSP  DCSP if hasattr(settings, 'MAILCHIMP_NEW_USER_LIST_ID'): DCNL DCSP  DCSP  DCSP identity_args.append({'MailChimp': {'listId': settings.MAILCHIMP_NEW_USER_LIST_ID}}) DCNL DCSP  DCSP analytics.identify(*identity_args) DCNL DCSP  DCSP analytics.track(user.id, 'edx.bi.user.account.registered', {'category': 'conversion', 'label': params.get('course_id'), 'provider': (third_party_provider.name if third_party_provider else None)}, context={'ip': tracking_context.get('ip'), 'Google DCSP Analytics': {'clientId': tracking_context.get('client_id')}}) DCNL DCSP REGISTER_USER.send(sender=None, user=user, profile=profile) DCNL DCSP create_comments_service_user(user) DCNL DCSP send_email = ((not settings.FEATURES.get('SKIP_EMAIL_VALIDATION', None)) and (not settings.FEATURES.get('AUTOMATIC_AUTH_FOR_TESTING')) and (not (do_external_auth and settings.FEATURES.get('BYPASS_ACTIVATION_EMAIL_FOR_EXTAUTH'))) and (not (third_party_provider and third_party_provider.skip_email_verification and (user.email == running_pipeline['kwargs'].get('details', {}).get('email'))))) DCNL DCSP if send_email: DCNL DCSP  DCSP dest_addr = user.email DCNL DCSP  DCSP context = {'name': profile.name, 'key': registration.activation_key} DCNL DCSP  DCSP subject = render_to_string('emails/activation_email_subject.txt', context) DCNL DCSP  DCSP subject = ''.join(subject.splitlines()) DCNL DCSP  DCSP message = render_to_string('emails/activation_email.txt', context) DCNL DCSP  DCSP from_address = configuration_helpers.get_value('email_from_address', settings.DEFAULT_FROM_EMAIL) DCNL DCSP  DCSP if settings.FEATURES.get('REROUTE_ACTIVATION_EMAIL'): DCNL DCSP  DCSP  DCSP dest_addr = settings.FEATURES['REROUTE_ACTIVATION_EMAIL'] DCNL DCSP  DCSP  DCSP message = (((('Activation DCSP for DCSP %s DCSP (%s): DCSP %s\n' % (user, user.email, profile.name)) + ('-' * 80)) + '\n\n') + message) DCNL DCSP  DCSP send_activation_email.delay(subject, message, from_address, dest_addr) DCNL DCSP else: DCNL DCSP  DCSP registration.activate() DCNL DCSP  DCSP _enroll_user_in_pending_courses(user) DCNL DCSP new_user = authenticate(username=user.username, password=params['password']) DCNL DCSP login(request, new_user) DCNL DCSP request.session.set_expiry(0) DCNL DCSP try: DCNL DCSP  DCSP record_registration_attributions(request, new_user) DCNL DCSP except Exception: DCNL DCSP  DCSP log.exception('Error DCSP while DCSP attributing DCSP cookies DCSP to DCSP user DCSP registration.') DCNL DCSP if (new_user is not None): DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP on DCSP new DCSP account DCSP creation DCSP - DCSP {0}'.format(new_user.username)) DCNL DCSP if do_external_auth: DCNL DCSP  DCSP eamap.user = new_user DCNL DCSP  DCSP eamap.dtsignup = datetime.datetime.now(UTC) DCNL DCSP  DCSP eamap.save() DCNL DCSP  DCSP AUDIT_LOG.info(u'User DCSP registered DCSP with DCSP external_auth DCSP %s', new_user.username) DCNL DCSP  DCSP AUDIT_LOG.info(u'Updated DCSP ExternalAuthMap DCSP for DCSP %s DCSP to DCSP be DCSP %s', new_user.username, eamap) DCNL DCSP  DCSP if settings.FEATURES.get('BYPASS_ACTIVATION_EMAIL_FOR_EXTAUTH'): DCNL DCSP  DCSP  DCSP log.info('bypassing DCSP activation DCSP email') DCNL DCSP  DCSP  DCSP new_user.is_active = True DCNL DCSP  DCSP  DCSP new_user.save() DCNL DCSP  DCSP  DCSP AUDIT_LOG.info(u'Login DCSP activated DCSP on DCSP extauth DCSP account DCSP - DCSP {0} DCSP ({1})'.format(new_user.username, new_user.email)) DCNL DCSP return new_user
def compose(*functions): DCNL  DCSP def _composed(*args): DCNL DCSP  DCSP for fn in functions: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP args = fn(*args) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP args = fn(args) DCNL DCSP  DCSP return args DCNL DCSP return _composed
@require_role('admin') DCNL def asset_update(request): DCNL  DCSP asset_id = request.GET.get('id', '') DCNL DCSP asset = get_object(Asset, id=asset_id) DCNL DCSP name = request.user.username DCNL DCSP if (not asset): DCNL DCSP  DCSP return HttpResponseRedirect((reverse('asset_detail') + ('?id=%s' % asset_id))) DCNL DCSP else: DCNL DCSP  DCSP asset_ansible_update([asset], name) DCNL DCSP return HttpResponseRedirect((reverse('asset_detail') + ('?id=%s' % asset_id)))
def ode_1st_homogeneous_coeff_subs_dep_div_indep(eq, func, order, match): DCNL  DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP u = Dummy('u') DCNL DCSP u1 = Dummy('u1') DCNL DCSP r = match DCNL DCSP C1 = get_numbered_constants(eq, num=1) DCNL DCSP xarg = match.get('xarg', 0) DCNL DCSP yarg = match.get('yarg', 0) DCNL DCSP int = Integral(((- r[r['e']]) / (r[r['d']] + (u1 * r[r['e']]))).subs({x: 1, r['y']: u1}), (u1, None, (f(x) / x))) DCNL DCSP sol = logcombine(Eq(log(x), (int + log(C1))), force=True) DCNL DCSP sol = sol.subs(f(x), u).subs(((u, (u - yarg)), (x, (x - xarg)), (u, f(x)))) DCNL DCSP return sol
@register.inclusion_tag('inclusion.html') DCNL def inclusion_two_params(one, two): DCNL  DCSP return {'result': ('inclusion_two_params DCSP - DCSP Expected DCSP result: DCSP %s, DCSP %s' % (one, two))}
def call_command(name, *args, **options): DCNL  DCSP try: DCNL DCSP  DCSP app_name = get_commands()[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise CommandError(('Unknown DCSP command: DCSP %r' % name)) DCNL DCSP if isinstance(app_name, BaseCommand): DCNL DCSP  DCSP klass = app_name DCNL DCSP else: DCNL DCSP  DCSP klass = load_command_class(app_name, name) DCNL DCSP defaults = {} DCNL DCSP for opt in klass.option_list: DCNL DCSP  DCSP if (opt.default is NO_DEFAULT): DCNL DCSP  DCSP  DCSP defaults[opt.dest] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP defaults[opt.dest] = opt.default DCNL DCSP defaults.update(options) DCNL DCSP return klass.execute(*args, **defaults)
def add_prerequisite(course_key, prereq_content_key): DCNL  DCSP milestone = milestones_api.add_milestone({'name': _('Gating DCSP milestone DCSP for DCSP {usage_key}').format(usage_key=unicode(prereq_content_key)), 'namespace': '{usage_key}{qualifier}'.format(usage_key=prereq_content_key, qualifier=GATING_NAMESPACE_QUALIFIER), 'description': _('System DCSP defined DCSP milestone')}, propagate=False) DCNL DCSP milestones_api.add_course_content_milestone(course_key, prereq_content_key, 'fulfills', milestone)
def HostAPI(*args, **kwargs): DCNL  DCSP compute_api_class_name = _get_compute_api_class_name() DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__module__ + '.HostAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
def run_script_with_context(script_path, cwd, context): DCNL  DCSP (_, extension) = os.path.splitext(script_path) DCNL DCSP contents = io.open(script_path, 'r', encoding='utf-8').read() DCNL DCSP with tempfile.NamedTemporaryFile(delete=False, mode='wb', suffix=extension) as temp: DCNL DCSP  DCSP env = StrictEnvironment(context=context, keep_trailing_newline=True) DCNL DCSP  DCSP template = env.from_string(contents) DCNL DCSP  DCSP output = template.render(**context) DCNL DCSP  DCSP temp.write(output.encode('utf-8')) DCNL DCSP run_script(temp.name, cwd)
def _filter_ipv4(addresses): DCNL  DCSP return [address for address in addresses if is_valid_ip_address(address=address, family=socket.AF_INET)]
def square(x): DCNL  DCSP return tf.square(x)
def lag_select(data, max_lags=5, ic=None): DCNL  DCSP pass
def setup_livestreamer(): DCNL  DCSP global livestreamer DCNL DCSP livestreamer = Livestreamer()
def __virtual__(): DCNL  DCSP if (not HAS_BOTO): DCNL DCSP  DCSP return (False, 'The DCSP module DCSP boto_cfs DCSP could DCSP not DCSP be DCSP loaded: DCSP boto DCSP libraries DCSP not DCSP found') DCNL DCSP return True
def bokeh_tree(name, rawtext, text, lineno, inliner, options=None, content=None): DCNL  DCSP app = inliner.document.settings.env.app DCNL DCSP tag = app.env.config['version'] DCNL DCSP if ('-' in tag): DCNL DCSP  DCSP tag = 'master' DCNL DCSP url = ('%s/tree/%s/%s' % (BOKEH_GH, tag, text)) DCNL DCSP _try_url(app, url, 'tree') DCNL DCSP options = (options or {}) DCNL DCSP set_classes(options) DCNL DCSP node = nodes.reference(rawtext, text, refuri=url, **options) DCNL DCSP return ([node], [])
def toptexts(query, texts, index, n=10): DCNL  DCSP sims = index[query] DCNL DCSP sims = sorted(enumerate(sims), key=(lambda item: (- item[1]))) DCNL DCSP result = [] DCNL DCSP for (topid, topcosine) in sims[:n]: DCNL DCSP  DCSP result.append((topid, topcosine, texts[topid])) DCNL DCSP return result
@register.tag('cache') DCNL def do_cache(parser, token): DCNL  DCSP nodelist = parser.parse(('endcache',)) DCNL DCSP parser.delete_first_token() DCNL DCSP tokens = token.split_contents() DCNL DCSP if (len(tokens) < 3): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%r' DCSP tag DCSP requires DCSP at DCSP least DCSP 2 DCSP arguments." % tokens[0])) DCNL DCSP if ((len(tokens) > 3) and tokens[(-1)].startswith('using=')): DCNL DCSP  DCSP cache_name = parser.compile_filter(tokens[(-1)][len('using='):]) DCNL DCSP  DCSP tokens = tokens[:(-1)] DCNL DCSP else: DCNL DCSP  DCSP cache_name = None DCNL DCSP return CacheNode(nodelist, parser.compile_filter(tokens[1]), tokens[2], [parser.compile_filter(t) for t in tokens[3:]], cache_name)
def unlock(hass, entity_id=None, code=None): DCNL  DCSP data = {} DCNL DCSP if code: DCNL DCSP  DCSP data[ATTR_CODE] = code DCNL DCSP if entity_id: DCNL DCSP  DCSP data[ATTR_ENTITY_ID] = entity_id DCNL DCSP hass.services.call(DOMAIN, SERVICE_UNLOCK, data)
def KernelVersion(): DCNL  DCSP rtl_osversioninfoexw = RtlOSVersionInfoExw() DCNL DCSP try: DCNL DCSP  DCSP RtlGetVersion(rtl_osversioninfoexw) DCNL DCSP except exceptions.WindowsError: DCNL DCSP  DCSP return 'unknown' DCNL DCSP return ('%d.%d.%d' % (rtl_osversioninfoexw.dwMajorVersion, rtl_osversioninfoexw.dwMinorVersion, rtl_osversioninfoexw.dwBuildNumber))
@tasklets.tasklet DCNL def fetch_data_async(blob, start_index, end_index, **options): DCNL  DCSP if isinstance(blob, BlobInfo): DCNL DCSP  DCSP blob = blob.key() DCNL DCSP rpc = blobstore.create_rpc(**options) DCNL DCSP rpc = blobstore.fetch_data_async(blob, start_index, end_index, rpc=rpc) DCNL DCSP result = (yield rpc) DCNL DCSP raise tasklets.Return(result)
def csd(x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=(-1)): DCNL  DCSP (freqs, _, Pxy) = _spectral_helper(x, y, fs, window, nperseg, noverlap, nfft, detrend, return_onesided, scaling, axis, mode='psd') DCNL DCSP if ((len(Pxy.shape) >= 2) and (Pxy.size > 0)): DCNL DCSP  DCSP if (Pxy.shape[(-1)] > 1): DCNL DCSP  DCSP  DCSP Pxy = Pxy.mean(axis=(-1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Pxy = np.reshape(Pxy, Pxy.shape[:(-1)]) DCNL DCSP return (freqs, Pxy)
def check_output(command, cwd=None, shell=False, env=None, stdin=__sentinel__, stderr=__sentinel__, preexec_fn=None, use_texpath=True, show_window=False): DCNL  DCSP (returncode, stdout, stderr) = execute_command(command, cwd=cwd, shell=shell, env=env, stdin=stdin, stderr=stderr, preexec_fn=preexec_fn, use_texpath=use_texpath, show_window=show_window) DCNL DCSP if returncode: DCNL DCSP  DCSP e = CalledProcessError(returncode, command) DCNL DCSP  DCSP e.output = stdout DCNL DCSP  DCSP e.stderr = stderr DCNL DCSP  DCSP raise e DCNL DCSP return stdout
def run_pyreverse(): DCNL  DCSP from pylint.pyreverse.main import Run DCNL DCSP Run(sys.argv[1:])
def scroll_page_up(event): DCNL  DCSP w = _current_window_for_event(event) DCNL DCSP b = event.cli.current_buffer DCNL DCSP if (w and w.render_info): DCNL DCSP  DCSP line_index = max(0, min(w.render_info.first_visible_line(), (b.document.cursor_position_row - 1))) DCNL DCSP  DCSP b.cursor_position = b.document.translate_row_col_to_index(line_index, 0) DCNL DCSP  DCSP b.cursor_position += b.document.get_start_of_line_position(after_whitespace=True) DCNL DCSP  DCSP w.vertical_scroll = 0
@hook.command('ghissue', 'issue') DCNL def issue(text): DCNL  DCSP args = text.split() DCNL DCSP repo = (args[0] if (args[0] not in shortcuts) else shortcuts[args[0]]) DCNL DCSP issue = (args[1] if (len(args) > 1) else None) DCNL DCSP if issue: DCNL DCSP  DCSP r = requests.get('https://api.github.com/repos/{}/issues/{}'.format(repo, issue)) DCNL DCSP  DCSP j = r.json() DCNL DCSP  DCSP url = web.try_shorten(j['html_url'], service='git.io') DCNL DCSP  DCSP number = j['number'] DCNL DCSP  DCSP title = j['title'] DCNL DCSP  DCSP summary = formatting.truncate(j['body'].split('\n')[0], 25) DCNL DCSP  DCSP if (j['state'] == 'open'): DCNL DCSP  DCSP  DCSP state = '\x033\x02Opened\x02\x0f DCSP by DCSP {}'.format(j['user']['login']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state = '\x034\x02Closed\x02\x0f DCSP by DCSP {}'.format(j['closed_by']['login']) DCNL DCSP  DCSP return 'Issue DCSP #{} DCSP ({}): DCSP {} DCSP | DCSP {}: DCSP {}'.format(number, state, url, title, summary) DCNL DCSP else: DCNL DCSP  DCSP r = requests.get('https://api.github.com/repos/{}/issues'.format(repo)) DCNL DCSP  DCSP j = r.json() DCNL DCSP  DCSP count = len(j) DCNL DCSP  DCSP if (count is 0): DCNL DCSP  DCSP  DCSP return 'Repository DCSP has DCSP no DCSP open DCSP issues.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'Repository DCSP has DCSP {} DCSP open DCSP issues.'.format(count)
def skip_unless_lms(func): DCNL  DCSP return skipUnless((settings.ROOT_URLCONF == 'lms.urls'), 'Test DCSP only DCSP valid DCSP in DCSP LMS')(func)
def getIndexedLoopFromIndexedGrid(indexedGrid): DCNL  DCSP indexedLoop = indexedGrid[0][:] DCNL DCSP for row in indexedGrid[1:(-1)]: DCNL DCSP  DCSP indexedLoop.append(row[(-1)]) DCNL DCSP indexedLoop += indexedGrid[(-1)][::(-1)] DCNL DCSP for row in indexedGrid[(len(indexedGrid) - 2):0:(-1)]: DCNL DCSP  DCSP indexedLoop.append(row[0]) DCNL DCSP return indexedLoop
def validate_password(user, password): DCNL  DCSP err_msg = None DCNL DCSP if settings.FEATURES.get('ENFORCE_PASSWORD_POLICY', False): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP validate_password_strength(password) DCNL DCSP  DCSP except ValidationError as err: DCNL DCSP  DCSP  DCSP err_msg = (_('Password: DCSP ') + '; DCSP '.join(err.messages)) DCNL DCSP if (not PasswordHistory.is_allowable_password_reuse(user, password)): DCNL DCSP  DCSP if user.is_staff: DCNL DCSP  DCSP  DCSP num_distinct = settings.ADVANCED_SECURITY_CONFIG['MIN_DIFFERENT_STAFF_PASSWORDS_BEFORE_REUSE'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num_distinct = settings.ADVANCED_SECURITY_CONFIG['MIN_DIFFERENT_STUDENT_PASSWORDS_BEFORE_REUSE'] DCNL DCSP  DCSP err_msg = ungettext('You DCSP are DCSP re-using DCSP a DCSP password DCSP that DCSP you DCSP have DCSP used DCSP recently. DCSP You DCSP must DCSP have DCSP {num} DCSP distinct DCSP password DCSP before DCSP reusing DCSP a DCSP previous DCSP password.', 'You DCSP are DCSP re-using DCSP a DCSP password DCSP that DCSP you DCSP have DCSP used DCSP recently. DCSP You DCSP must DCSP have DCSP {num} DCSP distinct DCSP passwords DCSP before DCSP reusing DCSP a DCSP previous DCSP password.', num_distinct).format(num=num_distinct) DCNL DCSP if PasswordHistory.is_password_reset_too_soon(user): DCNL DCSP  DCSP num_days = settings.ADVANCED_SECURITY_CONFIG['MIN_TIME_IN_DAYS_BETWEEN_ALLOWED_RESETS'] DCNL DCSP  DCSP err_msg = ungettext('You DCSP are DCSP resetting DCSP passwords DCSP too DCSP frequently. DCSP Due DCSP to DCSP security DCSP policies, DCSP {num} DCSP day DCSP must DCSP elapse DCSP between DCSP password DCSP resets.', 'You DCSP are DCSP resetting DCSP passwords DCSP too DCSP frequently. DCSP Due DCSP to DCSP security DCSP policies, DCSP {num} DCSP days DCSP must DCSP elapse DCSP between DCSP password DCSP resets.', num_days).format(num=num_days) DCNL DCSP is_password_valid = (err_msg is None) DCNL DCSP return (is_password_valid, err_msg)
def server_handled_successfully(status_int): DCNL  DCSP return (is_success(status_int) or is_redirection(status_int) or (status_int == HTTP_NOT_FOUND) or (status_int == HTTP_PRECONDITION_FAILED) or (status_int == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE))
def get_function_object(obj): DCNL  DCSP attr = getattr(obj, '__numba__', None) DCNL DCSP if attr: DCNL DCSP  DCSP return getattr(obj, attr) DCNL DCSP return obj
def get_service(hass, config, discovery_info=None): DCNL  DCSP import slacker DCNL DCSP try: DCNL DCSP  DCSP return SlackNotificationService(config[CONF_CHANNEL], config[CONF_API_KEY], config.get(CONF_USERNAME, None), config.get(CONF_ICON, None)) DCNL DCSP except slacker.Error: DCNL DCSP  DCSP _LOGGER.exception('Slack DCSP authentication DCSP failed') DCNL DCSP  DCSP return None
def maybeDeferred(f, *args, **kw): DCNL  DCSP try: DCNL DCSP  DCSP result = f(*args, **kw) DCNL DCSP except: DCNL DCSP  DCSP return fail(failure.Failure(captureVars=Deferred.debug)) DCNL DCSP if isinstance(result, Deferred): DCNL DCSP  DCSP return result DCNL DCSP elif isinstance(result, failure.Failure): DCNL DCSP  DCSP return fail(result) DCNL DCSP else: DCNL DCSP  DCSP return succeed(result)
def addToMenu(master, menu, repository, window): DCNL  DCSP metaFilePath = archive.getSkeinforgePluginsPath('meta.py') DCNL DCSP settings.addPluginsParentToMenu(skeinforge_meta.getPluginsDirectoryPath(), menu, metaFilePath, skeinforge_meta.getPluginFileNames())
def onlyPy26OrOlder(test): DCNL  DCSP @functools.wraps(test) DCNL DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP msg = '{name} DCSP only DCSP runs DCSP on DCSP Python2.6.x DCSP or DCSP older'.format(name=test.__name__) DCNL DCSP  DCSP if (sys.version_info >= (2, 7)): DCNL DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP return test(*args, **kwargs) DCNL DCSP return wrapper
def grain_funcs(opts, proxy=None): DCNL  DCSP return LazyLoader(_module_dirs(opts, 'grains', 'grain', ext_type_dirs='grains_dirs'), opts, tag='grains')
@_api_version(1.21) DCNL @_client_version('1.5.0') DCNL def connect_container_to_network(container, network_id): DCNL  DCSP response = _client_wrapper('connect_container_to_network', container, network_id) DCNL DCSP _clear_context() DCNL DCSP return response
def addListToListTable(elementList, key, listTable): DCNL  DCSP if (key in listTable): DCNL DCSP  DCSP listTable[key] += elementList DCNL DCSP else: DCNL DCSP  DCSP listTable[key] = elementList
def test_isotonic_regression_ties_secondary_(): DCNL  DCSP x = [8, 8, 8, 10, 10, 10, 12, 12, 12, 14, 14] DCNL DCSP y = [21, 23.5, 23, 24, 21, 25, 21.5, 22, 19, 23.5, 25] DCNL DCSP y_true = [22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 24.25, 24.25] DCNL DCSP ir = IsotonicRegression() DCNL DCSP ir.fit(x, y) DCNL DCSP assert_array_almost_equal(ir.transform(x), y_true, 4) DCNL DCSP assert_array_almost_equal(ir.fit_transform(x, y), y_true, 4)
def publish_badges(request): DCNL  DCSP return render(request, 'ecosystem/publish_badges.html', {'page': 'badges', 'category': 'publish'})
def Run(arg_dict, oauth2_parameters=None): DCNL  DCSP arg_dict = ProcessArguments(arg_dict) DCNL DCSP SetupLogging(arg_dict) DCNL DCSP return _PerformBulkload(arg_dict, oauth2_parameters)
def __virtual__(): DCNL  DCSP return ('boto_kms' if ('boto_kms.describe_key' in __salt__) else False)
def fitness_and_quality_parsed(mime_type, parsed_ranges): DCNL  DCSP (best_fitness, best_fit_q) = ((-1), 0) DCNL DCSP (target_type, target_subtype, target_params) = parse_media_range(mime_type) DCNL DCSP for (type, subtype, params) in parsed_ranges: DCNL DCSP  DCSP if (((type == target_type) or (type == '*') or (target_type == '*')) and ((subtype == target_subtype) or (subtype == '*') or (target_subtype == '*'))): DCNL DCSP  DCSP  DCSP fitness = 0 DCNL DCSP  DCSP  DCSP if (type == target_type): DCNL DCSP  DCSP  DCSP  DCSP fitness += 100 DCNL DCSP  DCSP  DCSP if (subtype == target_subtype): DCNL DCSP  DCSP  DCSP  DCSP fitness += 10 DCNL DCSP  DCSP  DCSP for key in target_params: DCNL DCSP  DCSP  DCSP  DCSP if ((key != 'q') and (key in params)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (params[key] == target_params[key]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fitness += 1 DCNL DCSP  DCSP  DCSP if (fitness > best_fitness): DCNL DCSP  DCSP  DCSP  DCSP best_fitness = fitness DCNL DCSP  DCSP  DCSP  DCSP best_fit_q = params['q'] DCNL DCSP return (best_fitness, float(best_fit_q))
def native(s): DCNL  DCSP if (not isinstance(s, (binary_type, text_type))): DCNL DCSP  DCSP raise TypeError(('%r DCSP is DCSP neither DCSP bytes DCSP nor DCSP unicode' % s)) DCNL DCSP if PY3: DCNL DCSP  DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP  DCSP return s.decode('utf-8') DCNL DCSP elif isinstance(s, text_type): DCNL DCSP  DCSP return s.encode('utf-8') DCNL DCSP return s
def test_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(cc.ratio, ratio)
def bump_version(version): DCNL  DCSP version_parts = [int(p) for p in version.split('.')] DCNL DCSP assert (len(version_parts) == 3), 'invalid DCSP version DCSP number' DCNL DCSP minor = '{}.{}'.format(*version_parts) DCNL DCSP major = '{}'.format(*version_parts) DCNL DCSP for (filename, locations) in VERSION_LOCS: DCNL DCSP  DCSP out_lines = [] DCNL DCSP  DCSP with open(filename) as f: DCNL DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP  DCSP for (pattern, template) in locations: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = re.match(pattern, line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP old_version = match.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP old_parts = [int(p) for p in old_version.split('.')] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (version_parts > old_parts), 'version DCSP must DCSP be DCSP newer DCSP than DCSP {}'.format(old_version) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out_lines.append((template.format(version=version, major=major, minor=minor) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out_lines.append(line) DCNL DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP print 'No DCSP pattern DCSP found DCSP in DCSP {}'.format(filename) DCNL DCSP  DCSP with open(filename, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(''.join(out_lines)) DCNL DCSP header_line = '{} DCSP (in DCSP development)'.format(version) DCNL DCSP header = (((('\n\n' + header_line) + '\n') + ('-' * len(header_line))) + '\n\n') DCNL DCSP header += 'Changelog DCSP goes DCSP here!\n' DCNL DCSP with open(CHANGELOG) as f: DCNL DCSP  DCSP contents = f.read() DCNL DCSP location = contents.find('\n\n') DCNL DCSP contents = ((contents[:location] + header) + contents[location:]) DCNL DCSP with open(CHANGELOG, 'w') as f: DCNL DCSP  DCSP f.write(contents)
def getRevisionNumber(): DCNL  DCSP retVal = None DCNL DCSP filePath = None DCNL DCSP _ = os.path.dirname(__file__) DCNL DCSP while True: DCNL DCSP  DCSP filePath = os.path.join(_, '.git', 'HEAD') DCNL DCSP  DCSP if os.path.exists(filePath): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filePath = None DCNL DCSP  DCSP  DCSP if (_ == os.path.dirname(_)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _ = os.path.dirname(_) DCNL DCSP while True: DCNL DCSP  DCSP if (filePath and os.path.isfile(filePath)): DCNL DCSP  DCSP  DCSP with open(filePath, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP content = f.read() DCNL DCSP  DCSP  DCSP  DCSP filePath = None DCNL DCSP  DCSP  DCSP  DCSP if content.startswith('ref: DCSP '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP filePath = os.path.join(_, '.git', content.replace('ref: DCSP ', '')).strip() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = re.match('(?i)[0-9a-f]{32}', content) DCNL DCSP  DCSP  DCSP  DCSP  DCSP retVal = (match.group(0) if match else None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not retVal): DCNL DCSP  DCSP process = subprocess.Popen('git DCSP rev-parse DCSP --verify DCSP HEAD', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP (stdout, _) = process.communicate() DCNL DCSP  DCSP match = re.search('(?i)[0-9a-f]{32}', (stdout or '')) DCNL DCSP  DCSP retVal = (match.group(0) if match else None) DCNL DCSP return (retVal[:7] if retVal else None)
def test_ncr_fit_sample(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def get_selections(pattern=None, state=None): DCNL  DCSP ret = {} DCNL DCSP cmd = ['dpkg', '--get-selections'] DCNL DCSP cmd.append((pattern if pattern else '*')) DCNL DCSP stdout = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False) DCNL DCSP ret = _parse_selections(stdout) DCNL DCSP if state: DCNL DCSP  DCSP return {state: ret.get(state, [])} DCNL DCSP return ret
def _diff_cache_subnet_group(current, desired): DCNL  DCSP modifiable = {'CacheSubnetGroupDescription': 'CacheSubnetGroupDescription', 'SubnetIds': 'SubnetIds'} DCNL DCSP need_update = {} DCNL DCSP for (m, o) in modifiable.items(): DCNL DCSP  DCSP if (m in desired): DCNL DCSP  DCSP  DCSP if (not o): DCNL DCSP  DCSP  DCSP  DCSP need_update[m] = desired[m] DCNL DCSP  DCSP  DCSP elif (m in current): DCNL DCSP  DCSP  DCSP  DCSP if (current[m] != desired[m]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP need_update[m] = desired[m] DCNL DCSP return need_update
def clearCache(indexerid=0): DCNL  DCSP cache_db_con = db.DBConnection('cache.db') DCNL DCSP cache_db_con.action('DELETE DCSP FROM DCSP scene_names DCSP WHERE DCSP indexer_id DCSP = DCSP ? DCSP OR DCSP indexer_id DCSP = DCSP ?', (indexerid, 0)) DCNL DCSP toRemove = [key for (key, value) in nameCache.iteritems() if (value in (0, indexerid))] DCNL DCSP for key in toRemove: DCNL DCSP  DCSP del nameCache[key]
def is_staging(srv): DCNL  DCSP return ((srv == constants.STAGING_URI) or ('staging' in srv))
def _get_or_default(mylist, i, default=None): DCNL  DCSP if (i >= len(mylist)): DCNL DCSP  DCSP return default DCNL DCSP else: DCNL DCSP  DCSP return mylist[i]
def pseudo_quoteattr(value): DCNL  DCSP return ('"%s"' % value)
def getFillOfSurroundings(surroundingLoops): DCNL  DCSP fillOfSurroundings = [] DCNL DCSP for surroundingLoop in surroundingLoops: DCNL DCSP  DCSP fillOfSurroundings += surroundingLoop.getFillLoops() DCNL DCSP return fillOfSurroundings
def decorator(caller, _func=None): DCNL  DCSP if (_func is not None): DCNL DCSP  DCSP return decorate(_func, caller) DCNL DCSP if inspect.isclass(caller): DCNL DCSP  DCSP name = caller.__name__.lower() DCNL DCSP  DCSP doc = ('decorator(%s) DCSP converts DCSP functions/generators DCSP into DCSP factories DCSP of DCSP %s DCSP objects' % (caller.__name__, caller.__name__)) DCNL DCSP elif inspect.isfunction(caller): DCNL DCSP  DCSP if (caller.__name__ == '<lambda>'): DCNL DCSP  DCSP  DCSP name = '_lambda_' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP name = caller.__name__ DCNL DCSP  DCSP doc = caller.__doc__ DCNL DCSP else: DCNL DCSP  DCSP name = caller.__class__.__name__.lower() DCNL DCSP  DCSP doc = caller.__call__.__doc__ DCNL DCSP evaldict = dict(_call_=caller, _decorate_=decorate) DCNL DCSP return FunctionMaker.create(('%s(func)' % name), 'return DCSP _decorate_(func, DCSP _call_)', evaldict, doc=doc, module=caller.__module__, __wrapped__=caller)
def update_exploration_summary(exploration_id, contributor_id_to_add): DCNL  DCSP exploration = get_exploration_by_id(exploration_id) DCNL DCSP exp_summary = compute_summary_of_exploration(exploration, contributor_id_to_add) DCNL DCSP save_exploration_summary(exp_summary)
def clean_fuzzable_request(fuzzable_request, dc_handler=clean_data_container): DCNL  DCSP res = ('(%s)-' % fuzzable_request.get_method().upper()) DCNL DCSP res += clean_url(fuzzable_request.get_uri(), dc_handler=dc_handler) DCNL DCSP raw_data = fuzzable_request.get_raw_data() DCNL DCSP if raw_data: DCNL DCSP  DCSP res += ('!' + dc_handler(raw_data)) DCNL DCSP return res
def switchOff(): DCNL  DCSP logging.info('deprecated: DCSP  DCSP microphone.switchOff() DCSP is DCSP no DCSP longer DCSP needed.')
@register.simple_tag DCNL def absolute_asset_url(module, path): DCNL  DCSP return absolute_uri(get_asset_url(module, path))
def create(context, namespace_name, values, session): DCNL  DCSP namespace = namespace_api.get(context, namespace_name, session) DCNL DCSP resource_type_name = values['name'] DCNL DCSP metadef_utils.drop_protected_attrs(models.MetadefNamespaceResourceType, values) DCNL DCSP try: DCNL DCSP  DCSP resource_type = resource_type_api.get(context, resource_type_name, session) DCNL DCSP except exc.NotFound: DCNL DCSP  DCSP resource_type = None DCNL DCSP  DCSP LOG.debug('Creating DCSP resource-type DCSP %s', resource_type_name) DCNL DCSP if (resource_type is None): DCNL DCSP  DCSP resource_type_dict = {'name': resource_type_name, 'protected': False} DCNL DCSP  DCSP resource_type = resource_type_api.create(context, resource_type_dict, session) DCNL DCSP ns_resource_type_dict = _to_db_dict(namespace['id'], resource_type['id'], values) DCNL DCSP new_rec = _create_association(context, namespace_name, resource_type_name, ns_resource_type_dict, session) DCNL DCSP return _to_model_dict(resource_type_name, new_rec)
@curry DCNL def as_labelarray(initial_dtype, missing_value, array): DCNL  DCSP return LabelArray(array.astype(initial_dtype), missing_value=initial_dtype.type(missing_value))
def is_equal(var, val): DCNL  DCSP try: DCNL DCSP  DCSP v = get_scalar_constant_value(var) DCNL DCSP  DCSP return (v == val) DCNL DCSP except NotScalarConstantError: DCNL DCSP  DCSP return False
def main(argv): DCNL  DCSP thin_path = os.path.join(OPTIONS.saltdir, THIN_ARCHIVE) DCNL DCSP if os.path.isfile(thin_path): DCNL DCSP  DCSP if (OPTIONS.checksum != get_hash(thin_path, OPTIONS.hashfunc)): DCNL DCSP  DCSP  DCSP need_deployment() DCNL DCSP  DCSP unpack_thin(thin_path) DCNL DCSP else: DCNL DCSP  DCSP scpstat = subprocess.Popen(['/bin/sh', '-c', 'command DCSP -v DCSP scp']).wait() DCNL DCSP  DCSP if (scpstat != 0): DCNL DCSP  DCSP  DCSP sys.exit(EX_SCP_NOT_FOUND) DCNL DCSP  DCSP if (not os.path.exists(OPTIONS.saltdir)): DCNL DCSP  DCSP  DCSP need_deployment() DCNL DCSP  DCSP if (not os.path.isdir(OPTIONS.saltdir)): DCNL DCSP  DCSP  DCSP sys.stderr.write('ERROR: DCSP salt DCSP path DCSP "{0}" DCSP exists DCSP but DCSP is DCSP not DCSP a DCSP directory\n'.format(OPTIONS.saltdir)) DCNL DCSP  DCSP  DCSP sys.exit(EX_CANTCREAT) DCNL DCSP  DCSP version_path = os.path.join(OPTIONS.saltdir, 'version') DCNL DCSP  DCSP if ((not os.path.exists(version_path)) or (not os.path.isfile(version_path))): DCNL DCSP  DCSP  DCSP sys.stderr.write('WARNING: DCSP Unable DCSP to DCSP locate DCSP current DCSP thin DCSP  DCSP version: DCSP {0}.\n'.format(version_path)) DCNL DCSP  DCSP  DCSP need_deployment() DCNL DCSP  DCSP with open(version_path, 'r') as vpo: DCNL DCSP  DCSP  DCSP cur_version = vpo.readline().strip() DCNL DCSP  DCSP if (cur_version != OPTIONS.version): DCNL DCSP  DCSP  DCSP sys.stderr.write('WARNING: DCSP current DCSP thin DCSP version DCSP {0} DCSP is DCSP not DCSP up-to-date DCSP with DCSP {1}.\n'.format(cur_version, OPTIONS.version)) DCNL DCSP  DCSP  DCSP need_deployment() DCNL DCSP salt_call_path = os.path.join(OPTIONS.saltdir, 'salt-call') DCNL DCSP if (not os.path.isfile(salt_call_path)): DCNL DCSP  DCSP sys.stderr.write('ERROR: DCSP thin DCSP is DCSP missing DCSP "{0}"\n'.format(salt_call_path)) DCNL DCSP  DCSP need_deployment() DCNL DCSP with open(os.path.join(OPTIONS.saltdir, 'minion'), 'w') as config: DCNL DCSP  DCSP config.write((OPTIONS.config + '\n')) DCNL DCSP if OPTIONS.ext_mods: DCNL DCSP  DCSP ext_path = os.path.join(OPTIONS.saltdir, EXT_ARCHIVE) DCNL DCSP  DCSP if os.path.exists(ext_path): DCNL DCSP  DCSP  DCSP unpack_ext(ext_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP version_path = os.path.join(OPTIONS.saltdir, 'ext_version') DCNL DCSP  DCSP  DCSP if ((not os.path.exists(version_path)) or (not os.path.isfile(version_path))): DCNL DCSP  DCSP  DCSP  DCSP need_ext() DCNL DCSP  DCSP  DCSP with open(version_path, 'r') as vpo: DCNL DCSP  DCSP  DCSP  DCSP cur_version = vpo.readline().strip() DCNL DCSP  DCSP  DCSP if (cur_version != OPTIONS.ext_mods): DCNL DCSP  DCSP  DCSP  DCSP need_ext() DCNL DCSP if (len(ARGS) == 1): DCNL DCSP  DCSP argv_prepared = ARGS[0].split() DCNL DCSP else: DCNL DCSP  DCSP argv_prepared = ARGS DCNL DCSP salt_argv = ([sys.executable, salt_call_path, '--retcode-passthrough', '--local', '--metadata', '--out', 'json', '-l', 'quiet', '-c', OPTIONS.saltdir, '--'] + argv_prepared) DCNL DCSP sys.stderr.write('SALT_ARGV: DCSP {0}\n'.format(salt_argv)) DCNL DCSP sys.stdout.write((OPTIONS.delimiter + '\n')) DCNL DCSP sys.stdout.flush() DCNL DCSP if (not OPTIONS.tty): DCNL DCSP  DCSP sys.stderr.write((OPTIONS.delimiter + '\n')) DCNL DCSP  DCSP sys.stderr.flush() DCNL DCSP if (OPTIONS.cmd_umask is not None): DCNL DCSP  DCSP old_umask = os.umask(OPTIONS.cmd_umask) DCNL DCSP if OPTIONS.tty: DCNL DCSP  DCSP (stdout, _) = subprocess.Popen(salt_argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate() DCNL DCSP  DCSP sys.stdout.write(stdout) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP if OPTIONS.wipe: DCNL DCSP  DCSP  DCSP shutil.rmtree(OPTIONS.saltdir) DCNL DCSP elif OPTIONS.wipe: DCNL DCSP  DCSP subprocess.call(salt_argv) DCNL DCSP  DCSP shutil.rmtree(OPTIONS.saltdir) DCNL DCSP else: DCNL DCSP  DCSP subprocess.call(salt_argv) DCNL DCSP if (OPTIONS.cmd_umask is not None): DCNL DCSP  DCSP os.umask(old_umask)
def new_figure_manager_given_figure(num, figure): DCNL  DCSP canvas = FigureCanvasQTAgg(figure) DCNL DCSP return FigureManagerQT(canvas, num)
def _default_selem(ndim): DCNL  DCSP return ndi.morphology.generate_binary_structure(ndim, 1)
@pytest.fixture DCNL def keyhint(qtbot, config_stub, key_config_stub): DCNL  DCSP config_stub.data = {'colors': {'keyhint.fg': 'white', 'keyhint.fg.suffix': 'yellow', 'keyhint.bg': 'black'}, 'fonts': {'keyhint': 'Comic DCSP Sans'}, 'ui': {'keyhint-blacklist': '', 'status-position': 'bottom'}} DCNL DCSP keyhint = KeyHintView(0, None) DCNL DCSP qtbot.add_widget(keyhint) DCNL DCSP assert (keyhint.text() == '') DCNL DCSP return keyhint
def decode_feedback(binary_tuples): DCNL  DCSP fmt = '!lh32s' DCNL DCSP size = struct.calcsize(fmt) DCNL DCSP with StringIO(binary_tuples) as f: DCNL DCSP  DCSP return [(datetime.datetime.fromtimestamp(ts), binascii.hexlify(tok)) for (ts, toklen, tok) in (struct.unpack(fmt, tup) for tup in iter((lambda : f.read(size)), ''))]
def _partition_tasks(worker): DCNL  DCSP task_history = worker._add_task_history DCNL DCSP pending_tasks = {task for (task, status, ext) in task_history if (status == 'PENDING')} DCNL DCSP set_tasks = {} DCNL DCSP set_tasks['completed'] = {task for (task, status, ext) in task_history if ((status == 'DONE') and (task in pending_tasks))} DCNL DCSP set_tasks['already_done'] = {task for (task, status, ext) in task_history if ((status == 'DONE') and (task not in pending_tasks) and (task not in set_tasks['completed']))} DCNL DCSP set_tasks['ever_failed'] = {task for (task, status, ext) in task_history if (status == 'FAILED')} DCNL DCSP set_tasks['failed'] = (set_tasks['ever_failed'] - set_tasks['completed']) DCNL DCSP set_tasks['scheduling_error'] = {task for (task, status, ext) in task_history if (status == 'UNKNOWN')} DCNL DCSP set_tasks['still_pending_ext'] = {task for (task, status, ext) in task_history if ((status == 'PENDING') and (task not in set_tasks['ever_failed']) and (task not in set_tasks['completed']) and (not ext))} DCNL DCSP set_tasks['still_pending_not_ext'] = {task for (task, status, ext) in task_history if ((status == 'PENDING') and (task not in set_tasks['ever_failed']) and (task not in set_tasks['completed']) and ext)} DCNL DCSP set_tasks['run_by_other_worker'] = set() DCNL DCSP set_tasks['upstream_failure'] = set() DCNL DCSP set_tasks['upstream_missing_dependency'] = set() DCNL DCSP set_tasks['upstream_run_by_other_worker'] = set() DCNL DCSP set_tasks['upstream_scheduling_error'] = set() DCNL DCSP set_tasks['not_run'] = set() DCNL DCSP return set_tasks
def rmtree(dirname): DCNL  DCSP excs = [] DCNL DCSP try: DCNL DCSP  DCSP os.chmod(dirname, ((stat.S_IWRITE | stat.S_IEXEC) | stat.S_IREAD)) DCNL DCSP  DCSP for f in os.listdir(dirname): DCNL DCSP  DCSP  DCSP fullname = os.path.join(dirname, f) DCNL DCSP  DCSP  DCSP if os.path.isdir(fullname): DCNL DCSP  DCSP  DCSP  DCSP rm_dir(fullname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP remove(fullname) DCNL DCSP  DCSP os.rmdir(dirname) DCNL DCSP except EnvironmentError as le: DCNL DCSP  DCSP if (((le.args[0] != 2) and (le.args[0] != 3)) or (le.args[0] != errno.ENOENT)): DCNL DCSP  DCSP  DCSP excs.append(le) DCNL DCSP except Exception as le: DCNL DCSP  DCSP excs.append(le) DCNL DCSP if os.path.exists(dirname): DCNL DCSP  DCSP if (len(excs) == 1): DCNL DCSP  DCSP  DCSP raise excs[0] DCNL DCSP  DCSP if (len(excs) == 0): DCNL DCSP  DCSP  DCSP raise OSError, 'Failed DCSP to DCSP remove DCSP dir DCSP for DCSP unknown DCSP reason.' DCNL DCSP  DCSP raise OSError, excs
def generate_skip_gram_batch(data, batch_size, num_skips, skip_window, data_index=0): DCNL  DCSP assert ((batch_size % num_skips) == 0) DCNL DCSP assert (num_skips <= (2 * skip_window)) DCNL DCSP batch = np.ndarray(shape=batch_size, dtype=np.int32) DCNL DCSP labels = np.ndarray(shape=(batch_size, 1), dtype=np.int32) DCNL DCSP span = ((2 * skip_window) + 1) DCNL DCSP buffer = collections.deque(maxlen=span) DCNL DCSP for _ in range(span): DCNL DCSP  DCSP buffer.append(data[data_index]) DCNL DCSP  DCSP data_index = ((data_index + 1) % len(data)) DCNL DCSP for i in range((batch_size // num_skips)): DCNL DCSP  DCSP target = skip_window DCNL DCSP  DCSP targets_to_avoid = [skip_window] DCNL DCSP  DCSP for j in range(num_skips): DCNL DCSP  DCSP  DCSP while (target in targets_to_avoid): DCNL DCSP  DCSP  DCSP  DCSP target = random.randint(0, (span - 1)) DCNL DCSP  DCSP  DCSP targets_to_avoid.append(target) DCNL DCSP  DCSP  DCSP batch[((i * num_skips) + j)] = buffer[skip_window] DCNL DCSP  DCSP  DCSP labels[(((i * num_skips) + j), 0)] = buffer[target] DCNL DCSP  DCSP buffer.append(data[data_index]) DCNL DCSP  DCSP data_index = ((data_index + 1) % len(data)) DCNL DCSP return (batch, labels, data_index)
def default_sort_key(item, order=None): DCNL  DCSP from .singleton import S DCNL DCSP from .basic import Basic DCNL DCSP from .sympify import sympify, SympifyError DCNL DCSP from .compatibility import iterable DCNL DCSP if isinstance(item, Basic): DCNL DCSP  DCSP return item.sort_key(order=order) DCNL DCSP if iterable(item, exclude=string_types): DCNL DCSP  DCSP if isinstance(item, dict): DCNL DCSP  DCSP  DCSP args = item.items() DCNL DCSP  DCSP  DCSP unordered = True DCNL DCSP  DCSP elif isinstance(item, set): DCNL DCSP  DCSP  DCSP args = item DCNL DCSP  DCSP  DCSP unordered = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = list(item) DCNL DCSP  DCSP  DCSP unordered = False DCNL DCSP  DCSP args = [default_sort_key(arg, order=order) for arg in args] DCNL DCSP  DCSP if unordered: DCNL DCSP  DCSP  DCSP args = sorted(args) DCNL DCSP  DCSP (cls_index, args) = (10, (len(args), tuple(args))) DCNL DCSP else: DCNL DCSP  DCSP if (not isinstance(item, string_types)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP item = sympify(item) DCNL DCSP  DCSP  DCSP except SympifyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(item, Basic): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return default_sort_key(item) DCNL DCSP  DCSP (cls_index, args) = (0, (1, (str(item),))) DCNL DCSP return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)
def aggregate_metadata_add(context, aggregate_id, metadata, set_delete=False): DCNL  DCSP IMPL.aggregate_metadata_add(context, aggregate_id, metadata, set_delete)
def remove_comments(code): DCNL  DCSP pattern = '(\\".*?\\"|\\\'.*?\\\')|(/\\*.*?\\*/|//[^\\r\\n]*\\n)' DCNL DCSP regex = re.compile(pattern, (re.MULTILINE | re.DOTALL)) DCNL DCSP def do_replace(match): DCNL DCSP  DCSP if (match.group(2) is not None): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return regex.sub(do_replace, code)
def getGeometryOutput(derivation, elementNode): DCNL  DCSP if (derivation == None): DCNL DCSP  DCSP derivation = PegDerivation(elementNode) DCNL DCSP positives = [] DCNL DCSP radiusArealized = complex(derivation.radiusArealized, derivation.radiusArealized) DCNL DCSP addPegOutput(derivation.bevel, derivation.endZ, positives, radiusArealized, derivation.sides, derivation.start, derivation.topOverBottom) DCNL DCSP return extrude.getGeometryOutputByNegativesPositives(elementNode, [], positives)
def serialize(name, dataset=None, dataset_pillar=None, user=None, group=None, mode=None, backup='', makedirs=False, show_diff=True, create=True, merge_if_exists=False, **kwargs): DCNL  DCSP if ('env' in kwargs): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', "Parameter DCSP 'env' DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen.") DCNL DCSP  DCSP kwargs.pop('env') DCNL DCSP name = os.path.expanduser(name) DCNL DCSP default_serializer_opts = {'yaml.serialize': {'default_flow_style': False}, 'json.serialize': {'indent': 2, 'separators': (',', ': DCSP '), 'sort_keys': True}} DCNL DCSP ret = {'changes': {}, 'comment': '', 'name': name, 'result': True} DCNL DCSP if (not name): DCNL DCSP  DCSP return _error(ret, 'Must DCSP provide DCSP name DCSP to DCSP file.serialize') DCNL DCSP if (not create): DCNL DCSP  DCSP if (not os.path.isfile(name)): DCNL DCSP  DCSP  DCSP ret['comment'] = 'File DCSP {0} DCSP is DCSP not DCSP present DCSP and DCSP is DCSP not DCSP set DCSP for DCSP creation'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP formatter = kwargs.pop('formatter', 'yaml').lower() DCNL DCSP if (len([x for x in (dataset, dataset_pillar) if x]) > 1): DCNL DCSP  DCSP return _error(ret, "Only DCSP one DCSP of DCSP 'dataset' DCSP and DCSP 'dataset_pillar' DCSP is DCSP permitted") DCNL DCSP if dataset_pillar: DCNL DCSP  DCSP dataset = __salt__['pillar.get'](dataset_pillar) DCNL DCSP if (dataset is None): DCNL DCSP  DCSP return _error(ret, "Neither DCSP 'dataset' DCSP nor DCSP 'dataset_pillar' DCSP was DCSP defined") DCNL DCSP if salt.utils.is_windows(): DCNL DCSP  DCSP if (group is not None): DCNL DCSP  DCSP  DCSP log.warning('The DCSP group DCSP argument DCSP for DCSP {0} DCSP has DCSP been DCSP ignored DCSP as DCSP this DCSP is DCSP a DCSP Windows DCSP system.'.format(name)) DCNL DCSP  DCSP group = user DCNL DCSP serializer_name = '{0}.serialize'.format(formatter) DCNL DCSP deserializer_name = '{0}.deserialize'.format(formatter) DCNL DCSP if (serializer_name not in __serializers__): DCNL DCSP  DCSP return {'changes': {}, 'comment': '{0} DCSP format DCSP is DCSP not DCSP supported'.format(formatter.capitalize()), 'name': name, 'result': False} DCNL DCSP if merge_if_exists: DCNL DCSP  DCSP if os.path.isfile(name): DCNL DCSP  DCSP  DCSP if ('{0}.deserialize'.format(formatter) not in __serializers__): DCNL DCSP  DCSP  DCSP  DCSP return {'changes': {}, 'comment': '{0} DCSP format DCSP is DCSP not DCSP supported DCSP for DCSP merging'.format(formatter.capitalize()), 'name': name, 'result': False} DCNL DCSP  DCSP  DCSP with salt.utils.fopen(name, 'r') as fhr: DCNL DCSP  DCSP  DCSP  DCSP existing_data = __serializers__[deserializer_name](fhr) DCNL DCSP  DCSP  DCSP if (existing_data is not None): DCNL DCSP  DCSP  DCSP  DCSP merged_data = salt.utils.dictupdate.merge_recurse(existing_data, dataset) DCNL DCSP  DCSP  DCSP  DCSP if (existing_data == merged_data): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'The DCSP file DCSP {0} DCSP is DCSP in DCSP the DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP  DCSP dataset = merged_data DCNL DCSP contents = __serializers__[serializer_name](dataset, **default_serializer_opts.get(serializer_name, {})) DCNL DCSP contents += '\n' DCNL DCSP mode = salt.utils.normalize_mode(mode) DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['changes'] = __salt__['file.check_managed_changes'](name=name, source=None, source_hash={}, source_hash_name=None, user=user, group=group, mode=mode, template=None, context=None, defaults=None, saltenv=__env__, contents=contents, skip_verify=False, **kwargs) DCNL DCSP  DCSP if ret['changes']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Dataset DCSP will DCSP be DCSP serialized DCSP and DCSP stored DCSP into DCSP {0}'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'The DCSP file DCSP {0} DCSP is DCSP in DCSP the DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP return __salt__['file.manage_file'](name=name, sfn='', ret=ret, source=None, source_sum={}, user=user, group=group, mode=mode, saltenv=__env__, backup=backup, makedirs=makedirs, template=None, show_changes=show_diff, contents=contents)
def _groupby_and_merge(by, on, left, right, _merge_pieces, check_duplicates=True): DCNL  DCSP pieces = [] DCNL DCSP if (not isinstance(by, (list, tuple))): DCNL DCSP  DCSP by = [by] DCNL DCSP lby = left.groupby(by, sort=False) DCNL DCSP try: DCNL DCSP  DCSP if check_duplicates: DCNL DCSP  DCSP  DCSP if (on is None): DCNL DCSP  DCSP  DCSP  DCSP on = [] DCNL DCSP  DCSP  DCSP elif (not isinstance(on, (list, tuple))): DCNL DCSP  DCSP  DCSP  DCSP on = [on] DCNL DCSP  DCSP  DCSP if right.duplicated((by + on)).any(): DCNL DCSP  DCSP  DCSP  DCSP right = right.drop_duplicates((by + on), keep='last') DCNL DCSP  DCSP rby = right.groupby(by, sort=False) DCNL DCSP except KeyError: DCNL DCSP  DCSP rby = None DCNL DCSP for (key, lhs) in lby: DCNL DCSP  DCSP if (rby is None): DCNL DCSP  DCSP  DCSP rhs = right DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rhs = right.take(rby.indices[key]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP lcols = lhs.columns.tolist() DCNL DCSP  DCSP  DCSP  DCSP cols = (lcols + [r for r in right.columns if (r not in set(lcols))]) DCNL DCSP  DCSP  DCSP  DCSP merged = lhs.reindex(columns=cols) DCNL DCSP  DCSP  DCSP  DCSP merged.index = range(len(merged)) DCNL DCSP  DCSP  DCSP  DCSP pieces.append(merged) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP merged = _merge_pieces(lhs, rhs) DCNL DCSP  DCSP for k in by: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (k in merged): DCNL DCSP  DCSP  DCSP  DCSP  DCSP merged[k] = key DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP pieces.append(merged) DCNL DCSP result = concat(pieces, ignore_index=True) DCNL DCSP result = result.reindex(columns=pieces[0].columns, copy=False) DCNL DCSP return (result, lby)
def draw_if_interactive(): DCNL  DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager is not None): DCNL DCSP  DCSP  DCSP figManager.canvas.invalidate()
def _(msg, lang=None): DCNL  DCSP from frappe.translate import get_full_dict DCNL DCSP if (not lang): DCNL DCSP  DCSP lang = local.lang DCNL DCSP msg = as_unicode(msg).strip() DCNL DCSP return (get_full_dict(local.lang).get(msg) or msg)
def privileges_revoke(name, object_name, object_type, privileges=None, prepend='public', maintenance_db=None, user=None, host=None, port=None, password=None, runas=None): DCNL  DCSP (object_type, privileges, _privs) = _mod_priv_opts(object_type, privileges) DCNL DCSP _validate_privileges(object_type, _privs, privileges) DCNL DCSP if (not has_privileges(name, object_name, object_type, privileges, prepend=prepend, maintenance_db=maintenance_db, user=user, host=host, port=port, password=password, runas=runas)): DCNL DCSP  DCSP log.info('The DCSP object: DCSP %s DCSP of DCSP type: DCSP %s DCSP does DCSP not DCSP have DCSP privileges: DCSP %s DCSP set', object_name, object_type, privileges) DCNL DCSP  DCSP return False DCNL DCSP _grants = ','.join(_privs) DCNL DCSP if (object_type in ['table', 'sequence']): DCNL DCSP  DCSP on_part = '{0}.{1}'.format(prepend, object_name) DCNL DCSP else: DCNL DCSP  DCSP on_part = object_name DCNL DCSP if (object_type == 'group'): DCNL DCSP  DCSP query = 'REVOKE DCSP {0} DCSP FROM DCSP {1}'.format(object_name, name) DCNL DCSP else: DCNL DCSP  DCSP query = 'REVOKE DCSP {0} DCSP ON DCSP {1} DCSP {2} DCSP FROM DCSP {3}'.format(_grants, object_type.upper(), on_part, name) DCNL DCSP ret = _psql_prepare_and_run(['-c', query], user=user, host=host, port=port, maintenance_db=maintenance_db, password=password, runas=runas) DCNL DCSP return (ret['retcode'] == 0)
def ensure_distance(dist): DCNL  DCSP try: DCNL DCSP  DCSP km = dist.km DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise SpatialError((u"'%s' DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP 'Distance' DCSP object." % dist)) DCNL DCSP return dist
def get_file_size(fileobj): DCNL  DCSP currpos = fileobj.tell() DCNL DCSP fileobj.seek(0, 2) DCNL DCSP total_size = fileobj.tell() DCNL DCSP fileobj.seek(currpos) DCNL DCSP return total_size
def cli(): DCNL  DCSP import getopt DCNL DCSP class BadUsage: DCNL DCSP  DCSP pass DCNL DCSP if ('' not in sys.path): DCNL DCSP  DCSP scriptdir = os.path.dirname(sys.argv[0]) DCNL DCSP  DCSP if (scriptdir in sys.path): DCNL DCSP  DCSP  DCSP sys.path.remove(scriptdir) DCNL DCSP  DCSP sys.path.insert(0, '.') DCNL DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], 'gk:p:w') DCNL DCSP  DCSP writing = 0 DCNL DCSP  DCSP for (opt, val) in opts: DCNL DCSP  DCSP  DCSP if (opt == '-g'): DCNL DCSP  DCSP  DCSP  DCSP gui() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-k'): DCNL DCSP  DCSP  DCSP  DCSP apropos(val) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-p'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP port = int(val) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise BadUsage DCNL DCSP  DCSP  DCSP  DCSP def ready(server): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('pydoc DCSP server DCSP ready DCSP at DCSP %s' % server.url) DCNL DCSP  DCSP  DCSP  DCSP def stopped(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'pydoc DCSP server DCSP stopped' DCNL DCSP  DCSP  DCSP  DCSP serve(port, ready, stopped) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-w'): DCNL DCSP  DCSP  DCSP  DCSP writing = 1 DCNL DCSP  DCSP if (not args): DCNL DCSP  DCSP  DCSP raise BadUsage DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP if (ispath(arg) and (not os.path.exists(arg))): DCNL DCSP  DCSP  DCSP  DCSP print ('file DCSP %r DCSP does DCSP not DCSP exist' % arg) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (ispath(arg) and os.path.isfile(arg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP arg = importfile(arg) DCNL DCSP  DCSP  DCSP  DCSP if writing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ispath(arg) and os.path.isdir(arg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writedocs(arg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writedoc(arg) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP help.help(arg) DCNL DCSP  DCSP  DCSP except ErrorDuringImport as value: DCNL DCSP  DCSP  DCSP  DCSP print value DCNL DCSP except (getopt.error, BadUsage): DCNL DCSP  DCSP cmd = os.path.basename(sys.argv[0]) DCNL DCSP  DCSP print ("pydoc DCSP - DCSP the DCSP Python DCSP documentation DCSP tool\n\n%s DCSP <name> DCSP ...\n DCSP  DCSP  DCSP  DCSP Show DCSP text DCSP documentation DCSP on DCSP something. DCSP  DCSP <name> DCSP may DCSP be DCSP the DCSP name DCSP of DCSP a\n DCSP  DCSP  DCSP  DCSP Python DCSP keyword, DCSP topic, DCSP function, DCSP module, DCSP or DCSP package, DCSP or DCSP a DCSP dotted\n DCSP  DCSP  DCSP  DCSP reference DCSP to DCSP a DCSP class DCSP or DCSP function DCSP within DCSP a DCSP module DCSP or DCSP module DCSP in DCSP a\n DCSP  DCSP  DCSP  DCSP package. DCSP  DCSP If DCSP <name> DCSP contains DCSP a DCSP '%s', DCSP it DCSP is DCSP used DCSP as DCSP the DCSP path DCSP to DCSP a\n DCSP  DCSP  DCSP  DCSP Python DCSP source DCSP file DCSP to DCSP document. DCSP If DCSP name DCSP is DCSP 'keywords', DCSP 'topics',\n DCSP  DCSP  DCSP  DCSP or DCSP 'modules', DCSP a DCSP listing DCSP of DCSP these DCSP things DCSP is DCSP displayed.\n\n%s DCSP -k DCSP <keyword>\n DCSP  DCSP  DCSP  DCSP Search DCSP for DCSP a DCSP keyword DCSP in DCSP the DCSP synopsis DCSP lines DCSP of DCSP all DCSP available DCSP modules.\n\n%s DCSP -p DCSP <port>\n DCSP  DCSP  DCSP  DCSP Start DCSP an DCSP HTTP DCSP server DCSP on DCSP the DCSP given DCSP port DCSP on DCSP the DCSP local DCSP machine. DCSP  DCSP Port\n DCSP  DCSP  DCSP  DCSP number DCSP 0 DCSP can DCSP be DCSP used DCSP to DCSP get DCSP an DCSP arbitrary DCSP unused DCSP port.\n\n%s DCSP -g\n DCSP  DCSP  DCSP  DCSP Pop DCSP up DCSP a DCSP graphical DCSP interface DCSP for DCSP finding DCSP and DCSP serving DCSP documentation.\n\n%s DCSP -w DCSP <name> DCSP ...\n DCSP  DCSP  DCSP  DCSP Write DCSP out DCSP the DCSP HTML DCSP documentation DCSP for DCSP a DCSP module DCSP to DCSP a DCSP file DCSP in DCSP the DCSP current\n DCSP  DCSP  DCSP  DCSP directory. DCSP  DCSP If DCSP <name> DCSP contains DCSP a DCSP '%s', DCSP it DCSP is DCSP treated DCSP as DCSP a DCSP filename; DCSP if\n DCSP  DCSP  DCSP  DCSP it DCSP names DCSP a DCSP directory, DCSP documentation DCSP is DCSP written DCSP for DCSP all DCSP the DCSP contents.\n" % (cmd, os.sep, cmd, cmd, cmd, cmd, os.sep))
def iter_style_files(style_dir): DCNL  DCSP for path in os.listdir(style_dir): DCNL DCSP  DCSP filename = os.path.basename(path) DCNL DCSP  DCSP if is_style_file(filename): DCNL DCSP  DCSP  DCSP match = STYLE_FILE_PATTERN.match(filename) DCNL DCSP  DCSP  DCSP path = os.path.abspath(os.path.join(style_dir, path)) DCNL DCSP  DCSP  DCSP (yield (path, match.groups()[0]))
def run_file(path_or_file, context=None): DCNL  DCSP if (context is None): DCNL DCSP  DCSP context = EvalJs() DCNL DCSP if (not isinstance(context, EvalJs)): DCNL DCSP  DCSP raise TypeError('context DCSP must DCSP be DCSP the DCSP instance DCSP of DCSP EvalJs') DCNL DCSP eval_value = context.eval(get_file_contents(path_or_file)) DCNL DCSP return (eval_value, context)
def try_except(cond): DCNL  DCSP try: DCNL DCSP  DCSP if cond: DCNL DCSP  DCSP  DCSP a = [] DCNL DCSP  DCSP raise ValueError DCNL DCSP except ValueError: DCNL DCSP  DCSP return a
def is_trunk_service_port(port_name): DCNL  DCSP return (is_trunk_bridge(port_name) or (port_name[:2] in (tman.TrunkParentPort.DEV_PREFIX, tman.SubPort.DEV_PREFIX)))
def deprecated(func, name='Unknown'): DCNL  DCSP def newFunc(*args, **kwargs): DCNL DCSP  DCSP warnings.warn(('Call DCSP to DCSP deprecated DCSP function DCSP %s.' % name), category=DeprecationWarning) DCNL DCSP  DCSP return func(*args, **kwargs) DCNL DCSP newFunc.__name__ = func.__name__ DCNL DCSP newFunc.__doc__ = func.__doc__ DCNL DCSP newFunc.__dict__.update(func.__dict__) DCNL DCSP return newFunc
def CDLADVANCEBLOCK(barDs, count): DCNL  DCSP return call_talib_with_ohlc(barDs, count, talib.CDLADVANCEBLOCK)
def iradon(radon_image, theta=None, output_size=None, filter='ramp', interpolation='linear', circle=None): DCNL  DCSP if (radon_image.ndim != 2): DCNL DCSP  DCSP raise ValueError('The DCSP input DCSP image DCSP must DCSP be DCSP 2-D') DCNL DCSP if (theta is None): DCNL DCSP  DCSP (m, n) = radon_image.shape DCNL DCSP  DCSP theta = np.linspace(0, 180, n, endpoint=False) DCNL DCSP else: DCNL DCSP  DCSP theta = np.asarray(theta) DCNL DCSP if (len(theta) != radon_image.shape[1]): DCNL DCSP  DCSP raise ValueError('The DCSP given DCSP ``theta`` DCSP does DCSP not DCSP match DCSP the DCSP number DCSP of DCSP projections DCSP in DCSP ``radon_image``.') DCNL DCSP interpolation_types = ('linear', 'nearest', 'cubic') DCNL DCSP if (interpolation not in interpolation_types): DCNL DCSP  DCSP raise ValueError(('Unknown DCSP interpolation: DCSP %s' % interpolation)) DCNL DCSP if (not output_size): DCNL DCSP  DCSP if circle: DCNL DCSP  DCSP  DCSP output_size = radon_image.shape[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output_size = int(np.floor(np.sqrt(((radon_image.shape[0] ** 2) / 2.0)))) DCNL DCSP if (circle is None): DCNL DCSP  DCSP warn('The DCSP default DCSP of DCSP `circle` DCSP in DCSP `skimage.transform.iradon` DCSP will DCSP change DCSP to DCSP `True` DCSP in DCSP version DCSP 0.15.') DCNL DCSP  DCSP circle = False DCNL DCSP if circle: DCNL DCSP  DCSP radon_image = _sinogram_circle_to_square(radon_image) DCNL DCSP th = ((np.pi / 180.0) * theta) DCNL DCSP projection_size_padded = max(64, int((2 ** np.ceil(np.log2((2 * radon_image.shape[0])))))) DCNL DCSP pad_width = ((0, (projection_size_padded - radon_image.shape[0])), (0, 0)) DCNL DCSP img = np.pad(radon_image, pad_width, mode='constant', constant_values=0) DCNL DCSP f = fftfreq(projection_size_padded).reshape((-1), 1) DCNL DCSP omega = ((2 * np.pi) * f) DCNL DCSP fourier_filter = (2 * np.abs(f)) DCNL DCSP if (filter == 'ramp'): DCNL DCSP  DCSP pass DCNL DCSP elif (filter == 'shepp-logan'): DCNL DCSP  DCSP fourier_filter[1:] = ((fourier_filter[1:] * np.sin(omega[1:])) / omega[1:]) DCNL DCSP elif (filter == 'cosine'): DCNL DCSP  DCSP fourier_filter *= np.cos(omega) DCNL DCSP elif (filter == 'hamming'): DCNL DCSP  DCSP fourier_filter *= (0.54 + (0.46 * np.cos((omega / 2)))) DCNL DCSP elif (filter == 'hann'): DCNL DCSP  DCSP fourier_filter *= ((1 + np.cos((omega / 2))) / 2) DCNL DCSP elif (filter is None): DCNL DCSP  DCSP fourier_filter[:] = 1 DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP filter: DCSP %s' % filter)) DCNL DCSP projection = (fft(img, axis=0) * fourier_filter) DCNL DCSP radon_filtered = np.real(ifft(projection, axis=0)) DCNL DCSP radon_filtered = radon_filtered[:radon_image.shape[0], :] DCNL DCSP reconstructed = np.zeros((output_size, output_size)) DCNL DCSP mid_index = (radon_image.shape[0] // 2) DCNL DCSP [X, Y] = np.mgrid[0:output_size, 0:output_size] DCNL DCSP xpr = (X - (int(output_size) // 2)) DCNL DCSP ypr = (Y - (int(output_size) // 2)) DCNL DCSP for i in range(len(theta)): DCNL DCSP  DCSP t = ((ypr * np.cos(th[i])) - (xpr * np.sin(th[i]))) DCNL DCSP  DCSP x = (np.arange(radon_filtered.shape[0]) - mid_index) DCNL DCSP  DCSP if (interpolation == 'linear'): DCNL DCSP  DCSP  DCSP backprojected = np.interp(t, x, radon_filtered[:, i], left=0, right=0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interpolant = interp1d(x, radon_filtered[:, i], kind=interpolation, bounds_error=False, fill_value=0) DCNL DCSP  DCSP  DCSP backprojected = interpolant(t) DCNL DCSP  DCSP reconstructed += backprojected DCNL DCSP if circle: DCNL DCSP  DCSP radius = (output_size // 2) DCNL DCSP  DCSP reconstruction_circle = (((xpr ** 2) + (ypr ** 2)) <= (radius ** 2)) DCNL DCSP  DCSP reconstructed[(~ reconstruction_circle)] = 0.0 DCNL DCSP return ((reconstructed * np.pi) / (2 * len(th)))
def spatial_dist_connectivity(src, dist, verbose=None): DCNL  DCSP return spatio_temporal_dist_connectivity(src, 1, dist)
def test_event_schema(): DCNL  DCSP options = ({}, None, {'event_data': {}}, {'event': 'state_changed', 'event_data': 1}) DCNL DCSP for value in options: DCNL DCSP  DCSP with pytest.raises(vol.MultipleInvalid): DCNL DCSP  DCSP  DCSP cv.EVENT_SCHEMA(value) DCNL DCSP options = ({'event': 'state_changed'}, {'event': 'state_changed', 'event_data': {'hello': 'world'}}) DCNL DCSP for value in options: DCNL DCSP  DCSP cv.EVENT_SCHEMA(value)
def get_can_enable_dns(): DCNL  DCSP if has_module(u'DNS'): DCNL DCSP  DCSP return (True, None) DCNL DCSP else: DCNL DCSP  DCSP return (False, _(u'PyDNS, DCSP which DCSP is DCSP required DCSP to DCSP find DCSP the DCSP domain DCSP controller, DCSP is DCSP not DCSP installed.'))
def findall(pattern, string, flags=0, pos=None, endpos=None, overlapped=False, concurrent=None, **kwargs): DCNL  DCSP return _compile(pattern, flags, kwargs).findall(string, pos, endpos, overlapped, concurrent)
def store_job(opts, load, event=None, mminion=None): DCNL  DCSP endtime = salt.utils.jid.jid_to_time(salt.utils.jid.gen_jid()) DCNL DCSP if any(((key not in load) for key in ('return', 'jid', 'id'))): DCNL DCSP  DCSP return False DCNL DCSP if (not salt.utils.verify.valid_id(opts, load['id'])): DCNL DCSP  DCSP return False DCNL DCSP if (mminion is None): DCNL DCSP  DCSP mminion = salt.minion.MasterMinion(opts, states=False, rend=False) DCNL DCSP job_cache = opts['master_job_cache'] DCNL DCSP if (load['jid'] == 'req'): DCNL DCSP  DCSP load['arg'] = load.get('arg', load.get('fun_args', [])) DCNL DCSP  DCSP load['tgt_type'] = 'glob' DCNL DCSP  DCSP load['tgt'] = load['id'] DCNL DCSP  DCSP prep_fstr = '{0}.prep_jid'.format(opts['master_job_cache']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP load['jid'] = mminion.returners[prep_fstr](nocache=load.get('nocache', False)) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP does DCSP not DCSP support DCSP function DCSP prep_jid".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP  DCSP saveload_fstr = '{0}.save_load'.format(job_cache) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mminion.returners[saveload_fstr](load['jid'], load) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP does DCSP not DCSP support DCSP function DCSP save_load".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP elif salt.utils.jid.is_jid(load['jid']): DCNL DCSP  DCSP jidstore_fstr = '{0}.prep_jid'.format(job_cache) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mminion.returners[jidstore_fstr](False, passed_jid=load['jid']) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP does DCSP not DCSP support DCSP function DCSP prep_jid".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP if event: DCNL DCSP  DCSP log.info('Got DCSP return DCSP from DCSP {id} DCSP for DCSP job DCSP {jid}'.format(**load)) DCNL DCSP  DCSP event.fire_event(load, salt.utils.event.tagify([load['jid'], 'ret', load['id']], 'job')) DCNL DCSP  DCSP event.fire_ret_load(load) DCNL DCSP if ((not opts['job_cache']) or opts.get('ext_job_cache')): DCNL DCSP  DCSP return DCNL DCSP if (load.get('jid') == 'nocache'): DCNL DCSP  DCSP log.debug('Ignoring DCSP job DCSP return DCSP with DCSP jid DCSP for DCSP caching DCSP {jid} DCSP from DCSP {id}'.format(**load)) DCNL DCSP  DCSP return DCNL DCSP savefstr = '{0}.save_load'.format(job_cache) DCNL DCSP getfstr = '{0}.get_load'.format(job_cache) DCNL DCSP fstr = '{0}.returner'.format(job_cache) DCNL DCSP if (('fun' not in load) and load.get('return', {})): DCNL DCSP  DCSP ret_ = load.get('return', {}) DCNL DCSP  DCSP if ('fun' in ret_): DCNL DCSP  DCSP  DCSP load.update({'fun': ret_['fun']}) DCNL DCSP  DCSP if ('user' in ret_): DCNL DCSP  DCSP  DCSP load.update({'user': ret_['user']}) DCNL DCSP try: DCNL DCSP  DCSP if (('jid' in load) and ('get_load' in mminion.returners) and (not mminion.returners[getfstr](load.get('jid', '')))): DCNL DCSP  DCSP  DCSP mminion.returners[savefstr](load['jid'], load) DCNL DCSP  DCSP mminion.returners[fstr](load) DCNL DCSP  DCSP updateetfstr = '{0}.update_endtime'.format(job_cache) DCNL DCSP  DCSP if (opts.get('job_cache_store_endtime') and (updateetfstr in mminion.returners)): DCNL DCSP  DCSP  DCSP mminion.returners[updateetfstr](load['jid'], endtime) DCNL DCSP except KeyError: DCNL DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP does DCSP not DCSP support DCSP function DCSP returner".format(job_cache) DCNL DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP raise KeyError(emsg)
def unparse(input_dict, output=None, encoding='utf-8', full_document=True, **kwargs): DCNL  DCSP ((key, value),) = input_dict.items() DCNL DCSP must_return = False DCNL DCSP if (output is None): DCNL DCSP  DCSP output = StringIO() DCNL DCSP  DCSP must_return = True DCNL DCSP content_handler = XMLGenerator(output, encoding) DCNL DCSP if full_document: DCNL DCSP  DCSP content_handler.startDocument() DCNL DCSP _emit(key, value, content_handler, **kwargs) DCNL DCSP if full_document: DCNL DCSP  DCSP content_handler.endDocument() DCNL DCSP if must_return: DCNL DCSP  DCSP value = output.getvalue() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = value.decode(encoding) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return value
def get_connection(alias=DEFAULT_CONNECTION_NAME, reconnect=False): DCNL  DCSP if reconnect: DCNL DCSP  DCSP disconnect(alias) DCNL DCSP if (alias in _connections): DCNL DCSP  DCSP return _connections[alias] DCNL DCSP if (alias not in _connection_settings): DCNL DCSP  DCSP if (alias == DEFAULT_CONNECTION_NAME): DCNL DCSP  DCSP  DCSP msg = 'You DCSP have DCSP not DCSP defined DCSP a DCSP default DCSP connection' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('Connection DCSP with DCSP alias DCSP "%s" DCSP has DCSP not DCSP been DCSP defined' % alias) DCNL DCSP  DCSP raise MongoEngineConnectionError(msg) DCNL DCSP def _clean_settings(settings_dict): DCNL DCSP  DCSP irrelevant_fields = set(['name', 'username', 'password', 'authentication_source', 'authentication_mechanism']) DCNL DCSP  DCSP return {k: v for (k, v) in settings_dict.items() if (k not in irrelevant_fields)} DCNL DCSP conn_settings = _clean_settings(_connection_settings[alias].copy()) DCNL DCSP is_mock = conn_settings.pop('is_mock', False) DCNL DCSP if is_mock: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import mongomock DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP raise RuntimeError('You DCSP need DCSP mongomock DCSP installed DCSP to DCSP mock DCSP MongoEngine.') DCNL DCSP  DCSP connection_class = mongomock.MongoClient DCNL DCSP else: DCNL DCSP  DCSP connection_class = MongoClient DCNL DCSP  DCSP if (('replicaSet' in conn_settings) and (not IS_PYMONGO_3)): DCNL DCSP  DCSP  DCSP connection_class = MongoReplicaSetClient DCNL DCSP  DCSP  DCSP conn_settings['hosts_or_uri'] = conn_settings.pop('host', None) DCNL DCSP  DCSP  DCSP if isinstance(conn_settings['hosts_or_uri'], list): DCNL DCSP  DCSP  DCSP  DCSP conn_settings['hosts_or_uri'] = ','.join(conn_settings['hosts_or_uri']) DCNL DCSP  DCSP  DCSP conn_settings.pop('port', None) DCNL DCSP existing_connection = None DCNL DCSP connection_settings_iterator = ((db_alias, settings.copy()) for (db_alias, settings) in _connection_settings.items()) DCNL DCSP for (db_alias, connection_settings) in connection_settings_iterator: DCNL DCSP  DCSP connection_settings = _clean_settings(connection_settings) DCNL DCSP  DCSP if ((conn_settings == connection_settings) and _connections.get(db_alias)): DCNL DCSP  DCSP  DCSP existing_connection = _connections[db_alias] DCNL DCSP  DCSP  DCSP break DCNL DCSP if existing_connection: DCNL DCSP  DCSP _connections[alias] = existing_connection DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _connections[alias] = connection_class(**conn_settings) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise MongoEngineConnectionError(('Cannot DCSP connect DCSP to DCSP database DCSP %s DCSP :\n%s' % (alias, e))) DCNL DCSP return _connections[alias]
def _slice_1d(dim_shape, lengths, index): DCNL  DCSP if isinstance(index, (int, long)): DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP ind = index DCNL DCSP  DCSP lens = list(lengths) DCNL DCSP  DCSP while (ind >= lens[0]): DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP ind -= lens.pop(0) DCNL DCSP  DCSP return {i: ind} DCNL DCSP assert isinstance(index, slice) DCNL DCSP if (index == colon): DCNL DCSP  DCSP return {k: colon for k in range(len(lengths))} DCNL DCSP step = (index.step or 1) DCNL DCSP if (step > 0): DCNL DCSP  DCSP start = (index.start or 0) DCNL DCSP  DCSP stop = (index.stop if (index.stop is not None) else dim_shape) DCNL DCSP else: DCNL DCSP  DCSP start = (index.start or (dim_shape - 1)) DCNL DCSP  DCSP start = ((dim_shape - 1) if (start >= dim_shape) else start) DCNL DCSP  DCSP stop = ((- (dim_shape + 1)) if (index.stop is None) else index.stop) DCNL DCSP if (start < 0): DCNL DCSP  DCSP start += dim_shape DCNL DCSP if (stop < 0): DCNL DCSP  DCSP stop += dim_shape DCNL DCSP d = dict() DCNL DCSP if (step > 0): DCNL DCSP  DCSP for (i, length) in enumerate(lengths): DCNL DCSP  DCSP  DCSP if ((start < length) and (stop > 0)): DCNL DCSP  DCSP  DCSP  DCSP d[i] = slice(start, min(stop, length), step) DCNL DCSP  DCSP  DCSP  DCSP start = ((start - length) % step) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start = (start - length) DCNL DCSP  DCSP  DCSP stop -= length DCNL DCSP else: DCNL DCSP  DCSP rstart = start DCNL DCSP  DCSP chunk_boundaries = list(accumulate(add, lengths)) DCNL DCSP  DCSP for (i, chunk_stop) in reversed(list(enumerate(chunk_boundaries))): DCNL DCSP  DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP  DCSP chunk_start = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP chunk_start = chunk_boundaries[(i - 1)] DCNL DCSP  DCSP  DCSP if ((chunk_start <= rstart < chunk_stop) and (rstart > stop)): DCNL DCSP  DCSP  DCSP  DCSP d[i] = slice((rstart - chunk_stop), max(((chunk_start - chunk_stop) - 1), (stop - chunk_stop)), step) DCNL DCSP  DCSP  DCSP  DCSP offset = ((rstart - (chunk_start - 1)) % step) DCNL DCSP  DCSP  DCSP  DCSP rstart = ((chunk_start + offset) - 1) DCNL DCSP for (k, v) in d.items(): DCNL DCSP  DCSP if (v == slice(0, lengths[k], 1)): DCNL DCSP  DCSP  DCSP d[k] = slice(None, None, None) DCNL DCSP if (not d): DCNL DCSP  DCSP d[0] = slice(0, 0, 1) DCNL DCSP return d
def diff_states(start, end, ignore=None): DCNL  DCSP ignore = (ignore or []) DCNL DCSP def prefix_match(path, prefix): DCNL DCSP  DCSP if (path == prefix): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP prefix = (prefix.rstrip(os.path.sep) + os.path.sep) DCNL DCSP  DCSP return path.startswith(prefix) DCNL DCSP start_keys = set([k for k in start.keys() if (not any([prefix_match(k, i) for i in ignore]))]) DCNL DCSP end_keys = set([k for k in end.keys() if (not any([prefix_match(k, i) for i in ignore]))]) DCNL DCSP deleted = dict([(k, start[k]) for k in start_keys.difference(end_keys)]) DCNL DCSP created = dict([(k, end[k]) for k in end_keys.difference(start_keys)]) DCNL DCSP updated = {} DCNL DCSP for k in start_keys.intersection(end_keys): DCNL DCSP  DCSP if (start[k].size != end[k].size): DCNL DCSP  DCSP  DCSP updated[k] = end[k] DCNL DCSP return dict(deleted=deleted, created=created, updated=updated)
def add_check(module, check): DCNL  DCSP if ((not check.name) and (not service_id)): DCNL DCSP  DCSP module.fail_json(msg='a DCSP check DCSP name DCSP is DCSP required DCSP for DCSP a DCSP node DCSP level DCSP check, DCSP one DCSP not DCSP attached DCSP to DCSP a DCSP service') DCNL DCSP consul_api = get_consul_api(module) DCNL DCSP check.register(consul_api) DCNL DCSP module.exit_json(changed=True, check_id=check.check_id, check_name=check.name, script=check.script, interval=check.interval, ttl=check.ttl, http=check.http, timeout=check.timeout, service_id=check.service_id)
def get_precreated_datasets(trans, params, data_obj, controller='root'): DCNL  DCSP rval = [] DCNL DCSP async_datasets = [] DCNL DCSP if (params.get('async_datasets', None) not in ['None', '', None]): DCNL DCSP  DCSP async_datasets = params['async_datasets'].split(',') DCNL DCSP current_user_roles = trans.get_current_user_roles() DCNL DCSP for id in async_datasets: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = trans.sa_session.query(data_obj).get(int(id)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP log.exception(('Unable DCSP to DCSP load DCSP precreated DCSP dataset DCSP (%s) DCSP sent DCSP in DCSP upload DCSP form' % id)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (data_obj is trans.app.model.HistoryDatasetAssociation): DCNL DCSP  DCSP  DCSP if ((trans.user is None) and (trans.galaxy_session.current_history != data.history)): DCNL DCSP  DCSP  DCSP  DCSP log.error(("Got DCSP a DCSP precreated DCSP dataset DCSP (%s) DCSP but DCSP it DCSP does DCSP not DCSP belong DCSP to DCSP anonymous DCSP user's DCSP current DCSP session DCSP (%s)" % (data.id, trans.galaxy_session.id))) DCNL DCSP  DCSP  DCSP elif (data.history.user != trans.user): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Got DCSP a DCSP precreated DCSP dataset DCSP (%s) DCSP but DCSP it DCSP does DCSP not DCSP belong DCSP to DCSP current DCSP user DCSP (%s)' % (data.id, trans.user.id))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rval.append(data) DCNL DCSP  DCSP elif (data_obj is trans.app.model.LibraryDatasetDatasetAssociation): DCNL DCSP  DCSP  DCSP if ((controller == 'library') and (not trans.app.security_agent.can_add_library_item(current_user_roles, data.library_dataset.folder))): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Got DCSP a DCSP precreated DCSP dataset DCSP (%s) DCSP but DCSP this DCSP user DCSP (%s) DCSP is DCSP not DCSP allowed DCSP to DCSP write DCSP to DCSP it' % (data.id, trans.user.id))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rval.append(data) DCNL DCSP return rval
def HTTPInfoFromException(value): DCNL  DCSP if isinstance(value, web.HTTPError): DCNL DCSP  DCSP return (value.status_code, value.log_message) DCNL DCSP elif isinstance(value, InvalidRequestError): DCNL DCSP  DCSP return (400, value.args[0]) DCNL DCSP elif isinstance(value, HttpForbiddenError): DCNL DCSP  DCSP return (403, value.args[0]) DCNL DCSP elif isinstance(value, NotFoundError): DCNL DCSP  DCSP return (404, value.args[0]) DCNL DCSP elif isinstance(value, ServiceUnavailableError): DCNL DCSP  DCSP return (503, value.args[0]) DCNL DCSP else: DCNL DCSP  DCSP return (500, str(value))
def usages_add_import_modules(evaluator, definitions): DCNL  DCSP new = set() DCNL DCSP for d in definitions: DCNL DCSP  DCSP imp_or_stmt = d.get_definition() DCNL DCSP  DCSP if isinstance(imp_or_stmt, tree.Import): DCNL DCSP  DCSP  DCSP s = imports.ImportWrapper(evaluator, d) DCNL DCSP  DCSP  DCSP new |= set(s.follow(is_goto=True)) DCNL DCSP return (set(definitions) | new)
def write_with_harness(codefile, sourcefile, start_linenum, linebuffer): DCNL  DCSP with io.open(codefile, u'w') as code_filehandle: DCNL DCSP  DCSP code_filehandle.write((u'#include<stdio.h> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<stdlib.h> DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<tuple> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<utility> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<limits> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<functional> DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<string> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<map> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<iostream> DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<vector> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<algorithm> DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\n#include<memory> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP md-split\nusing DCSP namespace DCSP std; DCSP  DCSP  DCSP // DCSP by DCSP md-split\n// DCSP %s DCSP : DCSP %s\n' % (sourcefile, start_linenum))) DCNL DCSP  DCSP for codeline in linebuffer: DCNL DCSP  DCSP  DCSP code_filehandle.write(codeline)
def parse(s, name=None): DCNL  DCSP tokens = lex(s, name=name) DCNL DCSP result = [] DCNL DCSP while tokens: DCNL DCSP  DCSP (next, tokens) = parse_expr(tokens, name) DCNL DCSP  DCSP result.append(next) DCNL DCSP return result
def GetLabel(plist): DCNL  DCSP try: DCNL DCSP  DCSP return plist['Label'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return 'False'
def make_scorer(score_func, greater_is_better=True, needs_proba=False, needs_threshold=False, **kwargs): DCNL  DCSP sign = (1 if greater_is_better else (-1)) DCNL DCSP if (needs_proba and needs_threshold): DCNL DCSP  DCSP raise ValueError('Set DCSP either DCSP needs_proba DCSP or DCSP needs_threshold DCSP to DCSP True, DCSP but DCSP not DCSP both.') DCNL DCSP if needs_proba: DCNL DCSP  DCSP cls = _ProbaScorer DCNL DCSP elif needs_threshold: DCNL DCSP  DCSP cls = _ThresholdScorer DCNL DCSP else: DCNL DCSP  DCSP cls = _PredictScorer DCNL DCSP return cls(score_func, sign, kwargs)
def _get_borrowing_getitem(context, seqty): DCNL  DCSP retty = seqty.dtype DCNL DCSP getitem_impl = context.get_function('getitem', signature(retty, seqty, types.intp)) DCNL DCSP def wrap(builder, args): DCNL DCSP  DCSP ret = getitem_impl(builder, args) DCNL DCSP  DCSP if context.enable_nrt: DCNL DCSP  DCSP  DCSP context.nrt.decref(builder, retty, ret) DCNL DCSP  DCSP return ret DCNL DCSP return wrap
def _make_entity_from_pb(annotations): DCNL  DCSP return [EntityAnnotation.from_pb(annotation) for annotation in annotations]
def route_view(request): DCNL  DCSP return Response('route')
def splitByCommas(str): DCNL  DCSP out = [] DCNL DCSP if (not str): DCNL DCSP  DCSP return out DCNL DCSP current = '' DCNL DCSP openQuotes = '"\'<({' DCNL DCSP closeQuotes = '"\'>)}' DCNL DCSP matchingQuote = '' DCNL DCSP insideQuotes = False DCNL DCSP nextIsLiteral = False DCNL DCSP for char in str: DCNL DCSP  DCSP if nextIsLiteral: DCNL DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP nextIsLiteral = False DCNL DCSP  DCSP elif insideQuotes: DCNL DCSP  DCSP  DCSP if (char == '\\'): DCNL DCSP  DCSP  DCSP  DCSP nextIsLiteral = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP  DCSP if (char == matchingQuote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP insideQuotes = False DCNL DCSP  DCSP elif (char == ','): DCNL DCSP  DCSP  DCSP out.append(current.strip()) DCNL DCSP  DCSP  DCSP current = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP quoteIndex = openQuotes.find(char) DCNL DCSP  DCSP  DCSP if (quoteIndex > (-1)): DCNL DCSP  DCSP  DCSP  DCSP matchingQuote = closeQuotes[quoteIndex] DCNL DCSP  DCSP  DCSP  DCSP insideQuotes = True DCNL DCSP out.append(current.strip()) DCNL DCSP return out
def read_style_directory(style_dir): DCNL  DCSP styles = dict() DCNL DCSP for (path, name) in iter_style_files(style_dir): DCNL DCSP  DCSP with warnings.catch_warnings(record=True) as warns: DCNL DCSP  DCSP  DCSP styles[name] = rc_params_from_file(path, use_default_template=False) DCNL DCSP  DCSP for w in warns: DCNL DCSP  DCSP  DCSP message = (u'In DCSP %s: DCSP %s' % (path, w.message)) DCNL DCSP  DCSP  DCSP warnings.warn(message) DCNL DCSP return styles
def getNumberOfBezierPoints(begin, end, xmlElement): DCNL  DCSP numberOfBezierPoints = int(math.ceil((0.5 * evaluate.getSidesMinimumThreeBasedOnPrecision(abs((end - begin)), xmlElement)))) DCNL DCSP return evaluate.getEvaluatedIntDefault(numberOfBezierPoints, 'sides', xmlElement)
def render_home(framework_name): DCNL  DCSP template = env.get_template('index.html') DCNL DCSP return template.render(providers=ASSEMBLED_CONFIG, oauth2_providers=OAUTH2_PROVIDERS, oauth1_providers=OAUTH1_PROVIDERS, openid_providers=OPENID_PROVIDERS, framework_name=framework_name)
def educateDashesOldSchoolInverted(str): DCNL  DCSP str = re.sub('---', '&#8211;', str) DCNL DCSP str = re.sub('--', '&#8212;', str) DCNL DCSP return str
def digest_secure_bootloader(args): DCNL  DCSP if (args.iv is not None): DCNL DCSP  DCSP print 'WARNING: DCSP --iv DCSP argument DCSP is DCSP for DCSP TESTING DCSP PURPOSES DCSP ONLY' DCNL DCSP  DCSP iv = args.iv.read(128) DCNL DCSP else: DCNL DCSP  DCSP iv = os.urandom(128) DCNL DCSP plaintext_image = args.image.read() DCNL DCSP if ((len(plaintext_image) % 128) != 0): DCNL DCSP  DCSP plaintext_image += ('\xff' * (128 - (len(plaintext_image) % 128))) DCNL DCSP plaintext = (iv + plaintext_image) DCNL DCSP key = args.keyfile.read() DCNL DCSP if (len(key) != 32): DCNL DCSP  DCSP raise esptool.FatalError(('Key DCSP file DCSP contains DCSP wrong DCSP length DCSP (%d DCSP bytes), DCSP 32 DCSP expected.' % len(key))) DCNL DCSP aes = pyaes.AESModeOfOperationECB(key) DCNL DCSP digest = hashlib.sha512() DCNL DCSP for block in get_chunks(plaintext, 16): DCNL DCSP  DCSP block = block[::(-1)] DCNL DCSP  DCSP cipher_block = aes.encrypt(block) DCNL DCSP  DCSP cipher_block = cipher_block[::(-1)] DCNL DCSP  DCSP for block in get_chunks(cipher_block, 4): DCNL DCSP  DCSP  DCSP digest.update(block[::(-1)]) DCNL DCSP if (args.output is None): DCNL DCSP  DCSP args.output = (os.path.splitext(args.image.name)[0] + '-digest-0x0000.bin') DCNL DCSP with open(args.output, 'wb') as f: DCNL DCSP  DCSP f.write(iv) DCNL DCSP  DCSP digest = digest.digest() DCNL DCSP  DCSP for word in get_chunks(digest, 4): DCNL DCSP  DCSP  DCSP f.write(word[::(-1)]) DCNL DCSP  DCSP f.write(('\xff' * (4096 - f.tell()))) DCNL DCSP  DCSP f.write(plaintext_image) DCNL DCSP print ('digest+image DCSP written DCSP to DCSP %s' % args.output)
def get_optional_parameters(dictionary): DCNL  DCSP return {key: dictionary[key] for key in OPTIONAL_PARAMETERS if (key in dictionary)}
def main(): DCNL  DCSP django.setup() DCNL DCSP switch1 = NetworkSwitch.objects.get(device_name='pynet-sw1') DCNL DCSP switch2 = NetworkSwitch.objects.get(device_name='pynet-sw2') DCNL DCSP switch3 = NetworkSwitch.objects.get(device_name='pynet-sw3') DCNL DCSP switch4 = NetworkSwitch.objects.get(device_name='pynet-sw4') DCNL DCSP print 'Creating DCSP Switch1 DCSP port DCSP objects' DCNL DCSP std_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 200), ('Ethernet7', 200)] DCNL DCSP for (switchport, vlan) in std_ports: DCNL DCSP  DCSP create_access_port(switch1, switchport, vlan) DCNL DCSP create_trunk_port(switch1, 'Ethernet4') DCNL DCSP create_lag_port(switch1, 'Ethernet5', lag_mode='active', lag_group=1) DCNL DCSP create_lag_port(switch1, 'Ethernet6', lag_mode='active', lag_group=1) DCNL DCSP create_trunk_port(switch1, 'Port-channel1') DCNL DCSP print 'Creating DCSP Switch2 DCSP port DCSP objects' DCNL DCSP std_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 200), ('Ethernet5', 300)] DCNL DCSP for (switchport, vlan) in std_ports: DCNL DCSP  DCSP create_access_port(switch2, switchport, vlan) DCNL DCSP create_trunk_port(switch2, 'Ethernet6', native_vlan=300, allowed_vlans='100,200,300') DCNL DCSP create_trunk_port(switch2, 'Ethernet7', native_vlan=300, allowed_vlans='100,200,300') DCNL DCSP print 'Creating DCSP Switch3 DCSP port DCSP objects' DCNL DCSP std_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 100), ('Ethernet5', 100), ('Ethernet6', 200), ('Ethernet7', 200)] DCNL DCSP for (switchport, vlan) in std_ports: DCNL DCSP  DCSP create_access_port(switch3, switchport, vlan) DCNL DCSP print 'Creating DCSP Switch4 DCSP port DCSP objects' DCNL DCSP std_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 100), ('Ethernet5', 100)] DCNL DCSP for (switchport, vlan) in std_ports: DCNL DCSP  DCSP create_access_port(switch4, switchport, vlan) DCNL DCSP create_trunk_port(switch4, 'Ethernet6', native_vlan=300, allowed_vlans='100,200,300') DCNL DCSP create_trunk_port(switch4, 'Ethernet7', native_vlan=300, allowed_vlans='100,200,300')
def title_from_columns(cols): DCNL  DCSP if (cols is not None): DCNL DCSP  DCSP cols_title = copy(cols) DCNL DCSP  DCSP if (not isinstance(cols_title, list)): DCNL DCSP  DCSP  DCSP cols_title = [cols_title] DCNL DCSP  DCSP return str(', DCSP '.join(cols_title).title()).title() DCNL DCSP else: DCNL DCSP  DCSP return None
def retention_action(client, stream_name, retention_period=24, action='increase', check_mode=False): DCNL  DCSP success = False DCNL DCSP err_msg = '' DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP try: DCNL DCSP  DCSP if (not check_mode): DCNL DCSP  DCSP  DCSP if (action == 'increase'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPeriodHours'] = retention_period DCNL DCSP  DCSP  DCSP  DCSP client.increase_stream_retention_period(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Period DCSP increased DCSP successfully DCSP to DCSP {0}'.format(retention_period) DCNL DCSP  DCSP  DCSP elif (action == 'decrease'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPeriodHours'] = retention_period DCNL DCSP  DCSP  DCSP  DCSP client.decrease_stream_retention_period(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Period DCSP decreased DCSP successfully DCSP to DCSP {0}'.format(retention_period) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Invalid DCSP action DCSP {0}'.format(action) DCNL DCSP  DCSP elif (action == 'increase'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif (action == 'decrease'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'Invalid DCSP action DCSP {0}'.format(action) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg)
def test_javascript_url(): DCNL  DCSP s = 'javascript:document.vulnerable' DCNL DCSP eq_(s, linkify(s))
def sign_string_v2(string_to_sign): DCNL  DCSP signature = base64.encodestring(hmac.new(Config.Config().secret_key, deunicodise(string_to_sign), sha1).digest()).strip() DCNL DCSP return signature
def getSquareLoopWiddershins(beginComplex, endComplex): DCNL  DCSP loop = [beginComplex, complex(endComplex.real, beginComplex.imag), endComplex] DCNL DCSP loop.append(complex(beginComplex.real, endComplex.imag)) DCNL DCSP return loop
@treeio_login_required DCNL def ical_all_event(request, response_format='ical'): DCNL  DCSP query = Q() DCNL DCSP events = Object.filter_by_request(request, Event.objects.filter(query)) DCNL DCSP icalstream = 'BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\nMETHOD:PUBLISH\nPRODID:-//PYVOBJECT//NONSGML DCSP Version DCSP 1//EN\n' DCNL DCSP vevent = '' DCNL DCSP for event in events: DCNL DCSP  DCSP vevent += 'BEGIN:VEVENT\n' DCNL DCSP  DCSP if event.start: DCNL DCSP  DCSP  DCSP vevent += ('DTSTART;VALUE=DATE:%s\n' % str(datetime.strptime(str(event.start)[0:10], '%Y-%m-%d'))[0:10].replace('-', '')) DCNL DCSP  DCSP vevent += ('DTEND;VALUE=DATE:%s\n' % str(datetime.strptime(str(event.end)[0:10], '%Y-%m-%d'))[0:10].replace('-', '')) DCNL DCSP  DCSP if (not event.details): DCNL DCSP  DCSP  DCSP vevent += ('SUMMARY:%s\n' % strip_tags(event.name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vevent += ('SUMMARY:%s\n' % strip_tags(event.details)) DCNL DCSP  DCSP vevent += ('UID:%s\n' % event.name) DCNL DCSP  DCSP vevent += 'END:VEVENT\n' DCNL DCSP icalstream += vevent DCNL DCSP icalstream += 'X-WR-CALDESC:Tree.io DCSP Calendar\nX-WR-CALNAME:Tree.io\nX-WR-TIMEZONE:London/UK\nEND:VCALENDAR\n' DCNL DCSP response = HttpResponse(icalstream, content_type='text/calendar') DCNL DCSP response['Filename'] = 'events.ics' DCNL DCSP response['Content-Disposition'] = 'attachment; DCSP filename=events.ics' DCNL DCSP return response
def test_read_normal_names_include(): DCNL  DCSP table = '\n# DCSP comment DCSP (with DCSP blank DCSP line DCSP above)\n| DCSP  DCSP Col1 DCSP  DCSP | DCSP  DCSP Col2 DCSP  DCSP  DCSP | DCSP  DCSP Col3 DCSP |\n| DCSP  DCSP 1.2 DCSP  DCSP  DCSP | DCSP "hello" DCSP | DCSP  DCSP  DCSP  DCSP  DCSP 3 DCSP |\n| DCSP  DCSP 2.4 DCSP  DCSP  DCSP |\'s DCSP worlds| DCSP  DCSP  DCSP  DCSP  DCSP 7 DCSP |\n' DCNL DCSP reader = ascii.get_reader(Reader=ascii.FixedWidth, names=('name1', 'name2', 'name3'), include_names=('name1', 'name3')) DCNL DCSP dat = reader.read(table) DCNL DCSP assert_equal(dat.colnames, ['name1', 'name3']) DCNL DCSP assert_almost_equal(dat[1][0], 2.4) DCNL DCSP assert_equal(dat[0][1], 3)
def get_database_string(fname): DCNL  DCSP f = open(fname) DCNL DCSP dtb = f.read() DCNL DCSP f.close() DCNL DCSP return dtb
def ipython_display(clip, filetype=None, maxduration=60, t=None, fps=None, rd_kwargs=None, center=True, **html_kwargs): DCNL  DCSP if (not ipython_available): DCNL DCSP  DCSP raise ImportError('Only DCSP works DCSP inside DCSP an DCSP IPython DCSP Notebook') DCNL DCSP if (rd_kwargs is None): DCNL DCSP  DCSP rd_kwargs = {} DCNL DCSP if (fps is not None): DCNL DCSP  DCSP rd_kwargs['fps'] = fps DCNL DCSP if (t is not None): DCNL DCSP  DCSP clip = clip.to_ImageClip(t) DCNL DCSP return HTML2(html_embed(clip, filetype=filetype, maxduration=maxduration, center=center, rd_kwargs=rd_kwargs, **html_kwargs))
def distance_transform_bf(input, metric='euclidean', sampling=None, return_distances=True, return_indices=False, distances=None, indices=None): DCNL  DCSP if ((not return_distances) and (not return_indices)): DCNL DCSP  DCSP msg = 'at DCSP least DCSP one DCSP of DCSP distances/indices DCSP must DCSP be DCSP specified' DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP tmp1 = (numpy.asarray(input) != 0) DCNL DCSP struct = generate_binary_structure(tmp1.ndim, tmp1.ndim) DCNL DCSP tmp2 = binary_dilation(tmp1, struct) DCNL DCSP tmp2 = numpy.logical_xor(tmp1, tmp2) DCNL DCSP tmp1 = (tmp1.astype(numpy.int8) - tmp2.astype(numpy.int8)) DCNL DCSP metric = metric.lower() DCNL DCSP if (metric == 'euclidean'): DCNL DCSP  DCSP metric = 1 DCNL DCSP elif (metric in ['taxicab', 'cityblock', 'manhattan']): DCNL DCSP  DCSP metric = 2 DCNL DCSP elif (metric == 'chessboard'): DCNL DCSP  DCSP metric = 3 DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('distance DCSP metric DCSP not DCSP supported') DCNL DCSP if (sampling is not None): DCNL DCSP  DCSP sampling = _ni_support._normalize_sequence(sampling, tmp1.ndim) DCNL DCSP  DCSP sampling = numpy.asarray(sampling, dtype=numpy.float64) DCNL DCSP  DCSP if (not sampling.flags.contiguous): DCNL DCSP  DCSP  DCSP sampling = sampling.copy() DCNL DCSP if return_indices: DCNL DCSP  DCSP ft = numpy.zeros(tmp1.shape, dtype=numpy.int32) DCNL DCSP else: DCNL DCSP  DCSP ft = None DCNL DCSP if return_distances: DCNL DCSP  DCSP if (distances is None): DCNL DCSP  DCSP  DCSP if (metric == 1): DCNL DCSP  DCSP  DCSP  DCSP dt = numpy.zeros(tmp1.shape, dtype=numpy.float64) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP dt = numpy.zeros(tmp1.shape, dtype=numpy.uint32) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (distances.shape != tmp1.shape): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('distances DCSP array DCSP has DCSP wrong DCSP shape') DCNL DCSP  DCSP  DCSP if (metric == 1): DCNL DCSP  DCSP  DCSP  DCSP if (distances.dtype.type != numpy.float64): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('distances DCSP array DCSP must DCSP be DCSP float64') DCNL DCSP  DCSP  DCSP elif (distances.dtype.type != numpy.uint32): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('distances DCSP array DCSP must DCSP be DCSP uint32') DCNL DCSP  DCSP  DCSP dt = distances DCNL DCSP else: DCNL DCSP  DCSP dt = None DCNL DCSP _nd_image.distance_transform_bf(tmp1, metric, sampling, dt, ft) DCNL DCSP if return_indices: DCNL DCSP  DCSP if isinstance(indices, numpy.ndarray): DCNL DCSP  DCSP  DCSP if (indices.dtype.type != numpy.int32): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('indices DCSP must DCSP of DCSP int32 DCSP type') DCNL DCSP  DCSP  DCSP if (indices.shape != ((tmp1.ndim,) + tmp1.shape)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('indices DCSP has DCSP wrong DCSP shape') DCNL DCSP  DCSP  DCSP tmp2 = indices DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp2 = numpy.indices(tmp1.shape, dtype=numpy.int32) DCNL DCSP  DCSP ft = numpy.ravel(ft) DCNL DCSP  DCSP for ii in range(tmp2.shape[0]): DCNL DCSP  DCSP  DCSP rtmp = numpy.ravel(tmp2[ii, ...])[ft] DCNL DCSP  DCSP  DCSP rtmp.shape = tmp1.shape DCNL DCSP  DCSP  DCSP tmp2[ii, ...] = rtmp DCNL DCSP  DCSP ft = tmp2 DCNL DCSP result = [] DCNL DCSP if (return_distances and (not isinstance(distances, numpy.ndarray))): DCNL DCSP  DCSP result.append(dt) DCNL DCSP if (return_indices and (not isinstance(indices, numpy.ndarray))): DCNL DCSP  DCSP result.append(ft) DCNL DCSP if (len(result) == 2): DCNL DCSP  DCSP return tuple(result) DCNL DCSP elif (len(result) == 1): DCNL DCSP  DCSP return result[0] DCNL DCSP else: DCNL DCSP  DCSP return None
def upload_dev_pdf(user='pandas'): DCNL  DCSP if os.system('cd DCSP build/latex; DCSP scp DCSP pandas.pdf DCSP {0}@pandas.pydata.org:/usr/share/nginx/pandas/pandas-docs/dev/'.format(user)): DCNL DCSP  DCSP raise SystemExit('PDF DCSP upload DCSP to DCSP Pydata DCSP Dev DCSP failed')
def load_csr(*names): DCNL  DCSP loader = _guess_loader(names[(-1)], OpenSSL.crypto.FILETYPE_PEM, OpenSSL.crypto.FILETYPE_ASN1) DCNL DCSP return OpenSSL.crypto.load_certificate_request(loader, load_vector(*names))
def auto_openstack_logging(interface, original): DCNL  DCSP return interface_decorator('auto_openstack_logging', interface, _openstack_logged_method, original)
def handle_translate(translation, request, user_locked, this_unit_url, next_unit_url): DCNL  DCSP antispam = AntispamForm(request.POST) DCNL DCSP if (not antispam.is_valid()): DCNL DCSP  DCSP return HttpResponseRedirect(next_unit_url) DCNL DCSP translation.check_sync() DCNL DCSP form = TranslationForm(translation, None, request.POST) DCNL DCSP if (not form.is_valid()): DCNL DCSP  DCSP return DCNL DCSP unit = form.cleaned_data[u'unit'] DCNL DCSP go_next = True DCNL DCSP if (u'suggest' in request.POST): DCNL DCSP  DCSP go_next = perform_suggestion(unit, form, request) DCNL DCSP elif (not can_translate(request.user, unit.translation)): DCNL DCSP  DCSP messages.error(request, _(u"You DCSP don't DCSP have DCSP privileges DCSP to DCSP save DCSP translations!")) DCNL DCSP elif (not user_locked): DCNL DCSP  DCSP message = request.POST.get(u'commit_message', None) DCNL DCSP  DCSP if ((message is not None) and (message != unit.translation.commit_message)): DCNL DCSP  DCSP  DCSP unit.translation.commit_pending(request, request.user) DCNL DCSP  DCSP  DCSP unit.translation.commit_message = message DCNL DCSP  DCSP  DCSP unit.translation.save() DCNL DCSP  DCSP go_next = perform_translation(unit, form, request) DCNL DCSP if go_next: DCNL DCSP  DCSP return HttpResponseRedirect(next_unit_url) DCNL DCSP else: DCNL DCSP  DCSP return HttpResponseRedirect(this_unit_url)
def get_group_type_by_name(context, name): DCNL  DCSP if (name is None): DCNL DCSP  DCSP msg = _('name DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidGroupType(reason=msg) DCNL DCSP return db.group_type_get_by_name(context, name)
def get_github_releases(project): DCNL  DCSP url = u'{}/{}/tags'.format(GITHUB_API, project) DCNL DCSP response = requests.get(url) DCNL DCSP response.raise_for_status() DCNL DCSP versions = get_versions(response.json()) DCNL DCSP return sorted(versions, reverse=True, key=operator.attrgetter(u'order'))
def get_client(host, port=None, timeout=None, use_ssl=False, username=None, password=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_upload=False, insecure=False): DCNL  DCSP if (auth_url or os.getenv('OS_AUTH_URL')): DCNL DCSP  DCSP force_strategy = 'keystone' DCNL DCSP else: DCNL DCSP  DCSP force_strategy = None DCNL DCSP creds = {'username': (username or os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME'))), 'password': (password or os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD'))), 'tenant': (tenant or os.getenv('OS_AUTH_TENANT', os.getenv('OS_TENANT_NAME'))), 'auth_url': (auth_url or os.getenv('OS_AUTH_URL')), 'strategy': (force_strategy or auth_strategy or os.getenv('OS_AUTH_STRATEGY', 'noauth')), 'region': (region or os.getenv('OS_REGION_NAME'))} DCNL DCSP if ((creds['strategy'] == 'keystone') and (not creds['auth_url'])): DCNL DCSP  DCSP msg = '--os_auth_url DCSP option DCSP or DCSP OS_AUTH_URL DCSP environment DCSP variable DCSP required DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enabled\n' DCNL DCSP  DCSP raise exception.ClientConfigurationError(msg) DCNL DCSP return CacheClient(host=host, port=port, timeout=timeout, use_ssl=use_ssl, auth_tok=(auth_token or os.getenv('OS_TOKEN')), creds=creds, insecure=insecure)
def load_item_types(): DCNL  DCSP item_types = {} DCNL DCSP for meta_source in META_SOURCES.values(): DCNL DCSP  DCSP item_types.update(meta_source.item_types) DCNL DCSP return item_types
def join_options(options): DCNL  DCSP rv = [] DCNL DCSP any_prefix_is_slash = False DCNL DCSP for opt in options: DCNL DCSP  DCSP prefix = split_opt(opt)[0] DCNL DCSP  DCSP if (prefix == '/'): DCNL DCSP  DCSP  DCSP any_prefix_is_slash = True DCNL DCSP  DCSP rv.append((len(prefix), opt)) DCNL DCSP rv.sort(key=(lambda x: x[0])) DCNL DCSP rv = ', DCSP '.join((x[1] for x in rv)) DCNL DCSP return (rv, any_prefix_is_slash)
def fake_view(request): DCNL  DCSP return HttpResponse(json.dumps(request.META))
def group_membership(): DCNL  DCSP if (auth.permission.format != 's3json'): DCNL DCSP  DCSP return '' DCNL DCSP def prep(r): DCNL DCSP  DCSP if (r.method != 'options'): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller()
def user_field(user, field, *args): DCNL  DCSP if (field and hasattr(user, field)): DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP v = args[0] DCNL DCSP  DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP  DCSP User = get_user_model() DCNL DCSP  DCSP  DCSP  DCSP v = v[0:User._meta.get_field(field).max_length] DCNL DCSP  DCSP  DCSP setattr(user, field, v) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return getattr(user, field)
def set_marker(folder): DCNL  DCSP name = cfg.marker_file() DCNL DCSP if name: DCNL DCSP  DCSP path = os.path.join(folder, name) DCNL DCSP  DCSP logging.debug('Create DCSP marker DCSP file DCSP %s', path) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fp = open(path, 'w') DCNL DCSP  DCSP  DCSP fp.close() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP logging.info('Cannot DCSP create DCSP marker DCSP file DCSP %s', path) DCNL DCSP  DCSP  DCSP logging.info('Traceback: DCSP ', exc_info=True) DCNL DCSP  DCSP  DCSP name = None DCNL DCSP return name
def bind_floating_ip(floating_ip, device): DCNL  DCSP _execute('ip', 'addr', 'add', (str(floating_ip) + '/32'), 'dev', device, run_as_root=True, check_exit_code=[0, 2, 254]) DCNL DCSP if (CONF.send_arp_for_ha and (CONF.send_arp_for_ha_count > 0)): DCNL DCSP  DCSP send_arp_for_ip(floating_ip, device, CONF.send_arp_for_ha_count)
def test_hermite_cardinal(Chart, datas): DCNL  DCSP chart = Chart(interpolate='hermite', interpolation_parameters={'type': 'cardinal', 'c': 0.75}) DCNL DCSP chart = make_data(chart, datas) DCNL DCSP assert chart.render()
@frappe.whitelist() DCNL def rename_doc(doctype, old, new, force=False, merge=False, ignore_permissions=False): DCNL  DCSP if (not frappe.db.exists(doctype, old)): DCNL DCSP  DCSP return DCNL DCSP force = cint(force) DCNL DCSP merge = cint(merge) DCNL DCSP meta = frappe.get_meta(doctype) DCNL DCSP old_doc = frappe.get_doc(doctype, old) DCNL DCSP out = (old_doc.run_method(u'before_rename', old, new, merge) or {}) DCNL DCSP new = ((out.get(u'new') or new) if isinstance(out, dict) else (out or new)) DCNL DCSP if (doctype != u'DocType'): DCNL DCSP  DCSP new = validate_rename(doctype, new, meta, merge, force, ignore_permissions) DCNL DCSP if (not merge): DCNL DCSP  DCSP rename_parent_and_child(doctype, old, new, meta) DCNL DCSP link_fields = get_link_fields(doctype) DCNL DCSP update_link_field_values(link_fields, old, new, doctype) DCNL DCSP rename_dynamic_links(doctype, old, new) DCNL DCSP if (doctype == u'DocType'): DCNL DCSP  DCSP rename_doctype(doctype, old, new, force) DCNL DCSP update_attachments(doctype, old, new) DCNL DCSP if merge: DCNL DCSP  DCSP frappe.delete_doc(doctype, old) DCNL DCSP new_doc = frappe.get_doc(doctype, new) DCNL DCSP new_doc._local = getattr(old_doc, u'_local', None) DCNL DCSP new_doc.run_method(u'after_rename', old, new, merge) DCNL DCSP rename_versions(doctype, old, new) DCNL DCSP if (not merge): DCNL DCSP  DCSP rename_password(doctype, old, new) DCNL DCSP frappe.db.sql(u"update DCSP tabDefaultValue DCSP set DCSP defvalue=%s DCSP where DCSP parenttype='User DCSP Permission'\n DCTB  DCTB and DCSP defkey=%s DCSP and DCSP defvalue=%s", (new, doctype, old)) DCNL DCSP frappe.clear_cache() DCNL DCSP if merge: DCNL DCSP  DCSP new_doc.add_comment(u'Edit', _(u'merged DCSP {0} DCSP into DCSP {1}').format(frappe.bold(old), frappe.bold(new))) DCNL DCSP else: DCNL DCSP  DCSP new_doc.add_comment(u'Edit', _(u'renamed DCSP from DCSP {0} DCSP to DCSP {1}').format(frappe.bold(old), frappe.bold(new))) DCNL DCSP return new
def commit_transaction(hostname, username, password, label): DCNL  DCSP bigip_session = _build_session(username, password) DCNL DCSP trans_id = __salt__['grains.get']('bigip_f5_trans:{label}'.format(label=label)) DCNL DCSP if trans_id: DCNL DCSP  DCSP payload = {} DCNL DCSP  DCSP payload['state'] = 'VALIDATING' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = bigip_session.patch((BIG_IP_URL_BASE.format(host=hostname) + '/transaction/{trans_id}'.format(trans_id=trans_id)), data=json.dumps(payload)) DCNL DCSP  DCSP  DCSP return _load_response(response) DCNL DCSP  DCSP except requests.exceptions.ConnectionError as e: DCNL DCSP  DCSP  DCSP return _load_connection_error(hostname, e) DCNL DCSP else: DCNL DCSP  DCSP return 'Error: DCSP the DCSP label DCSP for DCSP this DCSP transaction DCSP was DCSP not DCSP defined DCSP as DCSP a DCSP grain. DCSP  DCSP Begin DCSP a DCSP new DCSP transaction DCSP using DCSP the DCSP bigip.start_transaction DCSP function'
def invoke_cmd(stdout, stderr, environ, prefix, cmd, cmd_args, error_msg, error_status): DCNL  DCSP func_name = (prefix + cmd) DCNL DCSP if (func_name in globals()): DCNL DCSP  DCSP return globals()[func_name](stdout, stderr, environ, *cmd_args) DCNL DCSP else: DCNL DCSP  DCSP stderr.write(error_msg) DCNL DCSP  DCSP return (-1)
@register_stabilize DCNL @register_specialize DCNL @register_canonicalize DCNL @gof.local_optimizer([T.Elemwise]) DCNL def local_expm1(node): DCNL  DCSP if (isinstance(node.op, T.Elemwise) and isinstance(node.op.scalar_op, theano.scalar.basic.Sub)): DCNL DCSP  DCSP (in1, in2) = node.inputs DCNL DCSP  DCSP out = node.outputs[0] DCNL DCSP  DCSP if (in1.owner and isinstance(in1.owner.op, T.Elemwise) and isinstance(in1.owner.op.scalar_op, theano.scalar.basic.Exp) and (T.extract_constant(in2, only_process_constants=False) == 1)): DCNL DCSP  DCSP  DCSP in11 = in1.owner.inputs[0] DCNL DCSP  DCSP  DCSP new_out = T.expm1(in11) DCNL DCSP  DCSP  DCSP if (new_out.dtype != out.dtype): DCNL DCSP  DCSP  DCSP  DCSP new_out = T.cast(new_out, dtype=out.dtype) DCNL DCSP  DCSP  DCSP if (new_out.type != out.type): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP return [new_out]
@register.tag DCNL def firstof(parser, token): DCNL  DCSP return defaulttags.firstof(parser, token, escape=True)
def freecpu(): DCNL  DCSP conn = __get_conn() DCNL DCSP cpus = conn.getInfo()[2] DCNL DCSP for vm_ in list_domains(): DCNL DCSP  DCSP dom = _get_domain(vm_) DCNL DCSP  DCSP if (dom.ID() > 0): DCNL DCSP  DCSP  DCSP cpus -= dom.info()[3] DCNL DCSP return cpus
def unexpected_fail_on_npm_install(arg): DCNL  DCSP if ('npm DCSP install' in arg): DCNL DCSP  DCSP raise BuildFailure('Subprocess DCSP return DCSP code: DCSP 50') DCNL DCSP else: DCNL DCSP  DCSP return
def _list_interface_private_addrs(eni_desc): DCNL  DCSP primary = eni_desc.get('privateIpAddress') DCNL DCSP if (not primary): DCNL DCSP  DCSP return None DCNL DCSP addresses = [primary] DCNL DCSP lst = eni_desc.get('privateIpAddressesSet', {}).get('item', []) DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP return addresses DCNL DCSP for entry in lst: DCNL DCSP  DCSP if (entry.get('primary') == 'true'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if entry.get('privateIpAddress'): DCNL DCSP  DCSP  DCSP addresses.append(entry.get('privateIpAddress')) DCNL DCSP return addresses
def ls_(path='/', profile=None): DCNL  DCSP client = __utils__['etcd_util.get_conn'](__opts__, profile) DCNL DCSP return client.ls(path)
def _detect_gce_environment(): DCNL  DCSP http = transport.get_http_object(timeout=GCE_METADATA_TIMEOUT) DCNL DCSP try: DCNL DCSP  DCSP (response, _) = transport.request(http, _GCE_METADATA_URI, headers=_GCE_HEADERS) DCNL DCSP  DCSP return ((response.status == http_client.OK) and (response.get(_METADATA_FLAVOR_HEADER) == _DESIRED_METADATA_FLAVOR)) DCNL DCSP except socket.error: DCNL DCSP  DCSP logger.info('Timeout DCSP attempting DCSP to DCSP reach DCSP GCE DCSP metadata DCSP service.') DCNL DCSP  DCSP return False
@testing.requires_testing_data DCNL def test_dipole_fitting_fixed(): DCNL  DCSP tpeak = 0.073 DCNL DCSP sphere = make_sphere_model(head_radius=0.1) DCNL DCSP evoked = read_evokeds(fname_evo, baseline=(None, 0))[0] DCNL DCSP evoked.pick_types(meg=True) DCNL DCSP t_idx = np.argmin(np.abs((tpeak - evoked.times))) DCNL DCSP evoked_crop = evoked.copy().crop(tpeak, tpeak) DCNL DCSP assert_equal(len(evoked_crop.times), 1) DCNL DCSP cov = read_cov(fname_cov) DCNL DCSP (dip_seq, resid) = fit_dipole(evoked_crop, cov, sphere) DCNL DCSP assert_true(isinstance(dip_seq, Dipole)) DCNL DCSP assert_equal(len(dip_seq.times), 1) DCNL DCSP (pos, ori, gof) = (dip_seq.pos[0], dip_seq.ori[0], dip_seq.gof[0]) DCNL DCSP amp = dip_seq.amplitude[0] DCNL DCSP (dip_free, resid_free) = fit_dipole(evoked, cov, sphere, pos=pos) DCNL DCSP assert_true(isinstance(dip_free, Dipole)) DCNL DCSP assert_allclose(dip_free.times, evoked.times) DCNL DCSP assert_allclose(np.tile(pos[np.newaxis], (len(evoked.times), 1)), dip_free.pos) DCNL DCSP assert_allclose(ori, dip_free.ori[t_idx]) DCNL DCSP assert_true((np.dot(dip_free.ori, ori).mean() < 0.9)) DCNL DCSP assert_allclose(gof, dip_free.gof[t_idx]) DCNL DCSP assert_allclose(amp, dip_free.amplitude[t_idx]) DCNL DCSP assert_allclose(resid, resid_free[:, [t_idx]]) DCNL DCSP (dip_fixed, resid_fixed) = fit_dipole(evoked, cov, sphere, pos=pos, ori=ori) DCNL DCSP assert_true(isinstance(dip_fixed, DipoleFixed)) DCNL DCSP assert_allclose(dip_fixed.times, evoked.times) DCNL DCSP assert_allclose(dip_fixed.info['chs'][0]['loc'][:3], pos) DCNL DCSP assert_allclose(dip_fixed.info['chs'][0]['loc'][3:6], ori) DCNL DCSP assert_allclose(dip_fixed.data[(1, t_idx)], gof) DCNL DCSP assert_allclose(resid, resid_fixed[:, [t_idx]]) DCNL DCSP _check_roundtrip_fixed(dip_fixed) DCNL DCSP evoked_nan = evoked.copy().crop(0, 0) DCNL DCSP evoked_nan.data[(0, 0)] = None DCNL DCSP assert_raises(ValueError, fit_dipole, evoked_nan, cov, sphere) DCNL DCSP assert_raises(ValueError, fit_dipole, evoked, cov, sphere, ori=[1, 0, 0]) DCNL DCSP assert_raises(ValueError, fit_dipole, evoked, cov, sphere, pos=[0, 0, 0], ori=[2, 0, 0]) DCNL DCSP assert_raises(ValueError, fit_dipole, evoked, cov, sphere, pos=[0.1, 0, 0])
def _rec_list_terms(g, v, monom): DCNL  DCSP (d, terms) = (dmp_degree(g, v), []) DCNL DCSP if (not v): DCNL DCSP  DCSP for (i, c) in enumerate(g): DCNL DCSP  DCSP  DCSP if (not c): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP terms.append(((monom + ((d - i),)), c)) DCNL DCSP else: DCNL DCSP  DCSP w = (v - 1) DCNL DCSP  DCSP for (i, c) in enumerate(g): DCNL DCSP  DCSP  DCSP terms.extend(_rec_list_terms(c, w, (monom + ((d - i),)))) DCNL DCSP return terms
def update_quota(tenant_id, subnet=None, router=None, network=None, floatingip=None, port=None, security_group=None, security_group_rule=None, profile=None): DCNL  DCSP conn = _auth(profile) DCNL DCSP return conn.update_quota(tenant_id, subnet, router, network, floatingip, port, security_group, security_group_rule)
@staff_member_required DCNL def static_proxy(request): DCNL  DCSP normalize = (lambda u: ((u'//' + u.split(u'://')[(-1)]) if (u'://' in u) else u)) DCNL DCSP url = normalize(request.GET[u'u']) DCNL DCSP host = (u'//' + request.get_host()) DCNL DCSP static_url = normalize(settings.STATIC_URL) DCNL DCSP for prefix in (host, static_url, u'/'): DCNL DCSP  DCSP if url.startswith(prefix): DCNL DCSP  DCSP  DCSP url = url.replace(prefix, u'', 1) DCNL DCSP response = u'' DCNL DCSP (content_type, encoding) = mimetypes.guess_type(url) DCNL DCSP if (content_type is None): DCNL DCSP  DCSP content_type = u'application/octet-stream' DCNL DCSP path = finders.find(url) DCNL DCSP if path: DCNL DCSP  DCSP if isinstance(path, (list, tuple)): DCNL DCSP  DCSP  DCSP path = path[0] DCNL DCSP  DCSP if url.endswith(u'.htm'): DCNL DCSP  DCSP  DCSP static_url = ((settings.STATIC_URL + os.path.split(url)[0]) + u'/') DCNL DCSP  DCSP  DCSP if (not urlparse(static_url).scheme): DCNL DCSP  DCSP  DCSP  DCSP static_url = urljoin(host, static_url) DCNL DCSP  DCSP  DCSP base_tag = (u"<base DCSP href='%s'>" % static_url) DCNL DCSP  DCSP  DCSP with open(path, u'r') as f: DCNL DCSP  DCSP  DCSP  DCSP response = f.read().replace(u'<head>', (u'<head>' + base_tag)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(path, u'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP response = f.read() DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseNotFound() DCNL DCSP return HttpResponse(response, content_type=content_type)
def test_cache_remove_data(config_stub, tmpdir): DCNL  DCSP config_stub.data = {'storage': {'cache-size': 1024}, 'general': {'private-browsing': False}} DCNL DCSP url = 'http://qutebrowser.org' DCNL DCSP disk_cache = cache.DiskCache(str(tmpdir)) DCNL DCSP preload_cache(disk_cache, url) DCNL DCSP assert (disk_cache.cacheSize() > 0) DCNL DCSP assert disk_cache.remove(QUrl(url)) DCNL DCSP assert (disk_cache.cacheSize() == 0)
def _executeExternalCmdAndReapStdout(args): DCNL  DCSP _debugOut(('_executeExternalCmdAndReapStdout: DCSP Starting...\n<%s>' % (args,))) DCNL DCSP p = subprocess.Popen(args, env=os.environ, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP _debugOut(('Process DCSP started DCSP for DCSP <%s>' % (args,))) DCNL DCSP (stdoutData, stderrData) = p.communicate() DCNL DCSP _debugOut((('Process DCSP completed DCSP for DCSP <%s>: DCSP exit DCSP status=%s, DCSP ' + 'stdoutDataType=%s, DCSP stdoutData=<%s>, DCSP stderrData=<%s>') % (args, p.returncode, type(stdoutData), stdoutData, stderrData))) DCNL DCSP result = dict(exitStatus=p.returncode, stdoutData=stdoutData, stderrData=stderrData) DCNL DCSP _debugOut(('_executeExternalCmdAndReapStdout DCSP for DCSP <%s>: DCSP result=\n%s' % (args, pprint.pformat(result, indent=4)))) DCNL DCSP return result
def chars_to_ranges(s): DCNL  DCSP char_list = list(s) DCNL DCSP char_list.sort() DCNL DCSP i = 0 DCNL DCSP n = len(char_list) DCNL DCSP result = [] DCNL DCSP while (i < n): DCNL DCSP  DCSP code1 = ord(char_list[i]) DCNL DCSP  DCSP code2 = (code1 + 1) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP while ((i < n) and (code2 >= ord(char_list[i]))): DCNL DCSP  DCSP  DCSP code2 += 1 DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP result.append(code1) DCNL DCSP  DCSP result.append(code2) DCNL DCSP return result
def sfv_check(sfv_path): DCNL  DCSP failed = [] DCNL DCSP try: DCNL DCSP  DCSP fp = open(sfv_path, 'r') DCNL DCSP except: DCNL DCSP  DCSP logging.info('Cannot DCSP open DCSP SFV DCSP file DCSP %s', sfv_path) DCNL DCSP  DCSP failed.append(unicoder(sfv_path)) DCNL DCSP  DCSP return failed DCNL DCSP root = os.path.split(sfv_path)[0] DCNL DCSP for line in fp: DCNL DCSP  DCSP line = line.strip('\n\r DCSP ') DCNL DCSP  DCSP if (line and (line[0] != ';')): DCNL DCSP  DCSP  DCSP x = line.rfind(' DCSP ') DCNL DCSP  DCSP  DCSP if (x > 0): DCNL DCSP  DCSP  DCSP  DCSP filename = platform_encode(line[:x].strip()) DCNL DCSP  DCSP  DCSP  DCSP checksum = line[x:].strip() DCNL DCSP  DCSP  DCSP  DCSP path = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if crc_check(path, checksum): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.debug('File DCSP %s DCSP passed DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.info('File DCSP %s DCSP did DCSP not DCSP pass DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP failed.append(unicoder(filename)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info('File DCSP %s DCSP missing DCSP in DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP failed.append(unicoder(filename)) DCNL DCSP fp.close() DCNL DCSP return failed
def wait_for_image_status(client, image_id, status): DCNL  DCSP if isinstance(client, images_v1_client.ImagesClient): DCNL DCSP  DCSP def _show_image_v1(image_id): DCNL DCSP  DCSP  DCSP resp = client.check_image(image_id) DCNL DCSP  DCSP  DCSP return common_image.get_image_meta_from_headers(resp) DCNL DCSP  DCSP show_image = _show_image_v1 DCNL DCSP else: DCNL DCSP  DCSP show_image = client.show_image DCNL DCSP current_status = 'An DCSP unknown DCSP status' DCNL DCSP start = int(time.time()) DCNL DCSP while ((int(time.time()) - start) < client.build_timeout): DCNL DCSP  DCSP image = show_image(image_id) DCNL DCSP  DCSP if ('image' in image): DCNL DCSP  DCSP  DCSP image = image['image'] DCNL DCSP  DCSP current_status = image['status'] DCNL DCSP  DCSP if (current_status == status): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (current_status.lower() == 'killed'): DCNL DCSP  DCSP  DCSP raise exceptions.ImageKilledException(image_id=image_id, status=status) DCNL DCSP  DCSP if (current_status.lower() == 'error'): DCNL DCSP  DCSP  DCSP raise exceptions.AddImageException(image_id=image_id) DCNL DCSP  DCSP time.sleep(client.build_interval) DCNL DCSP message = ('Image DCSP %(image_id)s DCSP failed DCSP to DCSP reach DCSP %(status)s DCSP state DCSP (current DCSP state DCSP %(current_status)s) DCSP within DCSP the DCSP required DCSP time DCSP (%(timeout)s DCSP s).' % {'image_id': image_id, 'status': status, 'current_status': current_status, 'timeout': client.build_timeout}) DCNL DCSP caller = test_utils.find_test_caller() DCNL DCSP if caller: DCNL DCSP  DCSP message = ('(%s) DCSP %s' % (caller, message)) DCNL DCSP raise lib_exc.TimeoutException(message)
def _get_profile_image_filename(name, size, file_extension=PROFILE_IMAGE_FILE_EXTENSION): DCNL  DCSP return '{name}_{size}.{file_extension}'.format(name=name, size=size, file_extension=file_extension)
def get_loginclass(name): DCNL  DCSP if (__grains__['kernel'] != 'OpenBSD'): DCNL DCSP  DCSP return False DCNL DCSP userinfo = __salt__['cmd.run_stdout'](['userinfo', name], python_shell=False) DCNL DCSP for line in userinfo.splitlines(): DCNL DCSP  DCSP if line.startswith('class'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ret = line.split(None, 1)[1] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except (ValueError, IndexError): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP else: DCNL DCSP  DCSP ret = '' DCNL DCSP return ret
def find_path_file(specific_file, search_directory): DCNL  DCSP result_path_filename = list() DCNL DCSP result_path_filename.extend([os.path.join(dirpath, filename) for (dirpath, dirnames, filenames) in os.walk(search_directory) for filename in filenames if (os.path.splitext(filename)[1] == ('.' + specific_file))]) DCNL DCSP return result_path_filename
def home_link(): DCNL  DCSP return {'title': 'home', 'href': '/'}
def assert_array_less(x, y, err_msg='', verbose=True): DCNL  DCSP numpy.testing.assert_array_less(cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg, verbose=verbose)
def load_token(session_file): DCNL  DCSP if (not os.path.exists(session_file)): DCNL DCSP  DCSP return DCNL DCSP with open(session_file) as handle: DCNL DCSP  DCSP data = json.load(handle) DCNL DCSP for (mx_id, token) in data.items(): DCNL DCSP  DCSP AUTH_TOKENS[mx_id] = token
def reload_localzone(): DCNL  DCSP global _cache_tz DCNL DCSP _cache_tz = pytz.timezone(get_localzone_name())
@testing.requires_testing_data DCNL def test_make_field_map_eeg(): DCNL  DCSP evoked = read_evokeds(evoked_fname, condition='Left DCSP Auditory') DCNL DCSP evoked.info['bads'] = ['MEG DCSP 2443', 'EEG DCSP 053'] DCNL DCSP surf = get_head_surf('sample', subjects_dir=subjects_dir) DCNL DCSP assert_raises(ValueError, _make_surface_mapping, evoked.info, surf, 'eeg') DCNL DCSP evoked.pick_types(meg=False, eeg=True) DCNL DCSP fmd = make_field_map(evoked, trans_fname, subject='sample', subjects_dir=subjects_dir) DCNL DCSP assert_raises(RuntimeError, make_field_map, evoked, None, subject='sample', subjects_dir=subjects_dir) DCNL DCSP fmd = make_field_map(evoked, trans_fname, subject='sample', subjects_dir=subjects_dir) DCNL DCSP assert_true((len(fmd) == 1)) DCNL DCSP assert_array_equal(fmd[0]['data'].shape, (642, 59)) DCNL DCSP assert_true(len(fmd[0]['ch_names']), 59)
def main(): DCNL  DCSP options = get_options() DCNL DCSP options.resource = options.resource[0] DCNL DCSP before_str = __determine_before_str(options) DCNL DCSP resource_basename = options.resource[(options.resource.rfind('.') + 1):] DCNL DCSP resource_id_key = (resource_basename[:(-1)] if (resource_basename[(-1)] == 's') else resource_basename) DCNL DCSP delete_kwargs = __determine_delete_kwargs(options) DCNL DCSP list_kwargs = __determine_list_kwargs(options) DCNL DCSP resource_obj = make_resource_object(options.resource, options.credentials) DCNL DCSP num_errors = 0 DCNL DCSP if options.aggregated: DCNL DCSP  DCSP elems = collect_aggregated(resource_obj, resource_basename, list_kwargs, name_filter=re.compile(options.name), before_str=before_str) DCNL DCSP  DCSP for (keyvalue, resource_instance) in elems: DCNL DCSP  DCSP  DCSP (key, value) = keyvalue.split('/') DCNL DCSP  DCSP  DCSP delete_kwargs[key[:(-1)]] = value DCNL DCSP  DCSP  DCSP delete_kwargs[resource_id_key] = resource_instance['name'] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP delete(resource_obj, resource_instance, delete_kwargs, options.dry_run) DCNL DCSP  DCSP  DCSP except IOError as error: DCNL DCSP  DCSP  DCSP  DCSP sys.stderr.write((str(error) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP num_errors += 1 DCNL DCSP else: DCNL DCSP  DCSP elems = collect(resource_obj, list_kwargs, name_filter=re.compile(options.name), before_str=before_str) DCNL DCSP  DCSP for resource_instance in elems: DCNL DCSP  DCSP  DCSP delete_kwargs[resource_id_key] = resource_instance['name'] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP delete(resource_obj, resource_instance, delete_kwargs, options.dry_run) DCNL DCSP  DCSP  DCSP except IOError as error: DCNL DCSP  DCSP  DCSP  DCSP sys.stderr.write((str(error) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP num_errors += 1 DCNL DCSP return (0 if (num_errors == 0) else (-1))
def formstyle_divs(form, fields): DCNL  DCSP table = FIELDSET() DCNL DCSP for (id, label, controls, help) in fields: DCNL DCSP  DCSP _help = DIV(help, _class='w2p_fc') DCNL DCSP  DCSP _controls = DIV(controls, _class='w2p_fw') DCNL DCSP  DCSP _label = DIV(label, _class='w2p_fl') DCNL DCSP  DCSP table.append(DIV(_label, _controls, _help, _id=id)) DCNL DCSP return table
def main(): DCNL  DCSP with open('../show_version.txt') as show_ver_file: DCNL DCSP  DCSP show_ver = show_ver_file.read() DCNL DCSP print obtain_uptime(show_ver)
def is_list(value, min=None, max=None): DCNL  DCSP (min_len, max_len) = _is_num_param(('min', 'max'), (min, max)) DCNL DCSP if isinstance(value, string_type): DCNL DCSP  DCSP raise VdtTypeError(value) DCNL DCSP try: DCNL DCSP  DCSP num_members = len(value) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise VdtTypeError(value) DCNL DCSP if ((min_len is not None) and (num_members < min_len)): DCNL DCSP  DCSP raise VdtValueTooShortError(value) DCNL DCSP if ((max_len is not None) and (num_members > max_len)): DCNL DCSP  DCSP raise VdtValueTooLongError(value) DCNL DCSP return list(value)
@pytest.mark.xfail DCNL def test_precision_neg(): DCNL  DCSP t1 = Time((-100000.123456), format='jd', scale='tt') DCNL DCSP assert (np.round(t1.jd1) == t1.jd1) DCNL DCSP t1_tai = t1.tai DCNL DCSP assert (np.round(t1_tai.jd1) == t1_tai.jd1)
def __virtual__(): DCNL  DCSP return ('splunk_search' if ('splunk_search.get' in __salt__) else False)
def viewdefaults(wrapped): DCNL  DCSP def wrapper(self, *arg, **kw): DCNL DCSP  DCSP defaults = {} DCNL DCSP  DCSP if arg: DCNL DCSP  DCSP  DCSP view = arg[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = kw.get('view') DCNL DCSP  DCSP view = self.maybe_dotted(view) DCNL DCSP  DCSP if inspect.isclass(view): DCNL DCSP  DCSP  DCSP defaults = getattr(view, '__view_defaults__', {}).copy() DCNL DCSP  DCSP if ('_backframes' not in kw): DCNL DCSP  DCSP  DCSP kw['_backframes'] = 1 DCNL DCSP  DCSP defaults.update(kw) DCNL DCSP  DCSP return wrapped(self, *arg, **defaults) DCNL DCSP return functools.wraps(wrapped)(wrapper)
def insert(tup, loc, val): DCNL  DCSP L = list(tup) DCNL DCSP L[loc] = val DCNL DCSP return tuple(L)
def parse_date(ims): DCNL  DCSP try: DCNL DCSP  DCSP ts = email.utils.parsedate_tz(ims) DCNL DCSP  DCSP return ((time.mktime((ts[:8] + (0,))) - (ts[9] or 0)) - time.timezone) DCNL DCSP except (TypeError, ValueError, IndexError, OverflowError): DCNL DCSP  DCSP return None
def get_pending_file_rename(): DCNL  DCSP vnames = ('PendingFileRenameOperations', 'PendingFileRenameOperations2') DCNL DCSP key = 'SYSTEM\\CurrentControlSet\\Control\\Session DCSP Manager' DCNL DCSP for vname in vnames: DCNL DCSP  DCSP reg_ret = __salt__['reg.read_value']('HKLM', key, vname) DCNL DCSP  DCSP if reg_ret['success']: DCNL DCSP  DCSP  DCSP log.debug('Found DCSP key: DCSP %s', key) DCNL DCSP  DCSP  DCSP if (reg_ret['vdata'] and (reg_ret['vdata'] != '(value DCSP not DCSP set)')): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.debug('Unable DCSP to DCSP access DCSP key: DCSP %s', key) DCNL DCSP return False
def fix_html(container, raw): DCNL  DCSP root = container.parse_xhtml(raw) DCNL DCSP return serialize(root, u'text/html')
def bivariate_normal(X, Y, sigmax=1.0, sigmay=1.0, mux=0.0, muy=0.0, sigmaxy=0.0): DCNL  DCSP Xmu = (X - mux) DCNL DCSP Ymu = (Y - muy) DCNL DCSP rho = (sigmaxy / (sigmax * sigmay)) DCNL DCSP z = ((((Xmu ** 2) / (sigmax ** 2)) + ((Ymu ** 2) / (sigmay ** 2))) - ((((2 * rho) * Xmu) * Ymu) / (sigmax * sigmay))) DCNL DCSP denom = ((((2 * np.pi) * sigmax) * sigmay) * np.sqrt((1 - (rho ** 2)))) DCNL DCSP return (np.exp(((- z) / (2 * (1 - (rho ** 2))))) / denom)
@require_role('admin') DCNL def idc_edit(request): DCNL  DCSP (header_title, path1, path2) = (u'\u7f16\u8f91IDC', u'\u8d44\u4ea7\u7ba1\u7406', u'\u7f16\u8f91IDC') DCNL DCSP idc_id = request.GET.get('id', '') DCNL DCSP idc = get_object(IDC, id=idc_id) DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP idc_form = IdcForm(request.POST, instance=idc) DCNL DCSP  DCSP if idc_form.is_valid(): DCNL DCSP  DCSP  DCSP idc_form.save() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('idc_list')) DCNL DCSP else: DCNL DCSP  DCSP idc_form = IdcForm(instance=idc) DCNL DCSP  DCSP return my_render('jasset/idc_edit.html', locals(), request)
def translate_pattern(pattern, anchor=1, prefix=None, is_regex=0): DCNL  DCSP if is_regex: DCNL DCSP  DCSP if isinstance(pattern, str): DCNL DCSP  DCSP  DCSP return re.compile(pattern) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return pattern DCNL DCSP if pattern: DCNL DCSP  DCSP pattern_re = glob_to_re(pattern) DCNL DCSP else: DCNL DCSP  DCSP pattern_re = '' DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP empty_pattern = glob_to_re('') DCNL DCSP  DCSP prefix_re = glob_to_re(prefix)[:(- len(empty_pattern))] DCNL DCSP  DCSP sep = os.sep DCNL DCSP  DCSP if (os.sep == '\\'): DCNL DCSP  DCSP  DCSP sep = '\\\\' DCNL DCSP  DCSP pattern_re = ('^' + sep.join((prefix_re, ('.*' + pattern_re)))) DCNL DCSP elif anchor: DCNL DCSP  DCSP pattern_re = ('^' + pattern_re) DCNL DCSP return re.compile(pattern_re)
def sample_ids_from_metadata_description(mapping_f, valid_states_str): DCNL  DCSP (map_data, map_header, map_comments) = parse_mapping_file(mapping_f) DCNL DCSP valid_states = parse_metadata_state_descriptions(valid_states_str) DCNL DCSP sample_ids = get_sample_ids(map_data, map_header, valid_states) DCNL DCSP if (len(sample_ids) < 1): DCNL DCSP  DCSP raise ValueError('All DCSP samples DCSP have DCSP been DCSP filtered DCSP out DCSP for DCSP the DCSP criteria DCSP described DCSP in DCSP the DCSP valid DCSP states') DCNL DCSP return sample_ids
def _encode(s): DCNL  DCSP if isinstance(s, unicode): DCNL DCSP  DCSP for (char, repl) in URL_CHARACTERS.items(): DCNL DCSP  DCSP  DCSP s = s.replace(char, repl) DCNL DCSP  DCSP s = s.encode('utf8', 'ignore') DCNL DCSP return urllib.quote(s)
def makeSplitter(lstrip=None, sep='|', comments=True, origNotesSep=' DCSP (', newNotesSep='::(', strip=None): DCNL  DCSP def splitter(x): DCNL DCSP  DCSP if (not x): DCNL DCSP  DCSP  DCSP return x DCNL DCSP  DCSP x = x.strip() DCNL DCSP  DCSP if (not x): DCNL DCSP  DCSP  DCSP return x DCNL DCSP  DCSP if (lstrip is not None): DCNL DCSP  DCSP  DCSP x = x.lstrip(lstrip).lstrip() DCNL DCSP  DCSP lx = x.split(sep) DCNL DCSP  DCSP lx[:] = filter(None, [j.strip() for j in lx]) DCNL DCSP  DCSP if comments: DCNL DCSP  DCSP  DCSP lx[:] = [j.replace(origNotesSep, newNotesSep, 1) for j in lx] DCNL DCSP  DCSP if strip: DCNL DCSP  DCSP  DCSP lx[:] = [j.strip(strip) for j in lx] DCNL DCSP  DCSP return lx DCNL DCSP return splitter
@requires_sklearn DCNL def test_XdawnTransformer(): DCNL  DCSP (raw, events, picks) = _get_data() DCNL DCSP epochs = Epochs(raw, events, event_id, tmin, tmax, picks=picks, preload=True, baseline=None, verbose=False) DCNL DCSP X = epochs._data DCNL DCSP y = epochs.events[:, (-1)] DCNL DCSP xdt = _XdawnTransformer() DCNL DCSP xdt.fit(X, y) DCNL DCSP assert_raises(ValueError, xdt.fit, X, y[1:]) DCNL DCSP assert_raises(ValueError, xdt.fit, 'foo') DCNL DCSP signal_cov = compute_raw_covariance(raw, picks=picks) DCNL DCSP xdt = _XdawnTransformer(signal_cov=signal_cov) DCNL DCSP xdt.fit(X, y) DCNL DCSP signal_cov = np.eye(len(picks)) DCNL DCSP xdt = _XdawnTransformer(signal_cov=signal_cov) DCNL DCSP xdt.fit(X, y) DCNL DCSP signal_cov = np.eye((len(picks) - 1)) DCNL DCSP xdt = _XdawnTransformer(signal_cov=signal_cov) DCNL DCSP assert_raises(ValueError, xdt.fit, X, y) DCNL DCSP signal_cov = 42 DCNL DCSP xdt = _XdawnTransformer(signal_cov=signal_cov) DCNL DCSP assert_raises(ValueError, xdt.fit, X, y) DCNL DCSP xdt = _XdawnTransformer() DCNL DCSP xdt.fit(X) DCNL DCSP xd = Xdawn(correct_overlap=False) DCNL DCSP xd.fit(epochs) DCNL DCSP xdt = _XdawnTransformer() DCNL DCSP xdt.fit(X, y) DCNL DCSP assert_array_almost_equal(xd.filters_['cond2'][:, :2], xdt.filters_.reshape(2, 2, 8)[0].T) DCNL DCSP xdt.transform(X[1:, ...]) DCNL DCSP xdt.transform(X[:, :, 1:]) DCNL DCSP assert_raises(ValueError, xdt.transform, X[:, 1:, :]) DCNL DCSP Xt = xdt.transform(X) DCNL DCSP assert_raises(ValueError, xdt.transform, 42) DCNL DCSP Xinv = xdt.inverse_transform(Xt) DCNL DCSP assert_equal(Xinv.shape, X.shape) DCNL DCSP xdt.inverse_transform(Xt[1:, ...]) DCNL DCSP xdt.inverse_transform(Xt[:, :, 1:]) DCNL DCSP assert_raises(ValueError, xdt.inverse_transform, Xt[:, 1:, :]) DCNL DCSP assert_raises(ValueError, xdt.inverse_transform, 42)
@lower_getattr_generic(types.BaseNamedTuple) DCNL def namedtuple_getattr(context, builder, typ, value, attr): DCNL  DCSP index = typ.fields.index(attr) DCNL DCSP res = builder.extract_value(value, index) DCNL DCSP return impl_ret_borrowed(context, builder, typ[index], res)
def compute_logarithmic_scale(min_, max_, min_scale, max_scale): DCNL  DCSP if ((max_ <= 0) or (min_ <= 0)): DCNL DCSP  DCSP return [] DCNL DCSP min_order = int(floor(log10(min_))) DCNL DCSP max_order = int(ceil(log10(max_))) DCNL DCSP positions = [] DCNL DCSP amplitude = (max_order - min_order) DCNL DCSP if (amplitude <= 1): DCNL DCSP  DCSP return [] DCNL DCSP detail = 10.0 DCNL DCSP while ((amplitude * detail) < (min_scale * 5)): DCNL DCSP  DCSP detail *= 2 DCNL DCSP while ((amplitude * detail) > (max_scale * 3)): DCNL DCSP  DCSP detail /= 2 DCNL DCSP for order in range(min_order, (max_order + 1)): DCNL DCSP  DCSP for i in range(int(detail)): DCNL DCSP  DCSP  DCSP tick = ((((10 * i) / detail) or 1) * (10 ** order)) DCNL DCSP  DCSP  DCSP tick = round_to_scale(tick, tick) DCNL DCSP  DCSP  DCSP if ((min_ <= tick <= max_) and (tick not in positions)): DCNL DCSP  DCSP  DCSP  DCSP positions.append(tick) DCNL DCSP return positions
def getGeometryOutputByArguments(arguments, elementNode): DCNL  DCSP evaluate.setAttributesByArguments(['sides', 'radius'], arguments, elementNode) DCNL DCSP return getGeometryOutput(None, elementNode)
def graph_process(mg, lenmavlist): DCNL  DCSP mg.show(lenmavlist)
def is_py2exe_or_cx_Freeze(): DCNL  DCSP return osp.isfile(osp.join(get_module_path('spyder'), osp.pardir))
def get_profile_image_names(username): DCNL  DCSP name = _make_profile_image_name(username) DCNL DCSP return {size: _get_profile_image_filename(name, size) for size in _PROFILE_IMAGE_SIZES}
def _wait_until_complete(operation, max_attempts=5): DCNL  DCSP def _operation_complete(result): DCNL DCSP  DCSP return result DCNL DCSP retry = RetryResult(_operation_complete, max_tries=max_attempts) DCNL DCSP return retry(operation.poll)()
def _exit(code=0): DCNL  DCSP try: DCNL DCSP  DCSP code = int(code) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP raise SystemExit, code
def is_list(value): DCNL  DCSP return isinstance(value, list)
def randomRange(start=0, stop=1000, seed=None): DCNL  DCSP if (seed is not None): DCNL DCSP  DCSP _ = getCurrentThreadData().random DCNL DCSP  DCSP _.seed(seed) DCNL DCSP  DCSP randint = _.randint DCNL DCSP else: DCNL DCSP  DCSP randint = random.randint DCNL DCSP return int(randint(start, stop))
def hash_file(filename, size=None, method='md5'): DCNL  DCSP chunksize = 4096 DCNL DCSP fsize = os.path.getsize(filename) DCNL DCSP if ((not size) or (size > fsize)): DCNL DCSP  DCSP size = fsize DCNL DCSP f = open(filename, 'rb') DCNL DCSP try: DCNL DCSP  DCSP hash = utils.hash(method) DCNL DCSP except ValueError: DCNL DCSP  DCSP logging.error(('Unknown DCSP hash DCSP type DCSP %s, DCSP returning DCSP None' % method)) DCNL DCSP while (size > 0): DCNL DCSP  DCSP if (chunksize > size): DCNL DCSP  DCSP  DCSP chunksize = size DCNL DCSP  DCSP data = f.read(chunksize) DCNL DCSP  DCSP if (len(data) == 0): DCNL DCSP  DCSP  DCSP logging.debug(('Nothing DCSP left DCSP to DCSP read DCSP but DCSP size=%d' % size)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP hash.update(data) DCNL DCSP  DCSP size -= len(data) DCNL DCSP f.close() DCNL DCSP return hash.hexdigest()
def correlate_output_formatter(bt, test_stats, pvals, fdr_pvals, bon_pvals, md_key): DCNL  DCSP header = ['Feature DCSP ID', 'Test DCSP stat.', 'pval', 'pval_fdr', 'pval_bon', md_key] DCNL DCSP num_lines = len(test_stats) DCNL DCSP lines = [' DCTB '.join(header)] DCNL DCSP for i in range(num_lines): DCNL DCSP  DCSP tmp = [bt.ids(axis='observation')[i], test_stats[i], pvals[i], fdr_pvals[i], bon_pvals[i]] DCNL DCSP  DCSP lines.append(' DCTB '.join(map(str, tmp))) DCNL DCSP nls = _add_metadata(bt, md_key, lines) DCNL DCSP return nls
def format_unixtime_ms(unixtime): DCNL  DCSP if unixtime: DCNL DCSP  DCSP return str(datetime.datetime.fromtimestamp((unixtime / 1000)).strftime('%x DCSP %X DCSP %Z')) DCNL DCSP else: DCNL DCSP  DCSP return ''
def md5SessionKey(params, password): DCNL  DCSP keys = ('username', 'realm', 'nonce', 'cnonce') DCNL DCSP params_copy = {} DCNL DCSP for key in keys: DCNL DCSP  DCSP params_copy[key] = params[key] DCNL DCSP params_copy['algorithm'] = MD5_SESS DCNL DCSP return _A1(params_copy, password)
def get_items(xml): DCNL  DCSP try: DCNL DCSP  DCSP from bs4 import BeautifulSoup DCNL DCSP except ImportError: DCNL DCSP  DCSP error = u'Missing DCSP dependency DCSP "BeautifulSoup4" DCSP and DCSP "lxml" DCSP required DCSP to DCSP import DCSP WordPress DCSP XML DCSP files.' DCNL DCSP  DCSP sys.exit(error) DCNL DCSP with open(xml, encoding=u'utf-8') as infile: DCNL DCSP  DCSP xmlfile = infile.read() DCNL DCSP soup = BeautifulSoup(xmlfile, u'xml') DCNL DCSP items = soup.rss.channel.findAll(u'item') DCNL DCSP return items
def _AddSetListenerMethod(cls): DCNL  DCSP def SetListener(self, listener): DCNL DCSP  DCSP if (listener is None): DCNL DCSP  DCSP  DCSP self._listener = message_listener_mod.NullMessageListener() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._listener = listener DCNL DCSP cls._SetListener = SetListener
def eglQueryString(display, name): DCNL  DCSP out = _lib.eglQueryString(display, name) DCNL DCSP if (not out): DCNL DCSP  DCSP raise RuntimeError(('Could DCSP not DCSP query DCSP %s' % name)) DCNL DCSP return out
@register_opt() DCNL @local_optimizer([SparseBlockOuter, GpuFromHost]) DCNL def gpu_sparse_block_outer_opt(node): DCNL  DCSP if (isinstance(node.op, SparseBlockOuter) and any((_owner_isinstance(inp, HostFromGpu) for inp in node.inputs))): DCNL DCSP  DCSP inputs = _clear_host_from_gpu(node.inputs) DCNL DCSP  DCSP return [host_from_gpu(GpuSparseBlockOuter()(*inputs))] DCNL DCSP elif (isinstance(node.op, GpuFromHost) and _owner_isinstance(node.inputs[0], SparseBlockOuter)): DCNL DCSP  DCSP meta_node = node.inputs[0].owner DCNL DCSP  DCSP inputs = _clear_host_from_gpu(meta_node.inputs) DCNL DCSP  DCSP return [GpuSparseBlockOuter()(*inputs)]
def import_library(taglib_module): DCNL  DCSP try: DCNL DCSP  DCSP mod = import_module(taglib_module) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if is_library_missing(taglib_module): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvalidTemplateLibrary(('ImportError DCSP raised DCSP loading DCSP %s: DCSP %s' % (taglib_module, e))) DCNL DCSP try: DCNL DCSP  DCSP return mod.register DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise InvalidTemplateLibrary(("Template DCSP library DCSP %s DCSP does DCSP not DCSP have DCSP a DCSP variable DCSP named DCSP 'register'" % taglib_module))
def do_autopaginate(parser, token): DCNL  DCSP expr = (lambda obj: ((obj.token_type == TOKEN_BLOCK) and (len(obj.split_contents()) > 0) and (obj.split_contents()[0] == 'autopaginate'))) DCNL DCSP multiple_paginations = (len(filter(expr, parser.tokens)) > 0) DCNL DCSP split = token.split_contents() DCNL DCSP as_index = None DCNL DCSP context_var = None DCNL DCSP for (i, bit) in enumerate(split): DCNL DCSP  DCSP if (bit == 'as'): DCNL DCSP  DCSP  DCSP as_index = i DCNL DCSP  DCSP  DCSP break DCNL DCSP if (as_index is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP context_var = split[(as_index + 1)] DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((('Context DCSP variable DCSP assignment DCSP ' + 'must DCSP take DCSP the DCSP form DCSP of DCSP {%% DCSP %r DCSP object.example_set.all DCSP ... DCSP as DCSP ') + ('context_var_name DCSP %%}' % split[0]))) DCNL DCSP  DCSP del split[as_index:(as_index + 2)] DCNL DCSP if (len(split) == 2): DCNL DCSP  DCSP return AutoPaginateNode(split[1], multiple_paginations=multiple_paginations) DCNL DCSP elif (len(split) == 3): DCNL DCSP  DCSP return AutoPaginateNode(split[1], paginate_by=split[2], context_var=context_var, multiple_paginations=multiple_paginations) DCNL DCSP elif (len(split) == 4): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP orphans = int(split[3]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((u'Got DCSP %s, DCSP but DCSP expected DCSP integer.' % split[3])) DCNL DCSP  DCSP return AutoPaginateNode(split[1], paginate_by=split[2], orphans=orphans, context_var=context_var, multiple_paginations=multiple_paginations) DCNL DCSP else: DCNL DCSP  DCSP raise template.TemplateSyntaxError(('%r DCSP tag DCSP takes DCSP one DCSP required DCSP ' + ('argument DCSP and DCSP one DCSP optional DCSP argument' % split[0])))
@hook.command DCNL def escape(text): DCNL  DCSP encoder = codecs.getencoder('unicode_escape') DCNL DCSP return encoder(text)[0].decode()
def _validator(code_or_name, validator_type): DCNL  DCSP if (validator_type == 'error'): DCNL DCSP  DCSP from .errors import codes DCNL DCSP  DCSP from .errors import EXT DCNL DCSP elif (validator_type == 'warning'): DCNL DCSP  DCSP from .warnings import codes DCNL DCSP  DCSP from .warnings import EXT DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP def decorator(func): DCNL DCSP  DCSP def wrapper(*args, **kw): DCNL DCSP  DCSP  DCSP extra = func(*args, **kw) DCNL DCSP  DCSP  DCSP if (extra is None): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP if isinstance(code_or_name, string_types): DCNL DCSP  DCSP  DCSP  DCSP code = EXT DCNL DCSP  DCSP  DCSP  DCSP name = ((codes[code][0] + ':') + code_or_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP code = code_or_name DCNL DCSP  DCSP  DCSP  DCSP name = codes[code][0] DCNL DCSP  DCSP  DCSP text = codes[code][1] DCNL DCSP  DCSP  DCSP return [(code, name, text, extra)] DCNL DCSP  DCSP wrapper.validator_type = validator_type DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def lerp(a, b, t): DCNL  DCSP if (t < 0.0): DCNL DCSP  DCSP return a DCNL DCSP if (t > 1.0): DCNL DCSP  DCSP return b DCNL DCSP return (a + ((b - a) * t))
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return KeystoneAuth(app, conf) DCNL DCSP return auth_filter
def _get_globals(): DCNL  DCSP from __main__ import __dict__ as namespace DCNL DCSP shell = namespace.get('__ipythonshell__') DCNL DCSP if ((shell is not None) and hasattr(shell, 'user_ns')): DCNL DCSP  DCSP return shell.user_ns DCNL DCSP else: DCNL DCSP  DCSP return namespace DCNL DCSP return namespace
def mutShrink(individual): DCNL  DCSP if ((len(individual) < 3) or (individual.height <= 1)): DCNL DCSP  DCSP return (individual,) DCNL DCSP iprims = [] DCNL DCSP for (i, node) in enumerate(individual[1:], 1): DCNL DCSP  DCSP if (isinstance(node, Primitive) and (node.ret in node.args)): DCNL DCSP  DCSP  DCSP iprims.append((i, node)) DCNL DCSP if (len(iprims) != 0): DCNL DCSP  DCSP (index, prim) = random.choice(iprims) DCNL DCSP  DCSP arg_idx = random.choice([i for (i, type_) in enumerate(prim.args) if (type_ == prim.ret)]) DCNL DCSP  DCSP rindex = (index + 1) DCNL DCSP  DCSP for _ in range((arg_idx + 1)): DCNL DCSP  DCSP  DCSP rslice = individual.searchSubtree(rindex) DCNL DCSP  DCSP  DCSP subtree = individual[rslice] DCNL DCSP  DCSP  DCSP rindex += len(subtree) DCNL DCSP  DCSP slice_ = individual.searchSubtree(index) DCNL DCSP  DCSP individual[slice_] = subtree DCNL DCSP return (individual,)
def logout_then_login(request, login_url=None, extra_context=_sentinel): DCNL  DCSP if (extra_context is not _sentinel): DCNL DCSP  DCSP warnings.warn('The DCSP unused DCSP `extra_context` DCSP parameter DCSP to DCSP `logout_then_login` DCSP is DCSP deprecated.', RemovedInDjango21Warning) DCNL DCSP if (not login_url): DCNL DCSP  DCSP login_url = settings.LOGIN_URL DCNL DCSP login_url = resolve_url(login_url) DCNL DCSP return LogoutView.as_view(next_page=login_url)(request)
def create_relationship(model, instance, relation): DCNL  DCSP result = {} DCNL DCSP pk_value = primary_key_value(instance) DCNL DCSP self_link = url_for(model, pk_value, relation, relationship=True) DCNL DCSP related_link = url_for(model, pk_value, relation) DCNL DCSP result['links'] = {'self': self_link} DCNL DCSP try: DCNL DCSP  DCSP related_model = get_related_model(model, relation) DCNL DCSP  DCSP url_for(related_model) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP result['links']['related'] = related_link DCNL DCSP related_value = getattr(instance, relation) DCNL DCSP if is_like_list(instance, relation): DCNL DCSP  DCSP result['data'] = list(map(simple_relationship_dump, related_value)) DCNL DCSP elif (related_value is not None): DCNL DCSP  DCSP result['data'] = simple_relationship_dump(related_value) DCNL DCSP else: DCNL DCSP  DCSP result['data'] = None DCNL DCSP return result
def _validate_post_params(params): DCNL  DCSP try: DCNL DCSP  DCSP username = params.get('username') DCNL DCSP  DCSP user = User.objects.get(username=username) DCNL DCSP except User.DoesNotExist: DCNL DCSP  DCSP msg = _('User DCSP {username} DCSP does DCSP not DCSP exist').format(username=username) DCNL DCSP  DCSP return (None, HttpResponseBadRequest(msg)) DCNL DCSP try: DCNL DCSP  DCSP course_key = CourseKey.from_string(params.get('course_key')) DCNL DCSP except InvalidKeyError: DCNL DCSP  DCSP msg = _('{course_key} DCSP is DCSP not DCSP a DCSP valid DCSP course DCSP key').format(course_key=params.get('course_key')) DCNL DCSP  DCSP return (None, HttpResponseBadRequest(msg)) DCNL DCSP return ({'user': user, 'course_key': course_key}, None)
def to_numpy_matrix(G, nodelist=None, dtype=None, order=None, multigraph_weight=sum, weight='weight', nonedge=0.0): DCNL  DCSP import numpy as np DCNL DCSP if (nodelist is None): DCNL DCSP  DCSP nodelist = list(G) DCNL DCSP nodeset = set(nodelist) DCNL DCSP if (len(nodelist) != len(nodeset)): DCNL DCSP  DCSP msg = 'Ambiguous DCSP ordering: DCSP `nodelist` DCSP contained DCSP duplicates.' DCNL DCSP  DCSP raise nx.NetworkXError(msg) DCNL DCSP nlen = len(nodelist) DCNL DCSP undirected = (not G.is_directed()) DCNL DCSP index = dict(zip(nodelist, range(nlen))) DCNL DCSP if G.is_multigraph(): DCNL DCSP  DCSP M = np.full((nlen, nlen), np.nan, order=order) DCNL DCSP  DCSP operator = {sum: np.nansum, min: np.nanmin, max: np.nanmax} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP op = operator[multigraph_weight] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise ValueError('multigraph_weight DCSP must DCSP be DCSP sum, DCSP min, DCSP or DCSP max') DCNL DCSP  DCSP for (u, v, attrs) in G.edges(data=True): DCNL DCSP  DCSP  DCSP if ((u in nodeset) and (v in nodeset)): DCNL DCSP  DCSP  DCSP  DCSP (i, j) = (index[u], index[v]) DCNL DCSP  DCSP  DCSP  DCSP e_weight = attrs.get(weight, 1) DCNL DCSP  DCSP  DCSP  DCSP M[(i, j)] = op([e_weight, M[(i, j)]]) DCNL DCSP  DCSP  DCSP  DCSP if undirected: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(j, i)] = M[(i, j)] DCNL DCSP else: DCNL DCSP  DCSP M = np.full((nlen, nlen), np.nan, order=order) DCNL DCSP  DCSP for (u, nbrdict) in G.adjacency(): DCNL DCSP  DCSP  DCSP for (v, d) in nbrdict.items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(index[u], index[v])] = d.get(weight, 1) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP M[np.isnan(M)] = nonedge DCNL DCSP M = np.asmatrix(M, dtype=dtype) DCNL DCSP return M
def zeros_like(a, dtype=None): DCNL  DCSP if (dtype is None): DCNL DCSP  DCSP dtype = a.dtype DCNL DCSP return zeros(a.shape, dtype=dtype)
def clean_db(): DCNL  DCSP logging.info('Cleaning DCSP Zone') DCNL DCSP Zone.objects.all().delete() DCNL DCSP logging.info('Cleaning DCSP Facility') DCNL DCSP Facility.objects.all().delete() DCNL DCSP logging.info('Cleaning DCSP Device') DCNL DCSP Device.objects.all().delete()
def text_(s, encoding='latin-1', errors='strict'): DCNL  DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP return s.decode(encoding, errors) DCNL DCSP return s
def delete_object(request, model, post_delete_redirect, object_id=None, slug=None, slug_field='slug', template_name=None, template_loader=loader, extra_context=None, login_required=False, context_processors=None, template_object_name='object'): DCNL  DCSP if (extra_context is None): DCNL DCSP  DCSP extra_context = {} DCNL DCSP if (login_required and (not request.user.is_authenticated())): DCNL DCSP  DCSP return redirect_to_login(request.path) DCNL DCSP obj = lookup_object(model, object_id, slug, slug_field) DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP obj.delete() DCNL DCSP  DCSP msg = (ugettext('The DCSP %(verbose_name)s DCSP was DCSP deleted.') % {'verbose_name': model._meta.verbose_name}) DCNL DCSP  DCSP messages.success(request, msg, fail_silently=True) DCNL DCSP  DCSP return HttpResponseRedirect(post_delete_redirect) DCNL DCSP else: DCNL DCSP  DCSP if (not template_name): DCNL DCSP  DCSP  DCSP template_name = ('%s/%s_confirm_delete.html' % (model._meta.app_label, model._meta.object_name.lower())) DCNL DCSP  DCSP t = template_loader.get_template(template_name) DCNL DCSP  DCSP c = RequestContext(request, {template_object_name: obj}, context_processors) DCNL DCSP  DCSP apply_extra_context(extra_context, c) DCNL DCSP  DCSP response = HttpResponse(t.render(c)) DCNL DCSP  DCSP populate_xheaders(request, response, model, getattr(obj, obj._meta.pk.attname)) DCNL DCSP  DCSP return response
def subscription_check_iam_permissions(client, to_delete): DCNL  DCSP TOPIC_NAME = ('subscription_check_iam_permissions-%d' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_check_iam_permissions-defaults-%d' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_delete.append(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_delete.append(subscription) DCNL DCSP from google.cloud.pubsub.iam import OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE DCNL DCSP TO_CHECK = [OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE] DCNL DCSP ALLOWED = subscription.check_iam_permissions(TO_CHECK) DCNL DCSP assert (set(ALLOWED) == set(TO_CHECK))
def getPage(url, contextFactory=None, response_transform=None, *args, **kwargs): DCNL  DCSP def _clientfactory(url, *args, **kwargs): DCNL DCSP  DCSP url = to_unicode(url) DCNL DCSP  DCSP timeout = kwargs.pop('timeout', 0) DCNL DCSP  DCSP f = client.ScrapyHTTPClientFactory(Request(url, *args, **kwargs), timeout=timeout) DCNL DCSP  DCSP f.deferred.addCallback((response_transform or (lambda r: r.body))) DCNL DCSP  DCSP return f DCNL DCSP from twisted.web.client import _makeGetterFactory DCNL DCSP return _makeGetterFactory(to_bytes(url), _clientfactory, contextFactory=contextFactory, *args, **kwargs).deferred
def set_var_value(hass, entity_id, value): DCNL  DCSP data = {ATTR_ENTITY_ID: entity_id, ATTR_VALUE: value} DCNL DCSP hass.services.call(DOMAIN, SERVICE_SET_VAR_VALUE, data)
def beacon(config): DCNL  DCSP ret = [] DCNL DCSP interfaces = [] DCNL DCSP expanded_config = {} DCNL DCSP global LAST_STATS DCNL DCSP coalesce = False DCNL DCSP _stats = _copy_interfaces_info(IP.by_name) DCNL DCSP if (not LAST_STATS): DCNL DCSP  DCSP LAST_STATS = _stats DCNL DCSP if (('coalesce' in config) and config['coalesce']): DCNL DCSP  DCSP coalesce = True DCNL DCSP  DCSP changes = {} DCNL DCSP for item in config: DCNL DCSP  DCSP if (item == 'coalesce'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (item in _stats): DCNL DCSP  DCSP  DCSP interfaces.append(item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interface_regexp = item.replace('*', '[0-9]+') DCNL DCSP  DCSP  DCSP for interface in _stats: DCNL DCSP  DCSP  DCSP  DCSP match = re.search(interface_regexp, interface) DCNL DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP interfaces.append(match.group()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expanded_config[match.group()] = config[item] DCNL DCSP if expanded_config: DCNL DCSP  DCSP config.update(expanded_config) DCNL DCSP for interface in interfaces: DCNL DCSP  DCSP _send_event = False DCNL DCSP  DCSP _diff_stats = (_stats[interface] - LAST_STATS[interface]) DCNL DCSP  DCSP _ret_diff = {} DCNL DCSP  DCSP if _diff_stats: DCNL DCSP  DCSP  DCSP _diff_stats_dict = {} DCNL DCSP  DCSP  DCSP LAST_STATS[interface] = _stats[interface] DCNL DCSP  DCSP  DCSP for item in _diff_stats: DCNL DCSP  DCSP  DCSP  DCSP _diff_stats_dict.update(item) DCNL DCSP  DCSP  DCSP for attr in config[interface]: DCNL DCSP  DCSP  DCSP  DCSP if (attr in _diff_stats_dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP config_value = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (config[interface][attr] and ('onvalue' in config[interface][attr])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP config_value = config[interface][attr]['onvalue'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_value = ast.literal_eval(_diff_stats_dict[attr]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not config_value) or (config_value == new_value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _send_event = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _ret_diff[attr] = new_value DCNL DCSP  DCSP  DCSP if _send_event: DCNL DCSP  DCSP  DCSP  DCSP if coalesce: DCNL DCSP  DCSP  DCSP  DCSP  DCSP changes[interface] = _ret_diff DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.append({'tag': interface, 'interface': interface, 'change': _ret_diff}) DCNL DCSP if (coalesce and changes): DCNL DCSP  DCSP grains_info = salt.loader.grains(__opts__, True) DCNL DCSP  DCSP __grains__.update(grains_info) DCNL DCSP  DCSP ret.append({'tag': 'result', 'changes': changes}) DCNL DCSP return ret
def testIBP(): DCNL  DCSP from pybrain.tools.plotting.colormaps import ColorMap DCNL DCSP import pylab DCNL DCSP n = 50 DCNL DCSP ps = [(10, 0.1), (10,), (50,), (50, 0.5)] DCNL DCSP ms = [] DCNL DCSP for p in ps: DCNL DCSP  DCSP if (len(p) > 1): DCNL DCSP  DCSP  DCSP m = generateIBP(n, p[0], p[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP m = generateIBP(n, p[0]) DCNL DCSP  DCSP ms.append(leftordered(m)) DCNL DCSP for m in ms: DCNL DCSP  DCSP ColorMap(m, pixelspervalue=3) DCNL DCSP pylab.show()
def train_model(name, g_train, d_train, sampler, generator, samples_per_epoch, nb_epoch, z_dim=100, verbose=1, callbacks=[], validation_data=None, nb_val_samples=None, saver=None): DCNL  DCSP self = {} DCNL DCSP epoch = 0 DCNL DCSP counter = 0 DCNL DCSP out_labels = ['g_loss', 'd_loss', 'd_loss_fake', 'd_loss_legit', 'time'] DCNL DCSP callback_metrics = (out_labels + [('val_' + n) for n in out_labels]) DCNL DCSP history = cbks.History() DCNL DCSP callbacks = (([cbks.BaseLogger()] + callbacks) + [history]) DCNL DCSP if verbose: DCNL DCSP  DCSP callbacks += [cbks.ProgbarLogger()] DCNL DCSP callbacks = cbks.CallbackList(callbacks) DCNL DCSP callbacks._set_params({'nb_epoch': nb_epoch, 'nb_sample': samples_per_epoch, 'verbose': verbose, 'metrics': callback_metrics}) DCNL DCSP callbacks.on_train_begin() DCNL DCSP while (epoch < nb_epoch): DCNL DCSP  DCSP callbacks.on_epoch_begin(epoch) DCNL DCSP  DCSP samples_seen = 0 DCNL DCSP  DCSP batch_index = 0 DCNL DCSP  DCSP while (samples_seen < samples_per_epoch): DCNL DCSP  DCSP  DCSP (z, x) = next(generator) DCNL DCSP  DCSP  DCSP batch_logs = {} DCNL DCSP  DCSP  DCSP if (type(x) is list): DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(x[0]) DCNL DCSP  DCSP  DCSP elif (type(x) is dict): DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(list(x.values())[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(x) DCNL DCSP  DCSP  DCSP batch_logs['batch'] = batch_index DCNL DCSP  DCSP  DCSP batch_logs['size'] = batch_size DCNL DCSP  DCSP  DCSP callbacks.on_batch_begin(batch_index, batch_logs) DCNL DCSP  DCSP  DCSP t1 = time.time() DCNL DCSP  DCSP  DCSP d_losses = d_train(x, z, counter) DCNL DCSP  DCSP  DCSP (z, x) = next(generator) DCNL DCSP  DCSP  DCSP (g_loss, samples, xs) = g_train(x, z, counter) DCNL DCSP  DCSP  DCSP outs = (((g_loss,) + d_losses) + ((time.time() - t1),)) DCNL DCSP  DCSP  DCSP counter += 1 DCNL DCSP  DCSP  DCSP if ((batch_index % 100) == 0): DCNL DCSP  DCSP  DCSP  DCSP join_image = np.zeros_like(np.concatenate([samples[:64], xs[:64]], axis=0)) DCNL DCSP  DCSP  DCSP  DCSP for (j, (i1, i2)) in enumerate(zip(samples[:64], xs[:64])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[(j * 2)] = i1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[((j * 2) + 1)] = i2 DCNL DCSP  DCSP  DCSP  DCSP save_images(join_image, [(8 * 2), 8], ('./outputs/samples_%s/train_%s_%s.png' % (name, epoch, batch_index))) DCNL DCSP  DCSP  DCSP  DCSP (samples, xs) = sampler(z, x) DCNL DCSP  DCSP  DCSP  DCSP join_image = np.zeros_like(np.concatenate([samples[:64], xs[:64]], axis=0)) DCNL DCSP  DCSP  DCSP  DCSP for (j, (i1, i2)) in enumerate(zip(samples[:64], xs[:64])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[(j * 2)] = i1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[((j * 2) + 1)] = i2 DCNL DCSP  DCSP  DCSP  DCSP save_images(join_image, [(8 * 2), 8], ('./outputs/samples_%s/test_%s_%s.png' % (name, epoch, batch_index))) DCNL DCSP  DCSP  DCSP for (l, o) in zip(out_labels, outs): DCNL DCSP  DCSP  DCSP  DCSP batch_logs[l] = o DCNL DCSP  DCSP  DCSP callbacks.on_batch_end(batch_index, batch_logs) DCNL DCSP  DCSP  DCSP epoch_logs = {} DCNL DCSP  DCSP  DCSP batch_index += 1 DCNL DCSP  DCSP  DCSP samples_seen += batch_size DCNL DCSP  DCSP if (saver is not None): DCNL DCSP  DCSP  DCSP saver(epoch) DCNL DCSP  DCSP callbacks.on_epoch_end(epoch, epoch_logs) DCNL DCSP  DCSP epoch += 1 DCNL DCSP callbacks.on_train_end()
def rebuild_topictree(remove_unknown_exercises=False, remove_disabled_topics=True, whitewash_node_data=whitewash_node_data, retrieve_API_data=retrieve_API_data, channel_data={}, channel=None): DCNL  DCSP (topic_tree, exercises, assessment_items, contents) = retrieve_API_data(channel=channel) DCNL DCSP exercise_lookup = dict(((exercise['id'], exercise) for exercise in exercises)) DCNL DCSP content_lookup = dict(((content['id'], content) for content in contents)) DCNL DCSP def recurse_nodes(node, path=''): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Internal DCSP function DCSP for DCSP recursing DCSP over DCSP the DCSP topic DCSP tree, DCSP marking DCSP relevant DCSP metadata,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP and DCSP removing DCSP undesired DCSP attributes DCSP and DCSP children.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP kind = node['kind'] DCNL DCSP  DCSP node = whitewash_node_data(node, path) DCNL DCSP  DCSP if (kind != 'Topic'): DCNL DCSP  DCSP  DCSP if (kind in channel_data['denormed_attribute_list']): DCNL DCSP  DCSP  DCSP  DCSP for key in node.keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((key not in channel_data['denormed_attribute_list'][kind]) or (not node.get(key, ''))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP del node[key] DCNL DCSP  DCSP if ('child_data' in node): DCNL DCSP  DCSP  DCSP children_to_delete = [] DCNL DCSP  DCSP  DCSP child_kinds = set() DCNL DCSP  DCSP  DCSP for (i, child) in enumerate(node.get('children', [])): DCNL DCSP  DCSP  DCSP  DCSP child_kind = child.get('kind') DCNL DCSP  DCSP  DCSP  DCSP if ((child_kind == 'Video') or (child_kind == 'Exercise')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP for i in reversed(children_to_delete): DCNL DCSP  DCSP  DCSP  DCSP del node['children'][i] DCNL DCSP  DCSP for child_datum in node.get('child_data', []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP child_id = str(child_datum['id']) DCNL DCSP  DCSP  DCSP  DCSP child_kind = child_datum['kind'] DCNL DCSP  DCSP  DCSP  DCSP slug_key = channel_data['slug_key'][child_kind] DCNL DCSP  DCSP  DCSP  DCSP if (child_kind == 'Exercise'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_denormed_data = exercise_lookup[child_id] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (exercise_lookup[child_id][slug_key] if (exercise_lookup[child_id][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicode(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP exercise_lookup[child_id]['path'] = ((node['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP elif (child_kind == 'Video'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_denormed_data = content_lookup[child_id] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (content_lookup[child_id][slug_key] if (content_lookup[child_id][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicode(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP content_lookup[child_id]['path'] = ((node['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_denormed_data = None DCNL DCSP  DCSP  DCSP  DCSP if child_denormed_data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP node['children'].append(copy.deepcopy(dict(child_denormed_data))) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('%(kind)s DCSP %(id)s DCSP does DCSP not DCSP exist DCSP in DCSP lookup DCSP table' % child_datum)) DCNL DCSP  DCSP children_to_delete = [] DCNL DCSP  DCSP child_kinds = set() DCNL DCSP  DCSP for (i, child) in enumerate(node.get('children', [])): DCNL DCSP  DCSP  DCSP child_kind = child.get('kind') DCNL DCSP  DCSP  DCSP if (child_kind in channel_data['kind_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (child[channel_data['slug_key'][child_kind]] in channel_data['slug_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (not child.get('live', True)): DCNL DCSP  DCSP  DCSP  DCSP logging.debug(('Removing DCSP non-live DCSP child: DCSP %s' % child[channel_data['slug_key'][child_kind]])) DCNL DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif child.get('hide', False): DCNL DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP  DCSP logging.debug(('Removing DCSP hidden DCSP child: DCSP %s' % child[channel_data['slug_key'][child_kind]])) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((child_kind == 'Video') and (set(['mp4', 'png']) - set(child.get('download_urls', {}).keys()))): DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('No DCSP download DCSP link DCSP for DCSP video: DCSP %s\n' % child.get('youtube_id', child.get('id', '')))) DCNL DCSP  DCSP  DCSP  DCSP if channel_data.get('require_download_link', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP children_to_delete.append(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP child_kinds = child_kinds.union(set([child_kind])) DCNL DCSP  DCSP  DCSP child_kinds = child_kinds.union(recurse_nodes(child, path=node['path'])) DCNL DCSP  DCSP for i in reversed(children_to_delete): DCNL DCSP  DCSP  DCSP del node['children'][i] DCNL DCSP  DCSP if (kind == 'Topic'): DCNL DCSP  DCSP  DCSP node['contains'] = list(child_kinds) DCNL DCSP  DCSP return child_kinds DCNL DCSP recurse_nodes(topic_tree) DCNL DCSP dedupe_paths(topic_tree) DCNL DCSP def recurse_nodes_to_remove_childless_nodes(node): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Remove DCSP dead-end DCSP topics.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP children_to_delete = [] DCNL DCSP  DCSP for (ci, child) in enumerate(node.get('children', [])): DCNL DCSP  DCSP  DCSP if (child['kind'] != 'Topic'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP recurse_nodes_to_remove_childless_nodes(child) DCNL DCSP  DCSP  DCSP if (not child.get('children')): DCNL DCSP  DCSP  DCSP  DCSP children_to_delete.append(ci) DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('Removing DCSP childless DCSP topic: DCSP %s' % child['slug'])) DCNL DCSP  DCSP for ci in reversed(children_to_delete): DCNL DCSP  DCSP  DCSP del node['children'][ci] DCNL DCSP recurse_nodes_to_remove_childless_nodes(topic_tree) DCNL DCSP return (topic_tree, exercises, assessment_items, contents)
def p_command_let(p): DCNL  DCSP p[0] = ('LET', p[2], p[4])
def _get_spec(tree_base, spec, template, saltenv='base'): DCNL  DCSP spec_tgt = os.path.basename(spec) DCNL DCSP dest = os.path.join(tree_base, spec_tgt) DCNL DCSP return __salt__['cp.get_url'](spec, dest, saltenv=saltenv)
def gf_compose_mod(g, h, f, p, K): DCNL  DCSP if (not g): DCNL DCSP  DCSP return [] DCNL DCSP comp = [g[0]] DCNL DCSP for a in g[1:]: DCNL DCSP  DCSP comp = gf_mul(comp, h, p, K) DCNL DCSP  DCSP comp = gf_add_ground(comp, a, p, K) DCNL DCSP  DCSP comp = gf_rem(comp, f, p, K) DCNL DCSP return comp
def queryset_iterator(queryset, chunksize=1000): DCNL  DCSP if queryset.exists(): DCNL DCSP  DCSP primary_key = 0 DCNL DCSP  DCSP last_pk = queryset.order_by('-pk')[0].pk DCNL DCSP  DCSP queryset = queryset.order_by('pk') DCNL DCSP  DCSP while (primary_key < last_pk): DCNL DCSP  DCSP  DCSP for row in queryset.filter(pk__gt=primary_key)[:chunksize]: DCNL DCSP  DCSP  DCSP  DCSP primary_key = row.pk DCNL DCSP  DCSP  DCSP  DCSP (yield row) DCNL DCSP  DCSP  DCSP gc.collect()
def tweet(): DCNL  DCSP t = Twitter(auth=authen()) DCNL DCSP t.statuses.update(status=g['stuff'])
def patched(f): DCNL  DCSP def wrapped(*args, **kwargs): DCNL DCSP  DCSP kwargs['return_response'] = False DCNL DCSP  DCSP kwargs['prefetch'] = True DCNL DCSP  DCSP config = kwargs.get('config', {}) DCNL DCSP  DCSP config.update(safe_mode=True) DCNL DCSP  DCSP kwargs['config'] = config DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapped
def _remove_intercept_patsy(terms): DCNL  DCSP from patsy.desc import INTERCEPT DCNL DCSP if (INTERCEPT in terms): DCNL DCSP  DCSP terms.remove(INTERCEPT) DCNL DCSP return terms
def ValidateStringLength(name, value, max_len): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP value = value.encode('utf-8') DCNL DCSP if (len(value) > max_len): DCNL DCSP  DCSP raise datastore_errors.BadValueError(('Property DCSP %s DCSP is DCSP %d DCSP bytes DCSP long; DCSP it DCSP must DCSP be DCSP %d DCSP or DCSP less. DCSP Consider DCSP Text DCSP instead, DCSP which DCSP can DCSP store DCSP strings DCSP of DCSP any DCSP length.' % (name, len(value), max_len)))
def compat_tee(iterable): DCNL  DCSP def gen(next, data={}, cnt=[0]): DCNL DCSP  DCSP dpop = data.pop DCNL DCSP  DCSP for i in itertools.count(): DCNL DCSP  DCSP  DCSP if (i == cnt[0]): DCNL DCSP  DCSP  DCSP  DCSP item = data[i] = next() DCNL DCSP  DCSP  DCSP  DCSP cnt[0] += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP item = dpop(i) DCNL DCSP  DCSP  DCSP (yield item) DCNL DCSP next = iter(iterable).next DCNL DCSP return (gen(next), gen(next))
def get_protocol_from_tool_shed_url(tool_shed_url): DCNL  DCSP try: DCNL DCSP  DCSP if (tool_shed_url.find('://') > 0): DCNL DCSP  DCSP  DCSP return tool_shed_url.split('://')[0].lower() DCNL DCSP except Exception as e: DCNL DCSP  DCSP if (tool_shed_url is not None): DCNL DCSP  DCSP  DCSP log.exception('Handled DCSP exception DCSP getting DCSP the DCSP protocol DCSP from DCSP Tool DCSP Shed DCSP URL DCSP %s:\n%s', str(tool_shed_url), e) DCNL DCSP  DCSP return 'http'
def makeListCompatible(fn): DCNL  DCSP def newfn(*args): DCNL DCSP  DCSP 'Generated DCSP function. DCSP Closure-ish.' DCNL DCSP  DCSP if (len(args) == 1): DCNL DCSP  DCSP  DCSP return fn(*args) DCNL DCSP  DCSP args = ' DCSP '.join(map(str, args)) DCNL DCSP  DCSP return fn(args) DCNL DCSP setattr(newfn, '__name__', fn.__name__) DCNL DCSP setattr(newfn, '__doc__', fn.__doc__) DCNL DCSP return newfn
def register(request): DCNL  DCSP response = None DCNL DCSP if settings.FEATURES.get('AUTH_USE_CERTIFICATES_IMMEDIATE_SIGNUP'): DCNL DCSP  DCSP response = openedx.core.djangoapps.external_auth.views.redirect_with_get('root', request.GET) DCNL DCSP return response
def _reconstitute(config, full_path): DCNL  DCSP try: DCNL DCSP  DCSP renewal_candidate = storage.RenewableCert(full_path, config) DCNL DCSP except (errors.CertStorageError, IOError) as exc: DCNL DCSP  DCSP logger.warning(exc) DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP is DCSP broken. DCSP Skipping.', full_path) DCNL DCSP  DCSP logger.debug('Traceback DCSP was:\n%s', traceback.format_exc()) DCNL DCSP  DCSP return None DCNL DCSP if ('renewalparams' not in renewal_candidate.configuration): DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP lacks DCSP renewalparams. DCSP Skipping.', full_path) DCNL DCSP  DCSP return None DCNL DCSP renewalparams = renewal_candidate.configuration['renewalparams'] DCNL DCSP if ('authenticator' not in renewalparams): DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP does DCSP not DCSP specify DCSP an DCSP authenticator. DCSP Skipping.', full_path) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP restore_required_config_elements(config, renewalparams) DCNL DCSP  DCSP _restore_plugin_configs(config, renewalparams) DCNL DCSP except (ValueError, errors.Error) as error: DCNL DCSP  DCSP logger.warning('An DCSP error DCSP occurred DCSP while DCSP parsing DCSP %s. DCSP The DCSP error DCSP was DCSP %s. DCSP Skipping DCSP the DCSP file.', full_path, error.message) DCNL DCSP  DCSP logger.debug('Traceback DCSP was:\n%s', traceback.format_exc()) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP config.domains = [util.enforce_domain_sanity(d) for d in renewal_candidate.names()] DCNL DCSP except errors.ConfigurationError as error: DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP references DCSP a DCSP cert DCSP that DCSP contains DCSP an DCSP invalid DCSP domain DCSP name. DCSP The DCSP problem DCSP was: DCSP %s. DCSP Skipping.', full_path, error) DCNL DCSP  DCSP return None DCNL DCSP return renewal_candidate
def format_acl_v2(acl_dict): DCNL  DCSP return json.dumps(acl_dict, ensure_ascii=True, separators=(',', ':'), sort_keys=True)
def test_version(): DCNL  DCSP assert virtualenv.virtualenv_version, 'Should DCSP have DCSP version'
def done_command(client, args): DCNL  DCSP mark_done(client, args.task_id) DCNL DCSP print 'Task DCSP {} DCSP marked DCSP done.'.format(args.task_id)
def package_relationship_update(context, data_dict): DCNL  DCSP model = context['model'] DCNL DCSP schema = (context.get('schema') or schema_.default_update_relationship_schema()) DCNL DCSP (id, id2, rel) = _get_or_bust(data_dict, ['subject', 'object', 'type']) DCNL DCSP pkg1 = model.Package.get(id) DCNL DCSP pkg2 = model.Package.get(id2) DCNL DCSP if (not pkg1): DCNL DCSP  DCSP raise NotFound(('Subject DCSP package DCSP %r DCSP was DCSP not DCSP found.' % id)) DCNL DCSP if (not pkg2): DCNL DCSP  DCSP return NotFound(('Object DCSP package DCSP %r DCSP was DCSP not DCSP found.' % id2)) DCNL DCSP (data, errors) = _validate(data_dict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP model.Session.rollback() DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP _check_access('package_relationship_update', context, data_dict) DCNL DCSP existing_rels = pkg1.get_relationships_with(pkg2, rel) DCNL DCSP if (not existing_rels): DCNL DCSP  DCSP raise NotFound('This DCSP relationship DCSP between DCSP the DCSP packages DCSP was DCSP not DCSP found.') DCNL DCSP entity = existing_rels[0] DCNL DCSP comment = data_dict.get('comment', u'') DCNL DCSP context['relationship'] = entity DCNL DCSP return _update_package_relationship(entity, comment, context)
def scp(reactor, username, host, remote_path, local_path, direction, port=22, identity_file=None): DCNL  DCSP if (direction not in (DOWNLOAD, UPLOAD)): DCNL DCSP  DCSP raise ValueError('Invalid DCSP direction DCSP argument DCSP {!r}. DCSP Must DCSP be DCSP one DCSP of DCSP ``runner.DOWNLOAD`` DCSP or DCSP ``runner.UPLOAD``.'.format(direction)) DCNL DCSP remote_host_path = ((((username + '@') + host) + ':') + remote_path.path) DCNL DCSP scp_command = (['scp', '-r', '-P', bytes(port)] + SSH_OPTIONS) DCNL DCSP if (identity_file is not None): DCNL DCSP  DCSP scp_command += ['-i', identity_file.path] DCNL DCSP if (direction is DOWNLOAD): DCNL DCSP  DCSP scp_command += [remote_host_path, local_path.path] DCNL DCSP else: DCNL DCSP  DCSP scp_command += [local_path.path, remote_host_path] DCNL DCSP action = SCP_ACTION(username=username, host=host, remote_path=remote_path, local_path=local_path, port=port, identity_file=identity_file) DCNL DCSP failed_reason = [] DCNL DCSP def handle_stdout(line): DCNL DCSP  DCSP SCP_OUTPUT_MESSAGE(line=line).write(action=action) DCNL DCSP def handle_stderr(line): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Notice DCSP scp's DCSP particular DCSP way DCSP of DCSP describing DCSP the DCSP file-not-found DCSP condition\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP and DCSP turn DCSP it DCSP into DCSP a DCSP more DCSP easily DCSP recognized DCSP form.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if ('No DCSP such DCSP file DCSP or DCSP directory' in line): DCNL DCSP  DCSP  DCSP failed_reason.append(RemoteFileNotFound(remote_path)) DCNL DCSP  DCSP if ('lost DCSP connection' in line): DCNL DCSP  DCSP  DCSP failed_reason.append(SCPConnectionError()) DCNL DCSP  DCSP SCP_ERROR_MESSAGE(line=line).write(action=action) DCNL DCSP def scp_failed(reason): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Check DCSP for DCSP a DCSP known DCSP error DCSP with DCSP the DCSP scp DCSP attempt DCSP and DCSP turn DCSP the DCSP normal\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP failure DCSP into DCSP a DCSP more DCSP meaningful DCSP one.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP reason.trap(ProcessTerminated) DCNL DCSP  DCSP if failed_reason: DCNL DCSP  DCSP  DCSP return Failure(failed_reason[(-1)]) DCNL DCSP  DCSP return reason DCNL DCSP with action.context(): DCNL DCSP  DCSP context = DeferredContext(run(reactor, scp_command, handle_stdout=handle_stdout, handle_stderr=handle_stderr)) DCNL DCSP  DCSP context.addErrback(scp_failed) DCNL DCSP  DCSP return context.addActionFinish()
def stitch_rbms(batch_size, rbm_list, niter, inference_procedure=None, targets=False): DCNL  DCSP assert (len(rbm_list) > 1) DCNL DCSP for (this_rbm, above_rbm) in zip(rbm_list[:(-1)], rbm_list[1:]): DCNL DCSP  DCSP hidden_layer = this_rbm.hidden_layers[0] DCNL DCSP  DCSP visible_layer = above_rbm.visible_layer DCNL DCSP  DCSP new_biases = (0.5 * (hidden_layer.get_biases() + visible_layer.get_biases())) DCNL DCSP  DCSP hidden_layer.set_biases(new_biases) DCNL DCSP visible_layer = rbm_list[0].visible_layer DCNL DCSP visible_layer.dbm = None DCNL DCSP hidden_layers = [] DCNL DCSP for rbm in rbm_list: DCNL DCSP  DCSP if (rbm == rbm_list[(-1)]): DCNL DCSP  DCSP  DCSP if targets: DCNL DCSP  DCSP  DCSP  DCSP assert (len(rbm.hidden_layers) == 2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (len(rbm.hidden_layers) == 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (len(rbm.hidden_layers) == 1) DCNL DCSP  DCSP hidden_layers = (hidden_layers + rbm.hidden_layers) DCNL DCSP for hidden_layer in hidden_layers: DCNL DCSP  DCSP hidden_layer.dbm = None DCNL DCSP first_hidden_layer = hidden_layers[(-1)] DCNL DCSP if targets: DCNL DCSP  DCSP last_hidden_layer = hidden_layers[(-2)] DCNL DCSP else: DCNL DCSP  DCSP last_hidden_layer = hidden_layers[(-1)] DCNL DCSP first_hidden_layer.set_weights((0.5 * first_hidden_layer.get_weights())) DCNL DCSP last_hidden_layer.set_weights((0.5 * last_hidden_layer.get_weights())) DCNL DCSP return DBM(batch_size, visible_layer, hidden_layers, niter, inference_procedure)
def add_required_label_tag(original_function): DCNL  DCSP def required_label_tag(self, contents=None, attrs=None): DCNL DCSP  DCSP 'Required DCSP label DCSP tag' DCNL DCSP  DCSP contents = (contents or escape(self.label)) DCNL DCSP  DCSP if self.field.required: DCNL DCSP  DCSP  DCSP if (not self.label.endswith(' DCSP *')): DCNL DCSP  DCSP  DCSP  DCSP self.label += ' DCSP *' DCNL DCSP  DCSP  DCSP  DCSP contents += ' DCSP *' DCNL DCSP  DCSP  DCSP attrs = {'class': 'required'} DCNL DCSP  DCSP return original_function(self, contents, attrs) DCNL DCSP return required_label_tag
def make_script_tests(executable): DCNL  DCSP class ScriptTests(TestCase, ): DCNL DCSP  DCSP @skipUnless(which(executable), (executable + ' DCSP not DCSP installed')) DCNL DCSP  DCSP def test_version(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP script DCSP is DCSP a DCSP command DCSP available DCSP on DCSP the DCSP system DCSP path.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP result = run_process(([executable] + ['--version'])) DCNL DCSP  DCSP  DCSP self.assertEqual(result.output, ('%s\n' % (__version__,))) DCNL DCSP  DCSP @skipUnless(which(executable), (executable + ' DCSP not DCSP installed')) DCNL DCSP  DCSP def test_identification(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP script DCSP identifies DCSP itself DCSP as DCSP what DCSP it DCSP is.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP result = run_process(([executable] + ['--help'])) DCNL DCSP  DCSP  DCSP self.assertIn(executable, result.output) DCNL DCSP return ScriptTests
def no_import_translation_in_tests(logical_line, filename): DCNL  DCSP if ('nova/tests/' in filename): DCNL DCSP  DCSP res = import_translation_for_log_or_exception.match(logical_line) DCNL DCSP  DCSP if res: DCNL DCSP  DCSP  DCSP (yield (0, "N337 DCSP Don't DCSP import DCSP translation DCSP in DCSP tests"))
def _find_clickable_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME): DCNL  DCSP return WebDriverWait(context.browser, wait_time).until(EC.element_to_be_clickable(by))
def get_issues_from_bulk(bulk_data, **additional_fields): DCNL  DCSP return [models.Issue(subject=line, **additional_fields) for line in text.split_in_lines(bulk_data)]
def parse_kwarg(string_): DCNL  DCSP try: DCNL DCSP  DCSP return KWARG_REGEX.match(string_).groups() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return (None, None)
def short_group_names(groups): DCNL  DCSP groups = groups.split(u',') DCNL DCSP shortGroupList = [] DCNL DCSP if sickrage.srCore.ADBA_CONNECTION: DCNL DCSP  DCSP for groupName in groups: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP group = sickrage.srCore.ADBA_CONNECTION.group(gname=groupName) DCNL DCSP  DCSP  DCSP except AniDBCommandTimeoutError: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug(u'Timeout DCSP while DCSP loading DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug(u'Failed DCSP while DCSP loading DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for line in group.datalines: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line[u'shortname']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.append(line[u'shortname']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (groupName not in shortGroupList): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.append(groupName) DCNL DCSP else: DCNL DCSP  DCSP shortGroupList = groups DCNL DCSP return shortGroupList
def Internaldate2Time(resp): DCNL  DCSP mo = InternalDate.match(resp) DCNL DCSP if (not mo): DCNL DCSP  DCSP return None DCNL DCSP mon = Mon2num[mo.group('mon')] DCNL DCSP zonen = mo.group('zonen') DCNL DCSP day = int(mo.group('day')) DCNL DCSP year = int(mo.group('year')) DCNL DCSP hour = int(mo.group('hour')) DCNL DCSP min = int(mo.group('min')) DCNL DCSP sec = int(mo.group('sec')) DCNL DCSP zoneh = int(mo.group('zoneh')) DCNL DCSP zonem = int(mo.group('zonem')) DCNL DCSP zone = (((zoneh * 60) + zonem) * 60) DCNL DCSP if (zonen == '-'): DCNL DCSP  DCSP zone = (- zone) DCNL DCSP tt = (year, mon, day, hour, min, sec, (-1), (-1), (-1)) DCNL DCSP utc = time.mktime(tt) DCNL DCSP lt = time.localtime(utc) DCNL DCSP if (time.daylight and lt[(-1)]): DCNL DCSP  DCSP zone = (zone + time.altzone) DCNL DCSP else: DCNL DCSP  DCSP zone = (zone + time.timezone) DCNL DCSP return time.localtime((utc - zone))
def ftdi_to_clkbits(baudrate): DCNL  DCSP clk = 48000000 DCNL DCSP clk_div = 16 DCNL DCSP frac_code = [0, 3, 2, 4, 1, 5, 6, 7] DCNL DCSP actual_baud = 0 DCNL DCSP if (baudrate >= (clk / clk_div)): DCNL DCSP  DCSP encoded_divisor = 0 DCNL DCSP  DCSP actual_baud = (clk // clk_div) DCNL DCSP elif (baudrate >= (clk / (clk_div + (clk_div / 2)))): DCNL DCSP  DCSP encoded_divisor = 1 DCNL DCSP  DCSP actual_baud = (clk // (clk_div + (clk_div // 2))) DCNL DCSP elif (baudrate >= (clk / (2 * clk_div))): DCNL DCSP  DCSP encoded_divisor = 2 DCNL DCSP  DCSP actual_baud = (clk // (2 * clk_div)) DCNL DCSP else: DCNL DCSP  DCSP divisor = (((clk * 16) // clk_div) // baudrate) DCNL DCSP  DCSP best_divisor = ((divisor + 1) // 2) DCNL DCSP  DCSP if (best_divisor > 131072): DCNL DCSP  DCSP  DCSP best_divisor = 131071 DCNL DCSP  DCSP actual_baud = (((clk * 16) // clk_div) // best_divisor) DCNL DCSP  DCSP actual_baud = ((actual_baud + 1) // 2) DCNL DCSP  DCSP encoded_divisor = ((best_divisor >> 3) + (frac_code[(best_divisor & 7)] << 14)) DCNL DCSP value = (encoded_divisor & 65535) DCNL DCSP index = (encoded_divisor >> 16) DCNL DCSP return (actual_baud, value, index)
def question_metadata(): DCNL  DCSP output = s3_rest_controller() DCNL DCSP return output
def _find_es_dict_by_key(lookup_dict, term): DCNL  DCSP if (term in lookup_dict): DCNL DCSP  DCSP return (lookup_dict, term) DCNL DCSP dict_cursor = lookup_dict DCNL DCSP subkeys = term.split('.') DCNL DCSP subkey = '' DCNL DCSP while (len(subkeys) > 0): DCNL DCSP  DCSP subkey += subkeys.pop(0) DCNL DCSP  DCSP if (subkey in dict_cursor): DCNL DCSP  DCSP  DCSP if (len(subkeys) == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP dict_cursor = dict_cursor[subkey] DCNL DCSP  DCSP  DCSP subkey = '' DCNL DCSP  DCSP elif (len(subkeys) == 0): DCNL DCSP  DCSP  DCSP dict_cursor = None DCNL DCSP  DCSP  DCSP subkey = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subkey += '.' DCNL DCSP return (dict_cursor, subkey)
def set_ip_nonlocal_bind_for_namespace(namespace): DCNL  DCSP failed = set_ip_nonlocal_bind(value=0, namespace=namespace, log_fail_as_error=False) DCNL DCSP if failed: DCNL DCSP  DCSP LOG.warning(_LW('%s DCSP will DCSP not DCSP be DCSP set DCSP to DCSP 0 DCSP in DCSP the DCSP root DCSP namespace DCSP in DCSP order DCSP to DCSP not DCSP break DCSP DVR, DCSP which DCSP requires DCSP this DCSP value DCSP be DCSP set DCSP to DCSP 1. DCSP This DCSP may DCSP introduce DCSP a DCSP race DCSP between DCSP moving DCSP a DCSP floating DCSP IP DCSP to DCSP a DCSP different DCSP network DCSP node, DCSP and DCSP the DCSP peer DCSP side DCSP getting DCSP a DCSP populated DCSP ARP DCSP cache DCSP for DCSP a DCSP given DCSP floating DCSP IP DCSP address.'), IP_NONLOCAL_BIND)
def get_today_all(): DCNL  DCSP ct._write_head() DCNL DCSP df = _parsing_dayprice_json(1) DCNL DCSP if (df is not None): DCNL DCSP  DCSP for i in range(2, ct.PAGE_NUM[0]): DCNL DCSP  DCSP  DCSP newdf = _parsing_dayprice_json(i) DCNL DCSP  DCSP  DCSP df = df.append(newdf, ignore_index=True) DCNL DCSP return df
def block(bdaddr): DCNL  DCSP if (not salt.utils.validate.net.mac(bdaddr)): DCNL DCSP  DCSP raise CommandExecutionError('Invalid DCSP BD DCSP address DCSP passed DCSP to DCSP bluetooth.block') DCNL DCSP cmd = 'hciconfig DCSP {0} DCSP block'.format(bdaddr) DCNL DCSP __salt__['cmd.run'](cmd).splitlines()
def delete_comment(request, comment_id): DCNL  DCSP (cc_comment, context) = _get_comment_and_context(request, comment_id) DCNL DCSP if can_delete(cc_comment, context): DCNL DCSP  DCSP cc_comment.delete() DCNL DCSP  DCSP comment_deleted.send(sender=None, user=request.user, post=cc_comment) DCNL DCSP else: DCNL DCSP  DCSP raise PermissionDenied
def regex_uri(e, regexes, tag, default=None): DCNL  DCSP path = e['PATH_INFO'] DCNL DCSP host = e.get('HTTP_HOST', e.get('SERVER_NAME', 'localhost')).lower() DCNL DCSP i = host.find(':') DCNL DCSP if (i > 0): DCNL DCSP  DCSP host = host[:i] DCNL DCSP key = ('%s:%s://%s:%s DCSP %s' % (e.get('REMOTE_ADDR', 'localhost'), e.get('wsgi.url_scheme', 'http').lower(), host, e.get('REQUEST_METHOD', 'get').lower(), path)) DCNL DCSP for (regex, value, custom_env) in regexes: DCNL DCSP  DCSP if regex.match(key): DCNL DCSP  DCSP  DCSP e.update(custom_env) DCNL DCSP  DCSP  DCSP rewritten = regex.sub(value, key) DCNL DCSP  DCSP  DCSP log_rewrite(('%s: DCSP [%s] DCSP [%s] DCSP -> DCSP %s' % (tag, key, value, rewritten))) DCNL DCSP  DCSP  DCSP return rewritten DCNL DCSP log_rewrite(('%s: DCSP [%s] DCSP -> DCSP %s DCSP (not DCSP rewritten)' % (tag, key, default))) DCNL DCSP return default
def sort_otu_table(otu_table, sorted_sample_ids): DCNL  DCSP sorted_sample_ids_set = set(sorted_sample_ids) DCNL DCSP if (set(otu_table.ids()) - sorted_sample_ids_set): DCNL DCSP  DCSP raise KeyError(('Sample DCSP IDs DCSP present DCSP in DCSP OTU DCSP table DCSP but DCSP not DCSP sorted DCSP sample DCSP id DCSP list: DCSP ' + ' DCSP '.join(list((set(otu_table.ids()) - set(sorted_sample_ids)))))) DCNL DCSP if (len(sorted_sample_ids_set) != len(sorted_sample_ids)): DCNL DCSP  DCSP raise ValueError('Duplicate DCSP sample DCSP IDs DCSP are DCSP present DCSP in DCSP sorted DCSP sample DCSP id DCSP list.') DCNL DCSP safe_sorted_sample_ids = [] DCNL DCSP for k in sorted_sample_ids: DCNL DCSP  DCSP if otu_table.exists(k): DCNL DCSP  DCSP  DCSP safe_sorted_sample_ids.append(k) DCNL DCSP sorted_table = otu_table.sort_order(safe_sorted_sample_ids) DCNL DCSP return sorted_table
def ordinal(value): DCNL  DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return value DCNL DCSP t = ('th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th') DCNL DCSP if ((value % 100) in (11, 12, 13)): DCNL DCSP  DCSP return (u'%d%s' % (value, t[0])) DCNL DCSP return (u'%d%s' % (value, t[(value % 10)]))
def destroy(name, call=None): DCNL  DCSP log.info('Attempting DCSP to DCSP delete DCSP instance DCSP %s', name) DCNL DCSP if (not vb_machine_exists(name)): DCNL DCSP  DCSP return "{0} DCSP doesn't DCSP exist DCSP and DCSP can't DCSP be DCSP deleted".format(name) DCNL DCSP cloud.fire_event('event', 'destroying DCSP instance', 'salt/cloud/{0}/destroying'.format(name), args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP vb_destroy_machine(name) DCNL DCSP cloud.fire_event('event', 'destroyed DCSP instance', 'salt/cloud/{0}/destroyed'.format(name), args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport'])
def get_images_table(meta): DCNL  DCSP (get_images_table,) = from_migration_import('008_add_image_members_table', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
def concatenate_paths(paths): DCNL  DCSP vertices = [] DCNL DCSP codes = [] DCNL DCSP for p in paths: DCNL DCSP  DCSP p = make_path_regular(p) DCNL DCSP  DCSP vertices.append(p.vertices) DCNL DCSP  DCSP codes.append(p.codes) DCNL DCSP _path = Path(np.concatenate(vertices), np.concatenate(codes)) DCNL DCSP return _path
def label_table(dataset_id, table_id, label_key, label_value, project_id=None): DCNL  DCSP (credentials, default_project_id) = google.auth.default(scopes=['https://www.googleapis.com/auth/bigquery']) DCNL DCSP session = google.auth.transport.requests.AuthorizedSession(credentials) DCNL DCSP if (project_id is None): DCNL DCSP  DCSP project_id = default_project_id DCNL DCSP url_format = 'https://www.googleapis.com/bigquery/v2/projects/{project_id}/datasets/{dataset_id}/tables/{table_id}' DCNL DCSP response = session.patch(url_format.format(project_id=project_id, dataset_id=dataset_id, table_id=table_id), params={'fields': 'labels'}, json={'labels': {label_key: label_value}}) DCNL DCSP response.raise_for_status() DCNL DCSP labels = response.json()['labels'] DCNL DCSP print 'Updated DCSP label DCSP "{}" DCSP with DCSP value DCSP "{}"'.format(label_key, labels[label_key])
def prepro(I): DCNL  DCSP I = I[35:195] DCNL DCSP I = I[::2, ::2, 0] DCNL DCSP I[(I == 144)] = 0 DCNL DCSP I[(I == 109)] = 0 DCNL DCSP I[(I != 0)] = 1 DCNL DCSP return I.astype(np.float).ravel()
def put_meta(module, cf, container, src, dest, meta, clear_meta): DCNL  DCSP objs = None DCNL DCSP if (src and dest): DCNL DCSP  DCSP module.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP files DCSP to DCSP set DCSP meta DCSP have DCSP been DCSP specified DCSP on DCSP both DCSP src DCSP and DCSP dest DCSP args') DCNL DCSP elif dest: DCNL DCSP  DCSP objs = dest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP objs = objs.split(',') DCNL DCSP objs = map(str.strip, objs) DCNL DCSP c = _get_container(module, cf, container) DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = c.get_object(obj).set_metadata(meta, clear=clear_meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP module.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(result) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['success'] = True DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['changed'] = True DCNL DCSP  DCSP EXIT_DICT['num_changed'] = True DCNL DCSP module.exit_json(**EXIT_DICT)
def parse_ntlm_resp(msg3, seq): DCNL  DCSP if (seq in challenge_acks): DCNL DCSP  DCSP challenge = challenge_acks[seq] DCNL DCSP else: DCNL DCSP  DCSP challenge = 'CHALLENGE DCSP NOT DCSP FOUND' DCNL DCSP if (len(msg3) > 43): DCNL DCSP  DCSP (lmlen, lmmax, lmoff, ntlen, ntmax, ntoff, domlen, dommax, domoff, userlen, usermax, useroff) = struct.unpack('12xhhihhihhihhi', msg3[:44]) DCNL DCSP  DCSP lmhash = binascii.b2a_hex(msg3[lmoff:(lmoff + lmlen)]) DCNL DCSP  DCSP nthash = binascii.b2a_hex(msg3[ntoff:(ntoff + ntlen)]) DCNL DCSP  DCSP domain = msg3[domoff:(domoff + domlen)].replace('\x00', '') DCNL DCSP  DCSP user = msg3[useroff:(useroff + userlen)].replace('\x00', '') DCNL DCSP  DCSP if (ntlen == 24): DCNL DCSP  DCSP  DCSP msg = ('%s DCSP %s' % ('NETNTLMv1:', ((((((((user + '::') + domain) + ':') + lmhash) + ':') + nthash) + ':') + challenge))) DCNL DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP elif (ntlen > 60): DCNL DCSP  DCSP  DCSP msg = ('%s DCSP %s' % ('NETNTLMv2:', ((((((((user + '::') + domain) + ':') + challenge) + ':') + nthash[:32]) + ':') + nthash[32:]))) DCNL DCSP  DCSP  DCSP return msg
def test_prefer_deep(): DCNL  DCSP dsk = {'a': 1, 'b': (f, 'a'), 'c': (f, 'b'), 'x': 1, 'y': (f, 'x')} DCNL DCSP o = order(dsk) DCNL DCSP assert (o == {'c': 0, 'b': 1, 'a': 2, 'y': 3, 'x': 4})
def _gs_decorrelation(w, W, j): DCNL  DCSP w -= np.dot(np.dot(w, W[:j].T), W[:j]) DCNL DCSP return w
def removed(name, dir=None, user=None): DCNL  DCSP ret = {'name': name, 'result': None, 'comment': '', 'changes': {}} DCNL DCSP try: DCNL DCSP  DCSP installed_pkgs = __salt__['npm.list'](dir=dir) DCNL DCSP except (CommandExecutionError, CommandNotFoundError) as err: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP uninstalling DCSP '{0}': DCSP {1}".format(name, err) DCNL DCSP  DCSP return ret DCNL DCSP if (name not in installed_pkgs): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP is DCSP not DCSP installed".format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP is DCSP set DCSP to DCSP be DCSP removed".format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __salt__['npm.uninstall'](pkg=name, dir=dir, runas=user): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['changes'][name] = 'Removed' DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP was DCSP successfully DCSP removed".format(name) DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP removing DCSP package DCSP '{0}'".format(name) DCNL DCSP return ret
def create_gzip_message(payloads, key=None, compresslevel=None): DCNL  DCSP message_set = KafkaProtocol._encode_message_set([create_message(payload, pl_key) for (payload, pl_key) in payloads]) DCNL DCSP gzipped = gzip_encode(message_set, compresslevel=compresslevel) DCNL DCSP codec = (ATTRIBUTE_CODEC_MASK & CODEC_GZIP) DCNL DCSP return kafka.structs.Message(0, (0 | codec), key, gzipped)
def unpublish_exploration(committer_id, exploration_id): DCNL  DCSP _unpublish_activity(committer_id, exploration_id, feconf.ACTIVITY_TYPE_EXPLORATION)
def fork_exec(cmd, exec_env=None, logfile=None, pass_fds=None): DCNL  DCSP env = os.environ.copy() DCNL DCSP if (exec_env is not None): DCNL DCSP  DCSP for (env_name, env_val) in exec_env.items(): DCNL DCSP  DCSP  DCSP if callable(env_val): DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val(env.get(env_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val DCNL DCSP pid = os.fork() DCNL DCSP if (pid == 0): DCNL DCSP  DCSP if logfile: DCNL DCSP  DCSP  DCSP fds = [1, 2] DCNL DCSP  DCSP  DCSP with open(logfile, 'r+b') as fptr: DCNL DCSP  DCSP  DCSP  DCSP for desc in fds: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.dup2(fptr.fileno(), desc) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (pass_fds and hasattr(os, 'set_inheritable')): DCNL DCSP  DCSP  DCSP for fd in pass_fds: DCNL DCSP  DCSP  DCSP  DCSP os.set_inheritable(fd, True) DCNL DCSP  DCSP args = shlex.split(cmd) DCNL DCSP  DCSP os.execvpe(args[0], args, env) DCNL DCSP else: DCNL DCSP  DCSP return pid
def custom_create(request): DCNL  DCSP class SlugChangingArticleForm(forms.ModelForm, ): DCNL DCSP  DCSP 'Custom DCSP form DCSP class DCSP to DCSP overwrite DCSP the DCSP slug.' DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP model = Article DCNL DCSP  DCSP def save(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.instance.slug = 'some-other-slug' DCNL DCSP  DCSP  DCSP return super(SlugChangingArticleForm, self).save(*args, **kwargs) DCNL DCSP from django.views.generic.create_update import create_object DCNL DCSP return create_object(request, post_save_redirect='/create_update/view/article/%(slug)s/', form_class=SlugChangingArticleForm)
def getMinimumByPathsComplex(paths): DCNL  DCSP minimum = complex(999999999.0, 999999999.0) DCNL DCSP for path in paths: DCNL DCSP  DCSP minimum = getMinimum(minimum, getMinimumByPathComplex(path)) DCNL DCSP return minimum
def iter_texts_from_json_bz2(loc): DCNL  DCSP with bz2.BZ2File(loc) as file_: DCNL DCSP  DCSP for (i, line) in enumerate(file_): DCNL DCSP  DCSP  DCSP (yield ujson.loads(line)[u'body'])
def query_package(module, name): DCNL  DCSP (rc, out, err) = module.run_command(('%s DCSP -p DCSP -v' % PKGIN_PATH)) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP pflag = '-p' DCNL DCSP  DCSP splitchar = ';' DCNL DCSP else: DCNL DCSP  DCSP pflag = '' DCNL DCSP  DCSP splitchar = ' DCSP ' DCNL DCSP (rc, out, err) = module.run_command(('%s DCSP %s DCSP search DCSP "^%s$"' % (PKGIN_PATH, pflag, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP packages = out.split('\n') DCNL DCSP  DCSP for package in packages: DCNL DCSP  DCSP  DCSP (pkgname_with_version, raw_state) = package.split(splitchar)[0:2] DCNL DCSP  DCSP  DCSP pkg_search_obj = re.search('^(.*?)\\-[0-9][0-9.]*(nb[0-9]+)*', pkgname_with_version, re.M) DCNL DCSP  DCSP  DCSP if (not pkg_search_obj): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pkgname_without_version = pkg_search_obj.group(1) DCNL DCSP  DCSP  DCSP if (name != pkgname_without_version): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (raw_state == '<'): DCNL DCSP  DCSP  DCSP  DCSP return 'outdated' DCNL DCSP  DCSP  DCSP elif ((raw_state == '=') or (raw_state == '>')): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return False
def find_indentation(node): DCNL  DCSP while (node is not None): DCNL DCSP  DCSP if ((node.type == syms.suite) and (len(node.children) > 2)): DCNL DCSP  DCSP  DCSP indent = node.children[1] DCNL DCSP  DCSP  DCSP if (indent.type == token.INDENT): DCNL DCSP  DCSP  DCSP  DCSP return indent.value DCNL DCSP  DCSP node = node.parent DCNL DCSP return u''
def expect_warnings(*messages, **kw): DCNL  DCSP return _expect_warnings(sa_exc.SAWarning, messages, **kw)
def get_max_age(response): DCNL  DCSP if (not response.has_header('Cache-Control')): DCNL DCSP  DCSP return DCNL DCSP cc = dict([_to_tuple(el) for el in cc_delim_re.split(response['Cache-Control'])]) DCNL DCSP if ('max-age' in cc): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(cc['max-age']) DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP pass
def disabled_xblocks(): DCNL  DCSP return XBlockConfiguration.objects.current_set().filter(enabled=False)
@register.tag(name='crispy') DCNL def do_uni_form(parser, token): DCNL  DCSP token = token.split_contents() DCNL DCSP form = token.pop(1) DCNL DCSP helper = None DCNL DCSP template_pack = ("'%s'" % get_template_pack()) DCNL DCSP try: DCNL DCSP  DCSP helper = token.pop(1) DCNL DCSP except IndexError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP template_pack = token.pop(1) DCNL DCSP except IndexError: DCNL DCSP  DCSP pass DCNL DCSP if ((helper is not None) and isinstance(helper, string_types) and (("'" in helper) or ('"' in helper))): DCNL DCSP  DCSP template_pack = helper DCNL DCSP  DCSP helper = None DCNL DCSP if (template_pack is not None): DCNL DCSP  DCSP template_pack = template_pack[1:(-1)] DCNL DCSP  DCSP ALLOWED_TEMPLATE_PACKS = getattr(settings, 'CRISPY_ALLOWED_TEMPLATE_PACKS', ('bootstrap', 'uni_form', 'bootstrap3', 'bootstrap4')) DCNL DCSP  DCSP if (template_pack not in ALLOWED_TEMPLATE_PACKS): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError(("crispy DCSP tag's DCSP template_pack DCSP argument DCSP should DCSP be DCSP in DCSP %s" % str(ALLOWED_TEMPLATE_PACKS))) DCNL DCSP return CrispyFormNode(form, helper, template_pack=template_pack)
def t_CPP_CHAR(t): DCNL  DCSP t.lexer.lineno += t.value.count('\n') DCNL DCSP return t
def _CreateDbOperationMap(entry_list): DCNL  DCSP map = dict() DCNL DCSP for entry in entry_list: DCNL DCSP  DCSP handler = entry.handler DCNL DCSP  DCSP method_str = ((handler.im_self.__name__ + '.') + handler.im_func.__name__) DCNL DCSP  DCSP map[method_str] = entry DCNL DCSP return map
def make_envvar(name): DCNL  DCSP env = builtins.__xonsh_env__ DCNL DCSP vd = env.get_docs(name) DCNL DCSP if (not vd.configurable): DCNL DCSP  DCSP return DCNL DCSP default = vd.default DCNL DCSP if ('\n' in default): DCNL DCSP  DCSP default = ('\n' + _wrap_paragraphs(default, width=69)) DCNL DCSP curr = env.get(name) DCNL DCSP if (is_string(curr) and is_template_string(curr)): DCNL DCSP  DCSP curr = curr.replace('{', '{{').replace('}', '}}') DCNL DCSP curr = pprint.pformat(curr, width=69) DCNL DCSP if ('\n' in curr): DCNL DCSP  DCSP curr = ('\n' + curr) DCNL DCSP msg = ENVVAR_MESSAGE.format(name=name, default=default, current=curr, docstr=_wrap_paragraphs(vd.docstr, width=69)) DCNL DCSP mnode = wiz.Message(message=msg) DCNL DCSP ens = env.get_ensurer(name) DCNL DCSP path = ('/env/' + name) DCNL DCSP pnode = wiz.StoreNonEmpty(ENVVAR_PROMPT, converter=ens.convert, show_conversion=True, path=path, retry=True, store_raw=vd.store_as_str) DCNL DCSP return (mnode, pnode)
def parse_rarefaction_record(line): DCNL  DCSP def float_or_nan(v): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return float(v) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return nan DCNL DCSP entries = line.split(' DCTB ') DCNL DCSP return (entries[0], map(float_or_nan, entries[1:]))
def validate_key(key, shape): DCNL  DCSP (rows, cols) = shape DCNL DCSP if (not isinstance(key, tuple)): DCNL DCSP  DCSP if (rows == 1): DCNL DCSP  DCSP  DCSP key = (slice(0, 1, None), key) DCNL DCSP  DCSP elif (cols == 1): DCNL DCSP  DCSP  DCSP key = (key, slice(0, 1, None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise IndexError('Invalid DCSP index/slice.') DCNL DCSP key = (format_slice(slc, dim) for (slc, dim) in zip(key, shape)) DCNL DCSP return tuple(key)
def export_to_files(record_list=None, record_module=None, verbose=0, create_init=None): DCNL  DCSP if frappe.flags.in_import: DCNL DCSP  DCSP return DCNL DCSP if record_list: DCNL DCSP  DCSP for record in record_list: DCNL DCSP  DCSP  DCSP write_document_file(frappe.get_doc(record[0], record[1]), record_module, create_init=create_init)
def mkAssocResponse(*keys): DCNL  DCSP args = dict([(key, association_response_values[key]) for key in keys]) DCNL DCSP return Message.fromOpenIDArgs(args)
def test_end_pos_error_correction(): DCNL  DCSP s = u('def DCSP x():\n DCSP .') DCNL DCSP m = ParserWithRecovery(load_grammar(), s).module DCNL DCSP func = m.children[0] DCNL DCSP assert (func.type == 'funcdef') DCNL DCSP assert (func.end_pos == (3, 0)) DCNL DCSP assert (m.end_pos == (2, 2))
def int_from_geom(func, zero=False): DCNL  DCSP func.argtypes = [GEOM_PTR] DCNL DCSP func.restype = c_int DCNL DCSP if zero: DCNL DCSP  DCSP func.errcheck = check_zero DCNL DCSP else: DCNL DCSP  DCSP func.errcheck = check_minus_one DCNL DCSP return func
def check_header_validity(header): DCNL  DCSP (name, value) = header DCNL DCSP if isinstance(value, bytes): DCNL DCSP  DCSP pat = _CLEAN_HEADER_REGEX_BYTE DCNL DCSP else: DCNL DCSP  DCSP pat = _CLEAN_HEADER_REGEX_STR DCNL DCSP try: DCNL DCSP  DCSP if (not pat.match(value)): DCNL DCSP  DCSP  DCSP raise InvalidHeader(('Invalid DCSP return DCSP character DCSP or DCSP leading DCSP space DCSP in DCSP header: DCSP %s' % name)) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise InvalidHeader(('Header DCSP value DCSP %s DCSP must DCSP be DCSP of DCSP type DCSP str DCSP or DCSP bytes, DCSP not DCSP %s' % (value, type(value))))
def defoveate_channel(img, rings, dense_input, start_idx): DCNL  DCSP ring_w = numpy.sum(rings) DCNL DCSP inner_h = (img.shape[1] - (2 * ring_w)) DCNL DCSP inner_w = (img.shape[2] - (2 * ring_w)) DCNL DCSP end_idx = (start_idx + (inner_h * inner_w)) DCNL DCSP inner_img = dense_input[:, start_idx:end_idx].reshape((-1), inner_h, inner_w) DCNL DCSP img[:, ring_w:(ring_w + inner_h), ring_w:(ring_w + inner_w)] = inner_img DCNL DCSP idx = 0 DCNL DCSP start_idx = end_idx DCNL DCSP for rd in rings: DCNL DCSP  DCSP start_idx = restore_ring(img, idx, rd, dense_input, start_idx) DCNL DCSP  DCSP idx += rd DCNL DCSP return start_idx
def _get_options(ret=None): DCNL  DCSP attrs = {'database': 'database', 'timeout': 'timeout'} DCNL DCSP _options = salt.returners.get_returner_options(__virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__) DCNL DCSP return _options
def create_resource(): DCNL  DCSP deserializer = rpc.RPCJSONDeserializer() DCNL DCSP serializer = rpc.RPCJSONSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def _get_constant(name): DCNL  DCSP field_re = re.compile('__{}__\\s+=\\s+(.*)'.format(re.escape(name))) DCNL DCSP path = os.path.join(BASEDIR, 'qutebrowser', '__init__.py') DCNL DCSP line = field_re.search(read_file(path)).group(1) DCNL DCSP value = ast.literal_eval(line) DCNL DCSP return value
def assert_regex(result, expected, msg=''): DCNL  DCSP assert re.search(expected, result), ('%s%r DCSP not DCSP found DCSP in DCSP %r' % (_fmt_msg(msg), expected, result))
def scatter_plot(): DCNL  DCSP point_count = 1000 DCNL DCSP x_index = np.random.random(point_count) DCNL DCSP y_index = np.random.random(point_count) DCNL DCSP color_list = np.random.random(point_count) DCNL DCSP scale_list = (np.random.random(point_count) * 100) DCNL DCSP plt.scatter(x_index, y_index, s=scale_list, c=color_list, marker='o') DCNL DCSP plt.show() DCNL DCSP return
@webob.dec.wsgify DCNL @util.check_accept('application/json') DCNL def get_resource_provider(req): DCNL  DCSP uuid = util.wsgi_path_item(req.environ, 'uuid') DCNL DCSP context = req.environ['placement.context'] DCNL DCSP resource_provider = objects.ResourceProvider.get_by_uuid(context, uuid) DCNL DCSP req.response.body = encodeutils.to_utf8(jsonutils.dumps(_serialize_provider(req.environ, resource_provider))) DCNL DCSP req.response.content_type = 'application/json' DCNL DCSP return req.response
@require_admin_context DCNL def purge_deleted_rows(context, age_in_days): DCNL  DCSP try: DCNL DCSP  DCSP age_in_days = int(age_in_days) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = (_('Invalid DCSP value DCSP for DCSP age, DCSP %(age)s') % {'age': age_in_days}) DCNL DCSP  DCSP LOG.exception(msg) DCNL DCSP  DCSP raise exception.InvalidParameterValue(msg) DCNL DCSP engine = get_engine() DCNL DCSP session = get_session() DCNL DCSP metadata = MetaData() DCNL DCSP metadata.reflect(engine) DCNL DCSP for table in reversed(metadata.sorted_tables): DCNL DCSP  DCSP if ('deleted' not in table.columns.keys()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP LOG.info(_LI('Purging DCSP deleted DCSP rows DCSP older DCSP than DCSP age=%(age)d DCSP days DCSP from DCSP table=%(table)s'), {'age': age_in_days, 'table': table}) DCNL DCSP  DCSP deleted_age = (timeutils.utcnow() - dt.timedelta(days=age_in_days)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with session.begin(): DCNL DCSP  DCSP  DCSP  DCSP if (six.text_type(table) == 'quality_of_service_specs'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.query(models.QualityOfServiceSpecs).filter(and_(models.QualityOfServiceSpecs.specs_id.isnot(None), (models.QualityOfServiceSpecs.deleted == 1), (models.QualityOfServiceSpecs.deleted_at < deleted_age))).delete() DCNL DCSP  DCSP  DCSP  DCSP result = session.execute(table.delete().where((table.c.deleted_at < deleted_age))) DCNL DCSP  DCSP except db_exc.DBReferenceError as ex: DCNL DCSP  DCSP  DCSP LOG.error(_LE('DBError DCSP detected DCSP when DCSP purging DCSP from DCSP %(tablename)s: DCSP %(error)s.'), {'tablename': table, 'error': six.text_type(ex)}) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP rows_purged = result.rowcount DCNL DCSP  DCSP if (rows_purged != 0): DCNL DCSP  DCSP  DCSP LOG.info(_LI('Deleted DCSP %(row)d DCSP rows DCSP from DCSP table=%(table)s'), {'row': rows_purged, 'table': table})
def has_module(module_name, members=[]): DCNL  DCSP try: DCNL DCSP  DCSP mod = __import__(module_name, fromlist=members) DCNL DCSP except ImportError: DCNL DCSP  DCSP return False DCNL DCSP for member in members: DCNL DCSP  DCSP if (not hasattr(mod, member)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def create_realign_flow(name=u'realign'): DCNL  DCSP realignflow = pe.Workflow(name=name) DCNL DCSP inputnode = pe.Node(interface=util.IdentityInterface(fields=[u'func']), name=u'inputspec') DCNL DCSP outputnode = pe.Node(interface=util.IdentityInterface(fields=[u'realigned_file']), name=u'outputspec') DCNL DCSP realigner = pe.Node(fsl.MCFLIRT(save_mats=True, stats_imgs=True), name=u'realigner') DCNL DCSP splitter = pe.Node(fsl.Split(dimension=u't'), name=u'splitter') DCNL DCSP warper = pe.MapNode(fsl.ApplyWarp(interp=u'spline'), iterfield=[u'in_file', u'premat'], name=u'warper') DCNL DCSP joiner = pe.Node(fsl.Merge(dimension=u't'), name=u'joiner') DCNL DCSP realignflow.connect(inputnode, u'func', realigner, u'in_file') DCNL DCSP realignflow.connect(inputnode, (u'func', select_volume, u'middle'), realigner, u'ref_vol') DCNL DCSP realignflow.connect(realigner, u'out_file', splitter, u'in_file') DCNL DCSP realignflow.connect(realigner, u'mat_file', warper, u'premat') DCNL DCSP realignflow.connect(realigner, u'variance_img', warper, u'ref_file') DCNL DCSP realignflow.connect(splitter, u'out_files', warper, u'in_file') DCNL DCSP realignflow.connect(warper, u'out_file', joiner, u'in_files') DCNL DCSP realignflow.connect(joiner, u'merged_file', outputnode, u'realigned_file') DCNL DCSP return realignflow
def dmp_rem(f, g, u, K): DCNL  DCSP return dmp_div(f, g, u, K)[1]
def get_request_location(request, context): DCNL  DCSP if (context.location != ''): DCNL DCSP  DCSP return context.location DCNL DCSP context.location = None DCNL DCSP if getattr(request, 'via_cdn', False): DCNL DCSP  DCSP g.stats.simple_event('geoip.cdn_request') DCNL DCSP  DCSP cdn_geoinfo = g.cdn_provider.get_client_location(request.environ) DCNL DCSP  DCSP if cdn_geoinfo: DCNL DCSP  DCSP  DCSP context.location = cdn_geoinfo DCNL DCSP elif getattr(request, 'ip', None): DCNL DCSP  DCSP g.stats.simple_event('geoip.non_cdn_request') DCNL DCSP  DCSP timer = g.stats.get_timer('providers.geoip.location_by_ips') DCNL DCSP  DCSP timer.start() DCNL DCSP  DCSP location = location_by_ips(request.ip) DCNL DCSP  DCSP if location: DCNL DCSP  DCSP  DCSP context.location = location.get('country_code', None) DCNL DCSP  DCSP timer.stop() DCNL DCSP return context.location
def service_get_all_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_by_host(context, host)
def _quote_domain(domain): DCNL  DCSP return parse.quote(domain.replace('.', '%2E'))
def cache_key_prefix(request): DCNL  DCSP cache_key = (u'%s.%s.%s.' % (settings.CACHE_MIDDLEWARE_KEY_PREFIX, current_site_id(), (device_from_request(request) or u'default'))) DCNL DCSP return _i18n_cache_key_suffix(request, cache_key)
def forward(data, impulse_response=None, filter_params={}, predefined_filter=None): DCNL  DCSP assert_nD(data, 2, 'data') DCNL DCSP if (predefined_filter is None): DCNL DCSP  DCSP predefined_filter = LPIFilter2D(impulse_response, **filter_params) DCNL DCSP return predefined_filter(data)
def import_key(extern_key, passphrase=None): DCNL  DCSP extern_key = tobytes(extern_key) DCNL DCSP if (passphrase is not None): DCNL DCSP  DCSP passphrase = tobytes(passphrase) DCNL DCSP if extern_key.startswith(b('-----')): DCNL DCSP  DCSP (der, marker, enc_flag) = PEM.decode(tostr(extern_key), passphrase) DCNL DCSP  DCSP if enc_flag: DCNL DCSP  DCSP  DCSP passphrase = None DCNL DCSP  DCSP return _import_keyDER(der, passphrase) DCNL DCSP if extern_key.startswith(b('ssh-rsa DCSP ')): DCNL DCSP  DCSP keystring = binascii.a2b_base64(extern_key.split(b(' DCSP '))[1]) DCNL DCSP  DCSP keyparts = [] DCNL DCSP  DCSP while (len(keystring) > 4): DCNL DCSP  DCSP  DCSP l = struct.unpack('>I', keystring[:4])[0] DCNL DCSP  DCSP  DCSP keyparts.append(keystring[4:(4 + l)]) DCNL DCSP  DCSP  DCSP keystring = keystring[(4 + l):] DCNL DCSP  DCSP e = Integer.from_bytes(keyparts[1]) DCNL DCSP  DCSP n = Integer.from_bytes(keyparts[2]) DCNL DCSP  DCSP return construct([n, e]) DCNL DCSP if (bord(extern_key[0]) == 48): DCNL DCSP  DCSP return _import_keyDER(extern_key, passphrase) DCNL DCSP raise ValueError('RSA DCSP key DCSP format DCSP is DCSP not DCSP supported')
def computeComprRate(meta, compr_size): DCNL  DCSP if ((not meta.has('width')) or (not meta.has('height')) or (not meta.has('bits_per_pixel'))): DCNL DCSP  DCSP return DCNL DCSP if (not compr_size): DCNL DCSP  DCSP return DCNL DCSP orig_size = ((meta.get('width') * meta.get('height')) * meta.get('bits_per_pixel')) DCNL DCSP meta.compr_rate = (float(orig_size) / compr_size)
def buildAllTarballs(checkout, destination): DCNL  DCSP if (not checkout.child('.svn').exists()): DCNL DCSP  DCSP raise NotWorkingDirectory(('%s DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP an DCSP SVN DCSP working DCSP directory.' % (checkout.path,))) DCNL DCSP if runCommand(['svn', 'st', checkout.path]).strip(): DCNL DCSP  DCSP raise UncleanWorkingDirectory(('There DCSP are DCSP local DCSP modifications DCSP to DCSP the DCSP SVN DCSP checkout DCSP in DCSP %s.' % (checkout.path,))) DCNL DCSP workPath = FilePath(mkdtemp()) DCNL DCSP export = workPath.child('export') DCNL DCSP runCommand(['svn', 'export', checkout.path, export.path]) DCNL DCSP twistedPath = export.child('twisted') DCNL DCSP version = Project(twistedPath).getVersion() DCNL DCSP versionString = version.base() DCNL DCSP apiBaseURL = ('http://twistedmatrix.com/documents/%s/api/%%s.html' % versionString) DCNL DCSP if (not destination.exists()): DCNL DCSP  DCSP destination.createDirectory() DCNL DCSP db = DistributionBuilder(export, destination, apiBaseURL=apiBaseURL) DCNL DCSP db.buildCore(versionString) DCNL DCSP for subproject in twisted_subprojects: DCNL DCSP  DCSP if twistedPath.child(subproject).exists(): DCNL DCSP  DCSP  DCSP db.buildSubProject(subproject, versionString) DCNL DCSP db.buildTwisted(versionString) DCNL DCSP workPath.remove()
def sp_sum(x, axis=None, sparse_grad=False): DCNL  DCSP return SpSum(axis, sparse_grad)(x)
def start_debugger(rpchandler, gui_adap_oid): DCNL  DCSP gui_proxy = GUIProxy(rpchandler, gui_adap_oid) DCNL DCSP idb = Debugger.Idb(gui_proxy) DCNL DCSP idb_adap = IdbAdapter(idb) DCNL DCSP rpchandler.register(idb_adap_oid, idb_adap) DCNL DCSP return idb_adap_oid
def console(): DCNL  DCSP import optparse DCNL DCSP import textwrap DCNL DCSP usage = 'python DCSP web2py.py' DCNL DCSP description = " DCSP  DCSP  DCSP  DCSP web2py DCSP Web DCSP Framework DCSP startup DCSP script.\n DCSP  DCSP  DCSP  DCSP ATTENTION: DCSP unless DCSP a DCSP password DCSP is DCSP specified DCSP (-a DCSP 'passwd') DCSP web2py DCSP will\n DCSP  DCSP  DCSP  DCSP attempt DCSP to DCSP run DCSP a DCSP GUI. DCSP In DCSP this DCSP case DCSP command DCSP line DCSP options DCSP are DCSP ignored." DCNL DCSP description = textwrap.dedent(description) DCNL DCSP parser = optparse.OptionParser(usage, None, optparse.Option, ProgramVersion) DCNL DCSP parser.description = description DCNL DCSP msg = "IP DCSP address DCSP of DCSP the DCSP server DCSP (e.g., DCSP 127.0.0.1 DCSP or DCSP ::1); DCSP Note: DCSP This DCSP value DCSP is DCSP ignored DCSP when DCSP using DCSP the DCSP 'interfaces' DCSP option." DCNL DCSP parser.add_option('-i', '--ip', default='127.0.0.1', dest='ip', help=msg) DCNL DCSP parser.add_option('-p', '--port', default='8000', dest='port', type='int', help='port DCSP of DCSP server DCSP (8000)') DCNL DCSP parser.add_option('-G', '--GAE', default=None, dest='gae', help="'-G DCSP configure' DCSP will DCSP create DCSP app.yaml DCSP and DCSP gaehandler.py") DCNL DCSP msg = 'password DCSP to DCSP be DCSP used DCSP for DCSP administration DCSP (use DCSP -a DCSP "<recycle>" DCSP to DCSP reuse DCSP the DCSP last DCSP password))' DCNL DCSP parser.add_option('-a', '--password', default='<ask>', dest='password', help=msg) DCNL DCSP parser.add_option('-c', '--ssl_certificate', default='', dest='ssl_certificate', help='file DCSP that DCSP contains DCSP ssl DCSP certificate') DCNL DCSP parser.add_option('-k', '--ssl_private_key', default='', dest='ssl_private_key', help='file DCSP that DCSP contains DCSP ssl DCSP private DCSP key') DCNL DCSP msg = 'Use DCSP this DCSP file DCSP containing DCSP the DCSP CA DCSP certificate DCSP to DCSP validate DCSP X509 DCSP certificates DCSP from DCSP clients' DCNL DCSP parser.add_option('--ca-cert', action='store', dest='ssl_ca_certificate', default=None, help=msg) DCNL DCSP parser.add_option('-d', '--pid_filename', default='httpserver.pid', dest='pid_filename', help='file DCSP to DCSP store DCSP the DCSP pid DCSP of DCSP the DCSP server') DCNL DCSP parser.add_option('-l', '--log_filename', default='httpserver.log', dest='log_filename', help='file DCSP to DCSP log DCSP connections') DCNL DCSP parser.add_option('-n', '--numthreads', default=None, type='int', dest='numthreads', help='number DCSP of DCSP threads DCSP (deprecated)') DCNL DCSP parser.add_option('--minthreads', default=None, type='int', dest='minthreads', help='minimum DCSP number DCSP of DCSP server DCSP threads') DCNL DCSP parser.add_option('--maxthreads', default=None, type='int', dest='maxthreads', help='maximum DCSP number DCSP of DCSP server DCSP threads') DCNL DCSP parser.add_option('-s', '--server_name', default=socket.gethostname(), dest='server_name', help='server DCSP name DCSP for DCSP the DCSP web DCSP server') DCNL DCSP msg = 'max DCSP number DCSP of DCSP queued DCSP requests DCSP when DCSP server DCSP unavailable' DCNL DCSP parser.add_option('-q', '--request_queue_size', default='5', type='int', dest='request_queue_size', help=msg) DCNL DCSP parser.add_option('-o', '--timeout', default='10', type='int', dest='timeout', help='timeout DCSP for DCSP individual DCSP request DCSP (10 DCSP seconds)') DCNL DCSP parser.add_option('-z', '--shutdown_timeout', default='5', type='int', dest='shutdown_timeout', help='timeout DCSP on DCSP shutdown DCSP of DCSP server DCSP (5 DCSP seconds)') DCNL DCSP parser.add_option('--socket-timeout', default=5, type='int', dest='socket_timeout', help='timeout DCSP for DCSP socket DCSP (5 DCSP second)') DCNL DCSP parser.add_option('-f', '--folder', default=os.getcwd(), dest='folder', help='folder DCSP from DCSP which DCSP to DCSP run DCSP web2py') DCNL DCSP parser.add_option('-v', '--verbose', action='store_true', dest='verbose', default=False, help='increase DCSP --test DCSP verbosity') DCNL DCSP parser.add_option('-Q', '--quiet', action='store_true', dest='quiet', default=False, help='disable DCSP all DCSP output') DCNL DCSP parser.add_option('-e', '--errors_to_console', action='store_true', dest='print_errors', default=False, help='log DCSP all DCSP errors DCSP to DCSP console') DCNL DCSP msg = 'set DCSP debug DCSP output DCSP level DCSP (0-100, DCSP 0 DCSP means DCSP all, DCSP 100 DCSP means DCSP none; DCSP default DCSP is DCSP 30)' DCNL DCSP parser.add_option('-D', '--debug', dest='debuglevel', default=30, type='int', help=msg) DCNL DCSP msg = 'run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP IPython DCSP (if DCSP installed) DCSP with DCSP specified DCSP appname DCSP (if DCSP app DCSP does DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP created). DCSP APPNAME DCSP like DCSP a/c/f DCSP (c,f DCSP optional)' DCNL DCSP parser.add_option('-S', '--shell', dest='shell', metavar='APPNAME', help=msg) DCNL DCSP msg = 'run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP bpython DCSP (if DCSP installed) DCSP with DCSP specified DCSP appname DCSP (if DCSP app DCSP does DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP created).\nUse DCSP combined DCSP with DCSP --shell' DCNL DCSP parser.add_option('-B', '--bpython', action='store_true', default=False, dest='bpython', help=msg) DCNL DCSP msg = 'only DCSP use DCSP plain DCSP python DCSP shell; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option' DCNL DCSP parser.add_option('-P', '--plain', action='store_true', default=False, dest='plain', help=msg) DCNL DCSP msg = 'auto DCSP import DCSP model DCSP files; DCSP default DCSP is DCSP False; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option' DCNL DCSP parser.add_option('-M', '--import_models', action='store_true', default=False, dest='import_models', help=msg) DCNL DCSP msg = 'run DCSP PYTHON_FILE DCSP in DCSP web2py DCSP environment; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option' DCNL DCSP parser.add_option('-R', '--run', dest='run', metavar='PYTHON_FILE', default='', help=msg) DCNL DCSP msg = 'run DCSP scheduled DCSP tasks DCSP for DCSP the DCSP specified DCSP apps: DCSP expects DCSP a DCSP list DCSP of DCSP app DCSP names DCSP as DCSP -K DCSP app1,app2,app3 DCSP or DCSP a DCSP list DCSP of DCSP app:groups DCSP as DCSP -K DCSP app1:group1:group2,app2:group1 DCSP to DCSP override DCSP specific DCSP group_names. DCSP (only DCSP strings, DCSP no DCSP spaces DCSP allowed. DCSP Requires DCSP a DCSP scheduler DCSP defined DCSP in DCSP the DCSP models' DCNL DCSP parser.add_option('-K', '--scheduler', dest='scheduler', default=None, help=msg) DCNL DCSP msg = 'run DCSP schedulers DCSP alongside DCSP webserver, DCSP needs DCSP -K DCSP app1 DCSP and DCSP -a DCSP too' DCNL DCSP parser.add_option('-X', '--with-scheduler', action='store_true', default=False, dest='with_scheduler', help=msg) DCNL DCSP msg = 'run DCSP doctests DCSP in DCSP web2py DCSP environment; DCSP TEST_PATH DCSP like DCSP a/c/f DCSP (c,f DCSP optional)' DCNL DCSP parser.add_option('-T', '--test', dest='test', metavar='TEST_PATH', default=None, help=msg) DCNL DCSP msg = 'trigger DCSP a DCSP cron DCSP run DCSP manually; DCSP usually DCSP invoked DCSP from DCSP a DCSP system DCSP crontab' DCNL DCSP parser.add_option('-C', '--cron', action='store_true', dest='extcron', default=False, help=msg) DCNL DCSP msg = 'triggers DCSP the DCSP use DCSP of DCSP softcron' DCNL DCSP parser.add_option('--softcron', action='store_true', dest='softcron', default=False, help=msg) DCNL DCSP parser.add_option('-Y', '--run-cron', action='store_true', dest='runcron', default=False, help='start DCSP the DCSP background DCSP cron DCSP process') DCNL DCSP parser.add_option('-J', '--cronjob', action='store_true', dest='cronjob', default=False, help='identify DCSP cron-initiated DCSP command') DCNL DCSP parser.add_option('-L', '--config', dest='config', default='', help='config DCSP file') DCNL DCSP parser.add_option('-F', '--profiler', dest='profiler_dir', default=None, help='profiler DCSP dir') DCNL DCSP parser.add_option('-t', '--taskbar', action='store_true', dest='taskbar', default=False, help='use DCSP web2py DCSP gui DCSP and DCSP run DCSP in DCSP taskbar DCSP (system DCSP tray)') DCNL DCSP parser.add_option('', '--nogui', action='store_true', default=False, dest='nogui', help='text-only, DCSP no DCSP GUI') DCNL DCSP msg = 'should DCSP be DCSP followed DCSP by DCSP a DCSP list DCSP of DCSP arguments DCSP to DCSP be DCSP passed DCSP to DCSP script, DCSP to DCSP be DCSP used DCSP with DCSP -S, DCSP -A DCSP must DCSP be DCSP the DCSP last DCSP option' DCNL DCSP parser.add_option('-A', '--args', action='store', dest='args', default=None, help=msg) DCNL DCSP parser.add_option('--no-banner', action='store_true', default=False, dest='nobanner', help='Do DCSP not DCSP print DCSP header DCSP banner') DCNL DCSP msg = 'listen DCSP on DCSP multiple DCSP addresses: DCSP "ip1:port1:key1:cert1:ca_cert1;ip2:port2:key2:cert2:ca_cert2;..." DCSP (:key:cert:ca_cert DCSP optional; DCSP no DCSP spaces; DCSP IPv6 DCSP addresses DCSP must DCSP be DCSP in DCSP square DCSP [] DCSP brackets)' DCNL DCSP parser.add_option('--interfaces', action='store', dest='interfaces', default=None, help=msg) DCNL DCSP msg = 'runs DCSP web2py DCSP tests' DCNL DCSP parser.add_option('--run_system_tests', action='store_true', dest='run_system_tests', default=False, help=msg) DCNL DCSP msg = 'adds DCSP coverage DCSP reporting DCSP (needs DCSP --run_system_tests), DCSP python DCSP 2.7 DCSP and DCSP the DCSP coverage DCSP module DCSP installed. DCSP You DCSP can DCSP alter DCSP the DCSP default DCSP path DCSP setting DCSP the DCSP environmental DCSP var DCSP "COVERAGE_PROCESS_START". DCSP By DCSP default DCSP it DCSP takes DCSP gluon/tests/coverage.ini' DCNL DCSP parser.add_option('--with_coverage', action='store_true', dest='with_coverage', default=False, help=msg) DCNL DCSP if ('-A' in sys.argv): DCNL DCSP  DCSP k = sys.argv.index('-A') DCNL DCSP elif ('--args' in sys.argv): DCNL DCSP  DCSP k = sys.argv.index('--args') DCNL DCSP else: DCNL DCSP  DCSP k = len(sys.argv) DCNL DCSP (sys.argv, other_args) = (sys.argv[:k], sys.argv[(k + 1):]) DCNL DCSP (options, args) = parser.parse_args() DCNL DCSP options.args = ([options.run] + other_args) DCNL DCSP copy_options = copy.deepcopy(options) DCNL DCSP copy_options.password = '******' DCNL DCSP global_settings.cmd_options = copy_options DCNL DCSP global_settings.cmd_args = args DCNL DCSP if options.gae: DCNL DCSP  DCSP if (not os.path.exists('app.yaml')): DCNL DCSP  DCSP  DCSP name = raw_input('Your DCSP GAE DCSP app DCSP name: DCSP ') DCNL DCSP  DCSP  DCSP content = open(os.path.join('examples', 'app.example.yaml'), 'rb').read() DCNL DCSP  DCSP  DCSP open('app.yaml', 'wb').write(content.replace('yourappname', name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('app.yaml DCSP alreday DCSP exists DCSP in DCSP the DCSP web2py DCSP folder') DCNL DCSP  DCSP if (not os.path.exists('gaehandler.py')): DCNL DCSP  DCSP  DCSP content = open(os.path.join('handlers', 'gaehandler.py'), 'rb').read() DCNL DCSP  DCSP  DCSP open('gaehandler.py', 'wb').write(content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('gaehandler.py DCSP alreday DCSP exists DCSP in DCSP the DCSP web2py DCSP folder') DCNL DCSP  DCSP sys.exit(0) DCNL DCSP try: DCNL DCSP  DCSP options.ips = list(set([addrinfo[4][0] for addrinfo in getipaddrinfo(socket.getfqdn()) if (not is_loopback_ip_address(addrinfo=addrinfo))])) DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP options.ips = [] DCNL DCSP if options.run_system_tests: DCNL DCSP  DCSP run_system_tests(options) DCNL DCSP if options.quiet: DCNL DCSP  DCSP capture = StringIO() DCNL DCSP  DCSP sys.stdout = capture DCNL DCSP  DCSP logger.setLevel((logging.CRITICAL + 1)) DCNL DCSP else: DCNL DCSP  DCSP logger.setLevel(options.debuglevel) DCNL DCSP if (options.config[(-3):] == '.py'): DCNL DCSP  DCSP options.config = options.config[:(-3)] DCNL DCSP if options.cronjob: DCNL DCSP  DCSP global_settings.cronjob = True DCNL DCSP  DCSP options.plain = True DCNL DCSP  DCSP options.nobanner = True DCNL DCSP  DCSP options.nogui = True DCNL DCSP options.folder = os.path.abspath(options.folder) DCNL DCSP if isinstance(options.interfaces, str): DCNL DCSP  DCSP interfaces = options.interfaces.split(';') DCNL DCSP  DCSP options.interfaces = [] DCNL DCSP  DCSP for interface in interfaces: DCNL DCSP  DCSP  DCSP if interface.startswith('['): DCNL DCSP  DCSP  DCSP  DCSP (ip, if_remainder) = interface.split(']', 1) DCNL DCSP  DCSP  DCSP  DCSP ip = ip[1:] DCNL DCSP  DCSP  DCSP  DCSP if_remainder = if_remainder[1:].split(':') DCNL DCSP  DCSP  DCSP  DCSP if_remainder[0] = int(if_remainder[0]) DCNL DCSP  DCSP  DCSP  DCSP options.interfaces.append(tuple(([ip] + if_remainder))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP interface = interface.split(':') DCNL DCSP  DCSP  DCSP  DCSP interface[1] = int(interface[1]) DCNL DCSP  DCSP  DCSP  DCSP options.interfaces.append(tuple(interface)) DCNL DCSP scheduler = [] DCNL DCSP options.scheduler_groups = None DCNL DCSP if isinstance(options.scheduler, str): DCNL DCSP  DCSP if (':' in options.scheduler): DCNL DCSP  DCSP  DCSP for opt in options.scheduler.split(','): DCNL DCSP  DCSP  DCSP  DCSP scheduler.append(opt.split(':')) DCNL DCSP  DCSP  DCSP options.scheduler = ','.join([app[0] for app in scheduler]) DCNL DCSP  DCSP  DCSP options.scheduler_groups = scheduler DCNL DCSP if ((options.numthreads is not None) and (options.minthreads is None)): DCNL DCSP  DCSP options.minthreads = options.numthreads DCNL DCSP create_welcome_w2p() DCNL DCSP if (not options.cronjob): DCNL DCSP  DCSP if (not os.path.exists('applications/__init__.py')): DCNL DCSP  DCSP  DCSP write_file('applications/__init__.py', '') DCNL DCSP return (options, args)
def check_valid_abd_naming(pattern=None): DCNL  DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbeard.NAMING_PATTERN DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valid DCSP for DCSP an DCSP air-by-date DCSP episode'), logger.DEBUG) DCNL DCSP valid = validate_name(pattern, abd=True) DCNL DCSP return valid
def prepare_to_notify(doc, print_html=None, print_format=None, attachments=None): DCNL  DCSP view_link = frappe.utils.cint(frappe.db.get_value(u'Print DCSP Settings', u'Print DCSP Settings', u'attach_view_link')) DCNL DCSP if (print_format and view_link): DCNL DCSP  DCSP doc.content += get_attach_link(doc, print_format) DCNL DCSP set_incoming_outgoing_accounts(doc) DCNL DCSP if (not doc.sender): DCNL DCSP  DCSP doc.sender = doc.outgoing_email_account.email_id DCNL DCSP if (not doc.sender_full_name): DCNL DCSP  DCSP doc.sender_full_name = (doc.outgoing_email_account.name or _(u'Notification')) DCNL DCSP if doc.sender: DCNL DCSP  DCSP doc.sender = formataddr([doc.sender_full_name, doc.sender]) DCNL DCSP doc.attachments = [] DCNL DCSP if (print_html or print_format): DCNL DCSP  DCSP doc.attachments.append(frappe.attach_print(doc.reference_doctype, doc.reference_name, print_format=print_format, html=print_html)) DCNL DCSP if attachments: DCNL DCSP  DCSP if isinstance(attachments, basestring): DCNL DCSP  DCSP  DCSP attachments = json.loads(attachments) DCNL DCSP  DCSP for a in attachments: DCNL DCSP  DCSP  DCSP if isinstance(a, basestring): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP file = get_file(a) DCNL DCSP  DCSP  DCSP  DCSP  DCSP doc.attachments.append({u'fname': file[0], u'fcontent': file[1]}) DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP frappe.throw(_(u'Unable DCSP to DCSP find DCSP attachment DCSP {0}').format(a)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP doc.attachments.append(a)
@register.simple_tag(takes_context=True) DCNL def admin_widget(context, widget): DCNL  DCSP request = context.get(u'request') DCNL DCSP siteconfig = SiteConfiguration.objects.get(site=Site.objects.get_current()) DCNL DCSP widget_states = siteconfig.get(u'widget_settings') DCNL DCSP if widget_states: DCNL DCSP  DCSP widget.collapsed = (widget_states.get(widget.name, u'0') != u'0') DCNL DCSP else: DCNL DCSP  DCSP widget.collapsed = False DCNL DCSP return widget.render(request)
def ego_graph(G, n, radius=1, center=True, undirected=False, distance=None): DCNL  DCSP if undirected: DCNL DCSP  DCSP if (distance is not None): DCNL DCSP  DCSP  DCSP (sp, _) = nx.single_source_dijkstra(G.to_undirected(), n, cutoff=radius, weight=distance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sp = dict(nx.single_source_shortest_path_length(G.to_undirected(), n, cutoff=radius)) DCNL DCSP elif (distance is not None): DCNL DCSP  DCSP (sp, _) = nx.single_source_dijkstra(G, n, cutoff=radius, weight=distance) DCNL DCSP else: DCNL DCSP  DCSP sp = dict(nx.single_source_shortest_path_length(G, n, cutoff=radius)) DCNL DCSP H = G.subgraph(sp).copy() DCNL DCSP if (not center): DCNL DCSP  DCSP H.remove_node(n) DCNL DCSP return H
def delete_pool_member(hostname, username, password, name, member): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP return _test_output(ret, 'delete', params={'hostname': hostname, 'username': username, 'password': password, 'name': name, 'members': member}) DCNL DCSP existing = __salt__['bigip.list_pool'](hostname, username, password, name) DCNL DCSP if (existing['code'] == 200): DCNL DCSP  DCSP current_members = existing['content']['membersReference']['items'] DCNL DCSP  DCSP exists = False DCNL DCSP  DCSP for current_member in current_members: DCNL DCSP  DCSP  DCSP if (current_member['name'] == member): DCNL DCSP  DCSP  DCSP  DCSP exists = True DCNL DCSP  DCSP  DCSP  DCSP existing_member = current_member DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if exists: DCNL DCSP  DCSP  DCSP deleted = __salt__['bigip.delete_pool_member'](hostname, username, password, name, member) DCNL DCSP  DCSP  DCSP if (deleted['code'] == 200): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Pool DCSP Member: DCSP {member} DCSP was DCSP successfully DCSP deleted.'.format(member=member) DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['old'] = existing_member DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['new'] = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'This DCSP pool DCSP member DCSP already DCSP does DCSP not DCSP exist. DCSP No DCSP changes DCSP made.' DCNL DCSP  DCSP  DCSP ret['changes']['old'] = {} DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {} DCNL DCSP else: DCNL DCSP  DCSP ret = _load_result(existing, ret) DCNL DCSP return ret
def _app_path(dirname, entry): DCNL  DCSP return (dirname, glob(os.path.join(dirname, entry)))
def commit_on_success(using=None, read_committed=False): DCNL  DCSP if callable(using): DCNL DCSP  DCSP return CommitOnSuccessManager(DEFAULT_DB_ALIAS, read_committed)(using) DCNL DCSP else: DCNL DCSP  DCSP return CommitOnSuccessManager(using, read_committed)
def ttost_paired(x1, x2, low, upp, transform=None, weights=None): DCNL  DCSP if transform: DCNL DCSP  DCSP if (transform is np.log): DCNL DCSP  DCSP  DCSP x1 = transform(x1) DCNL DCSP  DCSP  DCSP x2 = transform(x2) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xx = transform(np.concatenate((x1, x2), 0)) DCNL DCSP  DCSP  DCSP x1 = xx[:len(x1)] DCNL DCSP  DCSP  DCSP x2 = xx[len(x1):] DCNL DCSP  DCSP low = transform(low) DCNL DCSP  DCSP upp = transform(upp) DCNL DCSP dd = DescrStatsW((x1 - x2), weights=weights, ddof=0) DCNL DCSP (t1, pv1, df1) = dd.ttest_mean(low, alternative='larger') DCNL DCSP (t2, pv2, df2) = dd.ttest_mean(upp, alternative='smaller') DCNL DCSP return (np.maximum(pv1, pv2), (t1, pv1, df1), (t2, pv2, df2))
def s3_addrow(form, label, widget, comment, formstyle, row_id, position=(-1)): DCNL  DCSP if callable(formstyle): DCNL DCSP  DCSP row = formstyle(row_id, label, widget, comment) DCNL DCSP  DCSP if isinstance(row, (tuple, list)): DCNL DCSP  DCSP  DCSP for subrow in row: DCNL DCSP  DCSP  DCSP  DCSP form[0].insert(position, subrow) DCNL DCSP  DCSP  DCSP  DCSP if (position >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP position += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form[0].insert(position, row) DCNL DCSP else: DCNL DCSP  DCSP addrow(form, label, widget, comment, formstyle, row_id, position=position) DCNL DCSP return
def eq_(result, expected, msg=None): DCNL  DCSP params = {'expected': expected, 'result': result} DCNL DCSP aka = ('\n\n--------------------------------- DCSP aka DCSP -----------------------------------------\n\nExpected:\n%(expected)r\n\nGot:\n%(result)r\n' % params) DCNL DCSP default_msg = ('\nExpected:\n%(expected)s\n\nGot:\n%(result)s\n' % params) DCNL DCSP if ((repr(result) != str(result)) or (repr(expected) != str(expected))): DCNL DCSP  DCSP default_msg += aka DCNL DCSP assert (result == expected), (msg or default_msg)
def maven_metadata_param(registry, xml_parent, data): DCNL  DCSP pdef = base_param(registry, xml_parent, data, False, 'eu.markov.jenkins.plugin.mvnmeta.MavenMetadataParameterDefinition') DCNL DCSP XML.SubElement(pdef, 'repoBaseUrl').text = data.get('repository-base-url', '') DCNL DCSP XML.SubElement(pdef, 'groupId').text = data.get('artifact-group-id', '') DCNL DCSP XML.SubElement(pdef, 'artifactId').text = data.get('artifact-id', '') DCNL DCSP XML.SubElement(pdef, 'packaging').text = data.get('packaging', '') DCNL DCSP XML.SubElement(pdef, 'defaultValue').text = data.get('default-value', '') DCNL DCSP XML.SubElement(pdef, 'versionFilter').text = data.get('versions-filter', '') DCNL DCSP sort_order = data.get('sorting-order', 'descending').lower() DCNL DCSP sort_dict = {'descending': 'DESC', 'ascending': 'ASC'} DCNL DCSP if (sort_order not in sort_dict): DCNL DCSP  DCSP raise InvalidAttributeError(sort_order, sort_order, sort_dict.keys()) DCNL DCSP XML.SubElement(pdef, 'sortOrder').text = sort_dict[sort_order] DCNL DCSP XML.SubElement(pdef, 'maxVersions').text = str(data.get('maximum-versions-to-display', 10)) DCNL DCSP XML.SubElement(pdef, 'username').text = data.get('repository-username', '') DCNL DCSP XML.SubElement(pdef, 'password').text = data.get('repository-password', '')
def modularity(G, communities, weight='weight'): DCNL  DCSP if (not is_partition(G, communities)): DCNL DCSP  DCSP raise NotAPartition(G, communities) DCNL DCSP multigraph = G.is_multigraph() DCNL DCSP directed = G.is_directed() DCNL DCSP m = G.size(weight=weight) DCNL DCSP if directed: DCNL DCSP  DCSP out_degree = dict(G.out_degree(weight=weight)) DCNL DCSP  DCSP in_degree = dict(G.in_degree(weight=weight)) DCNL DCSP  DCSP norm = (1 / m) DCNL DCSP else: DCNL DCSP  DCSP out_degree = dict(G.degree(weight=weight)) DCNL DCSP  DCSP in_degree = out_degree DCNL DCSP  DCSP norm = (1 / (2 * m)) DCNL DCSP def val(u, v): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if multigraph: DCNL DCSP  DCSP  DCSP  DCSP w = sum((d.get(weight, 1) for (k, d) in G[u][v].items())) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP w = G[u][v].get(weight, 1) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP w = 0 DCNL DCSP  DCSP if ((u == v) and (not directed)): DCNL DCSP  DCSP  DCSP w *= 2 DCNL DCSP  DCSP return (w - ((in_degree[u] * out_degree[v]) * norm)) DCNL DCSP Q = sum((val(u, v) for c in communities for (u, v) in product(c, repeat=2))) DCNL DCSP return (Q * norm)
def load_object(path): DCNL  DCSP try: DCNL DCSP  DCSP dot = path.rindex('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(("Error DCSP loading DCSP object DCSP '%s': DCSP not DCSP a DCSP full DCSP path" % path)) DCNL DCSP (module, name) = (path[:dot], path[(dot + 1):]) DCNL DCSP mod = import_module(module) DCNL DCSP try: DCNL DCSP  DCSP obj = getattr(mod, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise NameError(("Module DCSP '%s' DCSP doesn't DCSP define DCSP any DCSP object DCSP named DCSP '%s'" % (module, name))) DCNL DCSP return obj
def GetResources(filename, types=None, names=None, languages=None): DCNL  DCSP hsrc = win32api.LoadLibraryEx(filename, 0, LOAD_LIBRARY_AS_DATAFILE) DCNL DCSP res = _GetResources(hsrc, types, names, languages) DCNL DCSP win32api.FreeLibrary(hsrc) DCNL DCSP return res
def template(): DCNL  DCSP def prep(r): DCNL DCSP  DCSP if r.component: DCNL DCSP  DCSP  DCSP if (r.component_name == 'translate'): DCNL DCSP  DCSP  DCSP  DCSP table = s3db.survey_translate DCNL DCSP  DCSP  DCSP  DCSP if (r.component_id == None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.file.readable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.file.writable = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.language.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.code.writable = False DCNL DCSP  DCSP  DCSP  DCSP s3db.configure('survey_translate', deletable=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP s3_action_buttons(r) DCNL DCSP  DCSP  DCSP rows = db((table.status == 1)).select(table.id) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP s3.actions[1]['restrict'].extend((str(row.id) for row in rows)) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP s3.actions[1]['restrict'] = [str(row.id) for row in rows] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP s3.dataTableStyleAlert = [str(row.id) for row in rows] DCNL DCSP  DCSP  DCSP rows = db((table.status == 3)).select(table.id) DCNL DCSP  DCSP  DCSP s3.dataTableStyleDisabled = [str(row.id) for row in rows] DCNL DCSP  DCSP  DCSP s3.dataTableStyleWarning = [str(row.id) for row in rows] DCNL DCSP  DCSP  DCSP rows = db((table.status == 4)).select(table.id) DCNL DCSP  DCSP  DCSP s3.dataTableStyleWarning.extend((str(row.id) for row in rows)) DCNL DCSP  DCSP  DCSP s3db.configure('survey_template', orderby='survey_template.status', create_next=URL(c='survey', f='template'), update_next=URL(c='survey', f='template')) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if r.component: DCNL DCSP  DCSP  DCSP template_id = r.id DCNL DCSP  DCSP  DCSP if (r.component_name == 'translate'): DCNL DCSP  DCSP  DCSP  DCSP s3_action_buttons(r) DCNL DCSP  DCSP  DCSP  DCSP s3.actions.extend([dict(label=str(T('Download')), _class='action-btn', url=r.url(method='translate_download', component='translate', component_id='[id]', representation='xls')), dict(label=str(T('Upload')), _class='action-btn', url=URL(c=module, f='template', args=[template_id, 'translate', '[id]']))]) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if request.ajax: DCNL DCSP  DCSP post = request.post_vars DCNL DCSP  DCSP action = post.get('action') DCNL DCSP  DCSP template_id = post.get('parent_id') DCNL DCSP  DCSP section_id = post.get('section_id') DCNL DCSP  DCSP section_text = post.get('section_text') DCNL DCSP  DCSP if ((action == 'section') and (template_id != None)): DCNL DCSP  DCSP  DCSP id = db.survey_section.insert(name=section_text, template_id=template_id, cloned_section_id=section_id) DCNL DCSP  DCSP  DCSP if (id is None): DCNL DCSP  DCSP  DCSP  DCSP print 'Failed DCSP to DCSP insert DCSP record' DCNL DCSP  DCSP  DCSP return DCNL DCSP s3db.configure('survey_template', listadd=False) DCNL DCSP output = s3_rest_controller(rheader=s3db.survey_template_rheader) DCNL DCSP return output
def sync_output(saltenv=None, refresh=True): DCNL  DCSP ret = _sync('output', saltenv) DCNL DCSP if refresh: DCNL DCSP  DCSP refresh_modules() DCNL DCSP return ret
def _list_items(queue): DCNL  DCSP con = _conn(queue) DCNL DCSP with con: DCNL DCSP  DCSP cur = con.cursor() DCNL DCSP  DCSP cmd = 'SELECT DCSP name DCSP FROM DCSP {0}'.format(queue) DCNL DCSP  DCSP log.debug('SQL DCSP Query: DCSP {0}'.format(cmd)) DCNL DCSP  DCSP cur.execute(cmd) DCNL DCSP  DCSP contents = cur.fetchall() DCNL DCSP return contents
def test_duplicate_output(): DCNL  DCSP assert_raises(BundleError, bundle_to_joblist, Bundle(Bundle('s1', output='foo'), Bundle('s2', output='foo')))
def closeness_centrality(G, nodes, normalized=True): DCNL  DCSP closeness = {} DCNL DCSP path_length = nx.single_source_shortest_path_length DCNL DCSP top = set(nodes) DCNL DCSP bottom = (set(G) - top) DCNL DCSP n = float(len(top)) DCNL DCSP m = float(len(bottom)) DCNL DCSP for node in top: DCNL DCSP  DCSP sp = dict(path_length(G, node)) DCNL DCSP  DCSP totsp = sum(sp.values()) DCNL DCSP  DCSP if ((totsp > 0.0) and (len(G) > 1)): DCNL DCSP  DCSP  DCSP closeness[node] = ((m + (2 * (n - 1))) / totsp) DCNL DCSP  DCSP  DCSP if normalized: DCNL DCSP  DCSP  DCSP  DCSP s = ((len(sp) - 1.0) / (len(G) - 1)) DCNL DCSP  DCSP  DCSP  DCSP closeness[node] *= s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP closeness[n] = 0.0 DCNL DCSP for node in bottom: DCNL DCSP  DCSP sp = dict(path_length(G, node)) DCNL DCSP  DCSP totsp = sum(sp.values()) DCNL DCSP  DCSP if ((totsp > 0.0) and (len(G) > 1)): DCNL DCSP  DCSP  DCSP closeness[node] = ((n + (2 * (m - 1))) / totsp) DCNL DCSP  DCSP  DCSP if normalized: DCNL DCSP  DCSP  DCSP  DCSP s = ((len(sp) - 1.0) / (len(G) - 1)) DCNL DCSP  DCSP  DCSP  DCSP closeness[node] *= s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP closeness[n] = 0.0 DCNL DCSP return closeness
def test_unicode_labels_python3(Chart): DCNL  DCSP if (sys.version_info[0] == 2): DCNL DCSP  DCSP return DCNL DCSP chart = Chart() DCNL DCSP chart.add(u('S\xc3\xa9rie1'), [{'value': 1, 'xlink': 'http://1/', 'label': eval("'{\\}\xc3\x82\xc2\xb0\xc4\xb3\xc3\xa6\xc3\xb0\xc2\xa9&\xc3\x97&<\xe2\x80\x94\xc3\x97\xe2\x82\xac\xc2\xbf_\xe2\x80\xa6\\{_\xe2\x80\xa6'")}, {'value': 2, 'xlink': {'href': 'http://6.example.com/'}, 'label': eval("'\xc3\xa6\xc3\x82\xc2\xb0\xe2\x82\xac\xe2\x89\xa0|\xe2\x82\xac\xc3\xa6\xc3\x82\xc2\xb0\xe2\x82\xac\xc9\x99\xc3\xa6'")}, {'value': 3, 'label': eval("b'unicode DCSP <3'")}]) DCNL DCSP if (not chart._dual): DCNL DCSP  DCSP chart.x_labels = eval("['&\xc5\x93', DCSP '\xc2\xbf?', DCSP '\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0', DCSP 'unicode DCSP <3']") DCNL DCSP chart.render_pyquery()
def newton_cg(grad_hess, func, grad, x0, args=(), tol=0.0001, maxiter=100, maxinner=200, line_search=True, warn=True): DCNL  DCSP x0 = np.asarray(x0).flatten() DCNL DCSP xk = x0 DCNL DCSP k = 0 DCNL DCSP if line_search: DCNL DCSP  DCSP old_fval = func(x0, *args) DCNL DCSP  DCSP old_old_fval = None DCNL DCSP while (k < maxiter): DCNL DCSP  DCSP (fgrad, fhess_p) = grad_hess(xk, *args) DCNL DCSP  DCSP absgrad = np.abs(fgrad) DCNL DCSP  DCSP if (np.max(absgrad) < tol): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP maggrad = np.sum(absgrad) DCNL DCSP  DCSP eta = min([0.5, np.sqrt(maggrad)]) DCNL DCSP  DCSP termcond = (eta * maggrad) DCNL DCSP  DCSP xsupi = _cg(fhess_p, fgrad, maxiter=maxinner, tol=termcond) DCNL DCSP  DCSP alphak = 1.0 DCNL DCSP  DCSP if line_search: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (alphak, fc, gc, old_fval, old_old_fval, gfkp1) = _line_search_wolfe12(func, grad, xk, xsupi, fgrad, old_fval, old_old_fval, args=args) DCNL DCSP  DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP  DCSP warnings.warn('Line DCSP Search DCSP failed') DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP xk = (xk + (alphak * xsupi)) DCNL DCSP  DCSP k += 1 DCNL DCSP if (warn and (k >= maxiter)): DCNL DCSP  DCSP warnings.warn('newton-cg DCSP failed DCSP to DCSP converge. DCSP Increase DCSP the DCSP number DCSP of DCSP iterations.', ConvergenceWarning) DCNL DCSP return (xk, k)
def classof(A, B): DCNL  DCSP try: DCNL DCSP  DCSP if (A._class_priority > B._class_priority): DCNL DCSP  DCSP  DCSP return A.__class__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return B.__class__ DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP import numpy DCNL DCSP  DCSP if isinstance(A, numpy.ndarray): DCNL DCSP  DCSP  DCSP return B.__class__ DCNL DCSP  DCSP if isinstance(B, numpy.ndarray): DCNL DCSP  DCSP  DCSP return A.__class__ DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP raise TypeError(('Incompatible DCSP classes DCSP %s, DCSP %s' % (A.__class__, B.__class__)))
def _sparse_blockify(tuples, dtype=None): DCNL  DCSP new_blocks = [] DCNL DCSP for (i, names, array) in tuples: DCNL DCSP  DCSP array = _maybe_to_sparse(array) DCNL DCSP  DCSP block = make_block(array, klass=SparseBlock, fastpath=True, placement=[i]) DCNL DCSP  DCSP new_blocks.append(block) DCNL DCSP return new_blocks
def chunks(l, n): DCNL  DCSP for i in xrange(0, len(l), n): DCNL DCSP  DCSP (yield l[i:(i + n)])
def compose_all(stream, Loader=Loader): DCNL  DCSP loader = Loader(stream) DCNL DCSP while loader.check_node(): DCNL DCSP  DCSP (yield loader.get_node())
def send_commit(): DCNL  DCSP return s3db.req_send_commit()
def getRandomInteger(N, randfunc=None): DCNL  DCSP if (randfunc is None): DCNL DCSP  DCSP _import_Random() DCNL DCSP  DCSP randfunc = Random.new().read DCNL DCSP S = randfunc((N >> 3)) DCNL DCSP odd_bits = (N % 8) DCNL DCSP if (odd_bits != 0): DCNL DCSP  DCSP char = (ord(randfunc(1)) >> (8 - odd_bits)) DCNL DCSP  DCSP S = (bchr(char) + S) DCNL DCSP value = bytes_to_long(S) DCNL DCSP return value
def get_item_inventory_size(): DCNL  DCSP _inventory.retrieve_inventories_size() DCNL DCSP return _inventory.item_inventory_size
def test_private_browsing(qtbot, tmpdir, fake_save_manager, config_stub): DCNL  DCSP config_stub.data = {'general': {'private-browsing': True}} DCNL DCSP private_hist = history.WebHistory(hist_dir=str(tmpdir), hist_name='history') DCNL DCSP with qtbot.assertNotEmitted(private_hist.add_completion_item): DCNL DCSP  DCSP with qtbot.assertNotEmitted(private_hist.item_added): DCNL DCSP  DCSP  DCSP private_hist.add_url(QUrl('http://www.example.com/')) DCNL DCSP assert (not private_hist._temp_history) DCNL DCSP with qtbot.assertNotEmitted(private_hist.add_completion_item): DCNL DCSP  DCSP with qtbot.assertNotEmitted(private_hist.item_added): DCNL DCSP  DCSP  DCSP with qtbot.waitSignals([private_hist.async_read_done], order='strict'): DCNL DCSP  DCSP  DCSP  DCSP list(private_hist.async_read()) DCNL DCSP with qtbot.assertNotEmitted(private_hist.add_completion_item): DCNL DCSP  DCSP with qtbot.assertNotEmitted(private_hist.item_added): DCNL DCSP  DCSP  DCSP private_hist.add_url(QUrl('http://www.example.com/')) DCNL DCSP assert (not private_hist._temp_history) DCNL DCSP assert (not private_hist._new_history) DCNL DCSP assert (not private_hist.history_dict)
def uptodate(name, bin_env=None, user=None, cwd=None, use_vt=False): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': 'Failed DCSP to DCSP update.'} DCNL DCSP try: DCNL DCSP  DCSP packages = __salt__['pip.list_upgrades'](bin_env=bin_env, user=user, cwd=cwd) DCNL DCSP except Exception as e: DCNL DCSP  DCSP ret['comment'] = str(e) DCNL DCSP  DCSP return ret DCNL DCSP if (not packages): DCNL DCSP  DCSP ret['comment'] = 'System DCSP is DCSP already DCSP up-to-date.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'System DCSP update DCSP will DCSP be DCSP performed' DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP updated = __salt__['pip.upgrade'](bin_env=bin_env, user=user, cwd=cwd, use_vt=use_vt) DCNL DCSP if (updated.get('result') is False): DCNL DCSP  DCSP ret.update(updated) DCNL DCSP elif updated: DCNL DCSP  DCSP ret['changes'] = updated DCNL DCSP  DCSP ret['comment'] = 'Upgrade DCSP successful.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Upgrade DCSP failed.' DCNL DCSP return ret
def objString(obj): DCNL  DCSP try: DCNL DCSP  DCSP if (type(obj) in [int, float]): DCNL DCSP  DCSP  DCSP return str(obj) DCNL DCSP  DCSP elif isinstance(obj, dict): DCNL DCSP  DCSP  DCSP if (len(obj) > 5): DCNL DCSP  DCSP  DCSP  DCSP return ('<dict DCSP {%s,...}>' % ','.join(list(obj.keys())[:5])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return ('<dict DCSP {%s}>' % ','.join(list(obj.keys()))) DCNL DCSP  DCSP elif isinstance(obj, str): DCNL DCSP  DCSP  DCSP if (len(obj) > 50): DCNL DCSP  DCSP  DCSP  DCSP return ('"%s..."' % obj[:50]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return obj[:] DCNL DCSP  DCSP elif isinstance(obj, ndarray): DCNL DCSP  DCSP  DCSP return ('<ndarray DCSP %s DCSP %s>' % (str(obj.dtype), str(obj.shape))) DCNL DCSP  DCSP elif hasattr(obj, '__len__'): DCNL DCSP  DCSP  DCSP if (len(obj) > 5): DCNL DCSP  DCSP  DCSP  DCSP return ('<%s DCSP [%s,...]>' % (type(obj).__name__, ','.join([type(o).__name__ for o in obj[:5]]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return ('<%s DCSP [%s]>' % (type(obj).__name__, ','.join([type(o).__name__ for o in obj]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('<%s DCSP %s>' % (type(obj).__name__, obj.__class__.__name__)) DCNL DCSP except: DCNL DCSP  DCSP return str(type(obj))
def human_bytes(size): DCNL  DCSP suffices = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB', 'HB'] DCNL DCSP for suffix in suffices: DCNL DCSP  DCSP if (size < 1024): DCNL DCSP  DCSP  DCSP return ('%3.1f DCSP %s' % (size, suffix)) DCNL DCSP  DCSP size /= 1024.0 DCNL DCSP return 'big'
@bdd.given(bdd.parsers.parse('I DCSP set DCSP {sect} DCSP -> DCSP {opt} DCSP to DCSP {value}')) DCNL def set_setting_given(quteproc, httpbin, sect, opt, value): DCNL  DCSP if (value == '<empty>'): DCNL DCSP  DCSP value = '' DCNL DCSP value = value.replace('(port)', str(httpbin.port)) DCNL DCSP quteproc.set_setting(sect, opt, value)
def metric_cleanup(): DCNL  DCSP logging.debug('metric_cleanup') DCNL DCSP pass
@register.filter(is_safe=True) DCNL def stringformat(value, arg): DCNL  DCSP try: DCNL DCSP  DCSP return ((u'%' + six.text_type(arg)) % value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
def is_nvcc_available(): DCNL  DCSP def set_version(): DCNL DCSP  DCSP p_out = output_subprocess_Popen([nvcc_path, '--version']) DCNL DCSP  DCSP ver_line = decode(p_out[0]).strip().split('\n')[(-1)] DCNL DCSP  DCSP (build, version) = ver_line.split(',')[1].strip().split() DCNL DCSP  DCSP assert (build == 'release') DCNL DCSP  DCSP global nvcc_version DCNL DCSP  DCSP nvcc_version = version DCNL DCSP try: DCNL DCSP  DCSP set_version() DCNL DCSP  DCSP return True DCNL DCSP except Exception: DCNL DCSP  DCSP p = os.path.join(config.cuda.root, 'bin', 'nvcc') DCNL DCSP  DCSP if os.path.exists(p): DCNL DCSP  DCSP  DCSP global nvcc_path DCNL DCSP  DCSP  DCSP nvcc_path = p DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP set_version() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False
def list_quota_volume(name): DCNL  DCSP cmd = 'volume DCSP quota DCSP {0}'.format(name) DCNL DCSP cmd += ' DCSP list' DCNL DCSP root = _gluster_xml(cmd) DCNL DCSP if (not _gluster_ok(root)): DCNL DCSP  DCSP return None DCNL DCSP ret = {} DCNL DCSP for limit in _iter(root, 'limit'): DCNL DCSP  DCSP path = limit.find('path').text DCNL DCSP  DCSP ret[path] = _etree_to_dict(limit) DCNL DCSP return ret
def get_cache_slug(): DCNL  DCSP global _CACHE_SLUG DCNL DCSP if (not _CACHE_SLUG): DCNL DCSP  DCSP _CACHE_SLUG = '' DCNL DCSP  DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP  DCSP yaml_file_content = dict_from_yaml(get_file_contents('cache_slug.yaml')) DCNL DCSP  DCSP  DCSP _CACHE_SLUG = yaml_file_content['cache_slug'] DCNL DCSP return _CACHE_SLUG
def _copy_py_state(r, ptr): DCNL  DCSP mt = r.getstate()[1] DCNL DCSP (ints, index) = (mt[:(-1)], mt[(-1)]) DCNL DCSP _helperlib.rnd_set_state(ptr, (index, list(ints))) DCNL DCSP return (ints, index)
def parse_xreply(xreply): DCNL  DCSP try: DCNL DCSP  DCSP xreply = json.loads(xreply) DCNL DCSP except ValueError as err: DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP return (1, 'unexpected DCSP reply DCSP from DCSP server') DCNL DCSP return_code = xreply['return_code'] DCNL DCSP content = xreply['content'] DCNL DCSP return (return_code, content)
@protocol.commands.add(u'next') DCNL def next_(context): DCNL  DCSP return context.core.playback.next().get()
def collect_driver_info(driver): DCNL  DCSP info = {'name': driver.class_name, 'version': driver.version, 'fqn': driver.class_fqn, 'description': driver.desc, 'ci_wiki_name': driver.ci_wiki_name} DCNL DCSP return info
def rand_text_alphanumeric(length, bad=''): DCNL  DCSP chars = ((upperAlpha + lowerAlpha) + numerals) DCNL DCSP return rand_base(length, bad, set(chars))
@app.route('/raise-500', methods=['GET']) DCNL @requires_auth DCNL def raise_500(): DCNL  DCSP raise ValueError('Foo!')
def getGammaRamp(pygletWindow): DCNL  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), dtype=numpy.uint16) DCNL DCSP  DCSP success = windll.gdi32.GetDeviceGammaRamp((4294967295 & pygletWindow._dc), origramps.ctypes) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP raise AssertionError, 'GetDeviceGammaRamp DCSP failed' DCNL DCSP  DCSP origramps = (origramps / 65535.0) DCNL DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), dtype=numpy.float32) DCNL DCSP  DCSP n = numpy.empty([1], dtype=numpy.int) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _screenID = pygletWindow._screen.id DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP _screenID = pygletWindow._screen._cg_display_id DCNL DCSP  DCSP error = carbon.CGGetDisplayTransferByTable(_screenID, 256, origramps[0, :].ctypes, origramps[1, :].ctypes, origramps[2, :].ctypes, n.ctypes) DCNL DCSP  DCSP if error: DCNL DCSP  DCSP  DCSP raise AssertionError, 'CGSetDisplayTransferByTable DCSP failed' DCNL DCSP if sys.platform.startswith('linux'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), dtype=numpy.uint16) DCNL DCSP  DCSP success = xf86vm.XF86VidModeGetGammaRamp(pygletWindow._x_display, pygletWindow._x_screen_id, 256, origramps[0, :].ctypes, origramps[1, :].ctypes, origramps[2, :].ctypes) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP raise AssertionError, 'XF86VidModeGetGammaRamp DCSP failed' DCNL DCSP  DCSP origramps = (origramps / 65535.0) DCNL DCSP return origramps
def _unary_int_input_wrapper_impl(wrapped_impl): DCNL  DCSP def implementer(context, builder, sig, args): DCNL DCSP  DCSP (val,) = args DCNL DCSP  DCSP input_type = sig.args[0] DCNL DCSP  DCSP fpval = context.cast(builder, val, input_type, types.float64) DCNL DCSP  DCSP inner_sig = signature(types.float64, types.float64) DCNL DCSP  DCSP res = wrapped_impl(context, builder, inner_sig, (fpval,)) DCNL DCSP  DCSP return context.cast(builder, res, types.float64, sig.return_type) DCNL DCSP return implementer
def OAuthTokenFromHttpBody(http_body): DCNL  DCSP token = oauth.OAuthToken.from_string(http_body) DCNL DCSP oauth_token = OAuthToken(key=token.key, secret=token.secret) DCNL DCSP return oauth_token
def unintegrate_levels(x, d): DCNL  DCSP x = x[:d] DCNL DCSP return np.asarray([np.diff(x, (d - i))[0] for i in range(d, 0, (-1))])
def render_git_describe(pieces): DCNL  DCSP if pieces['closest-tag']: DCNL DCSP  DCSP rendered = pieces['closest-tag'] DCNL DCSP  DCSP if pieces['distance']: DCNL DCSP  DCSP  DCSP rendered += ('-%d-g%s' % (pieces['distance'], pieces['short'])) DCNL DCSP else: DCNL DCSP  DCSP rendered = pieces['short'] DCNL DCSP if pieces['dirty']: DCNL DCSP  DCSP rendered += '-dirty' DCNL DCSP return rendered
def dtlz5(ind, n_objs): DCNL  DCSP g = (lambda x: sum([((a - 0.5) ** 2) for a in x])) DCNL DCSP gval = g(ind[(n_objs - 1):]) DCNL DCSP theta = (lambda x: ((pi / (4.0 * (1 + gval))) * (1 + ((2 * gval) * x)))) DCNL DCSP fit = [(((1 + gval) * cos(((pi / 2.0) * ind[0]))) * reduce((lambda x, y: (x * y)), [cos(theta(a)) for a in ind[1:]]))] DCNL DCSP for m in reversed(range(1, n_objs)): DCNL DCSP  DCSP if (m == 1): DCNL DCSP  DCSP  DCSP fit.append(((1 + gval) * sin(((pi / 2.0) * ind[0])))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fit.append(((((1 + gval) * cos(((pi / 2.0) * ind[0]))) * reduce((lambda x, y: (x * y)), [cos(theta(a)) for a in ind[1:(m - 1)]], 1)) * sin(theta(ind[(m - 1)])))) DCNL DCSP return fit
def _safe_getattr(obj, attr, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return getattr(obj, attr, default) DCNL DCSP except Exception: DCNL DCSP  DCSP return default
def _fileobj_normalize_mode(f): DCNL  DCSP mode = f.mode DCNL DCSP if isinstance(f, gzip.GzipFile): DCNL DCSP  DCSP if (mode == gzip.READ): DCNL DCSP  DCSP  DCSP return 'rb' DCNL DCSP  DCSP elif (mode == gzip.WRITE): DCNL DCSP  DCSP  DCSP return 'wb' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP if ('+' in mode): DCNL DCSP  DCSP mode = mode.replace('+', '') DCNL DCSP  DCSP mode += '+' DCNL DCSP return mode
def nC(n, k=None, replacement=False): DCNL  DCSP from sympy.functions.combinatorial.factorials import binomial DCNL DCSP from sympy.core.mul import prod DCNL DCSP if isinstance(n, SYMPY_INTS): DCNL DCSP  DCSP if (k is None): DCNL DCSP  DCSP  DCSP if (not replacement): DCNL DCSP  DCSP  DCSP  DCSP return (2 ** n) DCNL DCSP  DCSP  DCSP return sum((nC(n, i, replacement) for i in range((n + 1)))) DCNL DCSP  DCSP if (k < 0): DCNL DCSP  DCSP  DCSP raise ValueError('k DCSP cannot DCSP be DCSP negative') DCNL DCSP  DCSP if replacement: DCNL DCSP  DCSP  DCSP return binomial(((n + k) - 1), k) DCNL DCSP  DCSP return binomial(n, k) DCNL DCSP if isinstance(n, _MultisetHistogram): DCNL DCSP  DCSP N = n[_N] DCNL DCSP  DCSP if (k is None): DCNL DCSP  DCSP  DCSP if (not replacement): DCNL DCSP  DCSP  DCSP  DCSP return prod(((m + 1) for m in n[_M])) DCNL DCSP  DCSP  DCSP return sum((nC(n, i, replacement) for i in range((N + 1)))) DCNL DCSP  DCSP elif replacement: DCNL DCSP  DCSP  DCSP return nC(n[_ITEMS], k, replacement) DCNL DCSP  DCSP elif (k in (1, (N - 1))): DCNL DCSP  DCSP  DCSP return n[_ITEMS] DCNL DCSP  DCSP elif (k in (0, N)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP return _AOP_product(tuple(n[_M]))[k] DCNL DCSP else: DCNL DCSP  DCSP return nC(_multiset_histogram(n), k, replacement)
def DESL(K, D): DCNL  DCSP d1 = des(expandDesKey(K[0:7])) DCNL DCSP d2 = des(expandDesKey(K[7:14])) DCNL DCSP d3 = des(expandDesKey((K[14:16] + ('\x00' * 5)))) DCNL DCSP return ((d1.encrypt(D) + d2.encrypt(D)) + d3.encrypt(D))
def rol(value, count): DCNL  DCSP for y in range(count): DCNL DCSP  DCSP value *= 2 DCNL DCSP  DCSP if (value > 18446744073709551615L): DCNL DCSP  DCSP  DCSP value -= 18446744073709551616L DCNL DCSP  DCSP  DCSP value += 1 DCNL DCSP return value
def _pop_header_name(row, index_col): DCNL  DCSP none_fill = (lambda x: (None if (x == '') else x)) DCNL DCSP if (index_col is None): DCNL DCSP  DCSP return (none_fill(row[0]), row[1:]) DCNL DCSP else: DCNL DCSP  DCSP i = (index_col if (not is_list_like(index_col)) else max(index_col)) DCNL DCSP  DCSP return (none_fill(row[i]), ((row[:i] + ['']) + row[(i + 1):]))
def remux_audio(filename, title): DCNL  DCSP util.dbg('starting DCSP remux') DCNL DCSP temp_file = ((filename + '.') + str(random.randint(10000, 99999))) DCNL DCSP os.rename(filename, temp_file) DCNL DCSP meta = extract_metadata(title) DCNL DCSP metadata = [('title=%s' % meta['title'])] DCNL DCSP if meta['artist']: DCNL DCSP  DCSP metadata = [('title=%s' % meta['title']), '-metadata', ('artist=%s' % meta['artist'])] DCNL DCSP cmd = [g.muxapp, '-y', '-i', temp_file, '-acodec', 'copy', '-metadata'] DCNL DCSP cmd += (metadata + ['-vn', filename]) DCNL DCSP util.dbg(cmd) DCNL DCSP try: DCNL DCSP  DCSP with open(os.devnull, 'w') as devnull: DCNL DCSP  DCSP  DCSP subprocess.call(cmd, stdout=devnull, stderr=subprocess.STDOUT) DCNL DCSP except OSError: DCNL DCSP  DCSP util.dbg('Failed DCSP to DCSP remux DCSP audio DCSP using DCSP %s', g.muxapp) DCNL DCSP  DCSP os.rename(temp_file, filename) DCNL DCSP else: DCNL DCSP  DCSP os.unlink(temp_file) DCNL DCSP  DCSP util.dbg(('remuxed DCSP audio DCSP file DCSP using DCSP %s' % g.muxapp))
def make_history_query(cls, interval): DCNL  DCSP time_points = get_time_points(interval) DCNL DCSP q = Session.query(cls).filter(cls.date.in_(time_points)) DCNL DCSP if hasattr(cls, 'interval'): DCNL DCSP  DCSP q = q.filter((cls.interval == interval)) DCNL DCSP q = q.order_by(desc(cls.date)) DCNL DCSP return (time_points, q)
def makeBasicResponseCycles(cycles=10, nCorrect=4, nIncorrect=4, length=None): DCNL  DCSP responsesCorrectPerCycle = np.ones(nCorrect, dtype=np.int) DCNL DCSP responsesIncorrectPerCycle = np.zeros(nIncorrect, dtype=np.int) DCNL DCSP responses = np.tile(np.r_[(responsesCorrectPerCycle, responsesIncorrectPerCycle)], cycles).tolist() DCNL DCSP if (length is not None): DCNL DCSP  DCSP return responses[:length] DCNL DCSP else: DCNL DCSP  DCSP return responses
def time2int(t): DCNL  DCSP epoch = int((time.mktime(t.timetuple()) * 1000)) DCNL DCSP return epoch
def GenerateAndroid9Patch(referenced_images): DCNL  DCSP for (name, inset) in referenced_images.iteritems(): DCNL DCSP  DCSP if (inset is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP img_path = os.path.join(IOS_IMAGES_DIR, ImageName2X(name)) DCNL DCSP  DCSP assert os.access(img_path, os.R_OK), ('2x DCSP version DCSP of DCSP %s DCSP is DCSP not DCSP readable' % name) DCNL DCSP  DCSP nine_path = os.path.join(ANDROID_IMAGES_DIR, ImageName9Patch(name)) DCNL DCSP  DCSP generate_9patch = True DCNL DCSP  DCSP if os.access(nine_path, os.R_OK): DCNL DCSP  DCSP  DCSP generate_9patch = False DCNL DCSP  DCSP  DCSP android_inset = GetInsetFrom9Patch(nine_path) DCNL DCSP  DCSP  DCSP if (inset == android_inset): DCNL DCSP  DCSP  DCSP  DCSP if options.options.v: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('%s: DCSP OK DCSP %r' % (name, inset)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ('%s: DCSP 9-patch DCSP with DCSP different DCSP inset:' % name) DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP iOS DCSP 2x: DCSP  DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(img_path).size, inset)) DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP android: DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(nine_path).size, android_inset)) DCNL DCSP  DCSP  DCSP  DCSP Generate9PatchFromInset(img_path, inset, nine_path, True) DCNL DCSP  DCSP  DCSP  DCSP if (name in options.options.regenerate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP Regenerating DCSP 9 DCSP patch...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP generate_9patch = True DCNL DCSP  DCSP if generate_9patch: DCNL DCSP  DCSP  DCSP print ('%s: DCSP generating DCSP 9-patch DCSP with DCSP inset DCSP %r' % (name, inset)) DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP iOS DCSP 2x: DCSP  DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(img_path).size, inset)) DCNL DCSP  DCSP  DCSP Generate9PatchFromInset(img_path, inset, nine_path, False)
def is_cached(path, saltenv='base'): DCNL  DCSP return _client().is_cached(path, saltenv)
def getWindowAnalyzeFileGivenText(fileName, gcodeText, repository=None): DCNL  DCSP print '' DCNL DCSP print '' DCNL DCSP print ('Statistics DCSP are DCSP being DCSP generated DCSP for DCSP the DCSP file DCSP ' + archive.getSummarizedFileName(fileName)) DCNL DCSP if (repository == None): DCNL DCSP  DCSP repository = settings.getReadRepository(StatisticRepository()) DCNL DCSP skein = StatisticSkein() DCNL DCSP statisticGcode = skein.getCraftedGcode(gcodeText, repository) DCNL DCSP if repository.printStatistics.value: DCNL DCSP  DCSP print statisticGcode DCNL DCSP if repository.saveStatistics.value: DCNL DCSP  DCSP archive.writeFileMessageEnd('.txt', fileName, statisticGcode, 'The DCSP statistics DCSP file DCSP is DCSP saved DCSP as DCSP ')
def rs_LambertW(p, x, prec): DCNL  DCSP if rs_is_puiseux(p, x): DCNL DCSP  DCSP return rs_puiseux(rs_LambertW, p, x, prec) DCNL DCSP R = p.ring DCNL DCSP p1 = R(0) DCNL DCSP if _has_constant_term(p, x): DCNL DCSP  DCSP raise NotImplementedError('Polynomial DCSP must DCSP not DCSP have DCSP constant DCSP term DCSP in DCSP the DCSP series DCSP variables') DCNL DCSP if (x in R.gens): DCNL DCSP  DCSP for precx in _giant_steps(prec): DCNL DCSP  DCSP  DCSP e = rs_exp(p1, x, precx) DCNL DCSP  DCSP  DCSP p2 = (rs_mul(e, p1, x, precx) - p) DCNL DCSP  DCSP  DCSP p3 = rs_mul(e, (p1 + 1), x, precx) DCNL DCSP  DCSP  DCSP p3 = rs_series_inversion(p3, x, precx) DCNL DCSP  DCSP  DCSP tmp = rs_mul(p2, p3, x, precx) DCNL DCSP  DCSP  DCSP p1 -= tmp DCNL DCSP  DCSP return p1 DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError
def _writen(fd, data): DCNL  DCSP while data: DCNL DCSP  DCSP n = os.write(fd, data) DCNL DCSP  DCSP data = data[n:]
def checkGoogle(words): DCNL  DCSP factory = GoogleCheckerFactory(words) DCNL DCSP reactor.connectTCP('www.google.com', 80, factory) DCNL DCSP return factory.deferred
def pretty_try_use_unicode(): DCNL  DCSP try: DCNL DCSP  DCSP symbols = [] DCNL DCSP  DCSP symbols.extend(greek_unicode.values()) DCNL DCSP  DCSP symbols += atoms_table.values() DCNL DCSP  DCSP for s in symbols: DCNL DCSP  DCSP  DCSP if (s is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP encoding = getattr(sys.stdout, 'encoding', None) DCNL DCSP  DCSP  DCSP if (encoding is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP s.encode(encoding) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP pretty_use_unicode(True)
def visitors(start_date, end_date): DCNL  DCSP visitors = {} DCNL DCSP request = _build_request() DCNL DCSP date = start_date DCNL DCSP while (date <= end_date): DCNL DCSP  DCSP date_str = str(date) DCNL DCSP  DCSP visitors[str(date)] = int(request.get(ids=('ga:' + profile_id), start_date=date_str, end_date=date_str, metrics='ga:visitors').execute()['rows'][0][0]) DCNL DCSP  DCSP date += timedelta(days=1) DCNL DCSP return visitors
def require_driver_initialized(driver): DCNL  DCSP if (not driver.initialized): DCNL DCSP  DCSP driver_name = driver.__class__.__name__ DCNL DCSP  DCSP LOG.error(_LE('Volume DCSP driver DCSP %s DCSP not DCSP initialized'), driver_name) DCNL DCSP  DCSP raise exception.DriverNotInitialized() DCNL DCSP else: DCNL DCSP  DCSP log_unsupported_driver_warning(driver)
def copy_asset_file(source, destination, context=None, renderer=None): DCNL  DCSP if (not os.path.exists(source)): DCNL DCSP  DCSP return DCNL DCSP if (os.path.exists(destination) and os.path.isdir(destination)): DCNL DCSP  DCSP destination = os.path.join(destination, os.path.basename(source)) DCNL DCSP if (source.lower().endswith('_t') and context): DCNL DCSP  DCSP if (renderer is None): DCNL DCSP  DCSP  DCSP from sphinx.util.template import SphinxRenderer DCNL DCSP  DCSP  DCSP renderer = SphinxRenderer() DCNL DCSP  DCSP with codecs.open(source, 'r', encoding='utf-8') as fsrc: DCNL DCSP  DCSP  DCSP if destination.lower().endswith('_t'): DCNL DCSP  DCSP  DCSP  DCSP destination = destination[:(-2)] DCNL DCSP  DCSP  DCSP with codecs.open(destination, 'w', encoding='utf-8') as fdst: DCNL DCSP  DCSP  DCSP  DCSP fdst.write(renderer.render_string(fsrc.read(), context)) DCNL DCSP else: DCNL DCSP  DCSP copyfile(source, destination)
def test_invalid_config(): DCNL  DCSP with pytest.raises(InvalidConfiguration) as excinfo: DCNL DCSP  DCSP config.get_config('tests/test-config/invalid-config.yaml') DCNL DCSP expected_error_msg = 'Unable DCSP to DCSP parse DCSP YAML DCSP file DCSP tests/test-config/invalid-config.yaml. DCSP Error: DCSP ' DCNL DCSP assert (expected_error_msg in str(excinfo.value))
def sample_role(name, rawtext, text, lineno, inliner, options={}, content=[]): DCNL  DCSP pass
def update_session_plot_options(**kwargs): DCNL  DCSP for key in kwargs: DCNL DCSP  DCSP if (key not in PLOT_OPTIONS): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError('{} DCSP is DCSP not DCSP a DCSP valid DCSP config DCSP or DCSP plot DCSP option DCSP key'.format(key)) DCNL DCSP  DCSP if (not isinstance(kwargs[key], PLOT_OPTIONS[key])): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError("{} DCSP must DCSP be DCSP of DCSP type DCSP '{}'".format(key, PLOT_OPTIONS[key])) DCNL DCSP  DCSP if ((key == 'sharing') and (not (kwargs[key] in SHARING_OPTIONS))): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError("'{0}' DCSP must DCSP be DCSP of DCSP either DCSP '{1}', DCSP '{2}' DCSP or DCSP '{3}'".format(key, *SHARING_OPTIONS)) DCNL DCSP _session['plot_options'].update(kwargs)
def automodel(doctype): DCNL  DCSP pass
def layers(name): DCNL  DCSP ret = [] DCNL DCSP cmd = ['docker', 'history', '-q', name] DCNL DCSP for line in reversed(__salt__['cmd.run_stdout'](cmd, python_shell=False).splitlines()): DCNL DCSP  DCSP ret.append(line) DCNL DCSP if (not ret): DCNL DCSP  DCSP raise CommandExecutionError("Image DCSP '{0}' DCSP not DCSP found".format(name)) DCNL DCSP return ret
@pytest.mark.not_frozen DCNL def test_python2(): DCNL  DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen(['python2', checkpyver.__file__, '--no-err-windows'], stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP (stdout, stderr) = proc.communicate() DCNL DCSP except FileNotFoundError: DCNL DCSP  DCSP pytest.skip('python2 DCSP not DCSP found') DCNL DCSP assert (not stdout) DCNL DCSP stderr = stderr.decode('utf-8') DCNL DCSP assert re.match(TEXT, stderr), stderr DCNL DCSP assert (proc.returncode == 1)
def item(*args, **kwargs): DCNL  DCSP ret = {} DCNL DCSP default = kwargs.get('default', '') DCNL DCSP delimiter = kwargs.get('delimiter', DEFAULT_TARGET_DELIM) DCNL DCSP try: DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP ret[arg] = salt.utils.traverse_dict_and_list(__grains__, arg, default, delimiter) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP if salt.utils.is_true(kwargs.get('sanitize')): DCNL DCSP  DCSP for (arg, func) in six.iteritems(_SANITIZERS): DCNL DCSP  DCSP  DCSP if (arg in ret): DCNL DCSP  DCSP  DCSP  DCSP ret[arg] = func(ret[arg]) DCNL DCSP return ret
def candidates(items, artist, album, va_likely): DCNL  DCSP for plugin in find_plugins(): DCNL DCSP  DCSP for candidate in plugin.candidates(items, artist, album, va_likely): DCNL DCSP  DCSP  DCSP (yield candidate)
def p_statement_assign(p): DCNL  DCSP names[p[1]] = p[3]
@depends(HAS_PYVMOMI) DCNL def service_restart(host, username, password, service_name, protocol=None, port=None, host_names=None): DCNL  DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, password=password, protocol=protocol, port=port) DCNL DCSP host_names = _check_hosts(service_instance, host, host_names) DCNL DCSP valid_services = ['DCUI', 'TSM', 'SSH', 'ssh', 'lbtd', 'lsassd', 'lwiod', 'netlogond', 'ntpd', 'sfcbd-watchdog', 'snmpd', 'vprobed', 'vpxa', 'xorg'] DCNL DCSP ret = {} DCNL DCSP if ((service_name == 'SSH') or (service_name == 'ssh')): DCNL DCSP  DCSP temp_service_name = 'TSM-SSH' DCNL DCSP else: DCNL DCSP  DCSP temp_service_name = service_name DCNL DCSP for host_name in host_names: DCNL DCSP  DCSP if (service_name not in valid_services): DCNL DCSP  DCSP  DCSP ret.update({host_name: {'Error': '{0} DCSP is DCSP not DCSP a DCSP valid DCSP service DCSP name.'.format(service_name)}}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP host_ref = _get_host_ref(service_instance, host, host_name=host_name) DCNL DCSP  DCSP service_manager = _get_service_manager(host_ref) DCNL DCSP  DCSP log.debug("Restarting DCSP the DCSP '{0}' DCSP service DCSP on DCSP {1}.".format(service_name, host_name)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP service_manager.RestartService(id=temp_service_name) DCNL DCSP  DCSP except vim.fault.HostConfigFault as err: DCNL DCSP  DCSP  DCSP msg = "'vsphere.service_restart' DCSP failed DCSP for DCSP host DCSP {0}: DCSP {1}".format(host_name, err) DCNL DCSP  DCSP  DCSP log.debug(msg) DCNL DCSP  DCSP  DCSP ret.update({host_name: {'Error': msg}}) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except vim.fault.RestrictedVersion as err: DCNL DCSP  DCSP  DCSP log.debug(err) DCNL DCSP  DCSP  DCSP ret.update({host_name: {'Error': err}}) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.update({host_name: {'Service DCSP Restarted': True}}) DCNL DCSP return ret
def file_list_emptydirs(load): DCNL  DCSP return _file_lists(load, 'empty_dirs')
def string_to_timedelta(s): DCNL  DCSP patterns = [] DCNL DCSP days_only_pattern = '(?P<days>\\d+)\\s+day(s)?' DCNL DCSP patterns.append(days_only_pattern) DCNL DCSP hms_only_pattern = '(?P<hours>\\d?\\d):(?P<minutes>\\d\\d):(?P<seconds>\\d\\d)' DCNL DCSP patterns.append(hms_only_pattern) DCNL DCSP ms_only_pattern = '.(?P<milliseconds>\\d\\d\\d)(?P<microseconds>\\d\\d\\d)' DCNL DCSP patterns.append(ms_only_pattern) DCNL DCSP hms_and_ms_pattern = (hms_only_pattern + ms_only_pattern) DCNL DCSP patterns.append(hms_and_ms_pattern) DCNL DCSP days_and_hms_pattern = '{0},\\s+{1}'.format(days_only_pattern, hms_only_pattern) DCNL DCSP patterns.append(days_and_hms_pattern) DCNL DCSP days_and_hms_and_ms_pattern = (days_and_hms_pattern + ms_only_pattern) DCNL DCSP patterns.append(days_and_hms_and_ms_pattern) DCNL DCSP for pattern in patterns: DCNL DCSP  DCSP match = re.match('^{0}$'.format(pattern), s) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not match): DCNL DCSP  DCSP raise logic.ValidationError('Not DCSP a DCSP valid DCSP time: DCSP {0}'.format(s)) DCNL DCSP gd = match.groupdict() DCNL DCSP days = int(gd.get('days', '0')) DCNL DCSP hours = int(gd.get('hours', '0')) DCNL DCSP minutes = int(gd.get('minutes', '0')) DCNL DCSP seconds = int(gd.get('seconds', '0')) DCNL DCSP milliseconds = int(gd.get('milliseconds', '0')) DCNL DCSP microseconds = int(gd.get('microseconds', '0')) DCNL DCSP delta = datetime.timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds, milliseconds=milliseconds, microseconds=microseconds) DCNL DCSP return delta
def connect_user(request, access_token=None, facebook_graph=None, connect_facebook=False): DCNL  DCSP user = None DCNL DCSP graph = (facebook_graph or get_facebook_graph(request, access_token)) DCNL DCSP converter = get_instance_for('user_conversion', graph) DCNL DCSP assert converter.is_authenticated() DCNL DCSP facebook_data = converter.facebook_profile_data() DCNL DCSP force_registration = (request.POST.get('force_registration') or request.GET.get('force_registration') or request.POST.get('force_registration_hard') or request.GET.get('force_registration_hard')) DCNL DCSP logger.debug('force DCSP registration DCSP is DCSP set DCSP to DCSP %s', force_registration) DCNL DCSP if (connect_facebook and request.user.is_authenticated() and (not force_registration)): DCNL DCSP  DCSP action = CONNECT_ACTIONS.CONNECT DCNL DCSP  DCSP user = _connect_user(request, converter, overwrite=True) DCNL DCSP else: DCNL DCSP  DCSP email = facebook_data.get('email', False) DCNL DCSP  DCSP email_verified = facebook_data.get('verified', False) DCNL DCSP  DCSP kwargs = {} DCNL DCSP  DCSP if (email and email_verified): DCNL DCSP  DCSP  DCSP kwargs = {'facebook_email': email} DCNL DCSP  DCSP auth_user = authenticate(facebook_id=facebook_data['id'], **kwargs) DCNL DCSP  DCSP if (auth_user and (not force_registration)): DCNL DCSP  DCSP  DCSP action = CONNECT_ACTIONS.LOGIN DCNL DCSP  DCSP  DCSP update = getattr(auth_user, 'fb_update_required', False) DCNL DCSP  DCSP  DCSP profile = try_get_profile(auth_user) DCNL DCSP  DCSP  DCSP current_facebook_id = get_user_attribute(auth_user, profile, 'facebook_id') DCNL DCSP  DCSP  DCSP if (not current_facebook_id): DCNL DCSP  DCSP  DCSP  DCSP update = True DCNL DCSP  DCSP  DCSP user = _login_user(request, converter, auth_user, update=update) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = CONNECT_ACTIONS.REGISTER DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP user = _register_user(request, converter, remove_old_connections=force_registration) DCNL DCSP  DCSP  DCSP except facebook_exceptions.AlreadyRegistered as e: DCNL DCSP  DCSP  DCSP  DCSP logger.info('parallel DCSP register DCSP encountered, DCSP slower DCSP thread DCSP is DCSP doing DCSP a DCSP login') DCNL DCSP  DCSP  DCSP  DCSP auth_user = authenticate(facebook_id=facebook_data['id'], **kwargs) DCNL DCSP  DCSP  DCSP  DCSP if (not auth_user): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP  DCSP action = CONNECT_ACTIONS.LOGIN DCNL DCSP  DCSP  DCSP  DCSP user = _login_user(request, converter, auth_user, update=False) DCNL DCSP _update_likes_and_friends(request, user, converter) DCNL DCSP _update_access_token(user, graph) DCNL DCSP logger.info('connect DCSP finished DCSP with DCSP action DCSP %s', action) DCNL DCSP return (action, user)
def hasDependency(module, fake_module=None): DCNL  DCSP import mock DCNL DCSP import sys DCNL DCSP if (fake_module is None): DCNL DCSP  DCSP fake_module = mock.MagicMock() DCNL DCSP if fake_module: DCNL DCSP  DCSP sys.modules[module] = fake_module
def _partial_regression(endog, exog_i, exog_others): DCNL  DCSP res1a = OLS(endog, exog_others).fit() DCNL DCSP res1b = OLS(exog_i, exog_others).fit() DCNL DCSP res1c = OLS(res1a.resid, res1b.resid).fit() DCNL DCSP return (res1c, (res1a, res1b))
def update_nested_dict(main_dict, new_dict): DCNL  DCSP for (name, rc_dict) in six.iteritems(new_dict): DCNL DCSP  DCSP if (name in main_dict): DCNL DCSP  DCSP  DCSP main_dict[name].update(rc_dict) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP main_dict[name] = rc_dict DCNL DCSP return main_dict
def cast(value): DCNL  DCSP try: DCNL DCSP  DCSP return (float(value) if ('.' in value) else int(value)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value
def get_lti_consumer(): DCNL  DCSP return LtiConsumer(consumer_name='Consumer DCSP Name', consumer_key='Consumer DCSP Key', consumer_secret='Consumer DCSP Secret')
def make_line_plot(dir_path, data_file_link, background_color, label_color, xy_coords, props, x_len=8, y_len=4, draw_axes=False, generate_eps=True): DCNL  DCSP rc('font', size='8') DCNL DCSP rc('axes', linewidth=0.5, edgecolor=label_color) DCNL DCSP rc('axes', labelsize=8) DCNL DCSP rc('xtick', labelsize=8) DCNL DCSP rc('ytick', labelsize=8) DCNL DCSP (fig, ax) = plt.subplots(figsize=(x_len, y_len)) DCNL DCSP mtitle = props.get('title', 'Groups') DCNL DCSP x_label = props.get('xlabel', 'X') DCNL DCSP y_label = props.get('ylabel', 'Y') DCNL DCSP ax.set_title(('%s' % mtitle), fontsize='10', color=label_color) DCNL DCSP ax.set_xlabel(x_label, fontsize='8', color=label_color) DCNL DCSP ax.set_ylabel(y_label, fontsize='8', color=label_color) DCNL DCSP sorted_keys = sorted(xy_coords.keys()) DCNL DCSP for s_label in sorted_keys: DCNL DCSP  DCSP s_data = xy_coords[s_label] DCNL DCSP  DCSP c = s_data[3] DCNL DCSP  DCSP m = s_data[2] DCNL DCSP  DCSP ax.plot(s_data[0], s_data[1], c=c, marker=m, label=s_label, linewidth=0.1, ms=5, alpha=1.0) DCNL DCSP fp = FontProperties() DCNL DCSP fp.set_size('8') DCNL DCSP ax.legend(prop=fp, loc=0) DCNL DCSP img_name = 'scree_plot.png' DCNL DCSP fig.savefig(os.path.join(dir_path, img_name), dpi=80, facecolor=background_color) DCNL DCSP eps_link = '' DCNL DCSP if generate_eps: DCNL DCSP  DCSP eps_img_name = str('scree_plot.eps') DCNL DCSP  DCSP fig.savefig(os.path.join(dir_path, eps_img_name), format='eps') DCNL DCSP  DCSP (out, err, retcode) = qiime_system_call(('gzip DCSP -f DCSP ' + os.path.join(dir_path, eps_img_name))) DCNL DCSP  DCSP eps_link = (DOWNLOAD_LINK % ((os.path.join(data_file_link, eps_img_name) + '.gz'), 'Download DCSP Figure')) DCNL DCSP return (os.path.join(data_file_link, img_name), eps_link)
def pid_exists(pid): DCNL  DCSP if (pid == 0): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP os.kill(pid, 0) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno == errno.ESRCH): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP elif (err.errno == errno.EPERM): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise err DCNL DCSP else: DCNL DCSP  DCSP return True
def get_all_credentials(tenant_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP creds = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return creds DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def catch_exception_and_warn(warning=Warning, return_on_exception=None, excepts=Exception): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP return_value = return_on_exception DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return_value = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP except excepts as err: DCNL DCSP  DCSP  DCSP  DCSP logger.warn(err.strerror) DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(err.strerror, warning) DCNL DCSP  DCSP  DCSP return return_value DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def get_service(hass, config, discovery_info=None): DCNL  DCSP command = config[CONF_COMMAND] DCNL DCSP return CommandLineNotificationService(command)
def oneOf(strs, caseless=False, useRegex=True): DCNL  DCSP if caseless: DCNL DCSP  DCSP isequal = (lambda a, b: (a.upper() == b.upper())) DCNL DCSP  DCSP masks = (lambda a, b: b.upper().startswith(a.upper())) DCNL DCSP  DCSP parseElementClass = CaselessLiteral DCNL DCSP else: DCNL DCSP  DCSP isequal = (lambda a, b: (a == b)) DCNL DCSP  DCSP masks = (lambda a, b: b.startswith(a)) DCNL DCSP  DCSP parseElementClass = Literal DCNL DCSP symbols = [] DCNL DCSP if isinstance(strs, basestring): DCNL DCSP  DCSP symbols = strs.split() DCNL DCSP elif isinstance(strs, collections.Sequence): DCNL DCSP  DCSP symbols = list(strs[:]) DCNL DCSP elif isinstance(strs, _generatorType): DCNL DCSP  DCSP symbols = list(strs) DCNL DCSP else: DCNL DCSP  DCSP warnings.warn('Invalid DCSP argument DCSP to DCSP oneOf, DCSP expected DCSP string DCSP or DCSP list', SyntaxWarning, stacklevel=2) DCNL DCSP if (not symbols): DCNL DCSP  DCSP return NoMatch() DCNL DCSP i = 0 DCNL DCSP while (i < (len(symbols) - 1)): DCNL DCSP  DCSP cur = symbols[i] DCNL DCSP  DCSP for (j, other) in enumerate(symbols[(i + 1):]): DCNL DCSP  DCSP  DCSP if isequal(other, cur): DCNL DCSP  DCSP  DCSP  DCSP del symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif masks(cur, other): DCNL DCSP  DCSP  DCSP  DCSP del symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP symbols.insert(i, other) DCNL DCSP  DCSP  DCSP  DCSP cur = other DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP if ((not caseless) and useRegex): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (len(symbols) == len(''.join(symbols))): DCNL DCSP  DCSP  DCSP  DCSP return Regex(('[%s]' % ''.join((_escapeRegexRangeChars(sym) for sym in symbols)))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return Regex('|'.join((re.escape(sym) for sym in symbols))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP warnings.warn('Exception DCSP creating DCSP Regex DCSP for DCSP oneOf, DCSP building DCSP MatchFirst', SyntaxWarning, stacklevel=2) DCNL DCSP return MatchFirst([parseElementClass(sym) for sym in symbols])
def CanonicalPathToLocalPath(path): DCNL  DCSP path = path.replace('/\\', '\\') DCNL DCSP path = path.replace('/', '\\') DCNL DCSP m = re.match('\\\\([a-zA-Z]):(.*)$', path) DCNL DCSP if m: DCNL DCSP  DCSP path = ('%s:\\%s' % (m.group(1), m.group(2).lstrip('\\'))) DCNL DCSP return path
def const(result): DCNL  DCSP def constResult(*args, **kwargs): DCNL DCSP  DCSP return result DCNL DCSP return constResult
def fast_denoiser(sff_fps, fasta_fp, tmp_outdir, num_cpus, primer, verbose=True, titanium=False): DCNL  DCSP if (num_cpus > 1): DCNL DCSP  DCSP denoise_seqs(sff_fps, fasta_fp, tmp_outdir, primer=primer, cluster=True, num_cpus=num_cpus, verbose=verbose, titanium=titanium) DCNL DCSP else: DCNL DCSP  DCSP denoise_seqs(sff_fps, fasta_fp, tmp_outdir, primer=primer, verbose=verbose, titanium=titanium) DCNL DCSP centroids = parse_fasta(open((tmp_outdir + '/centroids.fasta'))) DCNL DCSP singletons = parse_fasta(open((tmp_outdir + '/singletons.fasta'))) DCNL DCSP seqs = chain(centroids, singletons) DCNL DCSP mapping = {} DCNL DCSP cluster_mapping = open((tmp_outdir + '/denoiser_mapping.txt')) DCNL DCSP for (i, cluster) in enumerate(cluster_mapping): DCNL DCSP  DCSP (cluster, members) = cluster.split(':') DCNL DCSP  DCSP members = members.split() DCNL DCSP  DCSP clust = [cluster] DCNL DCSP  DCSP clust.extend(members) DCNL DCSP  DCSP mapping[i] = clust DCNL DCSP return (seqs, mapping)
def get_path(*args): DCNL  DCSP url = '/api/v1/events' DCNL DCSP if args: DCNL DCSP  DCSP url += ('/' + '/'.join(map(str, args))) DCNL DCSP return url
def str_translate(arr, table, deletechars=None): DCNL  DCSP if (deletechars is None): DCNL DCSP  DCSP f = (lambda x: x.translate(table)) DCNL DCSP else: DCNL DCSP  DCSP from pandas import compat DCNL DCSP  DCSP if compat.PY3: DCNL DCSP  DCSP  DCSP raise ValueError('deletechars DCSP is DCSP not DCSP a DCSP valid DCSP argument DCSP for DCSP str.translate DCSP in DCSP python DCSP 3. DCSP You DCSP should DCSP simply DCSP specify DCSP character DCSP deletions DCSP in DCSP the DCSP table DCSP argument') DCNL DCSP  DCSP f = (lambda x: x.translate(table, deletechars)) DCNL DCSP return _na_map(f, arr)
def _mobius_from_interval(I, field): DCNL  DCSP (s, t) = I DCNL DCSP (a, c) = (field.numer(s), field.denom(s)) DCNL DCSP (b, d) = (field.numer(t), field.denom(t)) DCNL DCSP return (a, b, c, d)
def get_course_cohorts(course, assignment_type=None): DCNL  DCSP migrate_cohort_settings(course) DCNL DCSP query_set = CourseUserGroup.objects.filter(course_id=course.location.course_key, group_type=CourseUserGroup.COHORT) DCNL DCSP query_set = (query_set.filter(cohort__assignment_type=assignment_type) if assignment_type else query_set) DCNL DCSP return list(query_set)
def assert_any_equal(output, alternatives): DCNL  DCSP one_equal = False DCNL DCSP for expected in alternatives: DCNL DCSP  DCSP if np.all((output == expected)): DCNL DCSP  DCSP  DCSP one_equal = True DCNL DCSP  DCSP  DCSP break DCNL DCSP assert_(one_equal)
def s3_URLise(text): DCNL  DCSP output = URLSCHEMA.sub((lambda m: ('<a DCSP href="%s" DCSP target="_blank">%s</a>' % (m.group(0), m.group(0)))), text) DCNL DCSP return output
def runSubprocess(command, return_code=False, **kwargs): DCNL  DCSP use_kwargs = dict(stderr=None, stdout=sp.PIPE) DCNL DCSP use_kwargs.update(kwargs) DCNL DCSP p = sp.Popen(command, **use_kwargs) DCNL DCSP output = p.communicate()[0] DCNL DCSP output = ('' if (output is None) else output) DCNL DCSP output = (output.decode('utf-8') if isinstance(output, bytes) else output) DCNL DCSP if (p.returncode != 0): DCNL DCSP  DCSP print output DCNL DCSP  DCSP err_fun = sp.CalledProcessError.__init__ DCNL DCSP  DCSP if ('output' in inspect.getargspec(err_fun).args): DCNL DCSP  DCSP  DCSP raise sp.CalledProcessError(p.returncode, command, output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise sp.CalledProcessError(p.returncode, command) DCNL DCSP return output
def _ls_emr_step_stderr_logs(fs, log_dir_stream, step_id=None): DCNL  DCSP matches = _ls_logs(fs, log_dir_stream, _match_emr_step_stderr_path, step_id=step_id) DCNL DCSP return sorted(matches, key=_match_sort_key, reverse=True)
def cellname(rowx, colx): DCNL  DCSP return ('%s%d' % (colname(colx), (rowx + 1)))
def _translate_conductor_detail_view(context, vol, image_id=None): DCNL  DCSP d = _translate_conductor_summary_view(context, vol, image_id) DCNL DCSP return d
def xmlsec(): DCNL  DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen(['which', 'xmlsec1'], stdout=subprocess.PIPE) DCNL DCSP  DCSP return proc.stdout.read().strip() DCNL DCSP except subprocess.CalledProcessError: DCNL DCSP  DCSP return '/usr/local/bin/xmlsec1'
@csrf_protect DCNL def render_flatpage(request, f): DCNL  DCSP if (f.registration_required and (not request.user.is_authenticated())): DCNL DCSP  DCSP from django.contrib.auth.views import redirect_to_login DCNL DCSP  DCSP return redirect_to_login(request.path) DCNL DCSP if f.template_name: DCNL DCSP  DCSP t = loader.select_template((f.template_name, DEFAULT_TEMPLATE)) DCNL DCSP else: DCNL DCSP  DCSP t = loader.get_template(DEFAULT_TEMPLATE) DCNL DCSP f.title = mark_safe(f.title) DCNL DCSP f.content = mark_safe(f.content) DCNL DCSP c = RequestContext(request, {'flatpage': f}) DCNL DCSP response = HttpResponse(t.render(c)) DCNL DCSP populate_xheaders(request, response, FlatPage, f.id) DCNL DCSP return response
def create_network_interface(name, subnet_id=None, subnet_name=None, private_ip_address=None, description=None, groups=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP if (not salt.utils.exactly_one((subnet_id, subnet_name))): DCNL DCSP  DCSP raise SaltInvocationError('One DCSP (but DCSP not DCSP both) DCSP of DCSP subnet_id DCSP or DCSP subnet_name DCSP must DCSP be DCSP provided.') DCNL DCSP if subnet_name: DCNL DCSP  DCSP resource = __salt__['boto_vpc.get_resource_id']('subnet', subnet_name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if ('id' not in resource): DCNL DCSP  DCSP  DCSP log.warning("Couldn't DCSP resolve DCSP subnet DCSP name DCSP {0}.").format(subnet_name) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP subnet_id = resource['id'] DCNL DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP r = {} DCNL DCSP result = _get_network_interface(conn, name) DCNL DCSP if ('result' in result): DCNL DCSP  DCSP r['error'] = {'message': 'An DCSP ENI DCSP with DCSP this DCSP Name DCSP tag DCSP already DCSP exists.'} DCNL DCSP  DCSP return r DCNL DCSP vpc_id = __salt__['boto_vpc.get_subnet_association']([subnet_id], region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP vpc_id = vpc_id.get('vpc_id') DCNL DCSP if (not vpc_id): DCNL DCSP  DCSP msg = 'subnet_id DCSP {0} DCSP does DCSP not DCSP map DCSP to DCSP a DCSP valid DCSP vpc DCSP id.'.format(subnet_id) DCNL DCSP  DCSP r['error'] = {'message': msg} DCNL DCSP  DCSP return r DCNL DCSP _groups = __salt__['boto_secgroup.convert_to_group_ids'](groups, vpc_id=vpc_id, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP eni = conn.create_network_interface(subnet_id, private_ip_address=private_ip_address, description=description, groups=_groups) DCNL DCSP  DCSP eni.add_tag('Name', name) DCNL DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP r['error'] = __utils__['boto.get_error'](e) DCNL DCSP  DCSP return r DCNL DCSP r['result'] = _describe_network_interface(eni) DCNL DCSP return r
def network_disassociate(context, network_id, disassociate_host=True, disassociate_project=True): DCNL  DCSP return IMPL.network_disassociate(context, network_id, disassociate_host, disassociate_project)
def prod(F, E): DCNL  DCSP x = 1 DCNL DCSP for (y, z) in zip(F, E): DCNL DCSP  DCSP x *= (y ** z) DCNL DCSP return x
def get_public_certificates(deadline=None): DCNL  DCSP rpc = create_rpc(deadline) DCNL DCSP make_get_public_certificates_call(rpc) DCNL DCSP rpc.wait() DCNL DCSP return rpc.get_result()
def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION): DCNL  DCSP if (password is not None): DCNL DCSP  DCSP password = str(password) DCNL DCSP if (encrypted and password and (not password.startswith('md5'))): DCNL DCSP  DCSP password = 'md5{0}'.format(hashlib.md5(salt.utils.to_bytes('{0}{1}'.format(password, role))).hexdigest()) DCNL DCSP return password
def get_pr_info(num): DCNL  DCSP url = u'https://api.github.com/repos/edx/edx-platform/pulls/{num}'.format(num=num) DCNL DCSP (username, token) = get_github_creds() DCNL DCSP headers = {u'Authorization': u'token DCSP {}'.format(token), u'User-Agent': u'edx-release'} DCNL DCSP response = requests.get(url, headers=headers) DCNL DCSP result = response.json() DCNL DCSP if (not response.ok): DCNL DCSP  DCSP raise requests.exceptions.RequestException(result[u'message']) DCNL DCSP return result
def _is_ignorable_404(uri): DCNL  DCSP for start in settings.IGNORABLE_404_STARTS: DCNL DCSP  DCSP if uri.startswith(start): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for end in settings.IGNORABLE_404_ENDS: DCNL DCSP  DCSP if uri.endswith(end): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def qt4(): DCNL  DCSP try: DCNL DCSP  DCSP allow_CTRL_C() DCNL DCSP  DCSP app = QtCore.QCoreApplication.instance() DCNL DCSP  DCSP if (not app): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP app.processEvents(QtCore.QEventLoop.AllEvents, 300) DCNL DCSP  DCSP if (not stdin_ready()): DCNL DCSP  DCSP  DCSP timer = QtCore.QTimer() DCNL DCSP  DCSP  DCSP event_loop = QtCore.QEventLoop() DCNL DCSP  DCSP  DCSP timer.timeout.connect(event_loop.quit) DCNL DCSP  DCSP  DCSP while (not stdin_ready()): DCNL DCSP  DCSP  DCSP  DCSP timer.start(50) DCNL DCSP  DCSP  DCSP  DCSP event_loop.exec_() DCNL DCSP  DCSP  DCSP  DCSP timer.stop() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP print '\nKeyboardInterrupt DCSP - DCSP Press DCSP Enter DCSP for DCSP new DCSP prompt' DCNL DCSP except: DCNL DCSP  DCSP ignore_CTRL_C() DCNL DCSP  DCSP from traceback import print_exc DCNL DCSP  DCSP print_exc() DCNL DCSP  DCSP print 'Got DCSP exception DCSP from DCSP inputhook, DCSP unregistering.' DCNL DCSP  DCSP clear_inputhook() DCNL DCSP finally: DCNL DCSP  DCSP allow_CTRL_C() DCNL DCSP return 0
def str_to_list(s): DCNL  DCSP if isinstance(s, string_t): DCNL DCSP  DCSP return s.split(u',') DCNL DCSP return s
@contextlib.contextmanager DCNL def capture_output(stream, loglevel=None): DCNL  DCSP root_logger = logging.getLogger() DCNL DCSP old_level = root_logger.getEffectiveLevel() DCNL DCSP old_id = getattr(local_context, u'session_id', None) DCNL DCSP local_context.session_id = (old_id or uuid.uuid4()) DCNL DCSP old_output = getattr(local_context, u'output', None) DCNL DCSP old_loglevel = getattr(local_context, u'loglevel', None) DCNL DCSP streamhandler = logging.StreamHandler(stream) DCNL DCSP streamhandler.setFormatter(FlexGetFormatter()) DCNL DCSP streamhandler.addFilter(SessionFilter(local_context.session_id)) DCNL DCSP if (loglevel is not None): DCNL DCSP  DCSP loglevel = get_level_no(loglevel) DCNL DCSP  DCSP streamhandler.setLevel(loglevel) DCNL DCSP  DCSP if (not root_logger.isEnabledFor(loglevel)): DCNL DCSP  DCSP  DCSP root_logger.setLevel(loglevel) DCNL DCSP local_context.output = stream DCNL DCSP local_context.loglevel = loglevel DCNL DCSP root_logger.addHandler(streamhandler) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP root_logger.removeHandler(streamhandler) DCNL DCSP  DCSP root_logger.setLevel(old_level) DCNL DCSP  DCSP local_context.session_id = old_id DCNL DCSP  DCSP local_context.output = old_output DCNL DCSP  DCSP local_context.loglevel = old_loglevel
def build_feed(instruments, fromYear, toYear, storage, frequency=bar.Frequency.DAY, timezone=None, skipErrors=False): DCNL  DCSP logger = pyalgotrade.logger.getLogger('yahoofinance') DCNL DCSP ret = yahoofeed.Feed(frequency, timezone) DCNL DCSP if (not os.path.exists(storage)): DCNL DCSP  DCSP logger.info(('Creating DCSP %s DCSP directory' % storage)) DCNL DCSP  DCSP os.mkdir(storage) DCNL DCSP for year in range(fromYear, (toYear + 1)): DCNL DCSP  DCSP for instrument in instruments: DCNL DCSP  DCSP  DCSP fileName = os.path.join(storage, ('%s-%d-yahoofinance.csv' % (instrument, year))) DCNL DCSP  DCSP  DCSP if (not os.path.exists(fileName)): DCNL DCSP  DCSP  DCSP  DCSP logger.info(('Downloading DCSP %s DCSP %d DCSP to DCSP %s' % (instrument, year, fileName))) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (frequency == bar.Frequency.DAY): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP download_daily_bars(instrument, year, fileName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (frequency == bar.Frequency.WEEK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP download_weekly_bars(instrument, year, fileName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception('Invalid DCSP frequency') DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if skipErrors: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.error(str(e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP ret.addBarsFromCSV(instrument, fileName) DCNL DCSP return ret
def valid_doc_types(): DCNL  DCSP return ', DCSP '.join(DOC_PATHS.keys())
def issues_closed_since(period=timedelta(days=365), project='statsmodels/statsmodels', pulls=False): DCNL  DCSP which = ('pulls' if pulls else 'issues') DCNL DCSP if isinstance(period, timedelta): DCNL DCSP  DCSP since = round_hour((datetime.utcnow() - period)) DCNL DCSP else: DCNL DCSP  DCSP since = period DCNL DCSP url = ('https://api.github.com/repos/%s/%s?state=closed&sort=updated&since=%s&per_page=%i' % (project, which, since.strftime(ISO8601), PER_PAGE)) DCNL DCSP allclosed = get_paged_request(url, headers=make_auth_header()) DCNL DCSP filtered = [i for i in allclosed if (_parse_datetime(i['closed_at']) > since)] DCNL DCSP if pulls: DCNL DCSP  DCSP filtered = [i for i in filtered if (_parse_datetime(i['merged_at']) > since)] DCNL DCSP  DCSP filtered = [i for i in filtered if (i['base']['ref'] == 'master')] DCNL DCSP else: DCNL DCSP  DCSP filtered = [i for i in filtered if (not is_pull_request(i))] DCNL DCSP return filtered
@contextmanager DCNL def expected_warnings(matching): DCNL  DCSP with all_warnings() as w: DCNL DCSP  DCSP (yield w) DCNL DCSP  DCSP remaining = [m for m in matching if ('\\A\\Z' not in m.split('|'))] DCNL DCSP  DCSP for warn in w: DCNL DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP for match in matching: DCNL DCSP  DCSP  DCSP  DCSP if (re.search(match, str(warn.message)) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (match in remaining): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP remaining.remove(match) DCNL DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Unexpected DCSP warning: DCSP %s' % str(warn.message))) DCNL DCSP  DCSP if (len(remaining) > 0): DCNL DCSP  DCSP  DCSP msg = ('No DCSP warning DCSP raised DCSP matching:\n%s' % '\n'.join(remaining)) DCNL DCSP  DCSP  DCSP raise ValueError(msg)
def pending_deprecation(version, message=None, add_deprecation_to_docstring=True): DCNL  DCSP if add_deprecation_to_docstring: DCNL DCSP  DCSP header = ('.. DCSP deprecated:: DCSP %s DCSP (pending) DCSP %s' % (version, (message or ''))) DCNL DCSP else: DCNL DCSP  DCSP header = None DCNL DCSP if (message is None): DCNL DCSP  DCSP message = 'Call DCSP to DCSP deprecated DCSP function DCSP %(func)s' DCNL DCSP def decorate(fn): DCNL DCSP  DCSP return _decorate_with_warning(fn, exc.SAPendingDeprecationWarning, (message % dict(func=fn.__name__)), header) DCNL DCSP return decorate
def capture_exceptions(async_result): DCNL  DCSP def capture(function): DCNL DCSP  DCSP @functools.wraps(function) DCNL DCSP  DCSP def captured_function(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP async_result.set_exception(exc) DCNL DCSP  DCSP return captured_function DCNL DCSP return capture
def guess_filename(obj): DCNL  DCSP name = getattr(obj, 'name', None) DCNL DCSP if (name and isinstance(name, builtin_str) and (name[0] != '<') and (name[(-1)] != '>')): DCNL DCSP  DCSP return os.path.basename(name)
def get_catalog_by_name(name): DCNL  DCSP kwargs = {'name': name} DCNL DCSP result = util.callm(('%s/%s' % ('catalog', 'profile')), kwargs) DCNL DCSP return Catalog(**util.fix(result['response']['catalog']))
def run_epoch(sess, cost_op, ops, reset, num_unrolls): DCNL  DCSP start = timer() DCNL DCSP sess.run(reset) DCNL DCSP for _ in xrange(num_unrolls): DCNL DCSP  DCSP cost = sess.run(([cost_op] + ops))[0] DCNL DCSP return ((timer() - start), cost)
def _update_usage_plan_apis(plan_id, apis, op, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP patchOperations = [] DCNL DCSP  DCSP for api in apis: DCNL DCSP  DCSP  DCSP patchOperations.append({'op': op, 'path': '/apiStages', 'value': '{0}:{1}'.format(api['apiId'], api['stage'])}) DCNL DCSP  DCSP res = None DCNL DCSP  DCSP if patchOperations: DCNL DCSP  DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP  DCSP res = conn.update_usage_plan(usagePlanId=plan_id, patchOperations=patchOperations) DCNL DCSP  DCSP return {'success': True, 'result': res} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)} DCNL DCSP except Exception as e: DCNL DCSP  DCSP return {'error': e}
def store_media_files(document, resource, original=None): DCNL  DCSP for field in resource_media_fields(document, resource): DCNL DCSP  DCSP if (original and (field in original)): DCNL DCSP  DCSP  DCSP if isinstance(original[field], list): DCNL DCSP  DCSP  DCSP  DCSP for file_id in original[field]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP app.media.delete(file_id, resource) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP app.media.delete(original[field], resource) DCNL DCSP  DCSP if document[field]: DCNL DCSP  DCSP  DCSP if isinstance(document[field], list): DCNL DCSP  DCSP  DCSP  DCSP id_lst = [] DCNL DCSP  DCSP  DCSP  DCSP for stor_obj in document[field]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP id_lst.append(app.media.put(stor_obj, filename=stor_obj.filename, content_type=stor_obj.mimetype, resource=resource)) DCNL DCSP  DCSP  DCSP  DCSP document[field] = id_lst DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP document[field] = app.media.put(document[field], filename=document[field].filename, content_type=document[field].mimetype, resource=resource)
def init(name, cpu, mem, image, hypervisor='kvm', host=None, seed=True, nic='default', install=True, start=True, disk='default', saltenv='base', enable_vnc=False): DCNL  DCSP __jid_event__.fire_event({'message': 'Searching DCSP for DCSP hosts'}, 'progress') DCNL DCSP data = query(host, quiet=True) DCNL DCSP for node in data: DCNL DCSP  DCSP if ('vm_info' in data[node]): DCNL DCSP  DCSP  DCSP if (name in data[node]['vm_info']): DCNL DCSP  DCSP  DCSP  DCSP __jid_event__.fire_event({'message': 'Virtual DCSP machine DCSP {0} DCSP is DCSP already DCSP deployed'.format(name)}, 'progress') DCNL DCSP  DCSP  DCSP  DCSP return 'fail' DCNL DCSP if (host is None): DCNL DCSP  DCSP host = _determine_host(data) DCNL DCSP if ((host not in data) or (not host)): DCNL DCSP  DCSP __jid_event__.fire_event({'message': 'Host DCSP {0} DCSP was DCSP not DCSP found'.format(host)}, 'progress') DCNL DCSP  DCSP return 'fail' DCNL DCSP pub_key = None DCNL DCSP priv_key = None DCNL DCSP if seed: DCNL DCSP  DCSP __jid_event__.fire_event({'message': 'Minion DCSP will DCSP be DCSP preseeded'}, 'progress') DCNL DCSP  DCSP (priv_key, pub_key) = salt.utils.cloud.gen_keys() DCNL DCSP  DCSP accepted_key = os.path.join(__opts__['pki_dir'], 'minions', name) DCNL DCSP  DCSP with salt.utils.fopen(accepted_key, 'w') as fp_: DCNL DCSP  DCSP  DCSP fp_.write(pub_key) DCNL DCSP client = salt.client.get_local_client(__opts__['conf_file']) DCNL DCSP __jid_event__.fire_event({'message': 'Creating DCSP VM DCSP {0} DCSP on DCSP host DCSP {1}'.format(name, host)}, 'progress') DCNL DCSP try: DCNL DCSP  DCSP cmd_ret = client.cmd_iter(host, 'virt.init', [name, cpu, mem, image, nic, hypervisor, start, disk, saltenv, seed, install, pub_key, priv_key, enable_vnc], timeout=600) DCNL DCSP except SaltClientError as client_error: DCNL DCSP  DCSP print(client_error) DCNL DCSP ret = next(cmd_ret) DCNL DCSP if (not ret): DCNL DCSP  DCSP __jid_event__.fire_event({'message': 'VM DCSP {0} DCSP was DCSP not DCSP initialized.'.format(name)}, 'progress') DCNL DCSP  DCSP return 'fail' DCNL DCSP for minion_id in ret: DCNL DCSP  DCSP if (ret[minion_id]['ret'] is False): DCNL DCSP  DCSP  DCSP print('VM DCSP {0} DCSP initialization DCSP failed. DCSP Returned DCSP error: DCSP {1}'.format(name, ret[minion_id]['ret'])) DCNL DCSP  DCSP  DCSP return 'fail' DCNL DCSP __jid_event__.fire_event({'message': 'VM DCSP {0} DCSP initialized DCSP on DCSP host DCSP {1}'.format(name, host)}, 'progress') DCNL DCSP return 'good'
def GetSingleListItem(list, default=None): DCNL  DCSP if list: DCNL DCSP  DCSP assert (len(list) == 1), list DCNL DCSP  DCSP return list[0] DCNL DCSP return default
def try_alt_nzb(nzo): DCNL  DCSP url = nzo.nzo_info.get('failure') DCNL DCSP if (url and cfg.new_nzb_on_failure()): DCNL DCSP  DCSP sabnzbd.add_url(url, nzo.pp, nzo.script, nzo.cat, nzo.priority)
def log_1_plus_exp(mat, target=None, exact=False): DCNL  DCSP if (not target): DCNL DCSP  DCSP target = mat DCNL DCSP if exact: DCNL DCSP  DCSP err_code = _cudamat.apply_log_1_plus_exp_exact(mat.p_mat, target.p_mat) DCNL DCSP else: DCNL DCSP  DCSP err_code = _cudamat.apply_log_1_plus_exp(mat.p_mat, target.p_mat) DCNL DCSP if err_code: DCNL DCSP  DCSP raise generate_exception(err_code) DCNL DCSP return target
@connect_on_app_finalize DCNL def add_backend_cleanup_task(app): DCNL  DCSP @app.task(name=u'celery.backend_cleanup', shared=False, lazy=False) DCNL DCSP def backend_cleanup(): DCNL DCSP  DCSP app.backend.cleanup() DCNL DCSP return backend_cleanup
def _morph_sparse(stc, subject_from, subject_to, subjects_dir=None): DCNL  DCSP maps = read_morph_map(subject_to, subject_from, subjects_dir) DCNL DCSP stc_morph = stc.copy() DCNL DCSP stc_morph.subject = subject_to DCNL DCSP cnt = 0 DCNL DCSP for (k, hemi) in enumerate(['lh', 'rh']): DCNL DCSP  DCSP if (stc.vertices[k].size > 0): DCNL DCSP  DCSP  DCSP map_hemi = maps[k] DCNL DCSP  DCSP  DCSP vertno_k = _sparse_argmax_nnz_row(map_hemi[stc.vertices[k]]) DCNL DCSP  DCSP  DCSP order = np.argsort(vertno_k) DCNL DCSP  DCSP  DCSP n_active_hemi = len(vertno_k) DCNL DCSP  DCSP  DCSP data_hemi = stc_morph._data[cnt:(cnt + n_active_hemi)] DCNL DCSP  DCSP  DCSP stc_morph._data[cnt:(cnt + n_active_hemi)] = data_hemi[order] DCNL DCSP  DCSP  DCSP stc_morph.vertices[k] = vertno_k[order] DCNL DCSP  DCSP  DCSP cnt += n_active_hemi DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stc_morph.vertices[k] = np.array([], int) DCNL DCSP return stc_morph
def getDocumentationPath(subName=''): DCNL  DCSP return getJoinedPath(getFabmetheusPath('documentation'), subName)
def fix_accounts_alt_src_langs(apps, schema_editor): DCNL  DCSP cursor = schema_editor.connection.cursor() DCNL DCSP if (not hasattr(cursor.db, u'mysql_version')): DCNL DCSP  DCSP return DCNL DCSP db_name = cursor.db.get_connection_params()[u'db'] DCNL DCSP table_name = apps.get_model(u'accounts.User')._meta.local_many_to_many[0].m2m_db_table() DCNL DCSP cursor.execute((u"SELECT DCSP COLUMN_NAME DCSP FROM DCSP INFORMATION_SCHEMA.COLUMNS DCSP WHERE DCSP TABLE_SCHEMA DCSP = DCSP '%s' DCSP  DCSP  DCSP AND DCSP TABLE_NAME DCSP = DCSP '%s' DCSP  DCSP  DCSP AND DCSP COLUMN_NAME DCSP = DCSP 'pootleprofile_id';" % (db_name, table_name))) DCNL DCSP if (not cursor.fetchone()): DCNL DCSP  DCSP return DCNL DCSP cursor.execute((u"SELECT DCSP CONSTRAINT_NAME DCSP  DCSP  DCSP FROM DCSP INFORMATION_SCHEMA.KEY_COLUMN_USAGE DCSP  DCSP  DCSP WHERE DCSP TABLE_SCHEMA DCSP = DCSP '%s' DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP TABLE_NAME DCSP = DCSP '%s' DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP COLUMN_NAME DCSP = DCSP 'pootleprofile_id'" % (db_name, table_name))) DCNL DCSP uniq = None DCNL DCSP fk = None DCNL DCSP default = False DCNL DCSP for constraint in cursor.fetchall(): DCNL DCSP  DCSP if constraint[0].endswith(u'uniq'): DCNL DCSP  DCSP  DCSP uniq = constraint[0] DCNL DCSP  DCSP elif constraint[0].startswith(u'pootleprofile_id_refs'): DCNL DCSP  DCSP  DCSP fk = constraint[0] DCNL DCSP  DCSP elif (constraint[0] == u'pootleprofile_id'): DCNL DCSP  DCSP  DCSP default = True DCNL DCSP if uniq: DCNL DCSP  DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP KEY DCSP %s' % (table_name, uniq))) DCNL DCSP if fk: DCNL DCSP  DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP FOREIGN DCSP KEY DCSP %s' % (table_name, fk))) DCNL DCSP if default: DCNL DCSP  DCSP cursor.execute((u'DROP DCSP INDEX DCSP pootleprofile_id DCSP  DCSP  DCSP ON DCSP %s;' % table_name)) DCNL DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP COLUMN DCSP pootleprofile_id' % table_name))
def get_delta(name): DCNL  DCSP [curr_metrics, last_metrics] = get_metrics() DCNL DCSP metric_name_list = name.split('_')[1:] DCNL DCSP metric_name = '_'.join(metric_name_list) DCNL DCSP try: DCNL DCSP  DCSP delta = ((float(curr_metrics['data'][metric_name]) - float(last_metrics['data'][metric_name])) / (curr_metrics['time'] - last_metrics['time'])) DCNL DCSP  DCSP if (delta < 0): DCNL DCSP  DCSP  DCSP if Debug: DCNL DCSP  DCSP  DCSP  DCSP print (name + ' DCSP is DCSP less DCSP 0. DCSP Setting DCSP value DCSP to DCSP 0.') DCNL DCSP  DCSP  DCSP delta = 0 DCNL DCSP except KeyError: DCNL DCSP  DCSP if Debug: DCNL DCSP  DCSP  DCSP print (('Key DCSP ' + name) + " DCSP can't DCSP be DCSP found.") DCNL DCSP  DCSP delta = 0.0 DCNL DCSP return delta
def description(): DCNL  DCSP for desc in _description.splitlines(): DCNL DCSP  DCSP print desc
def register(mgr): DCNL  DCSP mgr.set_lang_info(lang, silvercity_lexer=HTML5Lexer(), buf_class=HTML5Buffer, langintel_class=HTML5LangIntel, cile_driver_class=HTML5CILEDriver, is_cpln_lang=True)
def remove_comments(string): DCNL  DCSP pattern = '(\\".*?\\"|\\\'.*?\\\')|(<#.*?#>|#[^\\r\\n]*$)' DCNL DCSP regex = re.compile(pattern, (re.MULTILINE | re.DOTALL)) DCNL DCSP def _replacer(match): DCNL DCSP  DCSP if (match.group(2) is not None): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return regex.sub(_replacer, string)
def test_install_from_local_directory_with_no_setup_py(script, data): DCNL  DCSP result = script.pip('install', data.root, expect_error=True) DCNL DCSP assert (not result.files_created) DCNL DCSP assert ("is DCSP not DCSP installable. DCSP File DCSP 'setup.py' DCSP not DCSP found." in result.stderr)
def autolink_role(typ, rawtext, etext, lineno, inliner, options={}, content=[]): DCNL  DCSP env = inliner.document.settings.env DCNL DCSP r = env.get_domain('py').role('obj')('obj', rawtext, etext, lineno, inliner, options, content) DCNL DCSP pnode = r[0][0] DCNL DCSP prefixes = get_import_prefixes_from_env(env) DCNL DCSP try: DCNL DCSP  DCSP (name, obj, parent) = import_by_name(pnode['reftarget'], prefixes) DCNL DCSP except ImportError: DCNL DCSP  DCSP content = pnode[0] DCNL DCSP  DCSP r[0][0] = nodes.emphasis(rawtext, content[0].astext(), classes=content['classes']) DCNL DCSP return r
def mkdirs(newdir, mode=511): DCNL  DCSP if six.PY3: DCNL DCSP  DCSP os.makedirs(newdir, mode=mode, exist_ok=True) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(newdir, mode=mode) DCNL DCSP  DCSP except OSError as exception: DCNL DCSP  DCSP  DCSP if (exception.errno != errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP raise
def repeat(a, repeats, axis=None): DCNL  DCSP return a.repeat(repeats, axis)
def test_format(method, prec, exp_range, restricted_range, itr, stat): DCNL  DCSP for op in all_unary(prec, exp_range, itr): DCNL DCSP  DCSP fmt1 = rand_format(chr(random.randrange(0, 128)), 'EeGgn') DCNL DCSP  DCSP fmt2 = rand_locale() DCNL DCSP  DCSP for fmt in (fmt1, fmt2): DCNL DCSP  DCSP  DCSP fmtop = (op[0], fmt) DCNL DCSP  DCSP  DCSP t = TestSet(method, fmtop) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not convert(t, convstr=False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP callfuncs(t) DCNL DCSP  DCSP  DCSP  DCSP verify(t, stat) DCNL DCSP  DCSP  DCSP except VerifyError as err: DCNL DCSP  DCSP  DCSP  DCSP log(err) DCNL DCSP for op in all_unary(prec, 9999, itr): DCNL DCSP  DCSP fmt1 = rand_format(chr(random.randrange(0, 128)), 'Ff%') DCNL DCSP  DCSP fmt2 = rand_locale() DCNL DCSP  DCSP for fmt in (fmt1, fmt2): DCNL DCSP  DCSP  DCSP fmtop = (op[0], fmt) DCNL DCSP  DCSP  DCSP t = TestSet(method, fmtop) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not convert(t, convstr=False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP callfuncs(t) DCNL DCSP  DCSP  DCSP  DCSP verify(t, stat) DCNL DCSP  DCSP  DCSP except VerifyError as err: DCNL DCSP  DCSP  DCSP  DCSP log(err)
def runLengthEncode(stream): DCNL  DCSP encodedStream = '' DCNL DCSP return ((-1), 'RunLengthEncode DCSP not DCSP supported DCSP yet')
def split_keyword(keyword): DCNL  DCSP split = set(re.findall('\\w+', keyword)) DCNL DCSP return split
def get_subscribers_query(stream, requesting_user): DCNL  DCSP validate_user_access_to_subscribers(requesting_user, stream) DCNL DCSP subscriptions = Subscription.objects.filter(recipient__type=Recipient.STREAM, recipient__type_id=stream.id, user_profile__is_active=True, active=True) DCNL DCSP return subscriptions
def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP import hikvision.api DCNL DCSP from hikvision.error import HikvisionError, MissingParamError DCNL DCSP host = config.get(CONF_HOST) DCNL DCSP port = config.get(CONF_PORT) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP username = config.get(CONF_USERNAME) DCNL DCSP password = config.get(CONF_PASSWORD) DCNL DCSP try: DCNL DCSP  DCSP hikvision_cam = hikvision.api.CreateDevice(host, port=port, username=username, password=password, is_https=False) DCNL DCSP except MissingParamError as param_err: DCNL DCSP  DCSP _LOGGING.error('Missing DCSP required DCSP param: DCSP %s', param_err) DCNL DCSP  DCSP return False DCNL DCSP except HikvisionError as conn_err: DCNL DCSP  DCSP _LOGGING.error('Unable DCSP to DCSP connect: DCSP %s', conn_err) DCNL DCSP  DCSP return False DCNL DCSP add_devices([HikvisionMotionSwitch(name, hikvision_cam)])
def get_parent_xblock(xblock): DCNL  DCSP locator = xblock.location DCNL DCSP parent_location = modulestore().get_parent_location(locator) DCNL DCSP if (parent_location is None): DCNL DCSP  DCSP return None DCNL DCSP return modulestore().get_item(parent_location)
def getCraftedText(fileName, text='', repository=None): DCNL  DCSP return getCraftedTextFromText(archive.getTextIfEmpty(fileName, text), repository)
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def test_install_from_wheel_installs_deps(script, data): DCNL  DCSP package = data.packages.join('requires_source-1.0-py2.py3-none-any.whl') DCNL DCSP result = script.pip('install', '--no-index', '--find-links', data.find_links, package) DCNL DCSP result.assert_installed('source', editable=False)
@utils.arg('secgroup', metavar='<secgroup>', help=_('ID DCSP or DCSP name DCSP of DCSP security DCSP group.')) DCNL @deprecated_network DCNL def do_secgroup_delete(cs, args): DCNL  DCSP secgroup = _get_secgroup(cs, args.secgroup) DCNL DCSP cs.security_groups.delete(secgroup) DCNL DCSP _print_secgroups([secgroup])
def _save_attachment(attachment, filepath): DCNL  DCSP filepath = private_storage.save(filepath, attachment) DCNL DCSP return filepath.split('/')[(-1)]
def downgrade_wsgi_ux_to_1x(environ): DCNL  DCSP env1x = {} DCNL DCSP url_encoding = environ[ntou('wsgi.url_encoding')] DCNL DCSP for (k, v) in list(environ.items()): DCNL DCSP  DCSP if (k in [ntou('PATH_INFO'), ntou('SCRIPT_NAME'), ntou('QUERY_STRING')]): DCNL DCSP  DCSP  DCSP v = v.encode(url_encoding) DCNL DCSP  DCSP elif isinstance(v, six.text_type): DCNL DCSP  DCSP  DCSP v = v.encode('ISO-8859-1') DCNL DCSP  DCSP env1x[k.encode('ISO-8859-1')] = v DCNL DCSP return env1x
def restoreConfigZip(archive, targetDir): DCNL  DCSP try: DCNL DCSP  DCSP if (not ek(os.path.exists, targetDir)): DCNL DCSP  DCSP  DCSP ek(os.mkdir, targetDir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP def path_leaf(path): DCNL DCSP  DCSP  DCSP  DCSP (head, tail) = ek(os.path.split, path) DCNL DCSP  DCSP  DCSP  DCSP return (tail or ek(os.path.basename, head)) DCNL DCSP  DCSP  DCSP bakFilename = u'{0}-{1}'.format(path_leaf(targetDir), datetime.datetime.now().strftime(u'%Y%m%d_%H%M%S')) DCNL DCSP  DCSP  DCSP shutil.move(targetDir, ek(os.path.join, ek(os.path.dirname, targetDir), bakFilename)) DCNL DCSP  DCSP zip_file = zipfile.ZipFile(archive, u'r', allowZip64=True) DCNL DCSP  DCSP for member in zip_file.namelist(): DCNL DCSP  DCSP  DCSP zip_file.extract(member, targetDir) DCNL DCSP  DCSP zip_file.close() DCNL DCSP  DCSP return True DCNL DCSP except Exception as error: DCNL DCSP  DCSP logger.log(u'Zip DCSP extraction DCSP error: DCSP {0}'.format(error), logger.ERROR) DCNL DCSP  DCSP shutil.rmtree(targetDir) DCNL DCSP  DCSP return False
