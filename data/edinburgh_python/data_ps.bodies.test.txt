 DCSP if cint(frappe.db.get_single_value(u'System DCSP Settings', u'setup_complete')): DCNL DCSP  DCSP return DCNL DCSP args = process_args(args) DCNL DCSP try: DCNL DCSP  DCSP if (args.language and (args.language != u'english')): DCNL DCSP  DCSP  DCSP set_default_language(get_language_code(args.lang)) DCNL DCSP  DCSP frappe.clear_cache() DCNL DCSP  DCSP update_system_settings(args) DCNL DCSP  DCSP update_user_name(args) DCNL DCSP  DCSP for method in frappe.get_hooks(u'setup_wizard_complete'): DCNL DCSP  DCSP  DCSP frappe.get_attr(method)(args) DCNL DCSP  DCSP disable_future_access() DCNL DCSP  DCSP frappe.db.commit() DCNL DCSP  DCSP frappe.clear_cache() DCNL DCSP except: DCNL DCSP  DCSP frappe.db.rollback() DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP traceback = frappe.get_traceback() DCNL DCSP  DCSP  DCSP for hook in frappe.get_hooks(u'setup_wizard_exception'): DCNL DCSP  DCSP  DCSP  DCSP frappe.get_attr(hook)(traceback, args) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP for hook in frappe.get_hooks(u'setup_wizard_success'): DCNL DCSP  DCSP  DCSP frappe.get_attr(hook)(args)
 DCSP module = AnsibleModule(argument_spec=ClcGroup._define_module_argument_spec(), supports_check_mode=True) DCNL DCSP clc_group = ClcGroup(module) DCNL DCSP clc_group.process_request()
 DCSP try: DCNL DCSP  DCSP fields = os.path.split(filename) DCNL DCSP  DCSP if fields: DCNL DCSP  DCSP  DCSP if (fields[(-1)].startswith('dataset_') and fields[(-1)].endswith('.dat')): DCNL DCSP  DCSP  DCSP  DCSP return Dataset.get(int(fields[(-1)][len('dataset_'):(- len('.dat'))])) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return None
 DCSP result = [] DCNL DCSP for node in maybe_xrefs: DCNL DCSP  DCSP if isinstance(node, addnodes.pending_xref): DCNL DCSP  DCSP  DCSP result.extend(resolve_pending_xref(app, fromdocname, node.deepcopy())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(node) DCNL DCSP return result
 DCSP (is_travis, non_pr) = check_environment() DCNL DCSP if (not is_travis): DCNL DCSP  DCSP return DCNL DCSP if (not non_pr): DCNL DCSP  DCSP print('Running DCSP in DCSP Travis DCSP during DCSP non-merge DCSP to DCSP master, DCSP doing DCSP nothing.') DCNL DCSP  DCSP sys.exit(0) DCNL DCSP decrypt_keyfile()
 DCSP result = script.pip('download', expect_error=True) DCNL DCSP assert ('You DCSP must DCSP give DCSP at DCSP least DCSP one DCSP requirement DCSP to DCSP download' in result.stderr) DCNL DCSP assert (result.returncode == ERROR)
 DCSP with open('../show_version.txt') as show_ver_file: DCNL DCSP  DCSP show_ver = show_ver_file.read() DCNL DCSP print obtain_os_version(show_ver)
 DCSP stdout.write(msg.encode('utf-8'))
 DCSP api_key = bot.config.get('api_keys', {}).get('bing_azure') DCNL DCSP show_nsfw = text.endswith(' DCSP nsfw') DCNL DCSP if show_nsfw: DCNL DCSP  DCSP text = text[:(-5)].strip().lower() DCNL DCSP rating = (NSFW_FILTER if show_nsfw else DEFAULT_FILTER) DCNL DCSP if (not api_key): DCNL DCSP  DCSP return 'Error: DCSP No DCSP Bing DCSP Azure DCSP API DCSP details.' DCNL DCSP params = {'Sources': bingify('image'), 'Query': bingify(text), 'Adult': bingify(rating), '$format': 'json'} DCNL DCSP request = requests.get(API_URL, params=params, auth=(api_key, api_key)) DCNL DCSP j = request.json()['d']['results'][0] DCNL DCSP if (not j['Image']): DCNL DCSP  DCSP return 'No DCSP results.' DCNL DCSP result = random.choice(j['Image'][:10]) DCNL DCSP tags = [] DCNL DCSP tags.append('{}x{}px'.format(result['Width'], result['Height'])) DCNL DCSP tags.append(result['ContentType']) DCNL DCSP tags.append(filesize.size(int(result['FileSize']), system=filesize.alternative)) DCNL DCSP if ('explicit' in result['Thumbnail']['MediaUrl']): DCNL DCSP  DCSP tags.append('NSFW') DCNL DCSP tag_text = ', DCSP '.join(tags) DCNL DCSP return '{} DCSP ({})'.format(unescape(result['MediaUrl']), tag_text)
 DCSP if (not issubclass(optionable_type, Optionable)): DCNL DCSP  DCSP raise TypeError(u'The DCSP given DCSP `optionable_type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Optionable`: DCSP {}'.format(optionable_type)) DCNL DCSP option_values = {} DCNL DCSP registration_function = _options_registration_function(option_values) DCNL DCSP optionable_type.register_options(registration_function) DCNL DCSP option_values.update(**options) DCNL DCSP return create_option_values(option_values)
 DCSP q = ((2 * endog) - 1) DCNL DCSP X = exog DCNL DCSP return np.add.reduce(stats.norm.logcdf((q * np.dot(X, params))))
 DCSP filename = get_pkg_data_filename(u'data/sip2.fits') DCNL DCSP with catch_warnings(wcs.wcs.FITSFixedWarning) as caught_warnings: DCNL DCSP  DCSP ww = wcs.WCS(filename) DCNL DCSP  DCSP assert (len(caught_warnings) == 1) DCNL DCSP n = 3 DCNL DCSP pixels = (np.arange(n) * np.ones((2, n))).T DCNL DCSP result = ww.wcs_pix2world(pixels, 0, ra_dec_order=True) DCNL DCSP ww.wcs_pix2world(pixels[..., 0], pixels[..., 1], 0, ra_dec_order=True) DCNL DCSP close_enough = 1e-08 DCNL DCSP answer = np.array([[0.00024976, 0.00023018], [0.00023043, (-0.00024997)]]) DCNL DCSP assert np.all((np.abs((ww.wcs.pc - answer)) < close_enough)) DCNL DCSP answer = np.array([[202.39265216, 47.17756518], [202.39335826, 47.17754619], [202.39406436, 47.1775272]]) DCNL DCSP assert np.all((np.abs((result - answer)) < close_enough))
 DCSP (fig, ax) = utils.create_mpl_ax(ax) DCNL DCSP infl = results.get_influence() DCNL DCSP if criterion.lower().startswith('coo'): DCNL DCSP  DCSP psize = infl.cooks_distance[0] DCNL DCSP elif criterion.lower().startswith('dff'): DCNL DCSP  DCSP psize = np.abs(infl.dffits[0]) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Criterion DCSP %s DCSP not DCSP understood' % criterion)) DCNL DCSP old_range = np.ptp(psize) DCNL DCSP new_range = ((size ** 2) - (8 ** 2)) DCNL DCSP psize = ((((psize - psize.min()) * new_range) / old_range) + (8 ** 2)) DCNL DCSP leverage = infl.hat_matrix_diag DCNL DCSP if external: DCNL DCSP  DCSP resids = infl.resid_studentized_external DCNL DCSP else: DCNL DCSP  DCSP resids = infl.resid_studentized_internal DCNL DCSP from scipy import stats DCNL DCSP cutoff = stats.t.ppf((1.0 - (alpha / 2)), results.df_resid) DCNL DCSP large_resid = (np.abs(resids) > cutoff) DCNL DCSP large_leverage = (leverage > _high_leverage(results)) DCNL DCSP large_points = np.logical_or(large_resid, large_leverage) DCNL DCSP ax.scatter(leverage, resids, s=psize, alpha=plot_alpha) DCNL DCSP labels = results.model.data.row_labels DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = lrange(len(resids)) DCNL DCSP ax = utils.annotate_axes(np.where(large_points)[0], labels, lzip(leverage, resids), lzip((- ((psize / 2) ** 0.5)), ((psize / 2) ** 0.5)), 'x-large', ax) DCNL DCSP font = {'fontsize': 16, 'color': 'black'} DCNL DCSP ax.set_ylabel('Studentized DCSP Residuals', **font) DCNL DCSP ax.set_xlabel('H DCSP Leverage', **font) DCNL DCSP ax.set_title('Influence DCSP Plot', **font) DCNL DCSP return fig
 DCSP nf = NetlogFile(name) DCNL DCSP nf.sock.sendall(data) DCNL DCSP nf.close()
 DCSP root = get_or_create_root() DCNL DCSP return redirect('wiki:get', path=root.path)
 DCSP return IMPL.block_device_mapping_update_or_create(context, values)
 DCSP flavors = novaclient(request).flavors.list(is_public=is_public) DCNL DCSP if get_extras: DCNL DCSP  DCSP for flavor in flavors: DCNL DCSP  DCSP  DCSP flavor.extras = flavor_get_extras(request, flavor.id, True, flavor) DCNL DCSP return flavors
 DCSP if (u'charset' in format): DCNL DCSP  DCSP return format DCNL DCSP if (format in (u'application/json', u'text/javascript')): DCNL DCSP  DCSP return format DCNL DCSP return (u'%s; DCSP charset=%s' % (format, encoding))
 DCSP random_index = randint(0, (TopicCategory.objects.all().count() - 1)) DCNL DCSP tc = TopicCategory.objects.all()[random_index] DCNL DCSP resource.category = tc DCNL DCSP resource.save()
 DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
 DCSP modules = set(['textannotation', 'imageannotation', 'videoannotation']) DCNL DCSP return bool(modules.intersection(course.advanced_modules))
 DCSP for (label, seq) in parse_fasta(file_lines): DCNL DCSP  DCSP if (id_from_fasta_label_line(label) in ids): DCNL DCSP  DCSP  DCSP (yield (label, seq))
 DCSP inse = tf.reduce_sum((output * target)) DCNL DCSP l = tf.reduce_sum((output * output)) DCNL DCSP r = tf.reduce_sum((target * target)) DCNL DCSP dice = ((2 * inse) / (l + r)) DCNL DCSP if (epsilon == 0): DCNL DCSP  DCSP return dice DCNL DCSP else: DCNL DCSP  DCSP return tf.clip_by_value(dice, 0, (1.0 - epsilon))
 DCSP if callable(getattr(self.connection.features, 'confirm', None)): DCNL DCSP  DCSP self.connection.features.confirm() DCNL DCSP elif hasattr(self, '_rollback_works'): DCNL DCSP  DCSP can_rollback = self._rollback_works() DCNL DCSP  DCSP self.connection.settings_dict['SUPPORTS_TRANSACTIONS'] = can_rollback DCNL DCSP return self._get_test_db_name()
 DCSP missionlist = readmission(aFileName) DCNL DCSP print ('\nUpload DCSP mission DCSP from DCSP a DCSP file: DCSP %s' % import_mission_filename) DCNL DCSP print ' DCSP Clear DCSP mission' DCNL DCSP cmds = vehicle.commands DCNL DCSP cmds.clear() DCNL DCSP for command in missionlist: DCNL DCSP  DCSP cmds.add(command) DCNL DCSP print ' DCSP Upload DCSP mission' DCNL DCSP vehicle.commands.upload()
 DCSP if (math_expr.strip() == ''): DCNL DCSP  DCSP return float('nan') DCNL DCSP math_interpreter = ParseAugmenter(math_expr, case_sensitive) DCNL DCSP math_interpreter.parse_algebra() DCNL DCSP (all_variables, all_functions) = add_defaults(variables, functions, case_sensitive) DCNL DCSP math_interpreter.check_variables(all_variables, all_functions) DCNL DCSP if case_sensitive: DCNL DCSP  DCSP casify = (lambda x: x) DCNL DCSP else: DCNL DCSP  DCSP casify = (lambda x: x.lower()) DCNL DCSP evaluate_actions = {'number': eval_number, 'variable': (lambda x: all_variables[casify(x[0])]), 'function': (lambda x: all_functions[casify(x[0])](x[1])), 'atom': eval_atom, 'power': eval_power, 'parallel': eval_parallel, 'product': eval_product, 'sum': eval_sum} DCNL DCSP return math_interpreter.reduce_tree(evaluate_actions)
 DCSP if (not data): DCNL DCSP  DCSP raise ValueError('No DCSP data DCSP available DCSP for DCSP pie DCSP chart.') DCNL DCSP all_fracs = [] DCNL DCSP all_labels = [] DCNL DCSP colors = [] DCNL DCSP for (color_ix, (c_label, c_frac)) in enumerate(data): DCNL DCSP  DCSP if (c_label == others_key): DCNL DCSP  DCSP  DCSP colors.append(others_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP colors.append(data_colors[pref_colors[c_label]].toHex()) DCNL DCSP  DCSP all_fracs.append(c_frac) DCNL DCSP  DCSP if should_capitalize: DCNL DCSP  DCSP  DCSP capital = ('%s DCSP (%.2f%%)' % (c_label.capitalize(), (c_frac * 100.0))) DCNL DCSP  DCSP  DCSP all_labels.append(capital) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP all_labels.append(('%s DCSP (%.2f%%)' % (c_label, (c_frac * 100.0)))) DCNL DCSP rc('font', size='10') DCNL DCSP rc('text', color=label_color) DCNL DCSP rc('patch', linewidth=0.1) DCNL DCSP rc('axes', linewidth=0.5, edgecolor=label_color) DCNL DCSP rc('text', usetex=False) DCNL DCSP fig = figure(randrange(10000), figsize=(plot_width, plot_height)) DCNL DCSP fp = FontProperties() DCNL DCSP fp.set_size('8') DCNL DCSP if (len(data) > 30): DCNL DCSP  DCSP loc = 4 DCNL DCSP else: DCNL DCSP  DCSP loc = 5 DCNL DCSP mtitle = 'Pie DCSP Chart' DCNL DCSP if ('title' in props): DCNL DCSP  DCSP mtitle = props['title'] DCNL DCSP axis('off') DCNL DCSP title(mtitle, fontsize='10', color=label_color) DCNL DCSP ax = axes([0.0, 0.0, 0.5, 1]) DCNL DCSP p1 = pie(all_fracs, shadow=False, colors=colors) DCNL DCSP if (file_prefix is None): DCNL DCSP  DCSP img_name = make_img_name(file_ext='.png') DCNL DCSP else: DCNL DCSP  DCSP img_name = file_prefix DCNL DCSP img_abs = os.path.join(dir_path, 'charts', img_name) DCNL DCSP savefig(img_abs, dpi=dpi, facecolor=background_color) DCNL DCSP eps_link = '' DCNL DCSP eps_abs = '' DCNL DCSP if (file_prefix is None): DCNL DCSP  DCSP eps_img_name = make_img_name(file_ext=('.%s' % generate_image_type)) DCNL DCSP else: DCNL DCSP  DCSP eps_img_name = (file_prefix + ('.%s' % generate_image_type)) DCNL DCSP savefig(os.path.join(dir_path, 'charts', eps_img_name), facecolor=background_color) DCNL DCSP if (generate_image_type == 'eps'): DCNL DCSP  DCSP strip_eps_font(os.path.join(dir_path, 'charts', eps_img_name)) DCNL DCSP eps_abs = os.path.join(dir_path, 'charts', eps_img_name) DCNL DCSP eps_link = (PDF_LINK % (os.path.join('charts', eps_img_name), ('View DCSP Figure DCSP (.%s)' % generate_image_type))) DCNL DCSP close(fig) DCNL DCSP clf() DCNL DCSP updated_taxa = [] DCNL DCSP updated_colors = [] DCNL DCSP for i in data: DCNL DCSP  DCSP if (i[0] != others_key): DCNL DCSP  DCSP  DCSP updated_taxa.append(i[0].replace('"', '')) DCNL DCSP  DCSP  DCSP updated_colors.append(data_colors[pref_colors[i[0]]].toHex()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP updated_taxa.append(others_key) DCNL DCSP  DCSP  DCSP updated_colors.append(others_color) DCNL DCSP if include_html_legend: DCNL DCSP  DCSP legend_fname_png = make_legend(updated_taxa, updated_colors, plot_width, plot_height, label_color, background_color, img_abs, 'png', 80) DCNL DCSP  DCSP legend_fpath_png = os.path.join('charts', legend_fname_png) DCNL DCSP legend_fname = make_legend(updated_taxa, updated_colors, plot_width, plot_height, label_color, background_color, img_abs, generate_image_type, dpi) DCNL DCSP legend_fpath = os.path.join('charts', legend_fname) DCNL DCSP legend_link = (LEGEND_LINK % (legend_fpath, ('View DCSP Legend DCSP (.%s)' % generate_image_type))) DCNL DCSP points_id = '' DCNL DCSP xmap_html = '' DCNL DCSP if (not include_html_legend): DCNL DCSP  DCSP IMG_TEXT = (IMG_SRC_minus_legend % (os.path.join('charts', img_name), points_id)) DCNL DCSP else: DCNL DCSP  DCSP IMG_TEXT = (IMG_SRC_2 % (os.path.join('charts', img_name), points_id, legend_fpath_png)) DCNL DCSP return (eps_link, legend_link, IMG_TEXT, xmap_html)
 DCSP try: DCNL DCSP  DCSP return ismount_raw(path) DCNL DCSP except OSError: DCNL DCSP  DCSP return False
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_title', None) or _Cfunction('libvlc_vlm_get_media_instance_title', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP if (len(s) < 1): DCNL DCSP  DCSP return Raw(s) DCNL DCSP ietype = ord(s[0]) DCNL DCSP cls = ietypecls.get(ietype, Raw) DCNL DCSP if ((cls == Raw) and ((ietype & 128) == 128)): DCNL DCSP  DCSP cls = IE_NotImplementedTLV DCNL DCSP return cls(s)
 DCSP results = [] DCNL DCSP for path in combine_lists(*path_seqs): DCNL DCSP  DCSP expanded = expand_path(path) DCNL DCSP  DCSP paths = (sorted(glob.glob(expanded)) or [expanded]) DCNL DCSP  DCSP results.extend(paths) DCNL DCSP return results
 DCSP atoi = (lambda addr: struct.unpack('!I', socket.inet_aton(addr))[0]) DCNL DCSP itoa = (lambda addr: socket.inet_ntoa(struct.pack('!I', addr))) DCNL DCSP (address, netmask) = network.split('/') DCNL DCSP netmask_i = ((4294967295 << (32 - atoi(netmask))) & 4294967295) DCNL DCSP return itoa(((atoi(address) & netmask_i) + 1))
 DCSP assert (name in ['harry', 'terry', 'ule']) DCNL DCSP common = os.path.join(preprocess('${PYLEARN2_DATA_PATH}'), 'UTLC', 'sparse', (name + '_')) DCNL DCSP (trname, vname, tename) = [((common + subset) + '.npy') for subset in ['train', 'valid', 'test']] DCNL DCSP train = load_sparse(trname) DCNL DCSP valid = load_sparse(vname) DCNL DCSP test = load_sparse(tename) DCNL DCSP if randomize_valid: DCNL DCSP  DCSP rng = make_np_rng(None, [1, 2, 3, 4], which_method='permutation') DCNL DCSP  DCSP perm = rng.permutation(valid.shape[0]) DCNL DCSP  DCSP valid = valid[perm] DCNL DCSP if randomize_test: DCNL DCSP  DCSP rng = make_np_rng(None, [1, 2, 3, 4], which_method='permutation') DCNL DCSP  DCSP perm = rng.permutation(test.shape[0]) DCNL DCSP  DCSP test = test[perm] DCNL DCSP if normalize: DCNL DCSP  DCSP if (name == 'ule'): DCNL DCSP  DCSP  DCSP train = (train.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP  DCSP valid = (valid.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP  DCSP test = (test.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP elif (name == 'harry'): DCNL DCSP  DCSP  DCSP train = train.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP valid = valid.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP test = test.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP std = 0.6933604603392579 DCNL DCSP  DCSP  DCSP train = (train / std) DCNL DCSP  DCSP  DCSP valid = (valid / std) DCNL DCSP  DCSP  DCSP test = (test / std) DCNL DCSP  DCSP elif (name == 'terry'): DCNL DCSP  DCSP  DCSP train = train.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP valid = valid.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP test = test.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP train = (train / 300) DCNL DCSP  DCSP  DCSP valid = (valid / 300) DCNL DCSP  DCSP  DCSP test = (test / 300) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception("This DCSP dataset DCSP don't DCSP have DCSP its DCSP normalization DCSP defined") DCNL DCSP if transfer: DCNL DCSP  DCSP fname = os.path.join(preprocess('${PYLEARN2_DATA_PATH}'), 'UTLC', 'filetensor', (name + '_transfer.ft')) DCNL DCSP  DCSP transfer = load_filetensor(fname) DCNL DCSP  DCSP return (train, valid, test, transfer) DCNL DCSP else: DCNL DCSP  DCSP return (train, valid, test)
 DCSP f = (_Cfunctions.get('libvlc_video_get_spu_description', None) or _Cfunction('libvlc_video_get_spu_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP arr = np.asarray(data, dtype=np.float32) DCNL DCSP out = cuda.device_array(1, dtype=np.float32) DCNL DCSP gpu_single_block_sum[(1, gpu_block_sum_max_blockdim)](arr, out) DCNL DCSP return out.copy_to_host()[0]
 DCSP assert hug.validate.contains_one_of('no', 'way')(TEST_SCHEMA) DCNL DCSP assert (not hug.validate.contains_one_of('last', 'place')(TEST_SCHEMA))
 DCSP if (len(nestedRings) > 0): DCNL DCSP  DCSP oldOrderedLocation.z = nestedRings[0].z DCNL DCSP closestDistance = 9.876543219876543e+17 DCNL DCSP closestNestedRing = None DCNL DCSP for remainingNestedRing in nestedRings: DCNL DCSP  DCSP distance = getClosestDistanceIndexToLine(oldOrderedLocation.dropAxis(), remainingNestedRing.boundary).distance DCNL DCSP  DCSP if (distance < closestDistance): DCNL DCSP  DCSP  DCSP closestDistance = distance DCNL DCSP  DCSP  DCSP closestNestedRing = remainingNestedRing DCNL DCSP nestedRings.remove(closestNestedRing) DCNL DCSP closestNestedRing.addToThreads(extrusionHalfWidth, oldOrderedLocation, skein, threadSequence) DCNL DCSP return closestNestedRing
 DCSP requires = IS_ONE_OF(current.db, 'org_organisation.id', org_OrganisationRepresent(), realms=realms, updateable=updateable, orderby='org_organisation.name', sort=True) DCNL DCSP if (not required): DCNL DCSP  DCSP requires = IS_EMPTY_OR(requires) DCNL DCSP return requires
 DCSP return 'emoncms{}_{}_{}_{}_{}'.format(sensorid, feedtag, feedname, feedid, feeduserid)
 DCSP return __execute_cmd('setniccfg DCSP -s DCSP {0} DCSP {1} DCSP {2}'.format(ip, netmask, gateway))
 DCSP with smart_open(fname, 'wb') as fout: DCNL DCSP  DCSP _pickle.dump(obj, fout, protocol=protocol)
 DCSP return (None, changed_file)
 DCSP entries1 = _tree_entries(path, tree1) DCNL DCSP entries2 = _tree_entries(path, tree2) DCNL DCSP i1 = i2 = 0 DCNL DCSP len1 = len(entries1) DCNL DCSP len2 = len(entries2) DCNL DCSP result = [] DCNL DCSP while ((i1 < len1) and (i2 < len2)): DCNL DCSP  DCSP entry1 = entries1[i1] DCNL DCSP  DCSP entry2 = entries2[i2] DCNL DCSP  DCSP if (entry1.path < entry2.path): DCNL DCSP  DCSP  DCSP result.append((entry1, _NULL_ENTRY)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP elif (entry1.path > entry2.path): DCNL DCSP  DCSP  DCSP result.append((_NULL_ENTRY, entry2)) DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append((entry1, entry2)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP for i in range(i1, len1): DCNL DCSP  DCSP result.append((entries1[i], _NULL_ENTRY)) DCNL DCSP for i in range(i2, len2): DCNL DCSP  DCSP result.append((_NULL_ENTRY, entries2[i])) DCNL DCSP return result
 DCSP req_vars = form.request_vars DCNL DCSP position = req_vars.get('position', '') DCNL DCSP reason = req_vars.get('reason', '') DCNL DCSP db = current.db DCNL DCSP table = db.auth_user DCNL DCSP db((table.id == form.vars.id)).update(comments=('%s DCSP | DCSP %s' % (position, reason)))
 DCSP if (not a): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP return [((a * b) % p) for b in f]
 DCSP review_request_id_to_commits_map = defaultdict(list) DCNL DCSP branch_name = payload.get(u'repository_path') DCNL DCSP if (not branch_name): DCNL DCSP  DCSP return review_request_id_to_commits_map DCNL DCSP revisions = payload.get(u'revisions', []) DCNL DCSP for revision in revisions: DCNL DCSP  DCSP revision_id = revision.get(u'revision') DCNL DCSP  DCSP if (len(revision_id) > 7): DCNL DCSP  DCSP  DCSP revision_id = revision_id[:7] DCNL DCSP  DCSP commit_message = revision.get(u'message') DCNL DCSP  DCSP review_request_id = get_review_request_id(commit_message, server_url) DCNL DCSP  DCSP review_request_id_to_commits_map[review_request_id].append((u'%s DCSP (%s)' % (branch_name, revision_id))) DCNL DCSP return review_request_id_to_commits_map
 DCSP try: DCNL DCSP  DCSP codecs.lookup(argument) DCNL DCSP except LookupError: DCNL DCSP  DCSP raise ValueError(('unknown DCSP encoding: DCSP "%s"' % argument)) DCNL DCSP return argument
 DCSP for (k, v) in opts.items(): DCNL DCSP  DCSP setConfigOption(k, v)
 DCSP subKeys = itemName.split(':') DCNL DCSP subResults = results DCNL DCSP for subKey in subKeys: DCNL DCSP  DCSP subResults = subResults[subKey] DCNL DCSP return subResults
 DCSP inner_text = [] DCNL DCSP for child in node.childNodes: DCNL DCSP  DCSP if ((child.nodeType == child.TEXT_NODE) or (child.nodeType == child.CDATA_SECTION_NODE)): DCNL DCSP  DCSP  DCSP inner_text.append(child.data) DCNL DCSP  DCSP elif (child.nodeType == child.ELEMENT_NODE): DCNL DCSP  DCSP  DCSP inner_text.extend(getInnerText(child)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return ''.join(inner_text)
 DCSP if (not name): DCNL DCSP  DCSP return namespace(namespace_) DCNL DCSP name = canonicalize_name(name) DCNL DCSP if (name[0] == SEP): DCNL DCSP  DCSP resolved_name = name DCNL DCSP elif is_private(name): DCNL DCSP  DCSP resolved_name = canonicalize_name(((namespace_ + SEP) + name[1:])) DCNL DCSP else: DCNL DCSP  DCSP resolved_name = (namespace(namespace_) + name) DCNL DCSP if (remappings and (resolved_name in remappings)): DCNL DCSP  DCSP return remappings[resolved_name] DCNL DCSP else: DCNL DCSP  DCSP return resolved_name
 DCSP qt_start = u'<!--:' DCNL DCSP qt_end = u'-->' DCNL DCSP qt_end_with_lang_len = 5 DCNL DCSP qt_chunks = text.split(qt_start) DCNL DCSP content_by_lang = {} DCNL DCSP common_txt_list = [] DCNL DCSP for c in qt_chunks: DCNL DCSP  DCSP if (not c.strip()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if c.startswith(qt_end): DCNL DCSP  DCSP  DCSP lang = u'' DCNL DCSP  DCSP  DCSP c = c.lstrip(qt_end) DCNL DCSP  DCSP  DCSP if (not c): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif c[2:].startswith(qt_end): DCNL DCSP  DCSP  DCSP lang = c[:2] DCNL DCSP  DCSP  DCSP c = c[qt_end_with_lang_len:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lang = u'' DCNL DCSP  DCSP if (not lang): DCNL DCSP  DCSP  DCSP common_txt_list.append(c) DCNL DCSP  DCSP  DCSP for l in content_by_lang.keys(): DCNL DCSP  DCSP  DCSP  DCSP content_by_lang[l].append(c) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP content_by_lang[lang] = (content_by_lang.get(lang, common_txt_list) + [c]) DCNL DCSP if (common_txt_list and (not content_by_lang)): DCNL DCSP  DCSP content_by_lang[u''] = common_txt_list DCNL DCSP for l in content_by_lang.keys(): DCNL DCSP  DCSP content_by_lang[l] = u' DCSP '.join(content_by_lang[l]) DCNL DCSP return content_by_lang
 DCSP def getter(value): DCNL DCSP  DCSP if ET.iselement(value): DCNL DCSP  DCSP  DCSP value = value.attrib DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if _is_re_match(value): DCNL DCSP  DCSP  DCSP  DCSP return value.group(item) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return value[item] DCNL DCSP  DCSP except (KeyError, IndexError): DCNL DCSP  DCSP  DCSP return default DCNL DCSP  DCSP except (TypeError, AttributeError) as err: DCNL DCSP  DCSP  DCSP raise ValueError(err) DCNL DCSP return transform(getter)
 DCSP txt = txt.replace('\r\n', '\n') DCNL DCSP txt = txt.replace('\r', '\n') DCNL DCSP txt_line_count = len(re.findall('(?mu)^\\s*.+$', txt)) DCNL DCSP docanalysis = DocAnalysis('txt', txt) DCNL DCSP hardbreaks = docanalysis.line_histogram(0.55) DCNL DCSP if hardbreaks: DCNL DCSP  DCSP tab_line_count = len(re.findall('(?mu)^( DCTB |\\s{2,}).+$', txt)) DCNL DCSP  DCSP print_percent = (tab_line_count / float(txt_line_count)) DCNL DCSP  DCSP empty_line_count = len(re.findall('(?mu)^\\s*$', txt)) DCNL DCSP  DCSP block_percent = (empty_line_count / float(txt_line_count)) DCNL DCSP  DCSP if (print_percent >= block_percent): DCNL DCSP  DCSP  DCSP if (0.15 <= print_percent <= 0.75): DCNL DCSP  DCSP  DCSP  DCSP return 'print' DCNL DCSP  DCSP elif (0.15 <= block_percent <= 0.75): DCNL DCSP  DCSP  DCSP return 'block' DCNL DCSP  DCSP return 'unformatted' DCNL DCSP return 'single'
 DCSP idcount = 0 DCNL DCSP if (extension and (not extension.startswith('.'))): DCNL DCSP  DCSP extension = ('.%s' % extension) DCNL DCSP fname = (base_name + extension) DCNL DCSP while os.path.exists(fname): DCNL DCSP  DCSP fname = ('%s-%d%s' % (base_name, idcount, extension)) DCNL DCSP  DCSP idcount += 1 DCNL DCSP return fname
 DCSP so_far = set() DCNL DCSP def no_dups(x): DCNL DCSP  DCSP k = key(x) DCNL DCSP  DCSP if (k in so_far): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP so_far.add(k) DCNL DCSP  DCSP  DCSP return True DCNL DCSP return IteratorFilter(iterator, no_dups)
 DCSP if (not is_list_like(n)): DCNL DCSP  DCSP n = np.array(([n] * len(m))) DCNL DCSP elif (isinstance(n, np.ndarray) and (n.ndim == 0)): DCNL DCSP  DCSP n = np.repeat(np.array(n, ndmin=1), len(m)) DCNL DCSP try: DCNL DCSP  DCSP nn = n[m] DCNL DCSP  DCSP if (not _is_na_compat(v, nn[0])): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP nn_at = nn.astype(v.dtype) DCNL DCSP  DCSP if (not is_numeric_v_string_like(nn, nn_at)): DCNL DCSP  DCSP  DCSP comp = (nn == nn_at) DCNL DCSP  DCSP  DCSP if (is_list_like(comp) and comp.all()): DCNL DCSP  DCSP  DCSP  DCSP nv = v.copy() DCNL DCSP  DCSP  DCSP  DCSP nv[m] = nn_at DCNL DCSP  DCSP  DCSP  DCSP return nv DCNL DCSP except (ValueError, IndexError, TypeError): DCNL DCSP  DCSP pass DCNL DCSP (dtype, _) = _maybe_promote(n.dtype) DCNL DCSP if (is_extension_type(v.dtype) and is_object_dtype(dtype)): DCNL DCSP  DCSP nv = v.get_values(dtype) DCNL DCSP else: DCNL DCSP  DCSP nv = v.astype(dtype) DCNL DCSP try: DCNL DCSP  DCSP nv[m] = n[m] DCNL DCSP except ValueError: DCNL DCSP  DCSP (idx,) = np.where(np.squeeze(m)) DCNL DCSP  DCSP for (mask_index, new_val) in zip(idx, n[m]): DCNL DCSP  DCSP  DCSP nv[mask_index] = new_val DCNL DCSP return nv
 DCSP filter_func = (filter_func or (lambda __: True)) DCNL DCSP stack = deque([start_node]) DCNL DCSP yield_results = {} DCNL DCSP while stack: DCNL DCSP  DCSP current_node = stack.pop() DCNL DCSP  DCSP if (get_parents and (current_node != start_node)): DCNL DCSP  DCSP  DCSP parents = get_parents(current_node) DCNL DCSP  DCSP  DCSP if (not all(((parent in yield_results) for parent in parents))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((not yield_descendants_of_unyielded) and (not any((yield_results[parent] for parent in parents)))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (current_node not in yield_results): DCNL DCSP  DCSP  DCSP if get_parents: DCNL DCSP  DCSP  DCSP  DCSP unvisited_children = list(get_children(current_node)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unvisited_children = list((child for child in get_children(current_node) if (child not in yield_results))) DCNL DCSP  DCSP  DCSP unvisited_children.reverse() DCNL DCSP  DCSP  DCSP stack.extend(unvisited_children) DCNL DCSP  DCSP  DCSP should_yield_node = filter_func(current_node) DCNL DCSP  DCSP  DCSP if should_yield_node: DCNL DCSP  DCSP  DCSP  DCSP (yield current_node) DCNL DCSP  DCSP  DCSP yield_results[current_node] = should_yield_node
 DCSP end = evaluate.getVector3FromElementNode(elementNode) DCNL DCSP previousElementNode = elementNode.getPreviousElementNode() DCNL DCSP if (previousElementNode == None): DCNL DCSP  DCSP print 'Warning, DCSP can DCSP not DCSP get DCSP previousElementNode DCSP in DCSP getQuadraticPath DCSP in DCSP quadratic DCSP for:' DCNL DCSP  DCSP print elementNode DCNL DCSP  DCSP return [end] DCNL DCSP begin = elementNode.getPreviousVertex(Vector3()) DCNL DCSP controlPoint = evaluate.getVector3ByPrefix(None, elementNode, 'controlPoint') DCNL DCSP if (controlPoint == None): DCNL DCSP  DCSP oldControlPoint = evaluate.getVector3ByPrefixes(previousElementNode, ['controlPoint', 'controlPoint1'], None) DCNL DCSP  DCSP if (oldControlPoint == None): DCNL DCSP  DCSP  DCSP oldControlPoint = end DCNL DCSP  DCSP controlPoint = ((begin + begin) - oldControlPoint) DCNL DCSP  DCSP evaluate.addVector3ToElementNode(elementNode, 'controlPoint', controlPoint) DCNL DCSP return svg_reader.getQuadraticPoints(begin, controlPoint, end, lineation.getNumberOfBezierPoints(begin, elementNode, end))
 DCSP if (isinstance(node.op, tensor.Elemwise) and isinstance(node.op.scalar_op, scalar.basic.Log) and (len(node.inputs) == 1) and (node.inputs[0].owner is not None) and isinstance(node.inputs[0].owner.op, Softmax)): DCNL DCSP  DCSP inVars = node.inputs[0].owner.inputs[0] DCNL DCSP  DCSP new_op = LogSoftmax() DCNL DCSP  DCSP ret = new_op(inVars) DCNL DCSP  DCSP ret.tag.values_eq_approx = values_eq_approx_remove_inf DCNL DCSP  DCSP copy_stack_trace([node.inputs[0], node.outputs[0]], ret) DCNL DCSP  DCSP return [ret]
 DCSP freqs = numpy.array([(((f + 1) * fs) / (2 * nfft)) for f in range(nfft)]) DCNL DCSP Cp = 27.5 DCNL DCSP nChroma = numpy.round((12.0 * numpy.log2((freqs / Cp)))).astype(int) DCNL DCSP nFreqsPerChroma = numpy.zeros((nChroma.shape[0],)) DCNL DCSP uChroma = numpy.unique(nChroma) DCNL DCSP for u in uChroma: DCNL DCSP  DCSP idx = numpy.nonzero((nChroma == u)) DCNL DCSP  DCSP nFreqsPerChroma[idx] = idx[0].shape DCNL DCSP return (nChroma, nFreqsPerChroma)
 DCSP def _set_nxm_headers_dec(self): DCNL DCSP  DCSP self.nxm_headers = nxm_headers DCNL DCSP  DCSP return self DCNL DCSP return _set_nxm_headers_dec
 DCSP return get_i18n().gettext(string, **variables)
 DCSP diff = (X - x_old) DCNL DCSP diff_norm = np.sqrt(np.sum((diff ** 2), axis=1)) DCNL DCSP mask = (diff_norm >= _EPSILON) DCNL DCSP is_x_old_in_X = int((mask.sum() < X.shape[0])) DCNL DCSP diff = diff[mask] DCNL DCSP diff_norm = diff_norm[mask][:, np.newaxis] DCNL DCSP quotient_norm = linalg.norm(np.sum((diff / diff_norm), axis=0)) DCNL DCSP if (quotient_norm > _EPSILON): DCNL DCSP  DCSP new_direction = (np.sum((X[mask, :] / diff_norm), axis=0) / np.sum((1 / diff_norm), axis=0)) DCNL DCSP else: DCNL DCSP  DCSP new_direction = 1.0 DCNL DCSP  DCSP quotient_norm = 1.0 DCNL DCSP return ((max(0.0, (1.0 - (is_x_old_in_X / quotient_norm))) * new_direction) + (min(1.0, (is_x_old_in_X / quotient_norm)) * x_old))
 DCSP if (not hasattr(req, 'best_match_language')): DCNL DCSP  DCSP return e DCNL DCSP locale = req.best_match_language() DCNL DCSP if isinstance(e, webob.exc.HTTPError): DCNL DCSP  DCSP e.explanation = i18n.translate(e.explanation, locale) DCNL DCSP  DCSP e.detail = i18n.translate(e.detail, locale) DCNL DCSP  DCSP if getattr(e, 'body_template', None): DCNL DCSP  DCSP  DCSP e.body_template = i18n.translate(e.body_template, locale) DCNL DCSP return e
 DCSP return uuid.uuid4().hex
 DCSP return time.time()
 DCSP would_be_changed = [] DCNL DCSP for package in packages: DCNL DCSP  DCSP (installed, updated) = query_package(module, xbps_path, package) DCNL DCSP  DCSP if (((state in ['present', 'latest']) and (not installed)) or ((state == 'absent') and installed) or ((state == 'latest') and (not updated))): DCNL DCSP  DCSP  DCSP would_be_changed.append(package) DCNL DCSP if would_be_changed: DCNL DCSP  DCSP if (state == 'absent'): DCNL DCSP  DCSP  DCSP state = 'removed' DCNL DCSP  DCSP module.exit_json(changed=True, msg=('%s DCSP package(s) DCSP would DCSP be DCSP %s' % (len(would_be_changed), state)), packages=would_be_changed) DCNL DCSP else: DCNL DCSP  DCSP module.exit_json(changed=False, msg=('package(s) DCSP already DCSP %s' % state), packages=[])
 DCSP for d in frappe.get_all(u'Daily DCSP Work DCSP Summary', dict(status=u'Open')): DCNL DCSP  DCSP daily_work_summary = frappe.get_doc(u'Daily DCSP Work DCSP Summary', d.name) DCNL DCSP  DCSP daily_work_summary.send_summary()
 DCSP if (provider in drivers): DCNL DCSP  DCSP raise AttributeError(('Provider DCSP %s DCSP already DCSP registered' % provider)) DCNL DCSP drivers[provider] = (module, klass) DCNL DCSP try: DCNL DCSP  DCSP driver = get_driver(drivers, provider) DCNL DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP exp = sys.exc_info()[1] DCNL DCSP  DCSP drivers.pop(provider) DCNL DCSP  DCSP raise exp DCNL DCSP return driver
 DCSP return str(tablename)
 DCSP splitLine = line.split() DCNL DCSP return Vector3(float(splitLine[1]), float(splitLine[2]), float(splitLine[3]))
 DCSP flags = [] DCNL DCSP TCP_FIN = 1 DCNL DCSP TCP_SYN = 2 DCNL DCSP TCP_RST = 4 DCNL DCSP TCP_PSH = 8 DCNL DCSP TCP_ACK = 16 DCNL DCSP TCP_URG = 32 DCNL DCSP TCP_ECE = 64 DCNL DCSP TCP_CWK = 128 DCNL DCSP if (packet['tcp']['flags'] & TCP_FIN): DCNL DCSP  DCSP flags.append('FIN') DCNL DCSP elif (packet['tcp']['flags'] & TCP_SYN): DCNL DCSP  DCSP flags.append('SYN') DCNL DCSP elif (packet['tcp']['flags'] & TCP_RST): DCNL DCSP  DCSP flags.append('RST') DCNL DCSP elif (packet['tcp']['flags'] & TCP_PSH): DCNL DCSP  DCSP flags.append('PSH') DCNL DCSP elif (packet['tcp']['flags'] & TCP_ACK): DCNL DCSP  DCSP flags.append('ACK') DCNL DCSP elif (packet['tcp']['flags'] & TCP_URG): DCNL DCSP  DCSP flags.append('URG') DCNL DCSP elif (packet['tcp']['flags'] & TCP_ECE): DCNL DCSP  DCSP flags.append('ECE') DCNL DCSP elif (packet['tcp']['flags'] & TCP_CWK): DCNL DCSP  DCSP flags.append('CWK') DCNL DCSP else: DCNL DCSP  DCSP print('UNKNOWN DCSP PACKET') DCNL DCSP if (packet['tcp']['d_port'] == 4505): DCNL DCSP  DCSP if (('SYN' in flags) and (len(flags) == 1)): DCNL DCSP  DCSP  DCSP return 10 DCNL DCSP  DCSP elif ('FIN' in flags): DCNL DCSP  DCSP  DCSP return 12 DCNL DCSP elif (packet['tcp']['d_port'] == 4506): DCNL DCSP  DCSP if (('SYN' in flags) and (len(flags) == 1)): DCNL DCSP  DCSP  DCSP return 100 DCNL DCSP  DCSP elif ('FIN' in flags): DCNL DCSP  DCSP  DCSP return 120 DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP keys = [] DCNL DCSP for i in request['item']: DCNL DCSP  DCSP if ('MemcacheSetRequest_Item' in i): DCNL DCSP  DCSP  DCSP key = i['MemcacheSetRequest_Item']['key'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key = i['Item']['key'] DCNL DCSP  DCSP keys.append(truncate(key)) DCNL DCSP return '\n'.join(keys)
 DCSP if isinstance(tck, BSpline): DCNL DCSP  DCSP return tck.antiderivative(n) DCNL DCSP else: DCNL DCSP  DCSP return _impl.splantider(tck, n)
 DCSP if tag: DCNL DCSP  DCSP return tag(context, objects) DCNL DCSP request = context['request'] DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format' in context): DCNL DCSP  DCSP response_format = context['response_format'] DCNL DCSP return Markup(render_to_string('core/tags/generic_list', {'objects': objects, 'skip_group': skip_group}, context_instance=RequestContext(request), response_format=response_format))
 DCSP if pf_interface: DCNL DCSP  DCSP return ('/sys/bus/pci/devices/%s/physfn/net' % pci_addr) DCNL DCSP return ('/sys/bus/pci/devices/%s/net' % pci_addr)
 DCSP t = desc.type DCNL DCSP if unpacker_coercions.has_key(t): DCNL DCSP  DCSP desc = desc.AECoerceDesc(unpacker_coercions[t]) DCNL DCSP  DCSP t = desc.type DCNL DCSP if (t == typeAEList): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for i in range(desc.AECountItems()): DCNL DCSP  DCSP  DCSP (keyword, item) = desc.AEGetNthDesc((i + 1), '****') DCNL DCSP  DCSP  DCSP l.append(unpack(item, formodulename)) DCNL DCSP  DCSP return l DCNL DCSP if (t == typeAERecord): DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP for i in range(desc.AECountItems()): DCNL DCSP  DCSP  DCSP (keyword, item) = desc.AEGetNthDesc((i + 1), '****') DCNL DCSP  DCSP  DCSP d[keyword] = unpack(item, formodulename) DCNL DCSP  DCSP return d DCNL DCSP if (t == typeAEText): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkaetext(unpack(record, formodulename)) DCNL DCSP if (t == typeAlias): DCNL DCSP  DCSP return Carbon.File.Alias(rawdata=desc.data) DCNL DCSP if (t == typeBoolean): DCNL DCSP  DCSP return struct.unpack('b', desc.data)[0] DCNL DCSP if (t == typeChar): DCNL DCSP  DCSP return desc.data DCNL DCSP if (t == typeUnicodeText): DCNL DCSP  DCSP return unicode(desc.data, 'utf16') DCNL DCSP if (t == typeEnumeration): DCNL DCSP  DCSP return mkenum(desc.data) DCNL DCSP if (t == typeFalse): DCNL DCSP  DCSP return 0 DCNL DCSP if (t == typeFloat): DCNL DCSP  DCSP data = desc.data DCNL DCSP  DCSP return struct.unpack('d', data)[0] DCNL DCSP if (t == typeFSS): DCNL DCSP  DCSP return Carbon.File.FSSpec(rawdata=desc.data) DCNL DCSP if (t == typeFSRef): DCNL DCSP  DCSP return Carbon.File.FSRef(rawdata=desc.data) DCNL DCSP if (t == typeInsertionLoc): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkinsertionloc(unpack(record, formodulename)) DCNL DCSP if (t == typeIntlText): DCNL DCSP  DCSP (script, language) = struct.unpack('hh', desc.data[:4]) DCNL DCSP  DCSP return aetypes.IntlText(script, language, desc.data[4:]) DCNL DCSP if (t == typeIntlWritingCode): DCNL DCSP  DCSP (script, language) = struct.unpack('hh', desc.data) DCNL DCSP  DCSP return aetypes.IntlWritingCode(script, language) DCNL DCSP if (t == typeKeyword): DCNL DCSP  DCSP return mkkeyword(desc.data) DCNL DCSP if (t == typeLongInteger): DCNL DCSP  DCSP return struct.unpack('l', desc.data)[0] DCNL DCSP if (t == typeLongDateTime): DCNL DCSP  DCSP (a, b) = struct.unpack('lL', desc.data) DCNL DCSP  DCSP return ((long(a) << 32) + b) DCNL DCSP if (t == typeNull): DCNL DCSP  DCSP return None DCNL DCSP if (t == typeMagnitude): DCNL DCSP  DCSP v = struct.unpack('l', desc.data) DCNL DCSP  DCSP if (v < 0): DCNL DCSP  DCSP  DCSP v = (4294967296L + v) DCNL DCSP  DCSP return v DCNL DCSP if (t == typeObjectSpecifier): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP if formodulename: DCNL DCSP  DCSP  DCSP return mkobjectfrommodule(unpack(record, formodulename), formodulename) DCNL DCSP  DCSP return mkobject(unpack(record, formodulename)) DCNL DCSP if (t == typeQDPoint): DCNL DCSP  DCSP (v, h) = struct.unpack('hh', desc.data) DCNL DCSP  DCSP return aetypes.QDPoint(v, h) DCNL DCSP if (t == typeQDRectangle): DCNL DCSP  DCSP (v0, h0, v1, h1) = struct.unpack('hhhh', desc.data) DCNL DCSP  DCSP return aetypes.QDRectangle(v0, h0, v1, h1) DCNL DCSP if (t == typeRGBColor): DCNL DCSP  DCSP (r, g, b) = struct.unpack('hhh', desc.data) DCNL DCSP  DCSP return aetypes.RGBColor(r, g, b) DCNL DCSP if (t == typeShortFloat): DCNL DCSP  DCSP return struct.unpack('f', desc.data)[0] DCNL DCSP if (t == typeShortInteger): DCNL DCSP  DCSP return struct.unpack('h', desc.data)[0] DCNL DCSP if (t == typeTargetID): DCNL DCSP  DCSP return mktargetid(desc.data) DCNL DCSP if (t == typeTrue): DCNL DCSP  DCSP return 1 DCNL DCSP if (t == typeType): DCNL DCSP  DCSP return mktype(desc.data, formodulename) DCNL DCSP if (t == 'rang'): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkrange(unpack(record, formodulename)) DCNL DCSP if (t == 'cmpd'): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkcomparison(unpack(record, formodulename)) DCNL DCSP if (t == 'logi'): DCNL DCSP  DCSP record = desc.AECoerceDesc('reco') DCNL DCSP  DCSP return mklogical(unpack(record, formodulename)) DCNL DCSP return mkunknown(desc.type, desc.data)
 DCSP return [transl[l] for l in labels]
 DCSP mask = ','.join(mask) DCNL DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP status = _check_cron(user, path, mask, cmd) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP if (status == 'absent'): DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP is DCSP absent'.format(name) DCNL DCSP  DCSP elif ((status == 'present') or (status == 'update')): DCNL DCSP  DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP removed'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP data = __salt__['incron.rm_job'](user=user, path=path, mask=mask, cmd=cmd) DCNL DCSP if (data == 'absent'): DCNL DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP already DCSP absent'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if (data == 'removed'): DCNL DCSP  DCSP ret['comment'] = "Incron DCSP {0} DCSP removed DCSP from DCSP {1}'s DCSP crontab".format(name, user) DCNL DCSP  DCSP ret['changes'] = {user: name} DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = 'Incron DCSP {0} DCSP for DCSP user DCSP {1} DCSP failed DCSP to DCSP commit DCSP with DCSP error DCSP {2}'.format(name, user, data) DCNL DCSP ret['result'] = False DCNL DCSP return ret
 DCSP return _list_users()
 DCSP import inspect DCNL DCSP if isinstance(frame, six.string_types): DCNL DCSP  DCSP frame_names = frame_transform_graph.get_names() DCNL DCSP  DCSP if (frame not in frame_names): DCNL DCSP  DCSP  DCSP raise ValueError(u'Coordinate DCSP frame DCSP {0} DCSP not DCSP in DCSP allowed DCSP values DCSP {1}'.format(frame, sorted(frame_names))) DCNL DCSP  DCSP frame_cls = frame_transform_graph.lookup_name(frame) DCNL DCSP elif (inspect.isclass(frame) and issubclass(frame, BaseCoordinateFrame)): DCNL DCSP  DCSP frame_cls = frame DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u'Coordinate DCSP frame DCSP must DCSP be DCSP a DCSP frame DCSP name DCSP or DCSP frame DCSP class') DCNL DCSP return frame_cls
 DCSP while u: DCNL DCSP  DCSP f = dmp_TC(f, K) DCNL DCSP  DCSP u -= 1 DCNL DCSP return dup_TC(f, K)
 DCSP cur_chromosome = BasicChromosome.Chromosome(chr_name) DCNL DCSP num_segments = random.randrange(num_possible_segments) DCNL DCSP for seg in range(num_segments): DCNL DCSP  DCSP if (seg == 0): DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.TelomereSegment() DCNL DCSP  DCSP elif (seg == (num_segments - 1)): DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.TelomereSegment(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.ChromosomeSegment() DCNL DCSP  DCSP color_chance = random.random() DCNL DCSP  DCSP if (color_chance <= color_prob): DCNL DCSP  DCSP  DCSP fill_color = random.choice(color_choices) DCNL DCSP  DCSP  DCSP cur_segment.fill_color = fill_color DCNL DCSP  DCSP id_chance = random.random() DCNL DCSP  DCSP if (id_chance <= id_prob): DCNL DCSP  DCSP  DCSP id = get_random_id() DCNL DCSP  DCSP  DCSP cur_segment.label = id DCNL DCSP  DCSP cur_chromosome.add(cur_segment) DCNL DCSP return (cur_chromosome, num_segments)
 DCSP imdb = datasets.pascal_voc(split, year) DCNL DCSP imdb.roidb_handler = imdb.selective_search_IJCV_roidb DCNL DCSP imdb.config['top_k'] = top_k DCNL DCSP return imdb
 DCSP if opts['file_ignore_regex']: DCNL DCSP  DCSP for regex in opts['file_ignore_regex']: DCNL DCSP  DCSP  DCSP if re.search(regex, fname): DCNL DCSP  DCSP  DCSP  DCSP log.debug('File DCSP matching DCSP file_ignore_regex. DCSP Skipping: DCSP {0}'.format(fname)) DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP if opts['file_ignore_glob']: DCNL DCSP  DCSP for glob in opts['file_ignore_glob']: DCNL DCSP  DCSP  DCSP if fnmatch.fnmatch(fname, glob): DCNL DCSP  DCSP  DCSP  DCSP log.debug('File DCSP matching DCSP file_ignore_glob. DCSP Skipping: DCSP {0}'.format(fname)) DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP msg = u'{0} DCSP Assuming DCSP UT1-UTC=0 DCSP for DCSP coordinate DCSP transformations.' DCNL DCSP warnings.warn(msg.format(ierserr.args[0]), AstropyWarning)
 DCSP axis = _normalize_axis(axis, ndim(x)) DCNL DCSP if (x.dtype.base_dtype == tf.bool): DCNL DCSP  DCSP x = tf.cast(x, floatx()) DCNL DCSP return tf.reduce_mean(x, reduction_indices=axis, keep_dims=keepdims)
 DCSP src_from = _ensure_src(src_from) DCNL DCSP subject_from = _ensure_src_subject(src_from, subject_from) DCNL DCSP subjects_dir = get_subjects_dir(subjects_dir, raise_error=True) DCNL DCSP src_out = list() DCNL DCSP for fro in src_from: DCNL DCSP  DCSP (hemi, idx, id_) = _get_hemi(fro) DCNL DCSP  DCSP to = op.join(subjects_dir, subject_to, 'surf', ('%s.%s' % (hemi, surf))) DCNL DCSP  DCSP logger.info(('Reading DCSP destination DCSP surface DCSP %s' % (to,))) DCNL DCSP  DCSP to = read_surface(to, return_dict=True, verbose=False)[(-1)] DCNL DCSP  DCSP complete_surface_info(to, copy=False) DCNL DCSP  DCSP best = _get_vertex_map_nn(fro, subject_from, subject_to, hemi, subjects_dir, to['neighbor_tri']) DCNL DCSP  DCSP for key in ('neighbor_tri', 'tri_area', 'tri_cent', 'tri_nn', 'use_tris'): DCNL DCSP  DCSP  DCSP del to[key] DCNL DCSP  DCSP to['vertno'] = np.sort(best[fro['vertno']]) DCNL DCSP  DCSP to['inuse'] = np.zeros(len(to['rr']), int) DCNL DCSP  DCSP to['inuse'][to['vertno']] = True DCNL DCSP  DCSP to['use_tris'] = best[fro['use_tris']] DCNL DCSP  DCSP to.update(nuse=len(to['vertno']), nuse_tri=len(to['use_tris']), nearest=None, nearest_dist=None, patch_inds=None, pinfo=None, dist=None, id=id_, dist_limit=None, type='surf', coord_frame=FIFF.FIFFV_COORD_MRI, subject_his_id=subject_to, rr=(to['rr'] / 1000.0)) DCNL DCSP  DCSP src_out.append(to) DCNL DCSP  DCSP logger.info('[done]\n') DCNL DCSP info = dict(working_dir=os.getcwd(), command_line=_get_call_line(in_verbose=True)) DCNL DCSP return SourceSpaces(src_out, info=info)
 DCSP encoding = kwds.get('encoding', None) DCNL DCSP if (encoding is not None): DCNL DCSP  DCSP encoding = re.sub('_', '-', encoding).lower() DCNL DCSP  DCSP kwds['encoding'] = encoding DCNL DCSP compression = kwds.get('compression') DCNL DCSP compression = _infer_compression(filepath_or_buffer, compression) DCNL DCSP (filepath_or_buffer, _, compression) = get_filepath_or_buffer(filepath_or_buffer, encoding, compression) DCNL DCSP kwds['compression'] = compression DCNL DCSP if (kwds.get('date_parser', None) is not None): DCNL DCSP  DCSP if isinstance(kwds['parse_dates'], bool): DCNL DCSP  DCSP  DCSP kwds['parse_dates'] = True DCNL DCSP iterator = kwds.get('iterator', False) DCNL DCSP chunksize = kwds.get('chunksize', None) DCNL DCSP nrows = _validate_nrows(kwds.pop('nrows', None)) DCNL DCSP parser = TextFileReader(filepath_or_buffer, **kwds) DCNL DCSP if ((nrows is not None) and (chunksize is not None)): DCNL DCSP  DCSP raise NotImplementedError("'nrows' DCSP and DCSP 'chunksize' DCSP cannot DCSP be DCSP used DCSP together DCSP yet.") DCNL DCSP elif (nrows is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = parser.read(nrows) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP parser.close() DCNL DCSP  DCSP return data DCNL DCSP elif (chunksize or iterator): DCNL DCSP  DCSP return parser DCNL DCSP try: DCNL DCSP  DCSP data = parser.read() DCNL DCSP finally: DCNL DCSP  DCSP parser.close() DCNL DCSP return data
 DCSP (tags, noserver) = read_etag_file(options) DCNL DCSP if (noserver and (not options.noserver)): DCNL DCSP  DCSP options.noserver = noserver DCNL DCSP m = re.match('(?:W/)?"?(.*)"?$', options.etag) DCNL DCSP if m: DCNL DCSP  DCSP options.etag = m.group(1) DCNL DCSP etag = options.etag DCNL DCSP if (etag in tags): DCNL DCSP  DCSP print ('Found DCSP etag DCSP [%s] DCSP for DCSP version DCSP %s' % (etag, tags[etag][0]['version'])) DCNL DCSP  DCSP return tags[etag] DCNL DCSP short = etag[etag.index('-'):] DCNL DCSP for t in tags: DCNL DCSP  DCSP if (t.find(short) != (-1)): DCNL DCSP  DCSP  DCSP print ('Partial DCSP ETag DCSP match: DCSP [%s],[%s] DCSP for DCSP version DCSP %s' % (etag, t, tags[t][0]['version'])) DCNL DCSP  DCSP  DCSP return tags[t] DCNL DCSP return None
 DCSP if (get_configured_provider() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_dependencies() is False): DCNL DCSP  DCSP return False DCNL DCSP for (provider, details) in six.iteritems(__opts__['providers']): DCNL DCSP  DCSP if ('dimensiondata' not in details): DCNL DCSP  DCSP  DCSP continue DCNL DCSP return __virtualname__
 DCSP R = p.ring DCNL DCSP n = R.gens.index(x) DCNL DCSP p1 = R.zero DCNL DCSP mn = ([0] * R.ngens) DCNL DCSP mn[n] = 1 DCNL DCSP mn = tuple(mn) DCNL DCSP for expv in p: DCNL DCSP  DCSP if expv[n]: DCNL DCSP  DCSP  DCSP e = monomial_ldiv(expv, mn) DCNL DCSP  DCSP  DCSP p1[e] = (p[expv] * expv[n]) DCNL DCSP return p1
 DCSP if (pkg in _bootstrapped): DCNL DCSP  DCSP return [] DCNL DCSP m = rospack.get_manifest(pkg) DCNL DCSP if m.is_catkin: DCNL DCSP  DCSP _bootstrapped.append(pkg) DCNL DCSP  DCSP return [] DCNL DCSP packages = get_depends(pkg, rospack) DCNL DCSP packages.append(pkg) DCNL DCSP paths = [] DCNL DCSP try: DCNL DCSP  DCSP for p in packages: DCNL DCSP  DCSP  DCSP m = rospack.get_manifest(p) DCNL DCSP  DCSP  DCSP d = rospack.get_path(p) DCNL DCSP  DCSP  DCSP _append_package_paths(m, paths, d) DCNL DCSP  DCSP  DCSP _bootstrapped.append(p) DCNL DCSP except: DCNL DCSP  DCSP if (pkg in _bootstrapped): DCNL DCSP  DCSP  DCSP _bootstrapped.remove(pkg) DCNL DCSP  DCSP raise DCNL DCSP return paths
 DCSP (procs, pipes) = launch_tails(follow_paths, lastlines_dirpath) DCNL DCSP while pipes: DCNL DCSP  DCSP (lines, bad_pipes) = poll_tail_pipes(pipes, lastlines_dirpath, waitsecs) DCNL DCSP  DCSP for bad in bad_pipes: DCNL DCSP  DCSP  DCSP pipes.pop(bad) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP outstream.writelines((['\n'] + lines)) DCNL DCSP  DCSP  DCSP outstream.flush() DCNL DCSP  DCSP except (IOError, OSError) as e: DCNL DCSP  DCSP  DCSP break DCNL DCSP snuff(procs.values())
 DCSP if (not isinstance(data, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|failed DCSP expects DCSP to DCSP filter DCSP on DCSP a DCSP list') DCNL DCSP if (not isinstance(keys, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|failed DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list') DCNL DCSP retval = [oo_select_keys(item, keys) for item in data] DCNL DCSP return oo_flatten(retval)
 DCSP user = urllib.unquote(user) DCNL DCSP sys.stderr.write((((('checking DCSP permissions DCSP for DCSP user DCSP ' + user) + ' DCSP on DCSP api DCSP ') + api_name) + '\n')) DCNL DCSP secret_file = open('/etc/appscale/secret.key', 'r') DCNL DCSP secret = secret_file.read() DCNL DCSP secret = secret[0:(-1)] DCNL DCSP secret_file.close() DCNL DCSP uaserver_file = open('/etc/appscale/hypersoap', 'r') DCNL DCSP uaserver = uaserver_file.read() DCNL DCSP uaserver_file.close() DCNL DCSP server = SOAPpy.SOAPProxy((('https://' + uaserver) + ':4343')) DCNL DCSP capabilities = server.get_capabilities(user, secret) DCNL DCSP if (not isinstance(capabilities, str)): DCNL DCSP  DCSP return False DCNL DCSP capabilities = capabilities.split(':') DCNL DCSP sys.stderr.write((((('user DCSP ' + user) + ' DCSP has DCSP the DCSP following DCSP capabilities: DCSP ') + str(capabilities)) + '\n')) DCNL DCSP if (api_name in capabilities): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
 DCSP if any([getattr(c.op, 'check_input', config.check_input) for (c, _) in r.clients if (not isinstance(c, string_types))]): DCNL DCSP  DCSP if any([getattr(c.op, 'check_broadcast', True) for (c, _) in r.clients if (not isinstance(c, string_types))]): DCNL DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True, check_broadcast=False) DCNL DCSP  DCSP  DCSP except TypeError as e: DCNL DCSP  DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True) DCNL DCSP else: DCNL DCSP  DCSP c_extract = r.type.c_extract(name, sub, False) DCNL DCSP pre = ('\n DCSP  DCSP  DCSP  DCSP py_%(name)s DCSP = DCSP PyList_GET_ITEM(storage_%(name)s, DCSP 0);\n DCSP  DCSP  DCSP  DCSP {Py_XINCREF(py_%(name)s);}\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP return (pre + c_extract)
 DCSP return ' DCSP '.join(map(_stringify, value))
 DCSP ctx = zmq.Context.instance() DCNL DCSP s = ctx.socket(zmq.PUSH) DCNL DCSP s.connect(url) DCNL DCSP print(('Producing DCSP %s' % ident)) DCNL DCSP for i in range(MSGS): DCNL DCSP  DCSP s.send((u'%s: DCSP %i' % (ident, time.time())).encode('utf8')) DCNL DCSP  DCSP time.sleep(1) DCNL DCSP print(('Producer DCSP %s DCSP done' % ident)) DCNL DCSP s.close()
 DCSP closestIndex = getClosestDistanceIndexToLine(location, loop).index DCNL DCSP loop = getAroundLoop(closestIndex, closestIndex, loop) DCNL DCSP closestPoint = getClosestPointOnSegment(loop[0], loop[1], location) DCNL DCSP if ((abs((closestPoint - loop[0])) > extrusionHalfWidth) and (abs((closestPoint - loop[1])) > extrusionHalfWidth)): DCNL DCSP  DCSP loop = (([closestPoint] + loop[1:]) + [loop[0]]) DCNL DCSP elif (abs((closestPoint - loop[0])) > abs((closestPoint - loop[1]))): DCNL DCSP  DCSP loop = (loop[1:] + [loop[0]]) DCNL DCSP return loop
 DCSP if is_plotting: DCNL DCSP  DCSP v = 'Plotting' DCNL DCSP else: DCNL DCSP  DCSP v = 'Registering DCSP plot DCSP modes' DCNL DCSP if is_independent: DCNL DCSP  DCSP (n, s) = (PlotMode._i_var_max, 'independent') DCNL DCSP else: DCNL DCSP  DCSP (n, s) = (PlotMode._d_var_max, 'dependent') DCNL DCSP return ('%s DCSP with DCSP more DCSP than DCSP %i DCSP %s DCSP variables DCSP is DCSP not DCSP supported.' % (v, n, s))
 DCSP if (len(xs) != len(ys)): DCNL DCSP  DCSP raise ValueError('xs DCSP and DCSP ys DCSP should DCSP be DCSP the DCSP same DCSP length.') DCNL DCSP classes = set(ys) DCNL DCSP if (classes != set([0, 1])): DCNL DCSP  DCSP raise ValueError("Classes DCSP should DCSP be DCSP 0's DCSP and DCSP 1's") DCNL DCSP if (typecode is None): DCNL DCSP  DCSP typecode = 'd' DCNL DCSP (N, ndims) = (len(xs), (len(xs[0]) + 1)) DCNL DCSP if ((N == 0) or (ndims == 1)): DCNL DCSP  DCSP raise ValueError('No DCSP observations DCSP or DCSP observation DCSP of DCSP 0 DCSP dimension.') DCNL DCSP X = numpy.ones((N, ndims), typecode) DCNL DCSP X[:, 1:] = xs DCNL DCSP Xt = numpy.transpose(X) DCNL DCSP y = numpy.asarray(ys, typecode) DCNL DCSP beta = numpy.zeros(ndims, typecode) DCNL DCSP MAX_ITERATIONS = 500 DCNL DCSP CONVERGE_THRESHOLD = 0.01 DCNL DCSP stepsize = 1.0 DCNL DCSP i = 0 DCNL DCSP old_beta = old_llik = None DCNL DCSP while (i < MAX_ITERATIONS): DCNL DCSP  DCSP ebetaX = numpy.exp(numpy.dot(beta, Xt)) DCNL DCSP  DCSP p = (ebetaX / (1 + ebetaX)) DCNL DCSP  DCSP logp = ((y * numpy.log(p)) + ((1 - y) * numpy.log((1 - p)))) DCNL DCSP  DCSP llik = sum(logp) DCNL DCSP  DCSP if (update_fn is not None): DCNL DCSP  DCSP  DCSP update_fn(iter, llik) DCNL DCSP  DCSP if (old_llik is not None): DCNL DCSP  DCSP  DCSP if (llik < old_llik): DCNL DCSP  DCSP  DCSP  DCSP stepsize /= 2.0 DCNL DCSP  DCSP  DCSP  DCSP beta = old_beta DCNL DCSP  DCSP  DCSP if (numpy.fabs((llik - old_llik)) <= CONVERGE_THRESHOLD): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP (old_llik, old_beta) = (llik, beta) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP W = (numpy.identity(N) * p) DCNL DCSP  DCSP Xtyp = numpy.dot(Xt, (y - p)) DCNL DCSP  DCSP XtWX = numpy.dot(numpy.dot(Xt, W), X) DCNL DCSP  DCSP delta = numpy.linalg.solve(XtWX, Xtyp) DCNL DCSP  DCSP if (numpy.fabs((stepsize - 1.0)) > 0.001): DCNL DCSP  DCSP  DCSP delta *= stepsize DCNL DCSP  DCSP beta += delta DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError("Didn't DCSP converge.") DCNL DCSP lr = LogisticRegression() DCNL DCSP lr.beta = [float(x) for x in beta] DCNL DCSP return lr
 DCSP response = _client_wrapper('create_volume', name, driver=driver, driver_opts=driver_opts) DCNL DCSP _clear_context() DCNL DCSP return response
 DCSP linter.register_reporter(HTMLReporter)
 DCSP (i, j) = np.mgrid[(-5):6, (-5):6] DCNL DCSP image = (j >= 0).astype(float) DCNL DCSP result = filters.scharr_v(image) DCNL DCSP j[(np.abs(i) == 5)] = 10000 DCNL DCSP assert np.all((result[(j == 0)] == 1)) DCNL DCSP assert np.all((result[(np.abs(j) > 1)] == 0))
 DCSP try: DCNL DCSP  DCSP source = open(filename).readlines() DCNL DCSP  DCSP lower_bound = max(0, (lineno - context_lines)) DCNL DCSP  DCSP upper_bound = (lineno + context_lines) DCNL DCSP  DCSP pre_context = [line.strip('\n') for line in source[lower_bound:lineno]] DCNL DCSP  DCSP context_line = source[lineno].strip('\n') DCNL DCSP  DCSP post_context = [line.strip('\n') for line in source[(lineno + 1):upper_bound]] DCNL DCSP  DCSP return (lower_bound, pre_context, context_line, post_context) DCNL DCSP except (OSError, IOError): DCNL DCSP  DCSP return (None, [], None, [])
 DCSP parser = OptionParser(usage=u'%prog DCSP name DCSP [options]', version=(u'Review DCSP Board DCSP ' + get_version_string())) DCNL DCSP parser.add_option(u'--class-name', dest=u'class_name', default=None, help=u'class DCSP name DCSP of DCSP extension DCSP (capitalized DCSP no DCSP spaces)') DCNL DCSP parser.add_option(u'--package-name', dest=u'package_name', default=None, help=u'package DCSP name DCSP of DCSP extension DCSP (lower DCSP case DCSP with DCSP underscores)') DCNL DCSP parser.add_option(u'--description', dest=u'description', default=None, help=u'description DCSP of DCSP extension') DCNL DCSP parser.add_option(u'--author', dest=u'author', default=None, help=u'author DCSP of DCSP the DCSP extension') DCNL DCSP parser.add_option(u'--is-configurable', dest=u'is_configurable', action=u'store_true', default=False, help=u'whether DCSP this DCSP extension DCSP is DCSP configurable') DCNL DCSP (globals()[u'options'], args) = parser.parse_args() DCNL DCSP if (len(args) != 1): DCNL DCSP  DCSP print(u'Error: DCSP incorrect DCSP number DCSP of DCSP arguments') DCNL DCSP  DCSP parser.print_help() DCNL DCSP  DCSP exit((-1)) DCNL DCSP options.extension_name = args[0] DCNL DCSP autofill_unprovided_options()
 DCSP version_re = re.compile('^LATEST_LIBXML2_IS_(.*)$') DCNL DCSP filename = 'libxml2-%s.tar.gz' DCNL DCSP return download_library(dest_dir, LIBXML2_LOCATION, 'libxml2', version_re, filename, version=version)
 DCSP if (push_notification_enabled() and update.get('push_notification_selected')): DCNL DCSP  DCSP course = modulestore().get_course(course_key) DCNL DCSP  DCSP if course: DCNL DCSP  DCSP  DCSP push_course_update_task.delay(unicode(course_key), course.clean_id(padding_char='_'), course.display_name)
 DCSP paths_dict = dict(paths) DCNL DCSP def os_walk(top, topdown=True): DCNL DCSP  DCSP (dirs, nondirs) = paths_dict[top] DCNL DCSP  DCSP (yield (top, dirs, nondirs)) DCNL DCSP  DCSP for name in dirs: DCNL DCSP  DCSP  DCSP new_path = '/'.join([top, name]) DCNL DCSP  DCSP  DCSP for x in os_walk(new_path, topdown): DCNL DCSP  DCSP  DCSP  DCSP (yield x) DCNL DCSP return os_walk
 DCSP output = [''] DCNL DCSP widget_lines = _get_widgets() DCNL DCSP widget_lines = [(' DCSP  DCSP  DCSP  DCSP ' + e) for e in widget_lines] DCNL DCSP widget_lines.insert(0, 'Qt DCSP widgets DCSP - DCSP {} DCSP objects:'.format(len(widget_lines))) DCNL DCSP output += widget_lines DCNL DCSP if (start_obj is None): DCNL DCSP  DCSP start_obj = QApplication.instance() DCNL DCSP pyqt_lines = [] DCNL DCSP _get_pyqt_objects(pyqt_lines, start_obj) DCNL DCSP pyqt_lines = [(' DCSP  DCSP  DCSP  DCSP ' + e) for e in pyqt_lines] DCNL DCSP pyqt_lines.insert(0, 'Qt DCSP objects DCSP - DCSP {} DCSP objects:'.format(len(pyqt_lines))) DCNL DCSP output += [''] DCNL DCSP output += pyqt_lines DCNL DCSP output += objreg.dump_objects() DCNL DCSP return '\n'.join(output)
 DCSP if ('display_name' in param_dict): DCNL DCSP  DCSP param_dict['course_name'] = param_dict['display_name'] DCNL DCSP param_dict['site_name'] = configuration_helpers.get_value('SITE_NAME', param_dict['site_name']) DCNL DCSP subject = None DCNL DCSP message = None DCNL DCSP message_type = param_dict['message'] DCNL DCSP email_template_dict = {'allowed_enroll': ('emails/enroll_email_allowedsubject.txt', 'emails/enroll_email_allowedmessage.txt'), 'enrolled_enroll': ('emails/enroll_email_enrolledsubject.txt', 'emails/enroll_email_enrolledmessage.txt'), 'allowed_unenroll': ('emails/unenroll_email_subject.txt', 'emails/unenroll_email_allowedmessage.txt'), 'enrolled_unenroll': ('emails/unenroll_email_subject.txt', 'emails/unenroll_email_enrolledmessage.txt'), 'add_beta_tester': ('emails/add_beta_tester_email_subject.txt', 'emails/add_beta_tester_email_message.txt'), 'remove_beta_tester': ('emails/remove_beta_tester_email_subject.txt', 'emails/remove_beta_tester_email_message.txt'), 'account_creation_and_enrollment': ('emails/enroll_email_enrolledsubject.txt', 'emails/account_creation_and_enroll_emailMessage.txt')} DCNL DCSP (subject_template, message_template) = email_template_dict.get(message_type, (None, None)) DCNL DCSP if ((subject_template is not None) and (message_template is not None)): DCNL DCSP  DCSP (subject, message) = render_message_to_string(subject_template, message_template, param_dict, language=language) DCNL DCSP if (subject and message): DCNL DCSP  DCSP message = message.strip() DCNL DCSP  DCSP subject = ''.join(subject.splitlines()) DCNL DCSP  DCSP from_address = configuration_helpers.get_value('email_from_address', settings.DEFAULT_FROM_EMAIL) DCNL DCSP  DCSP send_mail(subject, message, from_address, [student], fail_silently=False)
 DCSP return os.path.join(autodir, 'results', 'default', 'debug', 'client.DEBUG')
 DCSP return check_call(cmd, shell=True)
 DCSP attr = exc.kwargs.get('attr') DCNL DCSP state = exc.kwargs.get('state') DCNL DCSP if ((attr is not None) and (state is not None)): DCNL DCSP  DCSP msg = (_("Cannot DCSP '%(action)s' DCSP instance DCSP %(server_id)s DCSP while DCSP it DCSP is DCSP in DCSP %(attr)s DCSP %(state)s") % {'action': action, 'attr': attr, 'state': state, 'server_id': server_id}) DCNL DCSP else: DCNL DCSP  DCSP msg = (_("Instance DCSP %(server_id)s DCSP is DCSP in DCSP an DCSP invalid DCSP state DCSP for DCSP '%(action)s'") % {'action': action, 'server_id': server_id}) DCNL DCSP raise webob.exc.HTTPConflict(explanation=msg)
 DCSP if (start < end): DCNL DCSP  DCSP p = choosePivot(start, end) DCNL DCSP  DCSP (a[start], a[p]) = (a[p], a[start]) DCNL DCSP  DCSP j = partition(a, start, end) DCNL DCSP  DCSP if (j == i): DCNL DCSP  DCSP  DCSP return a[i] DCNL DCSP  DCSP if (j < i): DCNL DCSP  DCSP  DCSP return random_selection(a, (j + 1), end, i) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return random_selection(a, start, (j - 1), i) DCNL DCSP else: DCNL DCSP  DCSP return a[start]
 DCSP parser = OptionParser() DCNL DCSP parser.add_option('-d', '--days', dest='days', action='store', type='int', help='number DCSP of DCSP days DCSP (14)', default=14) DCNL DCSP parser.add_option('-i', '--info_only', action='store_true', dest='info_only', help='info DCSP about DCSP the DCSP requested DCSP action', default=False) DCNL DCSP parser.add_option('-v', '--verbose', action='store_true', dest='verbose', help='verbose DCSP mode, DCSP print DCSP the DCSP name DCSP of DCSP each DCSP repository', default=False) DCNL DCSP (options, args) = parser.parse_args() DCNL DCSP try: DCNL DCSP  DCSP ini_file = args[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP sys.exit(('Usage: DCSP python DCSP %s DCSP <tool DCSP shed DCSP .ini DCSP file> DCSP [options]' % sys.argv[0])) DCNL DCSP config_parser = ConfigParser.ConfigParser({'here': os.getcwd()}) DCNL DCSP config_parser.read(ini_file) DCNL DCSP config_dict = {} DCNL DCSP for (key, value) in config_parser.items('app:main'): DCNL DCSP  DCSP config_dict[key] = value DCNL DCSP config = tool_shed_config.Configuration(**config_dict) DCNL DCSP app = DeprecateRepositoriesApplication(config) DCNL DCSP cutoff_time = (datetime.utcnow() - timedelta(days=options.days)) DCNL DCSP now = strftime('%Y-%m-%d DCSP %H:%M:%S') DCNL DCSP print '\n####################################################################################' DCNL DCSP print ('# DCSP %s DCSP - DCSP Handling DCSP stuff DCSP older DCSP than DCSP %i DCSP days' % (now, options.days)) DCNL DCSP if options.info_only: DCNL DCSP  DCSP print '# DCSP Displaying DCSP info DCSP only DCSP ( DCSP --info_only DCSP )' DCNL DCSP deprecate_repositories(app, cutoff_time, days=options.days, info_only=options.info_only, verbose=options.verbose)
 DCSP if (not isinstance(package, string_types)): DCNL DCSP  DCSP raise ValueError DCNL DCSP (pkg_base, pkg_dir) = get_package_paths(package) DCNL DCSP if subdir: DCNL DCSP  DCSP pkg_dir = os.path.join(pkg_dir, subdir) DCNL DCSP datas = [] DCNL DCSP for (dirpath, dirnames, files) in os.walk(pkg_dir): DCNL DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP extension = os.path.splitext(f)[1] DCNL DCSP  DCSP  DCSP if (include_py_files or (extension not in PY_IGNORE_EXTENSIONS)): DCNL DCSP  DCSP  DCSP  DCSP source = os.path.join(dirpath, f) DCNL DCSP  DCSP  DCSP  DCSP dest = remove_prefix(dirpath, (os.path.dirname(pkg_base) + os.sep)) DCNL DCSP  DCSP  DCSP  DCSP datas.append((source, dest)) DCNL DCSP return datas
 DCSP salt = _make_salt() DCNL DCSP return _encrypt(salt, plaintext, g.tracking_secret)
 DCSP referrers = [] DCNL DCSP groups = [] DCNL DCSP if acl_string: DCNL DCSP  DCSP for value in acl_string.split(','): DCNL DCSP  DCSP  DCSP if value.startswith('.r:'): DCNL DCSP  DCSP  DCSP  DCSP referrers.append(value[len('.r:'):]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups.append(value) DCNL DCSP return (referrers, groups)
 DCSP proc = popen_sp(*args, **kwargs) DCNL DCSP if proc.stdin: DCNL DCSP  DCSP proc.stdin = pipebuf.NonBlockBufferedWriter(proc.stdin) DCNL DCSP if proc.stdout: DCNL DCSP  DCSP proc.stdout = pipebuf.NonBlockBufferedReader(proc.stdout) DCNL DCSP if proc.stderr: DCNL DCSP  DCSP proc.stderr = pipebuf.NonBlockBufferedReader(proc.stderr) DCNL DCSP return proc
 DCSP if (not f): DCNL DCSP  DCSP return [] DCNL DCSP n = (len(f) - 1) DCNL DCSP (h, Q) = ([f[0]], [[K.one]]) DCNL DCSP for i in range(0, n): DCNL DCSP  DCSP Q.append(dup_mul(Q[(-1)], q, K)) DCNL DCSP for (c, q) in zip(f[1:], Q[1:]): DCNL DCSP  DCSP h = dup_mul(h, p, K) DCNL DCSP  DCSP q = dup_mul_ground(q, c, K) DCNL DCSP  DCSP h = dup_add(h, q, K) DCNL DCSP return h
 DCSP __connect() DCNL DCSP collection = mongodb[collection.collection_type()] DCNL DCSP data = collection.find_one({'name': item.name}) DCNL DCSP if data: DCNL DCSP  DCSP collection.update({'name': item.name}, item.to_dict()) DCNL DCSP else: DCNL DCSP  DCSP collection.insert(item.to_dict())
 DCSP return Serato(c_instance)
 DCSP if (request.function != 'fema'): DCNL DCSP  DCSP s3.filter = (FS('req_id$is_template') == False) DCNL DCSP def prep(r): DCNL DCSP  DCSP if (r.interactive or (r.representation == 'aadata')): DCNL DCSP  DCSP  DCSP list_fields = s3db.get_config('req_req_item', 'list_fields') DCNL DCSP  DCSP  DCSP list_fields.insert(1, 'req_id$site_id') DCNL DCSP  DCSP  DCSP levels = gis.get_relevant_hierarchy_levels() DCNL DCSP  DCSP  DCSP levels.reverse() DCNL DCSP  DCSP  DCSP for level in levels: DCNL DCSP  DCSP  DCSP  DCSP lfield = ('req_id$site_id$location_id$%s' % level) DCNL DCSP  DCSP  DCSP  DCSP list_fields.insert(1, lfield) DCNL DCSP  DCSP  DCSP s3db.configure('req_req_item', insertable=False, list_fields=list_fields) DCNL DCSP  DCSP  DCSP s3.crud_strings['req_req_item'].title_list = T('Requested DCSP Items') DCNL DCSP  DCSP  DCSP if ((r.method != None) and (r.method != 'update') and (r.method != 'read')): DCNL DCSP  DCSP  DCSP  DCSP s3db.req_hide_quantities(r.table) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller('req', 'req_item') DCNL DCSP if settings.get_req_prompt_match(): DCNL DCSP  DCSP req_item_inv_item_btn = dict(url=URL(c='req', f='req_item_inv_item', args=['[id]']), _class='action-btn', label=str(T('Request DCSP from DCSP Facility'))) DCNL DCSP  DCSP if s3.actions: DCNL DCSP  DCSP  DCSP s3.actions.append(req_item_inv_item_btn) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s3.actions = [req_item_inv_item_btn] DCNL DCSP return output
 DCSP if (not hostname): DCNL DCSP  DCSP raise CommandExecutionError('Missing DCSP hostname DCSP parameter') DCNL DCSP if (not service): DCNL DCSP  DCSP raise CommandExecutionError('Missing DCSP service DCSP parameter') DCNL DCSP target = 'service' DCNL DCSP numeric = kwargs.get('numeric') DCNL DCSP data = _status_query(target, hostname, service=service, enumerate=numeric) DCNL DCSP ret = {'result': data['result']} DCNL DCSP if ret['result']: DCNL DCSP  DCSP ret['status'] = data.get('json_data', {}).get('data', {}).get(target, {}).get('status', (((not numeric) and 'Unknown') or 2)) DCNL DCSP else: DCNL DCSP  DCSP ret['error'] = data['error'] DCNL DCSP return ret
 DCSP print problem.get_html()
 DCSP return request.current_route_url(*elements, **kw)
 DCSP import re DCNL DCSP newCode = code DCNL DCSP newCode = remove_comments(newCode) DCNL DCSP if ('function DCSP Invoke-ReflectivePEInjection' in newCode): DCNL DCSP  DCSP newCode = newCode.replace("$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', DCSP [UInt16] DCSP 0x0040) DCSP | DCSP Out-Null", "$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERIS'+'TICS_DYNAMIC_BASE', DCSP [UInt16] DCSP 0x0040) DCSP | DCSP Out-Null") DCNL DCSP return newCode
 DCSP buf = [] DCNL DCSP for line in ir.splitlines(): DCNL DCSP  DCSP if re_metadata_def.match(line): DCNL DCSP  DCSP  DCSP if (None is re_metadata_correct_usage.search(line)): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('!{', 'metadata DCSP !{') DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('!"', 'metadata DCSP !"') DCNL DCSP  DCSP  DCSP  DCSP def sub_metadata(m): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'metadata DCSP {0}'.format(m.group(0)) DCNL DCSP  DCSP  DCSP  DCSP line = re_metadata_ref.sub(sub_metadata, line) DCNL DCSP  DCSP  DCSP  DCSP line = line.lstrip('metadata DCSP ') DCNL DCSP  DCSP buf.append(line) DCNL DCSP return '\n'.join(buf)
 DCSP return ArrowFactory(type)
 DCSP def mbsize(x): DCNL DCSP  DCSP ' DCSP Return DCSP size DCSP in DCSP MB. DCSP ' DCNL DCSP  DCSP return str(int((x / (1024 ** 2)))) DCNL DCSP p = util.get_pafy(song) DCNL DCSP dldata = [] DCNL DCSP text = ' DCSP [Fetching DCSP stream DCSP info] DCSP >' DCNL DCSP streamlist = [x for x in p.allstreams] DCNL DCSP if (mediatype == 'audio'): DCNL DCSP  DCSP streamlist = [x for x in p.audiostreams] DCNL DCSP l = len(streamlist) DCNL DCSP for (n, stream) in enumerate(streamlist): DCNL DCSP  DCSP sys.stdout.write(((((text + ('-' * n)) + '>') + (' DCSP ' * ((l - n) - 1))) + '<\r')) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP size = mbsize(stream.get_filesize()) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP util.dbg(((c.r + '---Error DCSP getting DCSP stream DCSP size') + c.w)) DCNL DCSP  DCSP  DCSP size = 0 DCNL DCSP  DCSP item = {'mediatype': stream.mediatype, 'size': size, 'ext': stream.extension, 'quality': stream.quality, 'notes': stream.notes, 'url': stream.url} DCNL DCSP  DCSP dldata.append(item) DCNL DCSP screen.writestatus('') DCNL DCSP return (dldata, p)
 DCSP (algorithm_name, digestmod) = get_algorithm(algorithm) DCNL DCSP if first: DCNL DCSP  DCSP ctx = hmac.new(secret, digestmod=digestmod) DCNL DCSP  DCSP ml = len(request_mac) DCNL DCSP  DCSP if (ml > 0): DCNL DCSP  DCSP  DCSP ctx.update(struct.pack('!H', ml)) DCNL DCSP  DCSP  DCSP ctx.update(request_mac) DCNL DCSP id = struct.pack('!H', original_id) DCNL DCSP ctx.update(id) DCNL DCSP ctx.update(wire[2:]) DCNL DCSP if first: DCNL DCSP  DCSP ctx.update(keyname.to_digestable()) DCNL DCSP  DCSP ctx.update(struct.pack('!H', dns.rdataclass.ANY)) DCNL DCSP  DCSP ctx.update(struct.pack('!I', 0)) DCNL DCSP long_time = (time + 0L) DCNL DCSP upper_time = ((long_time >> 32) & 65535L) DCNL DCSP lower_time = (long_time & 4294967295L) DCNL DCSP time_mac = struct.pack('!HIH', upper_time, lower_time, fudge) DCNL DCSP pre_mac = (algorithm_name + time_mac) DCNL DCSP ol = len(other_data) DCNL DCSP if (ol > 65535): DCNL DCSP  DCSP raise ValueError('TSIG DCSP Other DCSP Data DCSP is DCSP > DCSP 65535 DCSP bytes') DCNL DCSP post_mac = (struct.pack('!HH', error, ol) + other_data) DCNL DCSP if first: DCNL DCSP  DCSP ctx.update(pre_mac) DCNL DCSP  DCSP ctx.update(post_mac) DCNL DCSP else: DCNL DCSP  DCSP ctx.update(time_mac) DCNL DCSP mac = ctx.digest() DCNL DCSP mpack = struct.pack('!H', len(mac)) DCNL DCSP tsig_rdata = ((((pre_mac + mpack) + mac) + id) + post_mac) DCNL DCSP if multi: DCNL DCSP  DCSP ctx = hmac.new(secret, digestmod=digestmod) DCNL DCSP  DCSP ml = len(mac) DCNL DCSP  DCSP ctx.update(struct.pack('!H', ml)) DCNL DCSP  DCSP ctx.update(mac) DCNL DCSP else: DCNL DCSP  DCSP ctx = None DCNL DCSP return (tsig_rdata, mac, ctx)
 DCSP document = {'errors': errors, 'jsonapi': {'version': JSONAPI_VERSION}} DCNL DCSP return (jsonpify(document), status)
 DCSP if ((j < 0) or (j > u)): DCNL DCSP  DCSP raise IndexError(('0 DCSP <= DCSP j DCSP <= DCSP u DCSP expected, DCSP got DCSP %s' % (u, j))) DCNL DCSP return _rec_integrate_in(f, m, u, 0, j, K)
 DCSP threads = threading.enumerate() DCNL DCSP output_file = (PROFILING_OUTPUT_FMT % get_filename_fmt()) DCNL DCSP data = {} DCNL DCSP for (thread, frame) in sys._current_frames().items(): DCNL DCSP  DCSP trace = traceback.format_stack(frame) DCNL DCSP  DCSP data[('%x' % thread)] = {'traceback': trace, 'name': get_thread_name(threads, thread)} DCNL DCSP json.dump(data, file(output_file, 'w'), indent=4)
 DCSP db = get_db(ctx, rd, library_id) DCNL DCSP with db.safe_read_lock: DCNL DCSP  DCSP id_is_uuid = rd.query.get(u'id_is_uuid', u'false') DCNL DCSP  DCSP ids = rd.query.get(u'ids') DCNL DCSP  DCSP if ((ids is None) or (ids == u'all')): DCNL DCSP  DCSP  DCSP ids = db.all_book_ids() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ids = ids.split(u',') DCNL DCSP  DCSP  DCSP if (id_is_uuid == u'true'): DCNL DCSP  DCSP  DCSP  DCSP ids = {db.lookup_by_uuid(x) for x in ids} DCNL DCSP  DCSP  DCSP  DCSP ids.discard(None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ids = {int(x) for x in ids} DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise HTTPNotFound(u'ids DCSP must DCSP a DCSP comma DCSP separated DCSP list DCSP of DCSP integers') DCNL DCSP  DCSP last_modified = None DCNL DCSP  DCSP category_urls = (rd.query.get(u'category_urls', u'true').lower() == u'true') DCNL DCSP  DCSP device_compatible = (rd.query.get(u'device_compatible', u'false').lower() == u'true') DCNL DCSP  DCSP device_for_template = rd.query.get(u'device_for_template', None) DCNL DCSP  DCSP ans = {} DCNL DCSP  DCSP restricted_to = ctx.allowed_book_ids(rd, db) DCNL DCSP  DCSP for book_id in ids: DCNL DCSP  DCSP  DCSP if (book_id not in restricted_to): DCNL DCSP  DCSP  DCSP  DCSP ans[book_id] = None DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (data, lm) = book_to_json(ctx, rd, db, book_id, get_category_urls=category_urls, device_compatible=device_compatible, device_for_template=device_for_template) DCNL DCSP  DCSP  DCSP last_modified = (lm if (last_modified is None) else max(lm, last_modified)) DCNL DCSP  DCSP  DCSP ans[book_id] = data DCNL DCSP if (last_modified is not None): DCNL DCSP  DCSP rd.outheaders[u'Last-Modified'] = http_date(timestampfromdt(last_modified)) DCNL DCSP return ans
 DCSP if (network_info is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(network_info, 'legacy'): DCNL DCSP  DCSP network_info = network_info.legacy() DCNL DCSP nets = [] DCNL DCSP ifc_num = (-1) DCNL DCSP have_injected_networks = False DCNL DCSP for (network_ref, mapping) in network_info: DCNL DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP if (not network_ref['injected']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP have_injected_networks = True DCNL DCSP  DCSP address = mapping['ips'][0]['ip'] DCNL DCSP  DCSP netmask = mapping['ips'][0]['netmask'] DCNL DCSP  DCSP address_v6 = None DCNL DCSP  DCSP gateway_v6 = None DCNL DCSP  DCSP netmask_v6 = None DCNL DCSP  DCSP if use_ipv6: DCNL DCSP  DCSP  DCSP address_v6 = mapping['ip6s'][0]['ip'] DCNL DCSP  DCSP  DCSP netmask_v6 = mapping['ip6s'][0]['netmask'] DCNL DCSP  DCSP  DCSP gateway_v6 = mapping['gateway_v6'] DCNL DCSP  DCSP net_info = {'name': ('eth%d' % ifc_num), 'address': address, 'netmask': netmask, 'gateway': mapping['gateway'], 'broadcast': mapping['broadcast'], 'dns': ' DCSP '.join(mapping['dns']), 'address_v6': address_v6, 'gateway_v6': gateway_v6, 'netmask_v6': netmask_v6} DCNL DCSP  DCSP nets.append(net_info) DCNL DCSP if (have_injected_networks is False): DCNL DCSP  DCSP return None DCNL DCSP if (not template): DCNL DCSP  DCSP return None DCNL DCSP _late_load_cheetah() DCNL DCSP ifc_template = open(template).read() DCNL DCSP return str(Template(ifc_template, searchList=[{'interfaces': nets, 'use_ipv6': use_ipv6}]))
 DCSP standarddir.init(None) DCNL DCSP (yield) DCNL DCSP standarddir.init(None)
 DCSP if full: DCNL DCSP  DCSP return (__salt__['cmd.retcode']('/bin/pkg DCSP refresh DCSP --full') == 0) DCNL DCSP else: DCNL DCSP  DCSP return (__salt__['cmd.retcode']('/bin/pkg DCSP refresh') == 0)
 DCSP if (settings.USE_TZ and (value is not None) and timezone.is_naive(value)): DCNL DCSP  DCSP current_timezone = timezone.get_current_timezone() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return timezone.make_aware(value, current_timezone) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise ValidationError((_(u"%(datetime)s DCSP couldn't DCSP be DCSP interpreted DCSP in DCSP time DCSP zone DCSP %(current_timezone)s; DCSP it DCSP may DCSP be DCSP ambiguous DCSP or DCSP it DCSP may DCSP not DCSP exist.") % {u'datetime': value, u'current_timezone': current_timezone})) DCNL DCSP return value
 DCSP CONFIG.AddOption(type_info.Bool(name=name, default=default, description=help))
 DCSP if osp.isfile(LANG_FILE): DCNL DCSP  DCSP with open(LANG_FILE, 'r') as f: DCNL DCSP  DCSP  DCSP lang = f.read() DCNL DCSP else: DCNL DCSP  DCSP lang = get_interface_language() DCNL DCSP  DCSP save_lang_conf(lang) DCNL DCSP if (lang.strip('\n') in DISABLED_LANGUAGES): DCNL DCSP  DCSP lang = DEFAULT_LANGUAGE DCNL DCSP  DCSP save_lang_conf(lang) DCNL DCSP return lang
 DCSP def nameCollision(*args, **kwargs): DCNL DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP return nameCollision
 DCSP if ('env' in kwargs): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', "Parameter DCSP 'env' DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen.") DCNL DCSP  DCSP kwargs.pop('env') DCNL DCSP path = os.path.normpath(path) DCNL DCSP fnd = {'path': '', 'rel': ''} DCNL DCSP if os.path.isabs(path): DCNL DCSP  DCSP return fnd DCNL DCSP if (saltenv not in __opts__['file_roots']): DCNL DCSP  DCSP return fnd DCNL DCSP def _add_file_stat(fnd): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Stat DCSP the DCSP file DCSP and, DCSP assuming DCSP no DCSP errors DCSP were DCSP found, DCSP convert DCSP the DCSP stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result DCSP to DCSP a DCSP list DCSP of DCSP values DCSP and DCSP add DCSP to DCSP the DCSP return DCSP dict.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Converting DCSP the DCSP stat DCSP result DCSP to DCSP a DCSP list, DCSP the DCSP elements DCSP of DCSP the DCSP list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP correspond DCSP to DCSP the DCSP following DCSP stat_result DCSP params:\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 0 DCSP => DCSP st_mode=33188\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 1 DCSP => DCSP st_ino=10227377\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 2 DCSP => DCSP st_dev=65026\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 3 DCSP => DCSP st_nlink=1\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 4 DCSP => DCSP st_uid=1000\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 5 DCSP => DCSP st_gid=1000\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 6 DCSP => DCSP st_size=1056233\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 7 DCSP => DCSP st_atime=1468284229\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 8 DCSP => DCSP st_mtime=1456338235\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 9 DCSP => DCSP st_ctime=1456338235\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fnd['stat'] = list(os.stat(fnd['path'])) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return fnd DCNL DCSP if ('index' in kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP root = __opts__['file_roots'][saltenv][int(kwargs['index'])] DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP return fnd DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return fnd DCNL DCSP  DCSP full = os.path.join(root, path) DCNL DCSP  DCSP if (os.path.isfile(full) and (not salt.fileserver.is_file_ignored(__opts__, full))): DCNL DCSP  DCSP  DCSP fnd['path'] = full DCNL DCSP  DCSP  DCSP fnd['rel'] = path DCNL DCSP  DCSP  DCSP return _add_file_stat(fnd) DCNL DCSP  DCSP return fnd DCNL DCSP for root in __opts__['file_roots'][saltenv]: DCNL DCSP  DCSP full = os.path.join(root, path) DCNL DCSP  DCSP if (os.path.isfile(full) and (not salt.fileserver.is_file_ignored(__opts__, full))): DCNL DCSP  DCSP  DCSP fnd['path'] = full DCNL DCSP  DCSP  DCSP fnd['rel'] = path DCNL DCSP  DCSP  DCSP return _add_file_stat(fnd) DCNL DCSP return fnd
 DCSP filepath = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP data = pd.read_csv(os.path.join((filepath + '/china_smoking.csv')), index_col='Location') DCNL DCSP return utils.Dataset(data=data, title='Smoking DCSP and DCSP lung DCSP cancer DCSP in DCSP Chinese DCSP regions')
 DCSP for item in seq: DCNL DCSP  DCSP if scalarp(item): DCNL DCSP  DCSP  DCSP (yield item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for subitem in flatten(item, scalarp): DCNL DCSP  DCSP  DCSP  DCSP (yield subitem)
 DCSP normalizedSegment = (pointEnd - pointBegin) DCNL DCSP normalizedSegmentLength = abs(normalizedSegment) DCNL DCSP if (normalizedSegmentLength > 0.0): DCNL DCSP  DCSP normalizedSegment /= normalizedSegmentLength DCNL DCSP  DCSP segmentYMirror = complex(normalizedSegment.real, (- normalizedSegment.imag)) DCNL DCSP  DCSP pointBeginRotated = (segmentYMirror * pointBegin) DCNL DCSP  DCSP pointEndRotated = (segmentYMirror * pointEnd) DCNL DCSP  DCSP if isLoopListIntersectingInsideXSegment(loops, pointBeginRotated.real, pointEndRotated.real, segmentYMirror, pointBeginRotated.imag): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not diffs): DCNL DCSP  DCSP return 'No DCSP differences' DCNL DCSP diffs = diffs.items() DCNL DCSP diffs.sort() DCNL DCSP s = [] DCNL DCSP last = '' DCNL DCSP for (path, desc) in diffs: DCNL DCSP  DCSP t = _space_prefix(last, path, indent=4, include_sep=False) DCNL DCSP  DCSP if colorize: DCNL DCSP  DCSP  DCSP t = color_line(t, 11) DCNL DCSP  DCSP last = path DCNL DCSP  DCSP if (len(desc.splitlines()) > 1): DCNL DCSP  DCSP  DCSP cur_indent = len(re.search('^[ DCSP ]*', t).group(0)) DCNL DCSP  DCSP  DCSP desc = indent((cur_indent + 2), desc) DCNL DCSP  DCSP  DCSP if colorize: DCNL DCSP  DCSP  DCSP  DCSP t += '\n' DCNL DCSP  DCSP  DCSP  DCSP for line in desc.splitlines(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line.strip().startswith('+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 10) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif line.strip().startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 9) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 14) DCNL DCSP  DCSP  DCSP  DCSP  DCSP t += (line + '\n') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t += ('\n' + desc) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP t += (' DCSP ' + desc) DCNL DCSP  DCSP s.append(t) DCNL DCSP s.append(('Files DCSP with DCSP differences: DCSP %s' % len(diffs))) DCNL DCSP return '\n'.join(s)
 DCSP tax = get_object_or_404(Tax, pk=tax_id) DCNL DCSP if ((not request.user.profile.has_permission(tax, mode='r')) and (not request.user.profile.is_admin('treeio_finance'))): DCNL DCSP  DCSP return user_denied(request, "You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Tax", response_format) DCNL DCSP return render_to_response('finance/tax_view', {'tax': tax}, context_instance=RequestContext(request), response_format=response_format)
 DCSP before = time.time() DCNL DCSP res = func() DCNL DCSP return ((time.time() - before), res)
 DCSP if (not obs_date): DCNL DCSP  DCSP return strptime(http_date, '%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z') DCNL DCSP time_formats = ('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z', '%a, DCSP %d-%b-%Y DCSP %H:%M:%S DCSP %Z', '%A, DCSP %d-%b-%y DCSP %H:%M:%S DCSP %Z', '%a DCSP %b DCSP %d DCSP %H:%M:%S DCSP %Y') DCNL DCSP for time_format in time_formats: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return strptime(http_date, time_format) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP raise ValueError(('time DCSP data DCSP %r DCSP does DCSP not DCSP match DCSP known DCSP formats' % http_date))
 DCSP import myusps DCNL DCSP try: DCNL DCSP  DCSP cookie = hass.config.path(COOKIE) DCNL DCSP  DCSP session = myusps.get_session(config.get(CONF_USERNAME), config.get(CONF_PASSWORD), cookie_path=cookie) DCNL DCSP except myusps.USPSError: DCNL DCSP  DCSP _LOGGER.exception('Could DCSP not DCSP connect DCSP to DCSP My DCSP USPS') DCNL DCSP  DCSP return False DCNL DCSP add_devices([USPSSensor(session, config.get(CONF_UPDATE_INTERVAL))])
 DCSP validate_start_action(action) DCNL DCSP if is_systemd_distribution(distribution): DCNL DCSP  DCSP return sequence([run_from_args(['systemctl', 'enable', 'flocker-control']), run_from_args(['systemctl', action.lower(), 'flocker-control'])]) DCNL DCSP elif is_ubuntu(distribution): DCNL DCSP  DCSP return sequence([put(path='/etc/init/flocker-control.override', content=dedent(' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start DCSP on DCSP runlevel DCSP [2345]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stop DCSP on DCSP runlevel DCSP [016]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ')), run("echo DCSP 'flocker-control-api DCTB 4523/tcp DCTB  DCTB  DCTB # DCSP Flocker DCSP Control DCSP API DCSP port' DCSP >> DCSP /etc/services"), run("echo DCSP 'flocker-control-agent DCTB 4524/tcp DCTB  DCTB  DCTB # DCSP Flocker DCSP Control DCSP Agent DCSP port' DCSP >> DCSP /etc/services"), run_from_args(['service', 'flocker-control', action.lower()])]) DCNL DCSP else: DCNL DCSP  DCSP raise DistributionNotSupported(distribution=distribution)
 DCSP client = SoftLayer.Client(username=config.get_cloud_config_value('user', get_configured_provider(), __opts__, search_global=False), api_key=config.get_cloud_config_value('apikey', get_configured_provider(), __opts__, search_global=False)) DCNL DCSP return client[service]
 DCSP N = s.shape[axis] DCNL DCSP S = np.fft.fft(s, n=((2 * N) - 1), axis=axis) DCNL DCSP sxx = np.fft.ifft((S * S.conjugate()), axis=axis).real[:N] DCNL DCSP return (sxx / N)
 DCSP def can_load(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Can DCSP this DCSP user DCSP load DCSP this DCSP course?\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NOTE: DCSP this DCSP is DCSP not DCSP checking DCSP whether DCSP user DCSP is DCSP actually DCSP enrolled DCSP in DCSP the DCSP course.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP response = (_visible_to_nonstaff_users(courselike) and _can_access_descriptor_with_start_date(user, courselike, courselike.id)) DCNL DCSP  DCSP return (ACCESS_GRANTED if (response or _has_staff_access_to_descriptor(user, courselike, courselike.id)) else response) DCNL DCSP def can_enroll(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP whether DCSP the DCSP user DCSP can DCSP enroll DCSP in DCSP the DCSP course.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return _can_enroll_courselike(user, courselike) DCNL DCSP def see_exists(): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Can DCSP see DCSP if DCSP can DCSP enroll, DCSP but DCSP also DCSP if DCSP can DCSP load DCSP it: DCSP if DCSP user DCSP enrolled DCSP in DCSP a DCSP course DCSP and DCSP now\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP it's DCSP past DCSP the DCSP enrollment DCSP period, DCSP they DCSP should DCSP still DCSP see DCSP it.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP return (ACCESS_GRANTED if (can_load() or can_enroll()) else ACCESS_DENIED) DCNL DCSP def can_see_in_catalog(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Implements DCSP the DCSP "can DCSP see DCSP course DCSP in DCSP catalog" DCSP logic DCSP if DCSP a DCSP course DCSP should DCSP be DCSP visible DCSP in DCSP the DCSP main DCSP course DCSP catalog\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog_visibility DCSP property DCSP on DCSP the DCSP course DCSP descriptor\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return (_has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_staff_access_to_descriptor(user, courselike, courselike.id)) DCNL DCSP def can_see_about_page(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Implements DCSP the DCSP "can DCSP see DCSP course DCSP about DCSP page" DCSP logic DCSP if DCSP a DCSP course DCSP about DCSP page DCSP should DCSP be DCSP visible\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog_visibility DCSP property DCSP on DCSP the DCSP course DCSP descriptor\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return (_has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_catalog_visibility(courselike, CATALOG_VISIBILITY_ABOUT) or _has_staff_access_to_descriptor(user, courselike, courselike.id)) DCNL DCSP checkers = {'load': can_load, 'view_courseware_with_prerequisites': (lambda : _can_view_courseware_with_prerequisites(user, courselike)), 'load_mobile': (lambda : (can_load() and _can_load_course_on_mobile(user, courselike))), 'enroll': can_enroll, 'see_exists': see_exists, 'staff': (lambda : _has_staff_access_to_descriptor(user, courselike, courselike.id)), 'instructor': (lambda : _has_instructor_access_to_descriptor(user, courselike, courselike.id)), 'see_in_catalog': can_see_in_catalog, 'see_about_page': can_see_about_page} DCNL DCSP return _dispatch(checkers, action, user, courselike)
 DCSP sequences_out = [[] for _ in range(len(sequences))] DCNL DCSP for i in range(len(sequences)): DCNL DCSP  DCSP if remove_last: DCNL DCSP  DCSP  DCSP sequences_out[i] = ([start_id] + sequences[i][:(-1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sequences_out[i] = ([start_id] + sequences[i]) DCNL DCSP return sequences_out
 DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cnn.sample, X, Y)
 DCSP f = int_or_true_div((as_scalar(x).type in discrete_types), (as_scalar(y).type in discrete_types)) DCNL DCSP return f(x, y)
 DCSP uid = parse_uid(uid) DCNL DCSP if (uid != os.getuid()): DCNL DCSP  DCSP os.seteuid(uid)
 DCSP nitems = payload.used DCNL DCSP listobj = c.pyapi.list_new(nitems) DCNL DCSP ok = cgutils.is_not_null(c.builder, listobj) DCNL DCSP with c.builder.if_then(ok, likely=True): DCNL DCSP  DCSP index = cgutils.alloca_once_value(c.builder, ir.Constant(nitems.type, 0)) DCNL DCSP  DCSP with payload._iterate() as loop: DCNL DCSP  DCSP  DCSP i = c.builder.load(index) DCNL DCSP  DCSP  DCSP item = loop.entry.key DCNL DCSP  DCSP  DCSP itemobj = c.box(typ.dtype, item) DCNL DCSP  DCSP  DCSP c.pyapi.list_setitem(listobj, i, itemobj) DCNL DCSP  DCSP  DCSP i = c.builder.add(i, ir.Constant(i.type, 1)) DCNL DCSP  DCSP  DCSP c.builder.store(i, index) DCNL DCSP return (ok, listobj)
 DCSP mtime = os.stat(filename).st_mtime DCNL DCSP (lastupdate, result) = cache.get(filename, (0, None)) DCNL DCSP if (lastupdate < mtime): DCNL DCSP  DCSP info = inspect.getmoduleinfo(filename) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file = open(filename) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (info and ('b' in info[2])): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP module = imp.load_module('__temp__', file, filename, info[1:]) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result = (module.__doc__ or '').splitlines()[0] DCNL DCSP  DCSP  DCSP del sys.modules['__temp__'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = source_synopsis(file) DCNL DCSP  DCSP  DCSP file.close() DCNL DCSP  DCSP cache[filename] = (mtime, result) DCNL DCSP return result
 DCSP print ("--- DCSP Cleaning DCSP Autoscale DCSP Groups DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.identity.services.autoscale.regions: DCNL DCSP  DCSP asg = pyrax.connect_to_autoscale(region=region) DCNL DCSP  DCSP for group in rax_list_iterator(asg): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, group.name): DCNL DCSP  DCSP  DCSP  DCSP group.manager._delete = _force_delete_rax_scaling_group(group.manager) DCNL DCSP  DCSP  DCSP  DCSP prompt_and_delete(group, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % group), args.assumeyes)
 DCSP user_home = os.path.expanduser('~') DCNL DCSP (join, exists) = (os.path.join, os.path.exists) DCNL DCSP if mswin: DCNL DCSP  DCSP return join(user_home, 'Downloads', 'mps') DCNL DCSP USER_DIRS = join(user_home, '.config', 'user-dirs.dirs') DCNL DCSP DOWNLOAD_HOME = join(user_home, 'Downloads') DCNL DCSP if ('XDG_DOWNLOAD_DIR' in os.environ): DCNL DCSP  DCSP ddir = os.environ['XDG_DOWNLOAD_DIR'] DCNL DCSP elif exists(USER_DIRS): DCNL DCSP  DCSP lines = open(USER_DIRS).readlines() DCNL DCSP  DCSP defn = [x for x in lines if x.startswith('XDG_DOWNLOAD_DIR')] DCNL DCSP  DCSP if (len(defn) == 1): DCNL DCSP  DCSP  DCSP ddir = defn[0].split('=')[1].replace('"', '') DCNL DCSP  DCSP  DCSP ddir = ddir.replace('$HOME', user_home).strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ddir = (DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home) DCNL DCSP else: DCNL DCSP  DCSP ddir = (DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home) DCNL DCSP ddir = ddir DCNL DCSP return os.path.join(ddir, 'mps')
 DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP floating_ip_pool_list DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function') DCNL DCSP conn = get_conn() DCNL DCSP return conn.floating_ip_pool_list()
 DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP table = Table(table_name, connection=conn) DCNL DCSP table.delete() DCNL DCSP MAX_ATTEMPTS = 30 DCNL DCSP for i in range(MAX_ATTEMPTS): DCNL DCSP  DCSP if (not exists(table_name, region, key, keyid, profile)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP return False
 DCSP (yield (qualName, [])) DCNL DCSP qualParts = qualName.split('.') DCNL DCSP for index in range(1, len(qualParts)): DCNL DCSP  DCSP (yield ('.'.join(qualParts[:(- index)]), qualParts[(- index):]))
 DCSP form_data = {'code': 'foo', 'fullname': 'Foo', 'checkstyle': 'foo', 'nplurals': '2', 'specialchars': specialchars} DCNL DCSP form = LanguageForm(form_data) DCNL DCSP assert form.is_valid() DCNL DCSP assert (form.cleaned_data['specialchars'].count(count_char) == 1)
 DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP is_present = __salt__['boto_sqs.exists'](name, region, key, keyid, profile) DCNL DCSP if (not is_present): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'AWS DCSP SQS DCSP queue DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP created.'.format(name) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP created = __salt__['boto_sqs.create'](name, region, key, keyid, profile) DCNL DCSP  DCSP if created: DCNL DCSP  DCSP  DCSP ret['changes']['old'] = None DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {'queue': name} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP {0} DCSP AWS DCSP queue'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = '{0} DCSP present.'.format(name) DCNL DCSP attrs_to_set = {} DCNL DCSP _attributes = __salt__['boto_sqs.get_attributes'](name, region, key, keyid, profile) DCNL DCSP if attributes: DCNL DCSP  DCSP for (attr, val) in six.iteritems(attributes): DCNL DCSP  DCSP  DCSP _val = _attributes.get(attr, None) DCNL DCSP  DCSP  DCSP if (attr == 'Policy'): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(_val, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _val = json.loads(_val) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = json.loads(val) DCNL DCSP  DCSP  DCSP  DCSP if (_val != val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.debug('Policies DCSP differ:\n{0}\n{1}'.format(_val, val)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs_to_set[attr] = json.dumps(val, sort_keys=True) DCNL DCSP  DCSP  DCSP elif (str(_val) != str(val)): DCNL DCSP  DCSP  DCSP  DCSP log.debug('Attributes DCSP differ:\n{0}\n{1}'.format(_val, val)) DCNL DCSP  DCSP  DCSP  DCSP attrs_to_set[attr] = val DCNL DCSP attr_names = ','.join(attrs_to_set) DCNL DCSP if attrs_to_set: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Attribute(s) DCSP {0} DCSP to DCSP be DCSP set DCSP on DCSP {1}.'.format(attr_names, name) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP msg = ' DCSP Setting DCSP {0} DCSP attribute(s).'.format(attr_names) DCNL DCSP  DCSP ret['comment'] = (ret['comment'] + msg) DCNL DCSP  DCSP if ('new' in ret['changes']): DCNL DCSP  DCSP  DCSP ret['changes']['new']['attributes_set'] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {'attributes_set': []} DCNL DCSP  DCSP for (attr, val) in six.iteritems(attrs_to_set): DCNL DCSP  DCSP  DCSP set_attr = __salt__['boto_sqs.set_attributes'](name, {attr: val}, region, key, keyid, profile) DCNL DCSP  DCSP  DCSP if (not set_attr): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP msg = 'Set DCSP attribute DCSP {0}.'.format(attr) DCNL DCSP  DCSP  DCSP ret['changes']['new']['attributes_set'].append(attr) DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = (ret['comment'] + ' DCSP Attributes DCSP set.') DCNL DCSP return ret
 DCSP from sympy.simplify.radsimp import split_surds DCNL DCSP p = _mexpand(p) DCNL DCSP if p.is_Number: DCNL DCSP  DCSP res = (p, S.Zero, S.Zero) DCNL DCSP elif p.is_Add: DCNL DCSP  DCSP pargs = sorted(p.args, key=default_sort_key) DCNL DCSP  DCSP if all(((x ** 2).is_Rational for x in pargs)): DCNL DCSP  DCSP  DCSP (r, b, a) = split_surds(p) DCNL DCSP  DCSP  DCSP res = (a, b, r) DCNL DCSP  DCSP  DCSP return list(res) DCNL DCSP  DCSP v = [(sqrt_depth(x), x, i) for (i, x) in enumerate(pargs)] DCNL DCSP  DCSP nmax = max(v, key=default_sort_key) DCNL DCSP  DCSP if (nmax[0] == 0): DCNL DCSP  DCSP  DCSP res = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (depth, _, i) = nmax DCNL DCSP  DCSP  DCSP r = pargs.pop(i) DCNL DCSP  DCSP  DCSP v.pop(i) DCNL DCSP  DCSP  DCSP b = S.One DCNL DCSP  DCSP  DCSP if r.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP bv = [] DCNL DCSP  DCSP  DCSP  DCSP rv = [] DCNL DCSP  DCSP  DCSP  DCSP for x in r.args: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sqrt_depth(x) < depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bv.append(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rv.append(x) DCNL DCSP  DCSP  DCSP  DCSP b = Mul._from_args(bv) DCNL DCSP  DCSP  DCSP  DCSP r = Mul._from_args(rv) DCNL DCSP  DCSP  DCSP a1 = [] DCNL DCSP  DCSP  DCSP b1 = [b] DCNL DCSP  DCSP  DCSP for x in v: DCNL DCSP  DCSP  DCSP  DCSP if (x[0] < depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP a1.append(x[1]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP x1 = x[1] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (x1 == r): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP b1.append(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif x1.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x1args = list(x1.args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r in x1args): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x1args.remove(r) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP b1.append(Mul(*x1args)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a1.append(x[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a1.append(x[1]) DCNL DCSP  DCSP  DCSP a = Add(*a1) DCNL DCSP  DCSP  DCSP b = Add(*b1) DCNL DCSP  DCSP  DCSP res = (a, b, (r ** 2)) DCNL DCSP else: DCNL DCSP  DCSP (b, r) = p.as_coeff_Mul() DCNL DCSP  DCSP if is_sqrt(r): DCNL DCSP  DCSP  DCSP res = (S.Zero, b, (r ** 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res = [] DCNL DCSP return list(res)
 DCSP event = get_object_or_404(Event, pk=event_id) DCNL DCSP if (not request.user.profile.has_permission(event, mode='w')): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Event") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP form = EventForm(request.user.profile, None, None, request.POST, instance=event) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP event = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('events_event_view', args=[event.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('events')) DCNL DCSP else: DCNL DCSP  DCSP form = EventForm(request.user.profile, instance=event) DCNL DCSP return render_to_response('events/event_edit', {'event': event, 'form': form}, context_instance=RequestContext(request), response_format=response_format)
 DCSP parsed_media_url = urlparse(settings.MEDIA_URL) DCNL DCSP if request.path_info.startswith(parsed_media_url.path): DCNL DCSP  DCSP if parsed_media_url.netloc: DCNL DCSP  DCSP  DCSP if (request.get_host() == parsed_media_url.netloc): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP subnet_ids = [] DCNL DCSP subnet_names = [] DCNL DCSP subnet_cidrs = [] DCNL DCSP for subnet in (identified_subnets or []): DCNL DCSP  DCSP if re.match(SUBNET_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_ids.append(subnet) DCNL DCSP  DCSP elif re.match(CIDR_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_cidrs.append(subnet) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subnet_names.append(subnet) DCNL DCSP subnets_by_id = [] DCNL DCSP if subnet_ids: DCNL DCSP  DCSP subnets_by_id = vpc_conn.get_all_subnets(subnet_ids, filters={'vpc_id': vpc_id}) DCNL DCSP  DCSP for subnet_id in subnet_ids: DCNL DCSP  DCSP  DCSP if (not any(((s.id == subnet_id) for s in subnets_by_id))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP ID DCSP "{0}" DCSP does DCSP not DCSP exist'.format(subnet_id)) DCNL DCSP subnets_by_cidr = [] DCNL DCSP if subnet_cidrs: DCNL DCSP  DCSP subnets_by_cidr = vpc_conn.get_all_subnets(filters={'vpc_id': vpc_id, 'cidr': subnet_cidrs}) DCNL DCSP  DCSP for cidr in subnet_cidrs: DCNL DCSP  DCSP  DCSP if (not any(((s.cidr_block == cidr) for s in subnets_by_cidr))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP CIDR DCSP "{0}" DCSP does DCSP not DCSP exist'.format(cidr)) DCNL DCSP subnets_by_name = [] DCNL DCSP if subnet_names: DCNL DCSP  DCSP subnets_by_name = vpc_conn.get_all_subnets(filters={'vpc_id': vpc_id, 'tag:Name': subnet_names}) DCNL DCSP  DCSP for name in subnet_names: DCNL DCSP  DCSP  DCSP matching_count = len([1 for s in subnets_by_name if (s.tags.get('Name') == name)]) DCNL DCSP  DCSP  DCSP if (matching_count == 0): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP named DCSP "{0}" DCSP does DCSP not DCSP exist'.format(name)) DCNL DCSP  DCSP  DCSP elif (matching_count > 1): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Multiple DCSP subnets DCSP named DCSP "{0}"'.format(name)) DCNL DCSP return ((subnets_by_id + subnets_by_cidr) + subnets_by_name)
 DCSP data = [0, 1] DCNL DCSP mask = np.array([True, False]) DCNL DCSP result = sigma_clipped_stats(data, mask=mask) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 0.0)) DCNL DCSP result = sigma_clipped_stats(data, mask_value=0.0) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 0.0)) DCNL DCSP data = [0, 2] DCNL DCSP result = sigma_clipped_stats(data) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 1.0)) DCNL DCSP _data = np.arange(10) DCNL DCSP data = np.ma.MaskedArray([_data, _data, (10 * _data)]) DCNL DCSP mean = sigma_clip(data, axis=0, sigma=1).mean(axis=0) DCNL DCSP assert_equal(mean, _data) DCNL DCSP (mean, median, stddev) = sigma_clipped_stats(data, axis=0, sigma=1) DCNL DCSP assert_equal(mean, _data) DCNL DCSP assert_equal(median, _data) DCNL DCSP assert_equal(stddev, np.zeros_like(_data))
 DCSP path = (example_bin_lush_path + 'ubyte_scalar.lushbin') DCNL DCSP result = read_bin_lush_matrix(path) DCNL DCSP assert (str(result.dtype) == 'uint8') DCNL DCSP assert (len(result.shape) == 3) DCNL DCSP assert (result.shape[0] == 1) DCNL DCSP assert (result.shape[1] == 1) DCNL DCSP assert (result.shape[1] == 1) DCNL DCSP assert (result[(0, 0)] == 12)
 DCSP return (path if isabs(path) else join(project_data_dir(), path))
 DCSP if (interface in get_interfaces(zone, permanent)): DCNL DCSP  DCSP log.info('Interface DCSP is DCSP already DCSP bound DCSP to DCSP zone.') DCNL DCSP cmd = '--zone={0} DCSP --add-interface={1}'.format(zone, interface) DCNL DCSP if permanent: DCNL DCSP  DCSP cmd += ' DCSP --permanent' DCNL DCSP return __firewall_cmd(cmd)
 DCSP is_dylib = DYLIB_RE.match(filename) DCNL DCSP if (not is_dylib): DCNL DCSP  DCSP return None DCNL DCSP return is_dylib.groupdict()
 DCSP function = sum.function DCNL DCSP for l in sum.limits: DCNL DCSP  DCSP function = function.subs(l[0], (l[(-1)] + 1)) DCNL DCSP return function
 DCSP mounts = utils.system_output('mount').splitlines() DCNL DCSP hd_list = [] DCNL DCSP hd_regexp = re.compile('([hsv]d[a-z]+3)$') DCNL DCSP partfile = open(_DISKPART_FILE) DCNL DCSP for partline in partfile: DCNL DCSP  DCSP parts = partline.strip().split() DCNL DCSP  DCSP if ((len(parts) != 4) or partline.startswith('major')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP partname = parts[3] DCNL DCSP  DCSP if (not get_all_disks): DCNL DCSP  DCSP  DCSP if (not partname[(-1):].isdigit()): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not fd_mgr.use_partition(partname)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tunepath = fd_mgr.map_drive_name(partname) DCNL DCSP  DCSP mstat = 0 DCNL DCSP  DCSP fstype = '' DCNL DCSP  DCSP fsopts = '' DCNL DCSP  DCSP fsmkfs = '?' DCNL DCSP  DCSP chkdev = ('/dev/' + partname) DCNL DCSP  DCSP mountpt = None DCNL DCSP  DCSP for mln in mounts: DCNL DCSP  DCSP  DCSP splt = mln.split() DCNL DCSP  DCSP  DCSP if (splt[0].strip() == chkdev.strip()): DCNL DCSP  DCSP  DCSP  DCSP mountpt = fd_mgr.check_mount_point(partname, splt[2]) DCNL DCSP  DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mstat = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP fstype = splt[4] DCNL DCSP  DCSP  DCSP  DCSP fsopts = splt[5] DCNL DCSP  DCSP  DCSP  DCSP if (fsopts[:3] != '(rw'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mstat = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP mstat = 1 DCNL DCSP  DCSP if (std_mounts_only and (mstat < 0)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not get_all_disks): DCNL DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP mountpt = fd_mgr.check_mount_point(partname, None) DCNL DCSP  DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP hd_list.append({'device': partname, 'mountpt': mountpt, 'tunable': tunepath, 'fs_type': fstype, 'fs_opts': fsopts, 'fs_mkfs': fsmkfs, 'mounted': mstat}) DCNL DCSP return hd_list
 DCSP if (Info.version() is None): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP cli.register('building-command-table.main', change_name) DCNL DCSP cli.register('building-command-table.deploy', inject_commands) DCNL DCSP cli.register('building-argument-table.deploy.get-application-revision', modify_revision_arguments) DCNL DCSP cli.register('building-argument-table.deploy.register-application-revision', modify_revision_arguments) DCNL DCSP cli.register('building-argument-table.deploy.create-deployment', modify_revision_arguments)
 DCSP get_random_state().seed(seed)
 DCSP if (not hasattr(settings, 'PEP_REPO_PATH')): DCNL DCSP  DCSP raise ImproperlyConfigured('No DCSP PEP_REPO_PATH DCSP in DCSP settings') DCNL DCSP if (not os.path.exists(settings.PEP_REPO_PATH)): DCNL DCSP  DCSP raise ImproperlyConfigured('PEP_REPO_PATH DCSP in DCSP settings DCSP does DCSP not DCSP exist')
 DCSP assert isinstance(message, text_type) DCNL DCSP app = create_confirm_application(message) DCNL DCSP return run_application(app)
 DCSP for (key, value) in dictionary.iteritems(): DCNL DCSP  DCSP if (element is value): DCNL DCSP  DCSP  DCSP return key
 DCSP next_heartbeat = int((time.time() + 600)) DCNL DCSP while ALIVE: DCNL DCSP  DCSP populate_collectors(options.cdir) DCNL DCSP  DCSP reload_changed_config_modules(modules, options, sender, tags) DCNL DCSP  DCSP reap_children() DCNL DCSP  DCSP check_children(options) DCNL DCSP  DCSP spawn_children() DCNL DCSP  DCSP time.sleep(15) DCNL DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP if (now >= next_heartbeat): DCNL DCSP  DCSP  DCSP LOG.info(('Heartbeat DCSP (%d DCSP collectors DCSP running)' % sum((1 for col in all_living_collectors())))) DCNL DCSP  DCSP  DCSP next_heartbeat = (now + 600)
 DCSP global _task DCNL DCSP _task.stop() DCNL DCSP _task = None
 DCSP if (x_discrete and y_discrete): DCNL DCSP  DCSP return mutual_info_score(x, y) DCNL DCSP elif (x_discrete and (not y_discrete)): DCNL DCSP  DCSP return _compute_mi_cd(y, x, n_neighbors) DCNL DCSP elif ((not x_discrete) and y_discrete): DCNL DCSP  DCSP return _compute_mi_cd(x, y, n_neighbors) DCNL DCSP else: DCNL DCSP  DCSP return _compute_mi_cc(x, y, n_neighbors)
 DCSP if (surfs[0]['np'] > 10000): DCNL DCSP  DCSP msg = ('The DCSP bem DCSP surface DCSP has DCSP %s DCSP data DCSP points. DCSP 5120 DCSP (ico DCSP grade=4) DCSP should DCSP be DCSP enough.' % surfs[0]['np']) DCNL DCSP  DCSP if (len(surfs) == 3): DCNL DCSP  DCSP  DCSP msg += ' DCSP Dense DCSP 3-layer DCSP bems DCSP may DCSP not DCSP save DCSP properly.' DCNL DCSP  DCSP warn(msg)
 DCSP return block.location.name
 DCSP stor = Storage() DCNL DCSP for k in (requireds + tuple(f.keys())): DCNL DCSP  DCSP v = f[k] DCNL DCSP  DCSP if isinstance(v, list): DCNL DCSP  DCSP  DCSP v = v[(-1)] DCNL DCSP  DCSP if hasattr(v, 'value'): DCNL DCSP  DCSP  DCSP v = v.value DCNL DCSP  DCSP setattr(stor, k, v) DCNL DCSP for (k, v) in defaults.iteritems(): DCNL DCSP  DCSP result = v DCNL DCSP  DCSP if hasattr(stor, k): DCNL DCSP  DCSP  DCSP result = stor[k] DCNL DCSP  DCSP if ((v == ()) and (not isinstance(result, tuple))): DCNL DCSP  DCSP  DCSP result = (result,) DCNL DCSP  DCSP setattr(stor, k, result) DCNL DCSP return stor
 DCSP if ((not session.logged_in) and ('name' in kwargs) and ('password' in kwargs)): DCNL DCSP  DCSP from evennia.commands.default.unloggedin import create_normal_player DCNL DCSP  DCSP player = create_normal_player(session, kwargs['name'], kwargs['password']) DCNL DCSP  DCSP if player: DCNL DCSP  DCSP  DCSP session.sessionhandler.login(session, player)
 DCSP size = g.size DCNL DCSP g = g.array_form DCNL DCSP num_dummies = (size - 2) DCNL DCSP indices = list(range(num_dummies)) DCNL DCSP all_metrics_with_sym = all([(_ is not None) for _ in sym]) DCNL DCSP num_types = len(sym) DCNL DCSP dumx = dummies[:] DCNL DCSP dumx_flat = [] DCNL DCSP for dx in dumx: DCNL DCSP  DCSP dumx_flat.extend(dx) DCNL DCSP b_S = b_S[:] DCNL DCSP sgensx = [h._array_form for h in sgens] DCNL DCSP if b_S: DCNL DCSP  DCSP S_transversals = transversal2coset(size, b_S, S_transversals) DCNL DCSP dsgsx = [] DCNL DCSP for i in range(num_types): DCNL DCSP  DCSP dsgsx.extend(dummy_sgs(dumx[i], sym[i], num_dummies)) DCNL DCSP ginv = _af_invert(g) DCNL DCSP idn = list(range(size)) DCNL DCSP TAB = [(idn, idn, g)] DCNL DCSP for i in range((size - 2)): DCNL DCSP  DCSP b = i DCNL DCSP  DCSP testb = ((b in b_S) and sgensx) DCNL DCSP  DCSP if testb: DCNL DCSP  DCSP  DCSP sgensx1 = [_af_new(_) for _ in sgensx] DCNL DCSP  DCSP  DCSP deltab = _orbit(size, sgensx1, b) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP deltab = {b} DCNL DCSP  DCSP if all_metrics_with_sym: DCNL DCSP  DCSP  DCSP md = _min_dummies(dumx, sym, indices) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP md = [min(_orbit(size, [_af_new(ddx) for ddx in dsgsx], ii)) for ii in range((size - 2))] DCNL DCSP  DCSP p_i = min([min([md[h[x]] for x in deltab]) for (s, d, h) in TAB]) DCNL DCSP  DCSP dsgsx1 = [_af_new(_) for _ in dsgsx] DCNL DCSP  DCSP Dxtrav = (_orbit_transversal(size, dsgsx1, p_i, False, af=True) if dsgsx else None) DCNL DCSP  DCSP if Dxtrav: DCNL DCSP  DCSP  DCSP Dxtrav = [_af_invert(x) for x in Dxtrav] DCNL DCSP  DCSP for ii in range(num_types): DCNL DCSP  DCSP  DCSP if (p_i in dumx[ii]): DCNL DCSP  DCSP  DCSP  DCSP if (sym[ii] is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP deltap = dumx[ii] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_i_index = (dumx[ii].index(p_i) % 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP deltap = dumx[ii][p_i_index::2] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP deltap = [p_i] DCNL DCSP  DCSP TAB1 = [] DCNL DCSP  DCSP nTAB = len(TAB) DCNL DCSP  DCSP while TAB: DCNL DCSP  DCSP  DCSP (s, d, h) = TAB.pop() DCNL DCSP  DCSP  DCSP if (min([md[h[x]] for x in deltab]) != p_i): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP deltab1 = [x for x in deltab if (md[h[x]] == p_i)] DCNL DCSP  DCSP  DCSP dg = _af_rmul(d, g) DCNL DCSP  DCSP  DCSP dginv = _af_invert(dg) DCNL DCSP  DCSP  DCSP sdeltab = [s[x] for x in deltab1] DCNL DCSP  DCSP  DCSP gdeltap = [dginv[x] for x in deltap] DCNL DCSP  DCSP  DCSP NEXT = [x for x in sdeltab if (x in gdeltap)] DCNL DCSP  DCSP  DCSP for j in NEXT: DCNL DCSP  DCSP  DCSP  DCSP if testb: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s1 = _trace_S(s, j, b, S_transversals) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not s1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s1 = [s[ix] for ix in s1] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s1 = s DCNL DCSP  DCSP  DCSP  DCSP if Dxtrav: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d1 = _trace_D(dg[j], p_i, Dxtrav) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not d1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p_i != dg[j]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP d1 = idn DCNL DCSP  DCSP  DCSP  DCSP assert (d1[dg[j]] == p_i) DCNL DCSP  DCSP  DCSP  DCSP d1 = [d1[ix] for ix in d] DCNL DCSP  DCSP  DCSP  DCSP h1 = [d1[g[ix]] for ix in s1] DCNL DCSP  DCSP  DCSP  DCSP TAB1.append((s1, d1, h1)) DCNL DCSP  DCSP TAB1.sort(key=(lambda x: x[(-1)])) DCNL DCSP  DCSP nTAB1 = len(TAB1) DCNL DCSP  DCSP prev = ([0] * size) DCNL DCSP  DCSP while TAB1: DCNL DCSP  DCSP  DCSP (s, d, h) = TAB1.pop() DCNL DCSP  DCSP  DCSP if (h[:(-2)] == prev[:(-2)]): DCNL DCSP  DCSP  DCSP  DCSP if (h[(-1)] != prev[(-1)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP TAB.append((s, d, h)) DCNL DCSP  DCSP  DCSP prev = h DCNL DCSP  DCSP sgensx = [h for h in sgensx if (h[b] == b)] DCNL DCSP  DCSP if (b in b_S): DCNL DCSP  DCSP  DCSP b_S.remove(b) DCNL DCSP  DCSP _dumx_remove(dumx, dumx_flat, p_i) DCNL DCSP  DCSP dsgsx = [] DCNL DCSP  DCSP for i in range(num_types): DCNL DCSP  DCSP  DCSP dsgsx.extend(dummy_sgs(dumx[i], sym[i], num_dummies)) DCNL DCSP return TAB[0][(-1)]
 DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(logging.NOTSET) DCNL DCSP for handler in logger.handlers[:]: DCNL DCSP  DCSP logger.removeHandler(handler) DCNL DCSP info_handler = NewLineStreamHandler(SafeEncodingWriter(status)) DCNL DCSP info_handler.addFilter(InfoFilter()) DCNL DCSP info_handler.setLevel(VERBOSITY_MAP[app.verbosity]) DCNL DCSP info_handler.setFormatter(ColorizeFormatter()) DCNL DCSP warning_handler = WarningStreamHandler(SafeEncodingWriter(warning)) DCNL DCSP warning_handler.addFilter(WarningSuppressor(app)) DCNL DCSP warning_handler.addFilter(WarningIsErrorFilter(app)) DCNL DCSP warning_handler.addFilter(WarningLogRecordTranslator(app)) DCNL DCSP warning_handler.setLevel(logging.WARNING) DCNL DCSP warning_handler.setFormatter(ColorizeFormatter()) DCNL DCSP logger.addHandler(info_handler) DCNL DCSP logger.addHandler(warning_handler)
 DCSP version = Version.objects.get(pk=version_pk) DCNL DCSP if html: DCNL DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_=version.project.documentation_type) DCNL DCSP  DCSP target = version.project.rtd_build_path(version.slug) DCNL DCSP  DCSP Syncer.copy(from_path, target, host=hostname) DCNL DCSP if ('sphinx' in version.project.documentation_type): DCNL DCSP  DCSP if localmedia: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_localmedia') DCNL DCSP  DCSP  DCSP to_path = version.project.get_production_media_path(type_='htmlzip', version_slug=version.slug, include_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if search: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_search') DCNL DCSP  DCSP  DCSP to_path = version.project.get_production_media_path(type_='json', version_slug=version.slug, include_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if pdf: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_pdf') DCNL DCSP  DCSP  DCSP to_path = version.project.get_production_media_path(type_='pdf', version_slug=version.slug, include_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if epub: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_epub') DCNL DCSP  DCSP  DCSP to_path = version.project.get_production_media_path(type_='epub', version_slug=version.slug, include_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP if ('mkdocs' in version.project.documentation_type): DCNL DCSP  DCSP if search: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='mkdocs_json') DCNL DCSP  DCSP  DCSP to_path = version.project.get_production_media_path(type_='json', version_slug=version.slug, include_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname)
 DCSP password_hash = (md5(user.password) if user.password else None) DCNL DCSP data = [str(user.id), password_hash] DCNL DCSP return _security.reset_serializer.dumps(data)
 DCSP rgbtuple = _namedict.get(color) DCNL DCSP if (rgbtuple is None): DCNL DCSP  DCSP if (color[0] != '#'): DCNL DCSP  DCSP  DCSP raise BadColor(color) DCNL DCSP  DCSP red = color[1:3] DCNL DCSP  DCSP green = color[3:5] DCNL DCSP  DCSP blue = color[5:7] DCNL DCSP  DCSP rgbtuple = (int(red, 16), int(green, 16), int(blue, 16)) DCNL DCSP  DCSP _namedict[color] = rgbtuple DCNL DCSP return rgbtuple
 DCSP if (not trigger.group(2)): DCNL DCSP  DCSP return bot.reply(u'No DCSP query DCSP term.') DCNL DCSP query = trigger.group(2) DCNL DCSP uri = u'http://websitedev.de/temp-bin/suggest.pl?q=' DCNL DCSP answer = web.get((uri + query.replace(u'+', u'%2B'))) DCNL DCSP if answer: DCNL DCSP  DCSP bot.say(answer) DCNL DCSP else: DCNL DCSP  DCSP bot.reply(u'Sorry, DCSP no DCSP result.')
 DCSP _assign_role(committer_id, assignee_id, new_role, exploration_id, feconf.ACTIVITY_TYPE_EXPLORATION) DCNL DCSP if (new_role in [ROLE_OWNER, ROLE_EDITOR]): DCNL DCSP  DCSP subscription_services.subscribe_to_exploration(assignee_id, exploration_id)
 DCSP executor = None DCNL DCSP def shutting_down(): DCNL DCSP  DCSP return (_shutdown or (executor is None) or executor._shutdown_thread) DCNL DCSP def shutdown_worker(): DCNL DCSP  DCSP nb_children_alive = sum((p.is_alive() for p in processes.values())) DCNL DCSP  DCSP for i in range(0, nb_children_alive): DCNL DCSP  DCSP  DCSP call_queue.put_nowait(None) DCNL DCSP  DCSP call_queue.close() DCNL DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP reader = result_queue._reader DCNL DCSP while True: DCNL DCSP  DCSP _add_call_item_to_queue(pending_work_items, work_ids_queue, call_queue) DCNL DCSP  DCSP sentinels = [p.sentinel for p in processes.values()] DCNL DCSP  DCSP assert sentinels DCNL DCSP  DCSP ready = wait(([reader] + sentinels)) DCNL DCSP  DCSP if (reader in ready): DCNL DCSP  DCSP  DCSP result_item = reader.recv() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP  DCSP if (executor is not None): DCNL DCSP  DCSP  DCSP  DCSP executor._broken = True DCNL DCSP  DCSP  DCSP  DCSP executor._shutdown_thread = True DCNL DCSP  DCSP  DCSP  DCSP executor = None DCNL DCSP  DCSP  DCSP for (work_id, work_item) in pending_work_items.items(): DCNL DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(BrokenProcessPool('A DCSP process DCSP in DCSP the DCSP process DCSP pool DCSP was DCSP terminated DCSP abruptly DCSP while DCSP the DCSP future DCSP was DCSP running DCSP or DCSP pending.')) DCNL DCSP  DCSP  DCSP  DCSP del work_item DCNL DCSP  DCSP  DCSP pending_work_items.clear() DCNL DCSP  DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP  DCSP p.terminate() DCNL DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if isinstance(result_item, int): DCNL DCSP  DCSP  DCSP assert shutting_down() DCNL DCSP  DCSP  DCSP p = processes.pop(result_item) DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP  DCSP  DCSP if (not processes): DCNL DCSP  DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP elif (result_item is not None): DCNL DCSP  DCSP  DCSP work_item = pending_work_items.pop(result_item.work_id, None) DCNL DCSP  DCSP  DCSP if (work_item is not None): DCNL DCSP  DCSP  DCSP  DCSP if result_item.exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(result_item.exception) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_result(result_item.result) DCNL DCSP  DCSP  DCSP  DCSP del work_item DCNL DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP if shutting_down(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not pending_work_items): DCNL DCSP  DCSP  DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Full: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP executor = None
 DCSP print(s.ljust(20), end=' DCSP ') DCNL DCSP res = func(*args, **kwargs) DCNL DCSP if (correct is not None): DCNL DCSP  DCSP assert np.allclose(res, correct), (res, correct) DCNL DCSP print('{:>5.0f} DCSP ms'.format((min(repeat((lambda : func(*args, **kwargs)), number=5, repeat=2)) * 1000))) DCNL DCSP return res
 DCSP from nltk import Tree, ProbabilisticTree DCNL DCSP s = u'(S DCSP (NP DCSP (DT DCSP the) DCSP (NN DCSP cat)) DCSP (VP DCSP (VBD DCSP ate) DCSP (NP DCSP (DT DCSP a) DCSP (NN DCSP cookie))))' DCNL DCSP t = Tree.fromstring(s) DCNL DCSP print(u'Convert DCSP bracketed DCSP string DCSP into DCSP tree:') DCNL DCSP print(t) DCNL DCSP print(t.__repr__()) DCNL DCSP print(u'Display DCSP tree DCSP properties:') DCNL DCSP print(t.label()) DCNL DCSP print(t[0]) DCNL DCSP print(t[1]) DCNL DCSP print(t.height()) DCNL DCSP print(t.leaves()) DCNL DCSP print(t[1]) DCNL DCSP print(t[(1, 1)]) DCNL DCSP print(t[(1, 1, 0)]) DCNL DCSP the_cat = t[0] DCNL DCSP the_cat.insert(1, Tree.fromstring(u'(JJ DCSP big)')) DCNL DCSP print(u'Tree DCSP modification:') DCNL DCSP print(t) DCNL DCSP t[(1, 1, 1)] = Tree.fromstring(u'(NN DCSP cake)') DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP print(u'Collapse DCSP unary:') DCNL DCSP t.collapse_unary() DCNL DCSP print(t) DCNL DCSP print(u'Chomsky DCSP normal DCSP form:') DCNL DCSP t.chomsky_normal_form() DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP pt = ProbabilisticTree(u'x', [u'y', u'z'], prob=0.5) DCNL DCSP print(u'Probabilistic DCSP Tree:') DCNL DCSP print(pt) DCNL DCSP print() DCNL DCSP t = Tree.fromstring(t.pformat()) DCNL DCSP print(u'Convert DCSP tree DCSP to DCSP bracketed DCSP string DCSP and DCSP back DCSP again:') DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP print(u'LaTeX DCSP output:') DCNL DCSP print(t.pformat_latex_qtree()) DCNL DCSP print() DCNL DCSP print(u'Production DCSP output:') DCNL DCSP print(t.productions()) DCNL DCSP print() DCNL DCSP t.set_label((u'test', 3)) DCNL DCSP print(t)
 DCSP if (node.op != T.mul): DCNL DCSP  DCSP return False DCNL DCSP for (idx, i) in enumerate(node.inputs): DCNL DCSP  DCSP if (i.owner and (i.owner.op == T.switch)): DCNL DCSP  DCSP  DCSP switch = i.owner DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (get_scalar_constant_value(switch.inputs[1], only_process_constants=True) == 0.0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP listmul = (node.inputs[:idx] + node.inputs[(idx + 1):]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fmul = T.mul(*(listmul + [switch.inputs[2]])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace(node.outputs, fmul) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct = [T.switch(switch.inputs[0], 0, fmul)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct[0].tag.values_eq_approx = values_eq_approx_remove_nan DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace((node.outputs + switch.outputs), fct) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return fct DCNL DCSP  DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (get_scalar_constant_value(switch.inputs[2], only_process_constants=True) == 0.0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP listmul = (node.inputs[:idx] + node.inputs[(idx + 1):]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fmul = T.mul(*(listmul + [switch.inputs[1]])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace(node.outputs, fmul) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct = [T.switch(switch.inputs[0], fmul, 0)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct[0].tag.values_eq_approx = values_eq_approx_remove_nan DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace((node.outputs + switch.outputs), fct) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return fct DCNL DCSP  DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return False
 DCSP query = ((FS('followup_date') <= datetime.datetime.utcnow().date()) & (FS('completed') != True)) DCNL DCSP resource = current.s3db.resource('po_household_followup', filter=query) DCNL DCSP return resource.count()
 DCSP return _strips('l', text, remove)
 DCSP repository = getNewRepository() DCNL DCSP repository.fileNameInput.value = fileName DCNL DCSP settings.startMainLoopFromWindow(repository.execute())
 DCSP real_dst = dst DCNL DCSP if os.path.isdir(dst): DCNL DCSP  DCSP if _samefile(src, dst): DCNL DCSP  DCSP  DCSP os.rename(src, dst) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP real_dst = os.path.join(dst, _basename(src)) DCNL DCSP  DCSP if os.path.exists(real_dst): DCNL DCSP  DCSP  DCSP raise Error, ("Destination DCSP path DCSP '%s' DCSP already DCSP exists" % real_dst) DCNL DCSP try: DCNL DCSP  DCSP os.rename(src, real_dst) DCNL DCSP except OSError: DCNL DCSP  DCSP if os.path.isdir(src): DCNL DCSP  DCSP  DCSP if _destinsrc(src, dst): DCNL DCSP  DCSP  DCSP  DCSP raise Error, ("Cannot DCSP move DCSP a DCSP directory DCSP '%s' DCSP into DCSP itself DCSP '%s'." % (src, dst)) DCNL DCSP  DCSP  DCSP copytree(src, real_dst, symlinks=True) DCNL DCSP  DCSP  DCSP rmtree(src) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP copy2(src, real_dst) DCNL DCSP  DCSP  DCSP os.unlink(src)
 DCSP if (iri is None): DCNL DCSP  DCSP return iri DCNL DCSP return quote(force_bytes(iri), safe="/#%[]=:;$&()+,!?*@'~")
 DCSP pypi = current_version DCNL DCSP try: DCNL DCSP  DCSP pypi = available_on_pypi(prerelease) DCNL DCSP except Exception: DCNL DCSP  DCSP log.warning('An DCSP issue DCSP occurred DCSP while DCSP checking DCSP PyPI') DCNL DCSP best = max(pypi, current_version) DCNL DCSP where = None DCNL DCSP command = None DCNL DCSP cache = cache_file() DCNL DCSP if cache: DCNL DCSP  DCSP os.utime(cache, None) DCNL DCSP if (best == current_version): DCNL DCSP  DCSP log.info(('You DCSP have DCSP the DCSP latest DCSP version DCSP of DCSP Pwntools DCSP (%s)' % best)) DCNL DCSP  DCSP return DCNL DCSP command = ['pip', 'install', '-U'] DCNL DCSP if (best == pypi): DCNL DCSP  DCSP where = 'pypi' DCNL DCSP  DCSP pypi_package = package_name DCNL DCSP  DCSP if best.is_prerelease: DCNL DCSP  DCSP  DCSP pypi_package += ('==%s' % best) DCNL DCSP  DCSP command += [pypi_package] DCNL DCSP command_str = ' DCSP '.join(command) DCNL DCSP log.info((('A DCSP newer DCSP version DCSP of DCSP %s DCSP is DCSP available DCSP on DCSP %s DCSP (%s DCSP --> DCSP %s).\n' % (package_name, where, current_version, best)) + ('Update DCSP with: DCSP $ DCSP %s' % command_str))) DCNL DCSP return command
 DCSP try: DCNL DCSP  DCSP reg = request.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP url_adapter = reg.queryMultiAdapter((resource, request), IResourceURL) DCNL DCSP if (url_adapter is None): DCNL DCSP  DCSP url_adapter = ResourceURL(resource, request) DCNL DCSP (vpath, rpath) = (url_adapter.virtual_path, url_adapter.physical_path) DCNL DCSP if ((rpath != vpath) and rpath.endswith(vpath)): DCNL DCSP  DCSP vroot_path = rpath[:(- len(vpath))] DCNL DCSP  DCSP return find_resource(resource, vroot_path) DCNL DCSP try: DCNL DCSP  DCSP return request.root DCNL DCSP except AttributeError: DCNL DCSP  DCSP return find_root(resource)
 DCSP ret = '' DCNL DCSP try: DCNL DCSP  DCSP with salt.utils.fopen(conf_path, 'r') as fp_: DCNL DCSP  DCSP  DCSP for line in fp_: DCNL DCSP  DCSP  DCSP  DCSP ret += line DCNL DCSP except IOError as exc: DCNL DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP raise CommandExecutionError('{0} DCSP does DCSP not DCSP exist'.format(conf_path)) DCNL DCSP  DCSP elif (exc.errno == errno.EACCES): DCNL DCSP  DCSP  DCSP raise CommandExecutionError('Unable DCSP to DCSP read DCSP {0}, DCSP access DCSP denied'.format(conf_path)) DCNL DCSP  DCSP elif (exc.errno == errno.EISDIR): DCNL DCSP  DCSP  DCSP raise CommandExecutionError('Unable DCSP to DCSP read DCSP {0}, DCSP path DCSP is DCSP a DCSP directory'.format(conf_path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise CommandExecutionError('Error DCSP {0}: DCSP {1}'.format(exc.errno, exc.strerror)) DCNL DCSP else: DCNL DCSP  DCSP return ret
 DCSP return int((time.time() * scale))
 DCSP if (not isinstance(key, (list, tuple))): DCNL DCSP  DCSP key = [key] DCNL DCSP return [table.columns[name] for name in key]
 DCSP _NO_DEFAULT.check(interfaceIndex) DCNL DCSP _NO_DEFAULT.check(name) DCNL DCSP _NO_DEFAULT.check(regtype) DCNL DCSP _NO_DEFAULT.check(domain) DCNL DCSP @_DNSServiceResolveReply DCNL DCSP def _callback(sdRef, flags, interfaceIndex, errorCode, fullname, hosttarget, port, txtLen, txtRecord, context): DCNL DCSP  DCSP if (callBack is not None): DCNL DCSP  DCSP  DCSP port = socket.ntohs(port) DCNL DCSP  DCSP  DCSP txtRecord = _length_and_void_p_to_string(txtLen, txtRecord) DCNL DCSP  DCSP  DCSP callBack(sdRef, flags, interfaceIndex, errorCode, fullname.decode(), hosttarget.decode(), port, txtRecord) DCNL DCSP _global_lock.acquire() DCNL DCSP try: DCNL DCSP  DCSP sdRef = _DNSServiceResolve(flags, interfaceIndex, name, regtype, domain, _callback, None) DCNL DCSP finally: DCNL DCSP  DCSP _global_lock.release() DCNL DCSP sdRef._add_callback(_callback) DCNL DCSP return sdRef
 DCSP import regutil, string DCNL DCSP if (not packageName): DCNL DCSP  DCSP raise error('A DCSP package DCSP name DCSP must DCSP be DCSP supplied') DCNL DCSP corePaths = regutil.GetRegisteredNamedPath(None).split(';') DCNL DCSP if (not searchPaths): DCNL DCSP  DCSP searchPaths = corePaths DCNL DCSP registryAppName = (registryAppName or packageName) DCNL DCSP try: DCNL DCSP  DCSP (pathLook, pathAdd) = FindPackagePath(packageName, knownFile, searchPaths) DCNL DCSP  DCSP if (pathAdd is not None): DCNL DCSP  DCSP  DCSP if (pathAdd in corePaths): DCNL DCSP  DCSP  DCSP  DCSP pathAdd = '' DCNL DCSP  DCSP  DCSP regutil.RegisterNamedPath(registryAppName, pathAdd) DCNL DCSP  DCSP return pathLook DCNL DCSP except error as details: DCNL DCSP  DCSP print ('*** DCSP The DCSP %s DCSP package DCSP could DCSP not DCSP be DCSP registered DCSP - DCSP %s' % (packageName, details)) DCNL DCSP  DCSP print '*** DCSP Please DCSP ensure DCSP you DCSP have DCSP passed DCSP the DCSP correct DCSP paths DCSP on DCSP the DCSP command DCSP line.' DCNL DCSP  DCSP print '*** DCSP - DCSP For DCSP packages, DCSP you DCSP should DCSP pass DCSP a DCSP path DCSP to DCSP the DCSP packages DCSP parent DCSP directory,' DCNL DCSP  DCSP print '*** DCSP - DCSP and DCSP not DCSP the DCSP package DCSP directory DCSP itself...'
 DCSP return _osquery_cmd(table='kernel_info', attrs=attrs, where=where)
 DCSP return {'geometry': geometry, 'atoms': atoms}
 DCSP tax_rules = TaxRule.objects.may_match_postal_code(taxing_context.postal_code).filter(enabled=True, tax_classes=tax_class) DCNL DCSP if taxing_context.customer_tax_group: DCNL DCSP  DCSP tax_rules = tax_rules.filter((Q(customer_tax_groups=taxing_context.customer_tax_group) | Q(customer_tax_groups=None))) DCNL DCSP tax_rules = tax_rules.order_by('-override_group', 'priority') DCNL DCSP return tax_rules
 DCSP values = (1.0 / (1.0 + np.arange(((2 * n) - 1)))) DCNL DCSP h = hankel(values[:n], r=values[(n - 1):]) DCNL DCSP return h
 DCSP return float(sum(iterable))
 DCSP (writer, outf) = outf_writer_compat(outfile, encoding, errors, gzip_compress) DCNL DCSP header = get_header_field_list(main_fields, entity_type, entity_fields) DCNL DCSP writer.writerow(header) DCNL DCSP for line in tweets_file: DCNL DCSP  DCSP tweet = json.loads(line) DCNL DCSP  DCSP if _is_composed_key(entity_type): DCNL DCSP  DCSP  DCSP (key, value) = _get_key_value_composed(entity_type) DCNL DCSP  DCSP  DCSP object_json = _get_entity_recursive(tweet, key) DCNL DCSP  DCSP  DCSP if (not object_json): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP object_fields = extract_fields(object_json, main_fields) DCNL DCSP  DCSP  DCSP items = _get_entity_recursive(object_json, value) DCNL DCSP  DCSP  DCSP _write_to_file(object_fields, items, entity_fields, writer) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tweet_fields = extract_fields(tweet, main_fields) DCNL DCSP  DCSP  DCSP items = _get_entity_recursive(tweet, entity_type) DCNL DCSP  DCSP  DCSP _write_to_file(tweet_fields, items, entity_fields, writer) DCNL DCSP outf.close()
 DCSP return IMPL.quota_allocated_update(context, project_id, resource, allocated)
 DCSP max = kwargs.pop('max', None) DCNL DCSP config = _GetConfigFromKwargs(kwargs) DCNL DCSP if (getattr(config, 'read_policy', None) == EVENTUAL_CONSISTENCY): DCNL DCSP  DCSP raise datastore_errors.BadRequestError('read_policy DCSP is DCSP only DCSP supported DCSP on DCSP read DCSP operations.') DCNL DCSP (keys, _) = NormalizeAndTypeCheckKeys(model_key) DCNL DCSP if (len(keys) > 1): DCNL DCSP  DCSP raise datastore_errors.BadArgumentError('Cannot DCSP allocate DCSP IDs DCSP for DCSP more DCSP than DCSP one DCSP model DCSP key DCSP at DCSP a DCSP time') DCNL DCSP rpc = _GetConnection().async_allocate_ids(config, keys[0], size, max) DCNL DCSP return rpc
 DCSP (payload, symtab, radix, count) = _filterargs(source) DCNL DCSP if (count != len(symtab)): DCNL DCSP  DCSP raise UnpackingError('Malformed DCSP p.a.c.k.e.r. DCSP symtab.') DCNL DCSP try: DCNL DCSP  DCSP unbase = Unbaser(radix) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise UnpackingError('Unknown DCSP p.a.c.k.e.r. DCSP encoding.') DCNL DCSP def lookup(match): DCNL DCSP  DCSP 'Look DCSP up DCSP symbols DCSP in DCSP the DCSP synthetic DCSP symtab.' DCNL DCSP  DCSP word = match.group(0) DCNL DCSP  DCSP return (symtab[unbase(word)] or word) DCNL DCSP source = re.sub('\\b\\w+\\b', lookup, payload) DCNL DCSP return _replacestrings(source)
 DCSP orig = msg.get_payload(decode=True) DCNL DCSP encdata = _qencode(orig) DCNL DCSP msg.set_payload(encdata) DCNL DCSP msg['Content-Transfer-Encoding'] = 'quoted-printable'
 DCSP def println(value): DCNL DCSP  DCSP u'Write DCSP a DCSP new DCSP line DCSP containing DCSP `value` DCSP to DCSP `out`.' DCNL DCSP  DCSP out.write((value + u'\n')) DCNL DCSP footer = read_footer(filename) DCNL DCSP println(u'File DCSP Metadata: DCSP {0}'.format(filename)) DCNL DCSP println(u' DCSP  DCSP Version: DCSP {0}'.format(footer.version)) DCNL DCSP println(u' DCSP  DCSP Num DCSP Rows: DCSP {0}'.format(footer.num_rows)) DCNL DCSP println(u' DCSP  DCSP k/v DCSP metadata: DCSP ') DCNL DCSP if (footer.key_value_metadata and (len(footer.key_value_metadata) > 0)): DCNL DCSP  DCSP for item in footer.key_value_metadata: DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP {0}={1}'.format(item.key, item.value)) DCNL DCSP else: DCNL DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP (none)') DCNL DCSP println(u' DCSP  DCSP schema: DCSP ') DCNL DCSP for element in footer.schema: DCNL DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP {name} DCSP ({type}): DCSP length={type_length}, DCSP repetition={repetition_type}, DCSP children={num_children}, DCSP converted_type={converted_type}'.format(name=element.name, type=(parquet_thrift.Type._VALUES_TO_NAMES[element.type] if element.type else None), type_length=element.type_length, repetition_type=_get_name(parquet_thrift.FieldRepetitionType, element.repetition_type), num_children=element.num_children, converted_type=element.converted_type)) DCNL DCSP if show_row_group_metadata: DCNL DCSP  DCSP println(u' DCSP  DCSP row DCSP groups: DCSP ') DCNL DCSP  DCSP for row_group in footer.row_groups: DCNL DCSP  DCSP  DCSP num_rows = row_group.num_rows DCNL DCSP  DCSP  DCSP size_bytes = row_group.total_byte_size DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP rows={num_rows}, DCSP bytes={bytes}'.format(num_rows=num_rows, bytes=size_bytes)) DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP chunks:') DCNL DCSP  DCSP  DCSP for col_group in row_group.columns: DCNL DCSP  DCSP  DCSP  DCSP cmd = col_group.meta_data DCNL DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type={type} DCSP file_offset={offset} DCSP compression={codec} DCSP encodings={encodings} DCSP path_in_schema={path_in_schema} DCSP num_values={num_values} DCSP uncompressed_bytes={raw_bytes} DCSP compressed_bytes={compressed_bytes} DCSP data_page_offset={data_page_offset} DCSP dictionary_page_offset={dictionary_page_offset}'.format(type=_get_name(parquet_thrift.Type, cmd.type), offset=col_group.file_offset, codec=_get_name(parquet_thrift.CompressionCodec, cmd.codec), encodings=u','.join([_get_name(parquet_thrift.Encoding, s) for s in cmd.encodings]), path_in_schema=cmd.path_in_schema, num_values=cmd.num_values, raw_bytes=cmd.total_uncompressed_size, compressed_bytes=cmd.total_compressed_size, data_page_offset=cmd.data_page_offset, dictionary_page_offset=cmd.dictionary_page_offset)) DCNL DCSP  DCSP  DCSP  DCSP with open(filename, u'rb') as file_obj: DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = _get_offset(cmd) DCNL DCSP  DCSP  DCSP  DCSP  DCSP file_obj.seek(offset, 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP values_read = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pages: DCSP ') DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (values_read < num_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page_header = _read_page_header(file_obj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP file_obj.seek(page_header.compressed_page_size, 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP daph = page_header.data_page_header DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type_ = _get_name(parquet_thrift.PageType, page_header.type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raw_bytes = page_header.uncompressed_page_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP num_values = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (page_header.type == parquet_thrift.PageType.DATA_PAGE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP num_values = daph.num_values DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values_read += num_values DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (page_header.type == parquet_thrift.PageType.DICTIONARY_PAGE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP encoding_type = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def_level_encoding = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rep_level_encoding = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if daph: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP encoding_type = _get_name(parquet_thrift.Encoding, daph.encoding) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def_level_encoding = _get_name(parquet_thrift.Encoding, daph.definition_level_encoding) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rep_level_encoding = _get_name(parquet_thrift.Encoding, daph.repetition_level_encoding) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page DCSP header: DCSP type={type} DCSP uncompressed_size={raw_bytes} DCSP num_values={num_values} DCSP encoding={encoding} DCSP def_level_encoding={def_level_encoding} DCSP rep_level_encoding={rep_level_encoding}'.format(type=type_, raw_bytes=raw_bytes, num_values=num_values, encoding=encoding_type, def_level_encoding=def_level_encoding, rep_level_encoding=rep_level_encoding))
 DCSP q = {} DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP q['user_id'] = sample_filter.user DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP q['project_id'] = sample_filter.project DCNL DCSP if sample_filter.meter: DCNL DCSP  DCSP q['counter_name'] = sample_filter.meter DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP ts_range = make_timestamp_range(sample_filter.start_timestamp, sample_filter.end_timestamp, sample_filter.start_timestamp_op, sample_filter.end_timestamp_op) DCNL DCSP if ts_range: DCNL DCSP  DCSP q['timestamp'] = ts_range DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP q['resource_id'] = sample_filter.resource DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP q['source'] = sample_filter.source DCNL DCSP if sample_filter.message_id: DCNL DCSP  DCSP q['message_id'] = sample_filter.message_id DCNL DCSP q.update(dict(((('resource_%s' % k), v) for (k, v) in six.iteritems(improve_keys(sample_filter.metaquery, metaquery=True))))) DCNL DCSP return q
 DCSP return _validate_user_input(InputDialog(message, default_value, is_truthy(hidden)))
 DCSP priv_subnets = [{'subnet': '10.0.0.0', 'mask': '255.0.0.0'}, {'subnet': '172.16.0.0', 'mask': '255.240.0.0'}, {'subnet': '192.168.0.0', 'mask': '255.255.0.0'}] DCNL DCSP ip = struct.unpack('I', socket.inet_aton(ip))[0] DCNL DCSP for network in priv_subnets: DCNL DCSP  DCSP subnet = struct.unpack('I', socket.inet_aton(network['subnet']))[0] DCNL DCSP  DCSP mask = struct.unpack('I', socket.inet_aton(network['mask']))[0] DCNL DCSP  DCSP if ((ip & mask) == (subnet & mask)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP event_name = '.'.join(['edx', 'certificate', event_name]) DCNL DCSP if (course is None): DCNL DCSP  DCSP course = modulestore().get_course(course_id, depth=0) DCNL DCSP context = {'org_id': course.org, 'course_id': unicode(course_id)} DCNL DCSP data = {'user_id': user.id, 'course_id': unicode(course_id), 'certificate_url': get_certificate_url(user.id, course_id)} DCNL DCSP event_data = (event_data or {}) DCNL DCSP event_data.update(data) DCNL DCSP with tracker.get_tracker().context(event_name, context): DCNL DCSP  DCSP tracker.emit(event_name, event_data)
 DCSP checkpoint_dir = (out_fp + '/checkpoints/') DCNL DCSP if (not exists(checkpoint_dir)): DCNL DCSP  DCSP create_dir(checkpoint_dir) DCNL DCSP out_fp = (checkpoint_dir + ('/checkpoint%d.pickle' % ctr)) DCNL DCSP out_fh = open(out_fp, 'w') DCNL DCSP pickle.dump((current_key, ctr, cluster_mapping, ids, bestscores, order), out_fh) DCNL DCSP return out_fp
 DCSP LOG.debug(_('get_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).filter_by(port_id=port_id).filter_by(instance_id=instance_id).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
 DCSP if user_ref: DCNL DCSP  DCSP user_ref = user_ref.copy() DCNL DCSP  DCSP user_ref.pop('password', None) DCNL DCSP  DCSP user_ref.pop('tenants', None) DCNL DCSP  DCSP user_ref.pop('groups', None) DCNL DCSP  DCSP user_ref.pop('domains', None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('password', None) DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('tenants', None) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ('password_expires_at' not in user_ref): DCNL DCSP  DCSP  DCSP user_ref['password_expires_at'] = None DCNL DCSP return user_ref
 DCSP warnings.warn('`BdbQuit_excepthook` DCSP is DCSP deprecated DCSP since DCSP version DCSP 5.1', DeprecationWarning, stacklevel=2) DCNL DCSP if (et == bdb.BdbQuit): DCNL DCSP  DCSP print 'Exiting DCSP Debugger.' DCNL DCSP elif (excepthook is not None): DCNL DCSP  DCSP excepthook(et, ev, tb) DCNL DCSP else: DCNL DCSP  DCSP BdbQuit_excepthook.excepthook_ori(et, ev, tb)
 DCSP redirect_value = request.REQUEST.get(REDIRECT_FIELD_NAME) DCNL DCSP if redirect_value: DCNL DCSP  DCSP redirect_querystring = ((REDIRECT_FIELD_NAME + '=') + redirect_value) DCNL DCSP else: DCNL DCSP  DCSP redirect_querystring = '' DCNL DCSP return {'REDIRECT_FIELD_NAME': REDIRECT_FIELD_NAME, 'REDIRECT_FIELD_VALUE': redirect_value, 'redirect_querystring': redirect_querystring}
 DCSP from django.db.models import get_model DCNL DCSP try: DCNL DCSP  DCSP (app_label, model_name) = settings.AUTH_USER_MODEL.split('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ImproperlyConfigured("AUTH_USER_MODEL DCSP must DCSP be DCSP of DCSP the DCSP form DCSP 'app_label.model_name'") DCNL DCSP user_model = get_model(app_label, model_name) DCNL DCSP if (user_model is None): DCNL DCSP  DCSP raise ImproperlyConfigured(("AUTH_USER_MODEL DCSP refers DCSP to DCSP model DCSP '%s' DCSP that DCSP has DCSP not DCSP been DCSP installed" % settings.AUTH_USER_MODEL)) DCNL DCSP return user_model
 DCSP if meta: DCNL DCSP  DCSP for name in USELESS_META: DCNL DCSP  DCSP  DCSP if (name in meta): DCNL DCSP  DCSP  DCSP  DCSP del meta[name] DCNL DCSP return meta
 DCSP assert (rnncell_fw._num_units == rnncell_bw._num_units), 'RNN DCSP Cells DCSP number DCSP of DCSP units DCSP must DCSP match!' DCNL DCSP sequence_length = None DCNL DCSP if dynamic: DCNL DCSP  DCSP sequence_length = retrieve_seq_length_op((incoming if isinstance(incoming, tf.Tensor) else tf.pack(incoming))) DCNL DCSP input_shape = utils.get_incoming_shape(incoming) DCNL DCSP with tf.variable_scope(scope, name, values=[incoming]) as scope: DCNL DCSP  DCSP name = scope.name DCNL DCSP  DCSP inference = incoming DCNL DCSP  DCSP if (type(inference) not in [list, np.array]): DCNL DCSP  DCSP  DCSP ndim = len(input_shape) DCNL DCSP  DCSP  DCSP assert (ndim >= 3), 'Input DCSP dim DCSP should DCSP be DCSP at DCSP least DCSP 3.' DCNL DCSP  DCSP  DCSP axes = ([1, 0] + list(range(2, ndim))) DCNL DCSP  DCSP  DCSP inference = tf.transpose(inference, axes) DCNL DCSP  DCSP  DCSP inference = tf.unpack(inference) DCNL DCSP  DCSP (outputs, states_fw, states_bw) = _brnn(rnncell_fw, rnncell_bw, inference, initial_state_fw=initial_state_fw, initial_state_bw=initial_state_bw, sequence_length=sequence_length, dtype=tf.float32) DCNL DCSP  DCSP c = ((tf.GraphKeys.LAYER_VARIABLES + '/') + scope.name) DCNL DCSP  DCSP for v in [rnncell_fw.W, rnncell_fw.b, rnncell_bw.W, rnncell_bw.b]: DCNL DCSP  DCSP  DCSP if hasattr(v, '__len__'): DCNL DCSP  DCSP  DCSP  DCSP for var in v: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tf.add_to_collection(c, var) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tf.add_to_collection(c, v) DCNL DCSP  DCSP tf.add_to_collection(tf.GraphKeys.ACTIVATIONS, outputs[(-1)]) DCNL DCSP if dynamic: DCNL DCSP  DCSP if return_seq: DCNL DCSP  DCSP  DCSP o = outputs DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP outputs = tf.transpose(tf.pack(outputs), [1, 0, 2]) DCNL DCSP  DCSP  DCSP o = advanced_indexing_op(outputs, sequence_length) DCNL DCSP else: DCNL DCSP  DCSP o = (outputs if return_seq else outputs[(-1)]) DCNL DCSP sfw = states_fw DCNL DCSP sbw = states_bw DCNL DCSP tf.add_to_collection(((tf.GraphKeys.LAYER_TENSOR + '/') + name), o) DCNL DCSP return ((o, sfw, sbw) if return_states else o)
 DCSP scenario = Scenario.from_string(OUTLINED_SCENARIO) DCNL DCSP assert_equals(len(scenario.steps), 4) DCNL DCSP expected_sentences = ['Given DCSP I DCSP have DCSP entered DCSP <input_1> DCSP into DCSP the DCSP calculator', 'And DCSP I DCSP have DCSP entered DCSP <input_2> DCSP into DCSP the DCSP calculator', 'When DCSP I DCSP press DCSP <button>', 'Then DCSP the DCSP result DCSP should DCSP be DCSP <output> DCSP on DCSP the DCSP screen'] DCNL DCSP for (step, expected_sentence) in zip(scenario.steps, expected_sentences): DCNL DCSP  DCSP assert_equals(type(step), Step) DCNL DCSP  DCSP assert_equals(step.sentence, expected_sentence) DCNL DCSP assert_equals(scenario.name, 'Add DCSP two DCSP numbers') DCNL DCSP assert_equals(scenario.outlines, [{'input_1': '20', 'input_2': '30', 'button': 'add', 'output': '50'}, {'input_1': '2', 'input_2': '5', 'button': 'add', 'output': '7'}, {'input_1': '0', 'input_2': '40', 'button': 'add', 'output': '40'}])
 DCSP string = string.replace('&amp;', '&') DCNL DCSP string = string.replace('&lt;', '<') DCNL DCSP string = string.replace('&gt;', '>') DCNL DCSP string = string.replace('&quot;', '"') DCNL DCSP string = string.replace('/', SLASH) DCNL DCSP return string
 DCSP return rv(name, ChiNoncentralDistribution, (k, l))
 DCSP return (referred_cls.__name__.lower() + '_collection')
 DCSP postag(ruleformat='str')
 DCSP return __opts__.get('location', config.get_cloud_config_value('location', (vm_ or get_configured_provider()), __opts__, default=DEFAULT_LOCATION, search_global=False))
 DCSP t = Table([np.array([u'a', u'b', u'cd'])]) DCNL DCSP t.write(str(tmpdir.join('test.fits')), overwrite=True) DCNL DCSP with fits.open(str(tmpdir.join('test.fits'))) as hdul: DCNL DCSP  DCSP assert np.all((hdul[1].data['col0'] == ['a', 'b', 'cd'])) DCNL DCSP  DCSP assert (hdul[1].header['TFORM1'] == '2A') DCNL DCSP t2 = Table([np.array([u'\u2603'])]) DCNL DCSP with pytest.raises(UnicodeEncodeError): DCNL DCSP  DCSP t2.write(str(tmpdir.join('test.fits')), overwrite=True)
 DCSP unfrozen = path.get_home_dir() DCNL DCSP sys.frozen = True DCNL DCSP IPython.__file__ = abspath(join(HOME_TEST_DIR, 'Lib/IPython/__init__.py')) DCNL DCSP home_dir = path.get_home_dir() DCNL DCSP nt.assert_equal(home_dir, unfrozen)
 DCSP if (isinstance(value, string_types) and value.endswith('%')): DCNL DCSP  DCSP value_pct = int(value.replace('%', '')) DCNL DCSP  DCSP return (int(((value_pct / 100.0) * num_items)) or min_value) DCNL DCSP else: DCNL DCSP  DCSP return int(value)
 DCSP next_slice = (max if (kwargs.get('order', 'descending') == 'descending') else min) DCNL DCSP iterators = [PeekableIterator(s) for s in series] DCNL DCSP widths = [] DCNL DCSP for w in iterators: DCNL DCSP  DCSP r = w.peek() DCNL DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP (date, values) = r DCNL DCSP  DCSP  DCSP widths.append(len(values)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP widths.append(0) DCNL DCSP while True: DCNL DCSP  DCSP items = [it.peek() for it in iterators] DCNL DCSP  DCSP if (not any(items)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP current_slice = next_slice((item[0] for item in items if item)) DCNL DCSP  DCSP data = [] DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if (item and (item[0] == current_slice)): DCNL DCSP  DCSP  DCSP  DCSP data.extend(item[1]) DCNL DCSP  DCSP  DCSP  DCSP iterators[i].next() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP data.extend(([0] * widths[i])) DCNL DCSP  DCSP (yield (current_slice, tuple(data)))
 DCSP parts = html_parts(input_string=input_string, source_path=source_path, destination_path=destination_path, input_encoding=input_encoding, doctitle=doctitle, initial_header_level=initial_header_level) DCNL DCSP fragment = parts['html_body'] DCNL DCSP if (output_encoding != 'unicode'): DCNL DCSP  DCSP fragment = fragment.encode(output_encoding) DCNL DCSP return fragment
 DCSP l1 = 400 DCNL DCSP l2 = 700 DCNL DCSP hue = np.clip(((((l2 - l1) - (wl - l1)) * 0.8) / (l2 - l1)), 0, 0.8) DCNL DCSP val = 1.0 DCNL DCSP if (wl > 700): DCNL DCSP  DCSP val = (1.0 * (((700 - wl) / 700.0) + 1)) DCNL DCSP elif (wl < 400): DCNL DCSP  DCSP val = ((wl * 1.0) / 400.0) DCNL DCSP color = pg.hsvColor(hue, 1.0, val) DCNL DCSP pen = pg.mkPen(color) DCNL DCSP return pen
 DCSP frags = defaultdict((lambda : [])) DCNL DCSP final = [] DCNL DCSP pos = 0 DCNL DCSP for p in plist: DCNL DCSP  DCSP p._defrag_pos = pos DCNL DCSP  DCSP pos += 1 DCNL DCSP  DCSP if (IP in p): DCNL DCSP  DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP  DCSP if ((ip.frag != 0) or (ip.flags & 1)): DCNL DCSP  DCSP  DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP  DCSP  DCSP uniq = (ip.id, ip.src, ip.dst, ip.proto) DCNL DCSP  DCSP  DCSP  DCSP frags[uniq].append(p) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP final.append(p) DCNL DCSP defrag = [] DCNL DCSP missfrag = [] DCNL DCSP for lst in frags.itervalues(): DCNL DCSP  DCSP lst.sort(key=(lambda x: x.frag)) DCNL DCSP  DCSP p = lst[0] DCNL DCSP  DCSP lastp = lst[(-1)] DCNL DCSP  DCSP if ((p.frag > 0) or ((lastp.flags & 1) != 0)): DCNL DCSP  DCSP  DCSP missfrag += lst DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP p = p.copy() DCNL DCSP  DCSP if (conf.padding_layer in p): DCNL DCSP  DCSP  DCSP del p[conf.padding_layer].underlayer.payload DCNL DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP if ((ip.len is None) or (ip.ihl is None)): DCNL DCSP  DCSP  DCSP clen = len(ip.payload) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP clen = (ip.len - (ip.ihl << 2)) DCNL DCSP  DCSP txt = conf.raw_layer() DCNL DCSP  DCSP for q in lst[1:]: DCNL DCSP  DCSP  DCSP if (clen != (q.frag << 3)): DCNL DCSP  DCSP  DCSP  DCSP if (clen > (q.frag << 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warning(('Fragment DCSP overlap DCSP (%i DCSP > DCSP %i) DCSP %r DCSP || DCSP %r DCSP || DCSP  DCSP %r' % (clen, (q.frag << 3), p, txt, q))) DCNL DCSP  DCSP  DCSP  DCSP missfrag += lst DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((q[IP].len is None) or (q[IP].ihl is None)): DCNL DCSP  DCSP  DCSP  DCSP clen += len(q[IP].payload) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP clen += (q[IP].len - (q[IP].ihl << 2)) DCNL DCSP  DCSP  DCSP if (conf.padding_layer in q): DCNL DCSP  DCSP  DCSP  DCSP del q[conf.padding_layer].underlayer.payload DCNL DCSP  DCSP  DCSP txt.add_payload(q[IP].payload.copy()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ip.flags &= (~ 1) DCNL DCSP  DCSP  DCSP del ip.chksum DCNL DCSP  DCSP  DCSP del ip.len DCNL DCSP  DCSP  DCSP p = (p / txt) DCNL DCSP  DCSP  DCSP p._defrag_pos = max((x._defrag_pos for x in lst)) DCNL DCSP  DCSP  DCSP defrag.append(p) DCNL DCSP defrag2 = [] DCNL DCSP for p in defrag: DCNL DCSP  DCSP q = p.__class__(str(p)) DCNL DCSP  DCSP q._defrag_pos = p._defrag_pos DCNL DCSP  DCSP defrag2.append(q) DCNL DCSP final += defrag2 DCNL DCSP final += missfrag DCNL DCSP final.sort(key=(lambda x: x._defrag_pos)) DCNL DCSP for p in final: DCNL DCSP  DCSP del p._defrag_pos DCNL DCSP if hasattr(plist, 'listname'): DCNL DCSP  DCSP name = ('Defragmented DCSP %s' % plist.listname) DCNL DCSP else: DCNL DCSP  DCSP name = 'Defragmented' DCNL DCSP return PacketList(final, name=name)
 DCSP if (value is None): DCNL DCSP  DCSP return value DCNL DCSP return validate_positive_integer(option, value)
 DCSP n = 0 DCNL DCSP for b in serial.iterbytes(data): DCNL DCSP  DCSP (yield ('{:02X} DCSP '.format(ord(b)), (b.decode('ascii') if (' DCSP ' <= b < '\x7f') else '.'))) DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP if (n == 8): DCNL DCSP  DCSP  DCSP (yield (' DCSP ', '')) DCNL DCSP  DCSP elif (n >= 16): DCNL DCSP  DCSP  DCSP (yield (None, None)) DCNL DCSP  DCSP  DCSP n = 0 DCNL DCSP if (n > 0): DCNL DCSP  DCSP while (n < 16): DCNL DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP  DCSP if (n == 8): DCNL DCSP  DCSP  DCSP  DCSP (yield (' DCSP ', '')) DCNL DCSP  DCSP  DCSP (yield (' DCSP  DCSP  DCSP ', ' DCSP ')) DCNL DCSP  DCSP (yield (None, None))
 DCSP vert_template = Function('\n DCSP  DCSP  DCSP  DCSP void DCSP main(void)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gl_Position DCSP = DCSP $position;\n DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP ') DCNL DCSP transformScale = Function('\n DCSP  DCSP  DCSP  DCSP vec4 DCSP transform_scale(vec4 DCSP pos)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos.xyz DCSP *= DCSP $scale;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP pos;\n DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP ') DCNL DCSP class Transform(object, ): DCNL DCSP  DCSP def __init__(self): DCNL DCSP  DCSP  DCSP self.func = Function(transformScale) DCNL DCSP  DCSP  DCSP self.func['scale'] = 'uniform DCSP float' DCNL DCSP  DCSP def set_scale(self, scale): DCNL DCSP  DCSP  DCSP self.func['scale'].value = scale DCNL DCSP transforms = [Transform(), Transform(), Transform()] DCNL DCSP code = Function(vert_template) DCNL DCSP ob = Variable('attribute DCSP vec3 DCSP a_position') DCNL DCSP for trans in transforms: DCNL DCSP  DCSP ob = trans.func(ob) DCNL DCSP code['position'] = ob DCNL DCSP print code
 DCSP return pq(e).text()
 DCSP mlp = MLP(layers=[Linear(layer_name='h', dim=5, irange=0.01)]) DCNL DCSP conditional = DummyConditional(mlp=mlp, name='conditional') DCNL DCSP vae = DummyVAE() DCNL DCSP conditional.set_vae(vae) DCNL DCSP testing.assert_same_object(conditional.get_vae(), vae)
 DCSP values = values.copy() DCNL DCSP session = (session or get_session()) DCNL DCSP with session.begin(): DCNL DCSP  DCSP task_info_values = _pop_task_info_values(values) DCNL DCSP  DCSP task_ref = models.Task() DCNL DCSP  DCSP _task_update(context, task_ref, values, session=session) DCNL DCSP  DCSP _task_info_create(context, task_ref.id, task_info_values, session=session) DCNL DCSP return task_get(context, task_ref.id, session)
 DCSP evaluatedInt = getEvaluatedInt(key, xmlElement) DCNL DCSP if (evaluatedInt == None): DCNL DCSP  DCSP return defaultInt DCNL DCSP return evaluatedInt
 DCSP error_map = {blobstore_service_pb.BlobstoreServiceError.INTERNAL_ERROR: InternalError, blobstore_service_pb.BlobstoreServiceError.BLOB_NOT_FOUND: BlobNotFoundError, blobstore_service_pb.BlobstoreServiceError.DATA_INDEX_OUT_OF_RANGE: DataIndexOutOfRangeError, blobstore_service_pb.BlobstoreServiceError.BLOB_FETCH_SIZE_TOO_LARGE: BlobFetchSizeTooLargeError, blobstore_service_pb.BlobstoreServiceError.PERMISSION_DENIED: PermissionDeniedError} DCNL DCSP desired_exc = error_map.get(error.application_error) DCNL DCSP return (desired_exc(error.error_detail) if desired_exc else error)
 DCSP from sympy.polys.domains import ZZ DCNL DCSP X1 = [i for i in range(p) if (gf_eval(f, i, p, ZZ) == 0)] DCNL DCSP if (e == 1): DCNL DCSP  DCSP return X1 DCNL DCSP X = [] DCNL DCSP S = list(zip(X1, ([1] * len(X1)))) DCNL DCSP while S: DCNL DCSP  DCSP (x, s) = S.pop() DCNL DCSP  DCSP if (s == e): DCNL DCSP  DCSP  DCSP X.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s1 = (s + 1) DCNL DCSP  DCSP  DCSP ps = (p ** s) DCNL DCSP  DCSP  DCSP S.extend([((x + (v * ps)), s1) for v in _raise_mod_power(x, s, p, f)]) DCNL DCSP return sorted(X)
 DCSP if (subnet.get_meta('dhcp_server') is not None): DCNL DCSP  DCSP net_info = {'id': ('network%d' % net_num), 'type': ('ipv%d_dhcp' % version), 'link': link_id, 'network_id': vif['network']['id']} DCNL DCSP  DCSP return net_info DCNL DCSP ip = subnet['ips'][0] DCNL DCSP address = ip['address'] DCNL DCSP if (version == 4): DCNL DCSP  DCSP netmask = model.get_netmask(ip, subnet) DCNL DCSP elif (version == 6): DCNL DCSP  DCSP netmask = str(subnet.as_netaddr().netmask) DCNL DCSP net_info = {'id': ('network%d' % net_num), 'type': ('ipv%d' % version), 'link': link_id, 'ip_address': address, 'netmask': netmask, 'routes': _get_default_route(version, subnet), 'network_id': vif['network']['id']} DCNL DCSP for route in subnet['routes']: DCNL DCSP  DCSP route_addr = netaddr.IPNetwork(route['cidr']) DCNL DCSP  DCSP new_route = {'network': str(route_addr.network), 'netmask': str(route_addr.netmask), 'gateway': route['gateway']['address']} DCNL DCSP  DCSP net_info['routes'].append(new_route) DCNL DCSP return net_info
 DCSP try: DCNL DCSP  DCSP item_id = request.args[0] DCNL DCSP except: DCNL DCSP  DCSP raise HTTP(400, current.xml.json_message(False, 400, 'No DCSP value DCSP provided!')) DCNL DCSP table = s3db.inv_inv_item DCNL DCSP ptable = db.supply_item_pack DCNL DCSP query = ((table.id == item_id) & (table.item_pack_id == ptable.id)) DCNL DCSP record = db(query).select(table.quantity, ptable.quantity, limitby=(0, 1)).first() DCNL DCSP d = {'iquantity': record.inv_inv_item.quantity, 'pquantity': record.supply_item_pack.quantity} DCNL DCSP output = json.dumps(d) DCNL DCSP response.headers['Content-Type'] = 'application/json' DCNL DCSP return output
 DCSP module = (module or service) DCNL DCSP (cxkey, region, key, keyid) = _get_profile(service, region, key, keyid, profile) DCNL DCSP cxkey = (cxkey + ':conn3') DCNL DCSP if (cxkey in __context__): DCNL DCSP  DCSP return __context__[cxkey] DCNL DCSP try: DCNL DCSP  DCSP session = boto3.session.Session(aws_access_key_id=keyid, aws_secret_access_key=key, region_name=region) DCNL DCSP  DCSP if (session is None): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Region DCSP "{0}" DCSP is DCSP not DCSP valid.'.format(region)) DCNL DCSP  DCSP conn = session.client(module) DCNL DCSP  DCSP if (conn is None): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Region DCSP "{0}" DCSP is DCSP not DCSP valid.'.format(region)) DCNL DCSP except boto.exception.NoAuthHandlerFound: DCNL DCSP  DCSP raise SaltInvocationError('No DCSP authentication DCSP credentials DCSP found DCSP when DCSP attempting DCSP to DCSP make DCSP boto DCSP {0} DCSP connection DCSP to DCSP region DCSP "{1}".'.format(service, region)) DCNL DCSP __context__[cxkey] = conn DCNL DCSP return conn
 DCSP tconfig = XML.SubElement(xml_parent, 'hudson.tasks.BuildTrigger') DCNL DCSP childProjects = XML.SubElement(tconfig, 'childProjects') DCNL DCSP childProjects.text = data['project'] DCNL DCSP tthreshold = XML.SubElement(tconfig, 'threshold') DCNL DCSP threshold = data.get('threshold', 'SUCCESS') DCNL DCSP supported_thresholds = ['SUCCESS', 'UNSTABLE', 'FAILURE'] DCNL DCSP if (threshold not in supported_thresholds): DCNL DCSP  DCSP raise JenkinsJobsException(('threshold DCSP must DCSP be DCSP one DCSP of DCSP %s' % ', DCSP '.join(supported_thresholds))) DCNL DCSP tname = XML.SubElement(tthreshold, 'name') DCNL DCSP tname.text = hudson_model.THRESHOLDS[threshold]['name'] DCNL DCSP tordinal = XML.SubElement(tthreshold, 'ordinal') DCNL DCSP tordinal.text = hudson_model.THRESHOLDS[threshold]['ordinal'] DCNL DCSP tcolor = XML.SubElement(tthreshold, 'color') DCNL DCSP tcolor.text = hudson_model.THRESHOLDS[threshold]['color']
 DCSP pass
 DCSP return _unpack_simple(fid, '>f8', np.float64)
 DCSP toothProfileHalfCylinder = getToothProfileHalfCylinder(derivation, pitchRadius) DCNL DCSP toothProfileHalfCylinder = getThicknessMultipliedPath(toothProfileHalfCylinder, derivation.toothThicknessMultiplier) DCNL DCSP toothProfileHalf = [] DCNL DCSP innerRadius = (pitchRadius - derivation.dedendum) DCNL DCSP for point in toothProfileHalfCylinder: DCNL DCSP  DCSP if (abs(point) >= innerRadius): DCNL DCSP  DCSP  DCSP toothProfileHalf.append(point) DCNL DCSP return getToothProfileCylinderByProfile(derivation, pitchRadius, teeth, toothProfileHalf)
 DCSP if use_debugger: DCNL DCSP  DCSP from werkzeug.debug import DebuggedApplication DCNL DCSP  DCSP application = DebuggedApplication(application, use_evalex) DCNL DCSP if static_files: DCNL DCSP  DCSP from werkzeug.wsgi import SharedDataMiddleware DCNL DCSP  DCSP application = SharedDataMiddleware(application, static_files) DCNL DCSP def log_startup(sock): DCNL DCSP  DCSP display_hostname = (((hostname not in ('', '*')) and hostname) or 'localhost') DCNL DCSP  DCSP if (':' in display_hostname): DCNL DCSP  DCSP  DCSP display_hostname = ('[%s]' % display_hostname) DCNL DCSP  DCSP quit_msg = '(Press DCSP CTRL+C DCSP to DCSP quit)' DCNL DCSP  DCSP port = sock.getsockname()[1] DCNL DCSP  DCSP _log('info', ' DCSP * DCSP Running DCSP on DCSP %s://%s:%d/ DCSP %s', (((ssl_context is None) and 'http') or 'https'), display_hostname, port, quit_msg) DCNL DCSP def inner(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fd = int(os.environ['WERKZEUG_SERVER_FD']) DCNL DCSP  DCSP except (LookupError, ValueError): DCNL DCSP  DCSP  DCSP fd = None DCNL DCSP  DCSP srv = make_server(hostname, port, application, threaded, processes, request_handler, passthrough_errors, ssl_context, fd=fd) DCNL DCSP  DCSP if (fd is None): DCNL DCSP  DCSP  DCSP log_startup(srv.socket) DCNL DCSP  DCSP srv.serve_forever() DCNL DCSP if use_reloader: DCNL DCSP  DCSP if (os.environ.get('WERKZEUG_RUN_MAIN') != 'true'): DCNL DCSP  DCSP  DCSP if ((port == 0) and (not can_open_by_fd)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Cannot DCSP bind DCSP to DCSP a DCSP random DCSP port DCSP with DCSP enabled DCSP reloader DCSP if DCSP the DCSP Python DCSP interpreter DCSP does DCSP not DCSP support DCSP socket DCSP opening DCSP by DCSP fd.') DCNL DCSP  DCSP  DCSP address_family = select_ip_version(hostname, port) DCNL DCSP  DCSP  DCSP s = socket.socket(address_family, socket.SOCK_STREAM) DCNL DCSP  DCSP  DCSP s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP  DCSP  DCSP s.bind((hostname, port)) DCNL DCSP  DCSP  DCSP if hasattr(s, 'set_inheritable'): DCNL DCSP  DCSP  DCSP  DCSP s.set_inheritable(True) DCNL DCSP  DCSP  DCSP if can_open_by_fd: DCNL DCSP  DCSP  DCSP  DCSP os.environ['WERKZEUG_SERVER_FD'] = str(s.fileno()) DCNL DCSP  DCSP  DCSP  DCSP s.listen(LISTEN_QUEUE) DCNL DCSP  DCSP  DCSP  DCSP log_startup(s) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s.close() DCNL DCSP  DCSP from ._reloader import run_with_reloader DCNL DCSP  DCSP run_with_reloader(inner, extra_files, reloader_interval, reloader_type) DCNL DCSP else: DCNL DCSP  DCSP inner()
 DCSP from scipy import stats DCNL DCSP from statsmodels.sandbox.regression.predstd import wls_prediction_std DCNL DCSP infl = OLSInfluence(res) DCNL DCSP predict_mean_se = np.sqrt((infl.hat_matrix_diag * res.mse_resid)) DCNL DCSP tppf = stats.t.isf((alpha / 2.0), res.df_resid) DCNL DCSP predict_mean_ci = np.column_stack([(res.fittedvalues - (tppf * predict_mean_se)), (res.fittedvalues + (tppf * predict_mean_se))]) DCNL DCSP (predict_se, predict_ci_low, predict_ci_upp) = wls_prediction_std(res) DCNL DCSP predict_ci = np.column_stack((predict_ci_low, predict_ci_upp)) DCNL DCSP resid_se = np.sqrt((res.mse_resid * (1 - infl.hat_matrix_diag))) DCNL DCSP table_sm = np.column_stack([(np.arange(res.nobs) + 1), res.model.endog, res.fittedvalues, predict_mean_se, predict_mean_ci[:, 0], predict_mean_ci[:, 1], predict_ci[:, 0], predict_ci[:, 1], res.resid, resid_se, infl.resid_studentized_internal, infl.cooks_distance[0]]) DCNL DCSP data = table_sm DCNL DCSP ss2 = ['Obs', 'Dep DCSP Var\nPopulation', 'Predicted\nValue', 'Std DCSP Error\nMean DCSP Predict', 'Mean DCSP ci\n95% DCSP low', 'Mean DCSP ci\n95% DCSP upp', 'Predict DCSP ci\n95% DCSP low', 'Predict DCSP ci\n95% DCSP upp', 'Residual', 'Std DCSP Error\nResidual', 'Student\nResidual', "Cook's\nD"] DCNL DCSP colnames = ss2 DCNL DCSP from statsmodels.iolib.table import SimpleTable, default_html_fmt DCNL DCSP from statsmodels.iolib.tableformatting import fmt_base DCNL DCSP from copy import deepcopy DCNL DCSP fmt = deepcopy(fmt_base) DCNL DCSP fmt_html = deepcopy(default_html_fmt) DCNL DCSP fmt['data_fmts'] = (['%4d'] + (['%6.3f'] * (data.shape[1] - 1))) DCNL DCSP st = SimpleTable(data, headers=colnames, txt_fmt=fmt, html_fmt=fmt_html) DCNL DCSP return (st, data, ss2)
 DCSP receptive_field = np.zeros((len(layers), 2)) DCNL DCSP conv_mode = True DCNL DCSP first_conv_layer = True DCNL DCSP expon = np.ones((1, 2)) DCNL DCSP for (i, layer) in enumerate(layers[1:]): DCNL DCSP  DCSP j = (i + 1) DCNL DCSP  DCSP if (not conv_mode): DCNL DCSP  DCSP  DCSP receptive_field[j] = img_size DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if is_conv2d(layer): DCNL DCSP  DCSP  DCSP if (not first_conv_layer): DCNL DCSP  DCSP  DCSP  DCSP last_field = receptive_field[i] DCNL DCSP  DCSP  DCSP  DCSP new_field = (last_field + (expon * (np.array(layer.filter_size) - 1))) DCNL DCSP  DCSP  DCSP  DCSP receptive_field[j] = new_field DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP receptive_field[j] = layer.filter_size DCNL DCSP  DCSP  DCSP  DCSP first_conv_layer = False DCNL DCSP  DCSP elif is_maxpool2d(layer): DCNL DCSP  DCSP  DCSP receptive_field[j] = receptive_field[i] DCNL DCSP  DCSP  DCSP expon *= np.array(layer.pool_size) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conv_mode = False DCNL DCSP  DCSP  DCSP receptive_field[j] = img_size DCNL DCSP receptive_field[0] = img_size DCNL DCSP return receptive_field
 DCSP global _populated DCNL DCSP _all_actions.clear() DCNL DCSP _top_level_ids.clear() DCNL DCSP _populated = False
 DCSP if abbreviate: DCNL DCSP  DCSP chunks = (((((60 * 60) * 24) * 365), (lambda n: 'y')), ((((60 * 60) * 24) * 30), (lambda n: 'm')), ((((60 * 60) * 24) * 7), (lambda n: 'w')), (((60 * 60) * 24), (lambda n: 'd')), ((60 * 60), (lambda n: 'h')), (60, (lambda n: 'm')), (1, (lambda n: 's'))) DCNL DCSP else: DCNL DCSP  DCSP chunks = (((((60 * 60) * 24) * 365), (lambda n: ungettext('year', 'years', n))), ((((60 * 60) * 24) * 30), (lambda n: ungettext('month', 'months', n))), ((((60 * 60) * 24) * 7), (lambda n: ungettext('week', 'weeks', n))), (((60 * 60) * 24), (lambda n: ungettext('day', 'days', n))), ((60 * 60), (lambda n: ungettext('hour', 'hours', n))), (60, (lambda n: ungettext('minute', 'minutes', n))), (1, (lambda n: ungettext('second', 'seconds', n)))) DCNL DCSP if (not isinstance(d, datetime.datetime)): DCNL DCSP  DCSP d = datetime.datetime(d.year, d.month, d.day) DCNL DCSP if (now and (not isinstance(now, datetime.datetime))): DCNL DCSP  DCSP now = datetime.datetime(now.year, now.month, now.day) DCNL DCSP if (not now): DCNL DCSP  DCSP if d.tzinfo: DCNL DCSP  DCSP  DCSP now = datetime.datetime.now(LocalTimezone(d)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP now = datetime.datetime.now() DCNL DCSP delta = (now - (d - datetime.timedelta(0, 0, d.microsecond))) DCNL DCSP since = ((((delta.days * 24) * 60) * 60) + delta.seconds) DCNL DCSP if (since <= 0): DCNL DCSP  DCSP if abbreviate: DCNL DCSP  DCSP  DCSP return (u'0' + ugettext('s')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'0 DCSP ' + ugettext('seconds')) DCNL DCSP for (i, (seconds, name)) in enumerate(chunks): DCNL DCSP  DCSP count = (since // seconds) DCNL DCSP  DCSP if (count != 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP if abbreviate: DCNL DCSP  DCSP s = (ugettext('%(number)d%(type)s') % {'number': count, 'type': name(count)}) DCNL DCSP else: DCNL DCSP  DCSP s = (ugettext('%(number)d DCSP %(type)s') % {'number': count, 'type': name(count)}) DCNL DCSP if ((i + 1) < len(chunks)): DCNL DCSP  DCSP (seconds2, name2) = chunks[(i + 1)] DCNL DCSP  DCSP count2 = ((since - (seconds * count)) // seconds2) DCNL DCSP  DCSP if (count2 != 0): DCNL DCSP  DCSP  DCSP if abbreviate: DCNL DCSP  DCSP  DCSP  DCSP s += (ugettext('%(separator)s DCSP %(number)d%(type)s') % {'separator': separator, 'number': count2, 'type': name2(count2)}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s += (ugettext('%(separator)s DCSP %(number)d DCSP %(type)s') % {'separator': separator, 'number': count2, 'type': name2(count2)}) DCNL DCSP return s
 DCSP funcs = {} DCNL DCSP for (key, name) in [('b', 'char'), ('h', 'short'), ('i', 'int'), ('q', 'longlong')]: DCNL DCSP  DCSP for (echar, esuffix) in [('<', 'le'), ('>', 'be')]: DCNL DCSP  DCSP  DCSP esuffix = ('_' + esuffix) DCNL DCSP  DCSP  DCSP for unsigned in [True, False]: DCNL DCSP  DCSP  DCSP  DCSP s = struct.Struct((echar + (key.upper() if unsigned else key))) DCNL DCSP  DCSP  DCSP  DCSP get_wrapper = (lambda f: (lambda *a, **k: f(*a, **k)[0])) DCNL DCSP  DCSP  DCSP  DCSP unpack = get_wrapper(s.unpack) DCNL DCSP  DCSP  DCSP  DCSP unpack_from = get_wrapper(s.unpack_from) DCNL DCSP  DCSP  DCSP  DCSP def get_unpack_from(s): DCNL DCSP  DCSP  DCSP  DCSP  DCSP def unpack_from(data, offset=0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (s.unpack_from(data, offset)[0], (offset + s.size)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unpack_from DCNL DCSP  DCSP  DCSP  DCSP unpack_from = get_unpack_from(s) DCNL DCSP  DCSP  DCSP  DCSP pack = s.pack DCNL DCSP  DCSP  DCSP  DCSP prefix = ('u' if unsigned else '') DCNL DCSP  DCSP  DCSP  DCSP if (s.size == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP esuffix = '' DCNL DCSP  DCSP  DCSP  DCSP bits = str((s.size * 8)) DCNL DCSP  DCSP  DCSP  DCSP funcs[('%s%s%s' % (prefix, name, esuffix))] = unpack DCNL DCSP  DCSP  DCSP  DCSP funcs[('%sint%s%s' % (prefix, bits, esuffix))] = unpack DCNL DCSP  DCSP  DCSP  DCSP funcs[('%s%s%s_from' % (prefix, name, esuffix))] = unpack_from DCNL DCSP  DCSP  DCSP  DCSP funcs[('%sint%s%s_from' % (prefix, bits, esuffix))] = unpack_from DCNL DCSP  DCSP  DCSP  DCSP funcs[('to_%s%s%s' % (prefix, name, esuffix))] = pack DCNL DCSP  DCSP  DCSP  DCSP funcs[('to_%sint%s%s' % (prefix, bits, esuffix))] = pack DCNL DCSP for (key, func) in iteritems(funcs): DCNL DCSP  DCSP setattr(cls, key, staticmethod(func))
 DCSP user = mapped_properties['user'] DCNL DCSP user_id = user.get('id') DCNL DCSP user_name = (user.get('name') or request.remote_user) DCNL DCSP if (not any([user_id, user_name])): DCNL DCSP  DCSP msg = _('Could DCSP not DCSP map DCSP user DCSP while DCSP setting DCSP ephemeral DCSP user DCSP identity. DCSP Either DCSP mapping DCSP rules DCSP must DCSP specify DCSP user DCSP id/name DCSP or DCSP REMOTE_USER DCSP environment DCSP variable DCSP must DCSP be DCSP set.') DCNL DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP elif (not user_name): DCNL DCSP  DCSP user['name'] = user_id DCNL DCSP elif (not user_id): DCNL DCSP  DCSP user_id = user_name DCNL DCSP user['id'] = parse.quote(user_id) DCNL DCSP return (user['id'], user['name'])
 DCSP if (expr_form is not None): DCNL DCSP  DCSP salt.utils.warn_until('Fluorine', "the DCSP target DCSP type DCSP should DCSP be DCSP passed DCSP using DCSP the DCSP 'tgt_type' DCSP argument DCSP instead DCSP of DCSP 'expr_form'. DCSP Support DCSP for DCSP using DCSP 'expr_form' DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Fluorine.") DCNL DCSP  DCSP tgt_type = expr_form DCNL DCSP return _talk2modjk(name, lbn, target, 'worker_disable', profile, tgt_type)
 DCSP if isinstance(val, string_types): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, collections.Sequence): DCNL DCSP  DCSP return [swap_inf_nan(v) for v in val] DCNL DCSP elif isinstance(val, collections.Mapping): DCNL DCSP  DCSP return dict([(swap_inf_nan(k), swap_inf_nan(v)) for (k, v) in iteritems(val)]) DCNL DCSP elif isinstance(val, float): DCNL DCSP  DCSP if math.isnan(val): DCNL DCSP  DCSP  DCSP return '__NaN__' DCNL DCSP  DCSP elif (val == float('inf')): DCNL DCSP  DCSP  DCSP return '__Infinity__' DCNL DCSP  DCSP elif (val == float('-inf')): DCNL DCSP  DCSP  DCSP return '__-Infinity__' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return val DCNL DCSP else: DCNL DCSP  DCSP return val
 DCSP res = {'completed': 0, 'running': 0, 'failed': 0, 'killed': 0, 'all': 0} DCNL DCSP jobcounts = request.jt.get_job_count_by_user(username) DCNL DCSP res['completed'] = jobcounts.nSucceeded DCNL DCSP res['running'] = (jobcounts.nPrep + jobcounts.nRunning) DCNL DCSP res['failed'] = jobcounts.nFailed DCNL DCSP res['killed'] = jobcounts.nKilled DCNL DCSP res['all'] = (((res['completed'] + res['running']) + res['failed']) + res['killed']) DCNL DCSP return res
 DCSP return _filer_file_from_upload(model=File, request=request, path=path, upload_data=upload_data, sha1=sha1)
 DCSP if (config.LAST_UPDATED in document): DCNL DCSP  DCSP return document[config.LAST_UPDATED].replace(tzinfo=None) DCNL DCSP else: DCNL DCSP  DCSP return epoch()
 DCSP test_stubs.stub_out_registry_server(stubs) DCNL DCSP def fake_image_update(ctx, image_id, values, purge_props=False): DCNL DCSP  DCSP return {'properties': {}} DCNL DCSP stubs.Set(db_api, 'image_update', fake_image_update)
 DCSP for flag_name in NamesOfDefinedFlags(): DCNL DCSP  DCSP module_bar.RemoveOneFlag(flag_name, flag_values=flag_values) DCNL DCSP module_bar.RemoveFlags(flag_values=flag_values)
 DCSP query = _volume_get_query(context).filter_by(consistencygroup_id=group_id) DCNL DCSP if filters: DCNL DCSP  DCSP query = _process_volume_filters(query, filters) DCNL DCSP  DCSP if (query is None): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP return query.all()
 DCSP xml_parts = [('<?xml DCSP version="1.0" DCSP encoding="%s"?>' % encoding)] DCNL DCSP if pretty: DCNL DCSP  DCSP xml_parts.append('\n') DCNL DCSP _ConstructContentList(xml_parts, content, pretty) DCNL DCSP return ''.join(xml_parts)
 DCSP token = settings.SURVEYGIZMO_API_TOKEN DCNL DCSP secret = settings.SURVEYGIZMO_API_TOKEN_SECRET DCNL DCSP if ((token is None) or (secret is None)): DCNL DCSP  DCSP return DCNL DCSP survey_id = SURVEYS[survey]['exit_survey_id'] DCNL DCSP campaign_id = SURVEYS[survey]['exit_survey_campaign_id'] DCNL DCSP try: DCNL DCSP  DCSP requests.put('https://restapi.surveygizmo.com/v2/survey/{survey}/surveycampaign/{campaign}/contact?semailaddress={email}&api_token={token}&api_token_secret={secret}'.format(survey=survey_id, campaign=campaign_id, email=email, token=token, secret=secret), timeout=30) DCNL DCSP except requests.exceptions.Timeout: DCNL DCSP  DCSP print ('Timedout DCSP adding: DCSP %s' % email)
 DCSP Z = np.zeros((5, 4)) DCNL DCSP for X in [Z, csr_matrix(Z)]: DCNL DCSP  DCSP lda = LatentDirichletAllocation(max_iter=750).fit(X) DCNL DCSP  DCSP assert_almost_equal(lda.components_.sum(axis=0), np.ones(lda.components_.shape[1]))
 DCSP objects_differ = None DCNL DCSP for (k, v) in state_data['service'].items(): DCNL DCSP  DCSP if (k == 'escalation_policy_id'): DCNL DCSP  DCSP  DCSP resource_value = resource_object['escalation_policy']['id'] DCNL DCSP  DCSP elif (k == 'service_key'): DCNL DCSP  DCSP  DCSP resource_value = resource_object['service_key'] DCNL DCSP  DCSP  DCSP if ('@' in resource_value): DCNL DCSP  DCSP  DCSP  DCSP resource_value = resource_value[0:resource_value.find('@')] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resource_value = resource_object[k] DCNL DCSP  DCSP if (v != resource_value): DCNL DCSP  DCSP  DCSP objects_differ = '{0} DCSP {1} DCSP {2}'.format(k, v, resource_value) DCNL DCSP  DCSP  DCSP break DCNL DCSP if objects_differ: DCNL DCSP  DCSP return state_data DCNL DCSP else: DCNL DCSP  DCSP return {}
 DCSP _find_server(cs, args.server).confirm_resize()
 DCSP if (lin_op.type is lo.NEG): DCNL DCSP  DCSP result = value DCNL DCSP elif (lin_op.type is lo.MUL): DCNL DCSP  DCSP coeff = mul(lin_op.data, {}, True) DCNL DCSP  DCSP if np.isscalar(coeff): DCNL DCSP  DCSP  DCSP result = (coeff * value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = (coeff.T * value) DCNL DCSP elif (lin_op.type is lo.DIV): DCNL DCSP  DCSP divisor = mul(lin_op.data, {}, True) DCNL DCSP  DCSP result = (value / divisor) DCNL DCSP elif (lin_op.type is lo.CONV): DCNL DCSP  DCSP result = conv_mul(lin_op, value, True, True) DCNL DCSP else: DCNL DCSP  DCSP result = op_tmul(lin_op, value) DCNL DCSP return result
 DCSP htmlpage = add_tagids(htmlpage) DCNL DCSP cleaned_html = descriptify(htmlpage, baseurl, proxy=proxy_resources) DCNL DCSP return cleaned_html
 DCSP obj = ctx.__enter__() DCNL DCSP try: DCNL DCSP  DCSP result = fn(obj, *arg, **kw) DCNL DCSP  DCSP ctx.__exit__(None, None, None) DCNL DCSP  DCSP return result DCNL DCSP except: DCNL DCSP  DCSP exc_info = sys.exc_info() DCNL DCSP  DCSP raise_ = ctx.__exit__(*exc_info) DCNL DCSP  DCSP if (raise_ is None): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return raise_
 DCSP first_row = tokens[0][2][0] DCNL DCSP nrows = ((1 + tokens[(-1)][2][0]) - first_row) DCNL DCSP if (noqa or (nrows == 1)): DCNL DCSP  DCSP return DCNL DCSP indent_next = logical_line.endswith(':') DCNL DCSP row = depth = 0 DCNL DCSP valid_hangs = ((4,) if (indent_char != ' DCTB ') else (4, 8)) DCNL DCSP parens = ([0] * nrows) DCNL DCSP rel_indent = ([0] * nrows) DCNL DCSP open_rows = [[0]] DCNL DCSP hangs = [None] DCNL DCSP indent_chances = {} DCNL DCSP last_indent = tokens[0][2] DCNL DCSP visual_indent = None DCNL DCSP last_token_multiline = False DCNL DCSP indent = [last_indent[1]] DCNL DCSP if (verbose >= 3): DCNL DCSP  DCSP print ('>>> DCSP ' + tokens[0][4].rstrip()) DCNL DCSP for (token_type, text, start, end, line) in tokens: DCNL DCSP  DCSP newline = (row < (start[0] - first_row)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP row = (start[0] - first_row) DCNL DCSP  DCSP  DCSP newline = ((not last_token_multiline) and (token_type not in NEWLINE)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP last_indent = start DCNL DCSP  DCSP  DCSP if (verbose >= 3): DCNL DCSP  DCSP  DCSP  DCSP print ('... DCSP ' + line.rstrip()) DCNL DCSP  DCSP  DCSP rel_indent[row] = (expand_indent(line) - indent_level) DCNL DCSP  DCSP  DCSP close_bracket = ((token_type == tokenize.OP) and (text in ']})')) DCNL DCSP  DCSP  DCSP for open_row in reversed(open_rows[depth]): DCNL DCSP  DCSP  DCSP  DCSP hang = (rel_indent[row] - rel_indent[open_row]) DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang in valid_hangs) DCNL DCSP  DCSP  DCSP  DCSP if hanging_indent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if hangs[depth]: DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang == hangs[depth]) DCNL DCSP  DCSP  DCSP visual_indent = ((not close_bracket) and (hang > 0) and indent_chances.get(start[1])) DCNL DCSP  DCSP  DCSP if (close_bracket and indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP if (start[1] != indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E124 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP visual DCSP indentation')) DCNL DCSP  DCSP  DCSP elif (close_bracket and (not hang)): DCNL DCSP  DCSP  DCSP  DCSP if hang_closing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E133 DCSP closing DCSP bracket DCSP is DCSP missing DCSP indentation')) DCNL DCSP  DCSP  DCSP elif (indent[depth] and (start[1] < indent[depth])): DCNL DCSP  DCSP  DCSP  DCSP if (visual_indent is not True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E128 DCSP continuation DCSP line DCSP under-indented DCSP for DCSP visual DCSP indent')) DCNL DCSP  DCSP  DCSP elif (hanging_indent or (indent_next and (rel_indent[row] == 8))): DCNL DCSP  DCSP  DCSP  DCSP if (close_bracket and (not hang_closing)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, "E123 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP indentation DCSP of DCSP opening DCSP bracket's DCSP line")) DCNL DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP elif (visual_indent is True): DCNL DCSP  DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP elif (visual_indent in (text, str)): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (hang <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E122', 'missing DCSP indentation DCSP or DCSP outdented') DCNL DCSP  DCSP  DCSP  DCSP elif indent[depth]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E127', 'over-indented DCSP for DCSP visual DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP elif ((not close_bracket) and hangs[depth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E131', 'unaligned DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hang > 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E126', 'over-indented DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E121', 'under-indented DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP (yield (start, ('%s DCSP continuation DCSP line DCSP %s' % error))) DCNL DCSP  DCSP if (parens[row] and (token_type not in (tokenize.NL, tokenize.COMMENT)) and (not indent[depth])): DCNL DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = True DCNL DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP print ('bracket DCSP depth DCSP %s DCSP indent DCSP to DCSP %s' % (depth, start[1])) DCNL DCSP  DCSP elif ((token_type in (tokenize.STRING, tokenize.COMMENT)) or (text in ('u', 'ur', 'b', 'br'))): DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = str DCNL DCSP  DCSP elif ((not indent_chances) and (not row) and (not depth) and (text == 'if')): DCNL DCSP  DCSP  DCSP indent_chances[(end[1] + 1)] = True DCNL DCSP  DCSP elif ((text == ':') and line[end[1]:].isspace()): DCNL DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP if (token_type == tokenize.OP): DCNL DCSP  DCSP  DCSP if (text in '([{'): DCNL DCSP  DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP  DCSP  DCSP indent.append(0) DCNL DCSP  DCSP  DCSP  DCSP hangs.append(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(open_rows) == depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP open_rows.append([]) DCNL DCSP  DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP  DCSP  DCSP parens[row] += 1 DCNL DCSP  DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('bracket DCSP depth DCSP %s DCSP seen, DCSP col DCSP %s, DCSP visual DCSP min DCSP = DCSP %s' % (depth, start[1], indent[depth])) DCNL DCSP  DCSP  DCSP elif ((text in ')]}') and (depth > 0)): DCNL DCSP  DCSP  DCSP  DCSP prev_indent = (indent.pop() or last_indent[1]) DCNL DCSP  DCSP  DCSP  DCSP hangs.pop() DCNL DCSP  DCSP  DCSP  DCSP for d in range(depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (indent[d] > prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP indent[d] = 0 DCNL DCSP  DCSP  DCSP  DCSP for ind in list(indent_chances): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ind >= prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP del indent_chances[ind] DCNL DCSP  DCSP  DCSP  DCSP del open_rows[(depth + 1):] DCNL DCSP  DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP  DCSP if depth: DCNL DCSP  DCSP  DCSP  DCSP  DCSP indent_chances[indent[depth]] = True DCNL DCSP  DCSP  DCSP  DCSP for idx in range(row, (-1), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parens[idx]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parens[idx] -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP assert (len(indent) == (depth + 1)) DCNL DCSP  DCSP  DCSP if (start[1] not in indent_chances): DCNL DCSP  DCSP  DCSP  DCSP indent_chances[start[1]] = text DCNL DCSP  DCSP last_token_multiline = (start[0] != end[0]) DCNL DCSP  DCSP if last_token_multiline: DCNL DCSP  DCSP  DCSP rel_indent[(end[0] - first_row)] = rel_indent[row] DCNL DCSP if (indent_next and (expand_indent(line) == (indent_level + 4))): DCNL DCSP  DCSP pos = (start[0], (indent[0] + 4)) DCNL DCSP  DCSP if visual_indent: DCNL DCSP  DCSP  DCSP code = 'E129 DCSP visually DCSP indented DCSP line' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP code = 'E125 DCSP continuation DCSP line' DCNL DCSP  DCSP (yield (pos, ('%s DCSP with DCSP same DCSP indent DCSP as DCSP next DCSP logical DCSP line' % code)))
 DCSP mock_read_user = mocker.patch('cookiecutter.vcs.read_user_yes_no', return_value=True, autospec=True) DCNL DCSP repo_dir = tmpdir.mkdir('repo') DCNL DCSP vcs.prompt_and_delete_repo(str(repo_dir)) DCNL DCSP assert mock_read_user.called DCNL DCSP assert (not repo_dir.exists())
 DCSP return np.modf(x)[1]
 DCSP from dipy.denoise.nlmeans import nlmeans DCNL DCSP from scipy.ndimage.morphology import binary_erosion DCNL DCSP from scipy import ndimage DCNL DCSP if (out_file is None): DCNL DCSP  DCSP (fname, fext) = op.splitext(op.basename(in_file)) DCNL DCSP  DCSP if (fext == u'.gz'): DCNL DCSP  DCSP  DCSP (fname, fext2) = op.splitext(fname) DCNL DCSP  DCSP  DCSP fext = (fext2 + fext) DCNL DCSP  DCSP out_file = op.abspath((u'./%s_denoise%s' % (fname, fext))) DCNL DCSP img = nb.load(in_file) DCNL DCSP hdr = img.header DCNL DCSP data = img.get_data() DCNL DCSP aff = img.affine DCNL DCSP if (data.ndim < 4): DCNL DCSP  DCSP data = data[..., np.newaxis] DCNL DCSP data = np.nan_to_num(data) DCNL DCSP if (data.max() < 0.0001): DCNL DCSP  DCSP raise RuntimeError(u'There DCSP is DCSP no DCSP signal DCSP in DCSP the DCSP image') DCNL DCSP df = 1.0 DCNL DCSP if (data.max() < 1000.0): DCNL DCSP  DCSP df = (1000.0 / data.max()) DCNL DCSP  DCSP data *= df DCNL DCSP b0 = data[..., 0] DCNL DCSP if (smask is None): DCNL DCSP  DCSP smask = np.zeros_like(b0) DCNL DCSP  DCSP smask[(b0 > np.percentile(b0, 85.0))] = 1 DCNL DCSP smask = binary_erosion(smask.astype(np.uint8), iterations=2).astype(np.uint8) DCNL DCSP if (nmask is None): DCNL DCSP  DCSP nmask = np.ones_like(b0, dtype=np.uint8) DCNL DCSP  DCSP bmask = settings[u'mask'] DCNL DCSP  DCSP if (bmask is None): DCNL DCSP  DCSP  DCSP bmask = np.zeros_like(b0) DCNL DCSP  DCSP  DCSP bmask[(b0 > np.percentile(b0[(b0 > 0)], 10))] = 1 DCNL DCSP  DCSP  DCSP (label_im, nb_labels) = ndimage.label(bmask) DCNL DCSP  DCSP  DCSP sizes = ndimage.sum(bmask, label_im, range((nb_labels + 1))) DCNL DCSP  DCSP  DCSP maxidx = np.argmax(sizes) DCNL DCSP  DCSP  DCSP bmask = np.zeros_like(b0, dtype=np.uint8) DCNL DCSP  DCSP  DCSP bmask[(label_im == maxidx)] = 1 DCNL DCSP  DCSP nmask[(bmask > 0)] = 0 DCNL DCSP else: DCNL DCSP  DCSP nmask = np.squeeze(nmask) DCNL DCSP  DCSP nmask[(nmask > 0.0)] = 1 DCNL DCSP  DCSP nmask[(nmask < 1)] = 0 DCNL DCSP  DCSP nmask = nmask.astype(bool) DCNL DCSP nmask = binary_erosion(nmask, iterations=1).astype(np.uint8) DCNL DCSP den = np.zeros_like(data) DCNL DCSP est_snr = True DCNL DCSP if (snr is not None): DCNL DCSP  DCSP snr = ([snr] * data.shape[(-1)]) DCNL DCSP  DCSP est_snr = False DCNL DCSP else: DCNL DCSP  DCSP snr = [] DCNL DCSP for i in range(data.shape[(-1)]): DCNL DCSP  DCSP d = data[..., i] DCNL DCSP  DCSP if est_snr: DCNL DCSP  DCSP  DCSP s = np.mean(d[(smask > 0)]) DCNL DCSP  DCSP  DCSP n = np.std(d[(nmask > 0)]) DCNL DCSP  DCSP  DCSP snr.append((s / n)) DCNL DCSP  DCSP den[..., i] = nlmeans(d, snr[i], **settings) DCNL DCSP den = np.squeeze(den) DCNL DCSP den /= df DCNL DCSP nb.Nifti1Image(den.astype(hdr.get_data_dtype()), aff, hdr).to_filename(out_file) DCNL DCSP return (out_file, snr)
 DCSP cmd = '--get-zones' DCNL DCSP if permanent: DCNL DCSP  DCSP cmd += ' DCSP --permanent' DCNL DCSP return __firewall_cmd(cmd).split()
 DCSP p[0] = p[1]
 DCSP if (sys.version_info >= (3, 3)): DCNL DCSP  DCSP import shutil DCNL DCSP  DCSP shutil_get_terminal_size = getattr(shutil, 'get_terminal_size', None) DCNL DCSP  DCSP if shutil_get_terminal_size: DCNL DCSP  DCSP  DCSP sz = shutil_get_terminal_size() DCNL DCSP  DCSP  DCSP return (sz.columns, sz.lines) DCNL DCSP if (get_winterm_size is not None): DCNL DCSP  DCSP return get_winterm_size() DCNL DCSP def ioctl_gwinsz(fd): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import fcntl DCNL DCSP  DCSP  DCSP import termios DCNL DCSP  DCSP  DCSP cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return cr DCNL DCSP cr = (ioctl_gwinsz(0) or ioctl_gwinsz(1) or ioctl_gwinsz(2)) DCNL DCSP if (not cr): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fd = os.open(os.ctermid(), os.O_RDONLY) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP cr = ioctl_gwinsz(fd) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP os.close(fd) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if ((not cr) or (not cr[0]) or (not cr[1])): DCNL DCSP  DCSP cr = (os.environ.get('LINES', 25), os.environ.get('COLUMNS', DEFAULT_COLUMNS)) DCNL DCSP return (int(cr[1]), int(cr[0]))
 DCSP forward_relations = OrderedDict() DCNL DCSP for field in [field for field in opts.fields if (field.serialize and get_remote_field(field))]: DCNL DCSP  DCSP forward_relations[field.name] = RelationInfo(model_field=field, related_model=get_related_model(field), to_many=False, to_field=_get_to_field(field), has_through_model=False, reverse=False) DCNL DCSP for field in [field for field in opts.many_to_many if field.serialize]: DCNL DCSP  DCSP forward_relations[field.name] = RelationInfo(model_field=field, related_model=get_related_model(field), to_many=True, to_field=None, has_through_model=(not get_remote_field(field).through._meta.auto_created), reverse=False) DCNL DCSP return forward_relations
 DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
 DCSP def get_rel_path(base, path): DCNL DCSP  DCSP base = base.replace(os.path.sep, '/') DCNL DCSP  DCSP path = path.replace(os.path.sep, '/') DCNL DCSP  DCSP assert path.startswith(base) DCNL DCSP  DCSP return path[len(base):].lstrip('/') DCNL DCSP destinations = {} DCNL DCSP for (base, suffix, dest) in rules: DCNL DCSP  DCSP prefix = os.path.join(resources_root, base) DCNL DCSP  DCSP for abs_base in iglob(prefix): DCNL DCSP  DCSP  DCSP abs_glob = os.path.join(abs_base, suffix) DCNL DCSP  DCSP  DCSP for abs_path in iglob(abs_glob): DCNL DCSP  DCSP  DCSP  DCSP resource_file = get_rel_path(resources_root, abs_path) DCNL DCSP  DCSP  DCSP  DCSP if (dest is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP destinations.pop(resource_file, None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_path = get_rel_path(abs_base, abs_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_dest = dest.replace(os.path.sep, '/').rstrip('/') DCNL DCSP  DCSP  DCSP  DCSP  DCSP destinations[resource_file] = ((rel_dest + '/') + rel_path) DCNL DCSP return destinations
 DCSP if (not alert_id): DCNL DCSP  DCSP return False DCNL DCSP table = current.s3db.cap_alert DCNL DCSP query = (table.id == alert_id) DCNL DCSP r = current.db(query).select(table.is_template, limitby=(0, 1)).first() DCNL DCSP return (r and r.is_template)
 DCSP return add_action(widget, N_(u'Close...'), widget.close, hotkeys.CLOSE, hotkeys.QUIT)
 DCSP if (not is_memcache_running()): DCNL DCSP  DCSP msg = colorize('red', 'Memcache DCSP is DCSP not DCSP running DCSP locally.') DCNL DCSP  DCSP print msg DCNL DCSP  DCSP sys.exit(1)
 DCSP funcobj.__isabstractmethod__ = True DCNL DCSP return funcobj
 DCSP operators = getattr(app.data, 'operators', set()) DCNL DCSP allowed = (config.DOMAIN[resource]['allowed_filters'] + list(operators)) DCNL DCSP def validate_filter(filter): DCNL DCSP  DCSP for (key, value) in filter.items(): DCNL DCSP  DCSP  DCSP if (('*' not in allowed) and (key not in allowed)): DCNL DCSP  DCSP  DCSP  DCSP return ("filter DCSP on DCSP '%s' DCSP not DCSP allowed" % key) DCNL DCSP  DCSP  DCSP if (key in ('$or', '$and', '$nor')): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ("operator DCSP '%s' DCSP expects DCSP a DCSP list DCSP of DCSP sub-queries" % key) DCNL DCSP  DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(v, dict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return ("operator DCSP '%s' DCSP expects DCSP a DCSP list DCSP of DCSP sub-queries" % key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP r = validate_filter(v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return r DCNL DCSP  DCSP  DCSP elif config.VALIDATE_FILTERS: DCNL DCSP  DCSP  DCSP  DCSP res_schema = config.DOMAIN[resource]['schema'] DCNL DCSP  DCSP  DCSP  DCSP if (key not in res_schema): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return "filter DCSP on DCSP '%s' DCSP is DCSP invalid" DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP field_schema = res_schema.get(key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = Validator({key: field_schema}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not v.validate({key: value})): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return "filter DCSP on DCSP '%s' DCSP is DCSP invalid" DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP if (('*' in allowed) and (not config.VALIDATE_FILTERS)): DCNL DCSP  DCSP return None DCNL DCSP return validate_filter(where)
 DCSP script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0') DCNL DCSP result = script.pip('install', '-e', 'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package') DCNL DCSP result = script.pip('list', '-f', data.find_links, '--no-index', '--editable', '--uptodate', '--format=legacy') DCNL DCSP assert ('simple DCSP (1.0)' not in result.stdout), str(result) DCNL DCSP assert (os.path.join('src', 'pip-test-package') in result.stdout), str(result)
 DCSP total_size = 0 DCNL DCSP if os.path.isdir(real_path): DCNL DCSP  DCSP for (dirpath, dirnames, filenames) in os.walk(real_path): DCNL DCSP  DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP  DCSP total_size += os.path.getsize(os.path.join(dirpath, filename)) DCNL DCSP else: DCNL DCSP  DCSP total_size += os.path.getsize(real_path) DCNL DCSP return total_size
 DCSP path = '/'.join(map(partial(replace, 'pull', 'pulls'), url_path_parts(url))) DCNL DCSP return ((API_BASE_URL + REPOS_API_PATH) + path)
 DCSP if (not session): DCNL DCSP  DCSP session = client_session.Session._construct(kwargs) DCNL DCSP d = discover.Discover(session=session, **kwargs) DCNL DCSP return d.create_client(version=version, unstable=unstable)
 DCSP return None
 DCSP context = get_jinja_context() DCNL DCSP icon_classes = SocialMediaLinksPlugin.icon_classes DCNL DCSP link_1_type = 'Facebook' DCNL DCSP link_1 = {'url': 'http://www.facebook.com', 'ordering': 2} DCNL DCSP link_2_type = 'Twitter' DCNL DCSP link_2 = {'url': 'http://www.twitter.com', 'ordering': 1} DCNL DCSP links = {link_1_type: link_1, link_2_type: link_2} DCNL DCSP plugin = SocialMediaLinksPlugin({'links': links}) DCNL DCSP assert (len(plugin.get_links()) == 2) DCNL DCSP assert (plugin.get_links()[0][2] == link_2['url'])
 DCSP conf = settings.CACHES.get(backend, None) DCNL DCSP if (conf is not None): DCNL DCSP  DCSP args = conf.copy() DCNL DCSP  DCSP args.update(kwargs) DCNL DCSP  DCSP backend = args.pop('BACKEND') DCNL DCSP  DCSP location = args.pop('LOCATION', '') DCNL DCSP  DCSP return (backend, location, args) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (mod_path, cls_name) = backend.rsplit('.', 1) DCNL DCSP  DCSP  DCSP mod = importlib.import_module(mod_path) DCNL DCSP  DCSP  DCSP backend_cls = getattr(mod, cls_name) DCNL DCSP  DCSP except (AttributeError, ImportError, ValueError): DCNL DCSP  DCSP  DCSP raise InvalidCacheBackendError(("Could DCSP not DCSP find DCSP backend DCSP '%s'" % backend)) DCNL DCSP  DCSP location = kwargs.pop('LOCATION', '') DCNL DCSP  DCSP return (backend, location, kwargs) DCNL DCSP raise InvalidCacheBackendError(("Couldn't DCSP find DCSP a DCSP cache DCSP backend DCSP named DCSP '%s'" % backend))
 DCSP sys = kwds.get('sys', _sys) DCNL DCSP assert (sys is not None) DCNL DCSP p = shell_process(cmds, env, **kwds) DCNL DCSP if redirecting_io(sys=sys): DCNL DCSP  DCSP redirect_aware_commmunicate(p, sys=sys) DCNL DCSP  DCSP exit = p.returncode DCNL DCSP  DCSP return exit DCNL DCSP else: DCNL DCSP  DCSP return p.wait()
 DCSP return Timestamp(timestamp).normal
 DCSP if ('message_parser' in dir(hangups)): DCNL DCSP  DCSP segments = hangups.ChatMessageSegment.from_str(formatted_text) DCNL DCSP else: DCNL DCSP  DCSP segments = kludgy_html_parser.simple_parse_to_segments(formatted_text) DCNL DCSP return segments
 DCSP if (len(projs) == 0): DCNL DCSP  DCSP return DCNL DCSP start_block(fid, FIFF.FIFFB_PROJ) DCNL DCSP for proj in projs: DCNL DCSP  DCSP start_block(fid, FIFF.FIFFB_PROJ_ITEM) DCNL DCSP  DCSP write_int(fid, FIFF.FIFF_NCHAN, proj['data']['ncol']) DCNL DCSP  DCSP write_name_list(fid, FIFF.FIFF_PROJ_ITEM_CH_NAME_LIST, proj['data']['col_names']) DCNL DCSP  DCSP write_string(fid, FIFF.FIFF_NAME, proj['desc']) DCNL DCSP  DCSP write_int(fid, FIFF.FIFF_PROJ_ITEM_KIND, proj['kind']) DCNL DCSP  DCSP if (proj['kind'] == FIFF.FIFFV_PROJ_ITEM_FIELD): DCNL DCSP  DCSP  DCSP write_float(fid, FIFF.FIFF_PROJ_ITEM_TIME, 0.0) DCNL DCSP  DCSP write_int(fid, FIFF.FIFF_PROJ_ITEM_NVEC, proj['data']['nrow']) DCNL DCSP  DCSP write_int(fid, FIFF.FIFF_MNE_PROJ_ITEM_ACTIVE, proj['active']) DCNL DCSP  DCSP write_float_matrix(fid, FIFF.FIFF_PROJ_ITEM_VECTORS, proj['data']['data']) DCNL DCSP  DCSP if (proj['explained_var'] is not None): DCNL DCSP  DCSP  DCSP write_float(fid, FIFF.FIFF_MNE_ICA_PCA_EXPLAINED_VAR, proj['explained_var']) DCNL DCSP  DCSP end_block(fid, FIFF.FIFFB_PROJ_ITEM) DCNL DCSP end_block(fid, FIFF.FIFFB_PROJ)
 DCSP db.execute('BEGIN') DCNL DCSP for table in ('point', 'line', 'roads', 'polygon'): DCNL DCSP  DCSP db.execute(('DROP DCSP TABLE DCSP %(tmp_prefix)s_%(table)s' % locals())) DCNL DCSP  DCSP db.execute(("DELETE DCSP FROM DCSP geometry_columns DCSP WHERE DCSP f_table_name DCSP = DCSP '%(tmp_prefix)s_%(table)s'" % locals())) DCNL DCSP db.execute('COMMIT')
 DCSP global global_siteurl DCNL DCSP global_siteurl = generator.settings['SITEURL']
 DCSP paths = [] DCNL DCSP for dir in SEARCH_DIRS: DCNL DCSP  DCSP if ((not os.path.isdir(dir)) or (not os.access(dir, os.R_OK))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for name in os.listdir(dir): DCNL DCSP  DCSP  DCSP subdir = os.path.join(dir, name) DCNL DCSP  DCSP  DCSP if ((not os.path.isdir(subdir)) or (not os.access(subdir, os.R_OK))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for subname in os.listdir(subdir): DCNL DCSP  DCSP  DCSP  DCSP path = os.path.join(subdir, subname) DCNL DCSP  DCSP  DCSP  DCSP if utils.is_sockfile(path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP paths.append(path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP for sockfile in DEFAULT_SOCKFILES: DCNL DCSP  DCSP if (not utils.is_sockfile(sockfile)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP paths.append(sockfile) DCNL DCSP return paths
 DCSP def wraps(self, *args, **kwargs): DCNL DCSP  DCSP if (kwargs.get('base_dir', None) is None): DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for c in self.__class__.__mro__: DCNL DCSP  DCSP  DCSP  DCSP if (c.__name__ == 'DiskObjectStore'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return getattr(c, func.__name__)(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP raise Exception(("Could DCSP not DCSP call DCSP DiskObjectStore's DCSP %s DCSP method, DCSP does DCSP your DCSP Object DCSP Store DCSP plugin DCSP inherit DCSP from DCSP DiskObjectStore?" % func.__name__)) DCNL DCSP return wraps
 DCSP (V, E) = graph DCNL DCSP L = [] DCNL DCSP S = set(V) DCNL DCSP E = list(E) DCNL DCSP for (v, u) in E: DCNL DCSP  DCSP S.discard(u) DCNL DCSP if (key is None): DCNL DCSP  DCSP key = (lambda value: value) DCNL DCSP S = sorted(S, key=key, reverse=True) DCNL DCSP while S: DCNL DCSP  DCSP node = S.pop() DCNL DCSP  DCSP L.append(node) DCNL DCSP  DCSP for (u, v) in list(E): DCNL DCSP  DCSP  DCSP if (u == node): DCNL DCSP  DCSP  DCSP  DCSP E.remove((u, v)) DCNL DCSP  DCSP  DCSP  DCSP for (_u, _v) in E: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (v == _v): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP kv = key(v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (i, s) in enumerate(S): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ks = key(s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (kv > ks): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP S.insert(i, v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP S.append(v) DCNL DCSP if E: DCNL DCSP  DCSP raise ValueError('cycle DCSP detected') DCNL DCSP else: DCNL DCSP  DCSP return L
 DCSP _ = i18n.ugettext DCNL DCSP utf8_parser = etree.XMLParser(encoding='utf-8') DCNL DCSP youtube_text_api = copy.deepcopy(settings.YOUTUBE['TEXT_API']) DCNL DCSP youtube_text_api['params']['v'] = youtube_id DCNL DCSP youtube_transcript_name = youtube_video_transcript_name(youtube_text_api) DCNL DCSP if youtube_transcript_name: DCNL DCSP  DCSP youtube_text_api['params']['name'] = youtube_transcript_name DCNL DCSP data = requests.get(('http://' + youtube_text_api['url']), params=youtube_text_api['params']) DCNL DCSP if ((data.status_code != 200) or (not data.text)): DCNL DCSP  DCSP msg = _("Can't DCSP receive DCSP transcripts DCSP from DCSP Youtube DCSP for DCSP {youtube_id}. DCSP Status DCSP code: DCSP {status_code}.").format(youtube_id=youtube_id, status_code=data.status_code) DCNL DCSP  DCSP raise GetTranscriptsFromYouTubeException(msg) DCNL DCSP (sub_starts, sub_ends, sub_texts) = ([], [], []) DCNL DCSP xmltree = etree.fromstring(data.content, parser=utf8_parser) DCNL DCSP for element in xmltree: DCNL DCSP  DCSP if (element.tag == 'text'): DCNL DCSP  DCSP  DCSP start = float(element.get('start')) DCNL DCSP  DCSP  DCSP duration = float(element.get('dur', 0)) DCNL DCSP  DCSP  DCSP text = element.text DCNL DCSP  DCSP  DCSP end = (start + duration) DCNL DCSP  DCSP  DCSP if text: DCNL DCSP  DCSP  DCSP  DCSP sub_starts.append(int((start * 1000))) DCNL DCSP  DCSP  DCSP  DCSP sub_ends.append(int(((end + 0.0001) * 1000))) DCNL DCSP  DCSP  DCSP  DCSP sub_texts.append(text.replace('\n', ' DCSP ')) DCNL DCSP return {'start': sub_starts, 'end': sub_ends, 'text': sub_texts}
 DCSP coreprops = makeelement('coreProperties', nsprefix='cp') DCNL DCSP coreprops.append(makeelement('title', tagtext=title, nsprefix='dc')) DCNL DCSP coreprops.append(makeelement('subject', tagtext=subject, nsprefix='dc')) DCNL DCSP coreprops.append(makeelement('creator', tagtext=creator, nsprefix='dc')) DCNL DCSP coreprops.append(makeelement('keywords', tagtext=','.join(keywords), nsprefix='cp')) DCNL DCSP if (not lastmodifiedby): DCNL DCSP  DCSP lastmodifiedby = creator DCNL DCSP coreprops.append(makeelement('lastModifiedBy', tagtext=lastmodifiedby, nsprefix='cp')) DCNL DCSP coreprops.append(makeelement('revision', tagtext='1', nsprefix='cp')) DCNL DCSP coreprops.append(makeelement('category', tagtext='Examples', nsprefix='cp')) DCNL DCSP coreprops.append(makeelement('description', tagtext='Examples', nsprefix='dc')) DCNL DCSP currenttime = time.strftime('%Y-%m-%dT%H:%M:%SZ') DCNL DCSP for doctime in ['created', 'modified']: DCNL DCSP  DCSP elm_str = ('<dcterms:%s DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xmlns:dcterms="http://purl.org/dc/terms/" DCSP xsi:type="dcterms:W3CDTF">%s</dcterms:%s>' % (doctime, currenttime, doctime)) DCNL DCSP  DCSP coreprops.append(etree.fromstring(elm_str)) DCNL DCSP return coreprops
 DCSP def attach_bound_data(request): DCNL DCSP  DCSP parent = getattr(request, 'parent', None) DCNL DCSP  DCSP return (parent.bound_data if parent else {}) DCNL DCSP config.add_request_method(attach_bound_data, name='bound_data', reify=True)
 DCSP if isinstance(at, datetime): DCNL DCSP  DCSP return False DCNL DCSP return ((at.hour is None) and (at.minute is None) and (at.second is None) and (at.microsecond is None))
 DCSP passbC = passb.copy() DCNL DCSP passbC[ind] = wp DCNL DCSP nat = ((stopb * (passbC[0] - passbC[1])) / ((stopb ** 2) - (passbC[0] * passbC[1]))) DCNL DCSP nat = min(abs(nat)) DCNL DCSP if (type == 'butter'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * abs(gstop))) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * abs(gpass))) DCNL DCSP  DCSP n = (log10(((GSTOP - 1.0) / (GPASS - 1.0))) / (2 * log10(nat))) DCNL DCSP elif (type == 'cheby'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * abs(gstop))) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * abs(gpass))) DCNL DCSP  DCSP n = (arccosh(sqrt(((GSTOP - 1.0) / (GPASS - 1.0)))) / arccosh(nat)) DCNL DCSP elif (type == 'ellip'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * gstop)) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * gpass)) DCNL DCSP  DCSP arg1 = sqrt(((GPASS - 1.0) / (GSTOP - 1.0))) DCNL DCSP  DCSP arg0 = (1.0 / nat) DCNL DCSP  DCSP d0 = special.ellipk([(arg0 ** 2), (1 - (arg0 ** 2))]) DCNL DCSP  DCSP d1 = special.ellipk([(arg1 ** 2), (1 - (arg1 ** 2))]) DCNL DCSP  DCSP n = ((d0[0] * d1[1]) / (d0[1] * d1[0])) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP type: DCSP %s' % type)) DCNL DCSP return n
 DCSP def decorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(result, (dict, DictMixin)): DCNL DCSP  DCSP  DCSP  DCSP tplvars = defaults.copy() DCNL DCSP  DCSP  DCSP  DCSP tplvars.update(result) DCNL DCSP  DCSP  DCSP  DCSP return template(tpl_name, **tplvars) DCNL DCSP  DCSP  DCSP elif (result is None): DCNL DCSP  DCSP  DCSP  DCSP return template(tpl_name, defaults) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
 DCSP if (n == 2): DCNL DCSP  DCSP return [2] DCNL DCSP elif (n < 2): DCNL DCSP  DCSP return [] DCNL DCSP s = list(range(3, (n + 1), 2)) DCNL DCSP mroot = (n ** 0.5) DCNL DCSP half = (((n + 1) // 2) - 1) DCNL DCSP i = 0 DCNL DCSP m = 3 DCNL DCSP while (m <= mroot): DCNL DCSP  DCSP if s[i]: DCNL DCSP  DCSP  DCSP j = (((m * m) - 3) // 2) DCNL DCSP  DCSP  DCSP s[j] = 0 DCNL DCSP  DCSP  DCSP while (j < half): DCNL DCSP  DCSP  DCSP  DCSP s[j] = 0 DCNL DCSP  DCSP  DCSP  DCSP j += m DCNL DCSP  DCSP i = (i + 1) DCNL DCSP  DCSP m = ((2 * i) + 3) DCNL DCSP return ([2] + [x for x in s if x])
 DCSP S = sentence DCNL DCSP if (not (hasattr(S, 'words') and hasattr(S, 'parse_token'))): DCNL DCSP  DCSP raise TypeError(('%s DCSP object DCSP is DCSP not DCSP a DCSP parsed DCSP Sentence' % repr(S.__class__.__name__))) DCNL DCSP if question(S): DCNL DCSP  DCSP return False DCNL DCSP for (i, w) in enumerate(S): DCNL DCSP  DCSP b = False DCNL DCSP  DCSP if w.type.startswith('VB'): DCNL DCSP  DCSP  DCSP if s(w).startswith('wish'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((s(w) == 'hope') and (i > 0) and (s(S[(i - 1)]) in ('i', 'we'))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((s(w) == 'were') and (i > 0) and ((s(S[(i - 1)]) in ('i', 'it', 'he', 'she')) or (S[(i - 1)].type == 'NN'))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if (s(w) in subjunctive1): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP  DCSP elif ((s(w) == 'is') and (0 < i < (len(S) - 1)) and (s(S[(i - 1)]) == 'it') and (s(S[(i + 1)]) in subjunctive2)): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP  DCSP elif ((s(w) == 'is') and (0 < i < (len(S) - 3)) and (s(S[(i - 1)]) == 'it') and (s(S[(i + 2)]) in ('good', 'bad')) and (s(S[(i + 3)]) == 'idea')): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP if b: DCNL DCSP  DCSP  DCSP v = find((lambda w: w.type.startswith('VB')), S[(i + 1):]) DCNL DCSP  DCSP  DCSP if (v and (classical is True) and v and (v.type == 'VB')): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if (v and (classical is False)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP mult = mticker.MultipleLocator(base=0.7) DCNL DCSP mult.set_params(base=1.7) DCNL DCSP assert (mult._base == 1.7)
 DCSP prev = _OVERRIDES_DISABLED.disabled DCNL DCSP _OVERRIDES_DISABLED.disabled += (True,) DCNL DCSP (yield) DCNL DCSP _OVERRIDES_DISABLED.disabled = prev
 DCSP if (not find_sockfiles()): DCNL DCSP  DCSP return 13 DCNL DCSP if (MySQLdb is None): DCNL DCSP  DCSP utils.err("error: DCSP Python DCSP module DCSP `MySQLdb' DCSP is DCSP missing") DCNL DCSP  DCSP return 1 DCNL DCSP last_db_refresh = now() DCNL DCSP dbs = find_databases() DCNL DCSP while True: DCNL DCSP  DCSP ts = now() DCNL DCSP  DCSP if ((ts - last_db_refresh) >= DB_REFRESH_INTERVAL): DCNL DCSP  DCSP  DCSP find_databases(dbs) DCNL DCSP  DCSP  DCSP last_db_refresh = ts DCNL DCSP  DCSP errs = [] DCNL DCSP  DCSP for (dbname, db) in dbs.iteritems(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP collect(db) DCNL DCSP  DCSP  DCSP except (EnvironmentError, EOFError, RuntimeError, socket.error, MySQLdb.MySQLError) as e: DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(e, IOError) and (e[0] == errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 2 DCNL DCSP  DCSP  DCSP  DCSP utils.err(('error: DCSP failed DCSP to DCSP collect DCSP data DCSP from DCSP %s: DCSP %s' % (db, e))) DCNL DCSP  DCSP  DCSP  DCSP errs.append(dbname) DCNL DCSP  DCSP for dbname in errs: DCNL DCSP  DCSP  DCSP del dbs[dbname] DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP time.sleep(COLLECTION_INTERVAL)
 DCSP xs = [expand_dims.expand_dims(x, axis=axis) for x in xs] DCNL DCSP return concat.concat(xs, axis=axis)
 DCSP if CONF.fake_network: DCNL DCSP  DCSP LOG.debug('FAKE DCSP NET: DCSP %s', ' DCSP '.join(map(str, cmd))) DCNL DCSP  DCSP return ('fake', 0) DCNL DCSP else: DCNL DCSP  DCSP return utils.execute(*cmd, **kwargs)
 DCSP (filepath, file) = split(file) DCNL DCSP if filepath: DCNL DCSP  DCSP path = (filepath,) DCNL DCSP elif (path is None): DCNL DCSP  DCSP path = defpath DCNL DCSP elif isinstance(path, str): DCNL DCSP  DCSP path = path.split(pathsep) DCNL DCSP if (pathext is None): DCNL DCSP  DCSP pathext = defpathext DCNL DCSP elif isinstance(pathext, str): DCNL DCSP  DCSP pathext = pathext.split(pathsep) DCNL DCSP if (not ('' in pathext)): DCNL DCSP  DCSP pathext.insert(0, '') DCNL DCSP for dir in path: DCNL DCSP  DCSP basepath = join(dir, file) DCNL DCSP  DCSP for ext in pathext: DCNL DCSP  DCSP  DCSP fullpath = (basepath + ext) DCNL DCSP  DCSP  DCSP if (exists(fullpath) and access(fullpath, mode)): DCNL DCSP  DCSP  DCSP  DCSP (yield fullpath)
 DCSP client = salt.runner.RunnerClient(__opts__) DCNL DCSP ret = client.get_docs() DCNL DCSP return ret
 DCSP string = re.sub('\\n', ' DCSP ', string) DCNL DCSP string = re.sub("\\'s", " DCSP 's", string) DCNL DCSP string = re.sub('\\\xe2\x80\x99s', " DCSP 's", string) DCNL DCSP string = re.sub("\\'ve", ' DCSP have', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99ve', ' DCSP have', string) DCNL DCSP string = re.sub("\\'t", ' DCSP not', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99t', ' DCSP not', string) DCNL DCSP string = re.sub("\\'re", ' DCSP are', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99re', ' DCSP are', string) DCNL DCSP string = re.sub("\\'d", '', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99d', '', string) DCNL DCSP string = re.sub("\\'ll", ' DCSP will', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99ll', ' DCSP will', string) DCNL DCSP string = re.sub('\\\xe2\x80\x9c', ' DCSP \xe2\x80\x9c DCSP ', string) DCNL DCSP string = re.sub('\\\xe2\x80\x9d', ' DCSP \xe2\x80\x9d DCSP ', string) DCNL DCSP string = re.sub('\\"', ' DCSP \xe2\x80\x9c DCSP ', string) DCNL DCSP string = re.sub("\\'", " DCSP ' DCSP ", string) DCNL DCSP string = re.sub('\\\xe2\x80\x99', " DCSP ' DCSP ", string) DCNL DCSP string = re.sub('\\.', ' DCSP . DCSP ', string) DCNL DCSP string = re.sub('\\,', ' DCSP , DCSP ', string) DCNL DCSP string = re.sub('\\-', ' DCSP ', string) DCNL DCSP string = re.sub('\\(', ' DCSP ( DCSP ', string) DCNL DCSP string = re.sub('\\)', ' DCSP ) DCSP ', string) DCNL DCSP string = re.sub('\\!', ' DCSP ! DCSP ', string) DCNL DCSP string = re.sub('\\]', ' DCSP ] DCSP ', string) DCNL DCSP string = re.sub('\\[', ' DCSP [ DCSP ', string) DCNL DCSP string = re.sub('\\?', ' DCSP ? DCSP ', string) DCNL DCSP string = re.sub('\\>', ' DCSP > DCSP ', string) DCNL DCSP string = re.sub('\\<', ' DCSP < DCSP ', string) DCNL DCSP string = re.sub('\\=', ' DCSP = DCSP ', string) DCNL DCSP string = re.sub('\\;', ' DCSP ; DCSP ', string) DCNL DCSP string = re.sub('\\;', ' DCSP ; DCSP ', string) DCNL DCSP string = re.sub('\\:', ' DCSP : DCSP ', string) DCNL DCSP string = re.sub('\\"', ' DCSP " DCSP ', string) DCNL DCSP string = re.sub('\\$', ' DCSP $ DCSP ', string) DCNL DCSP string = re.sub('\\_', ' DCSP _ DCSP ', string) DCNL DCSP string = re.sub('\\s{2,}', ' DCSP ', string) DCNL DCSP return string.strip().lower()
 DCSP if (var.name is not None): DCNL DCSP  DCSP return var.name DCNL DCSP elif isinstance(var, gof.Constant): DCNL DCSP  DCSP h = np.asarray(var.data) DCNL DCSP  DCSP is_const = False DCNL DCSP  DCSP if (h.ndim == 0): DCNL DCSP  DCSP  DCSP is_const = True DCNL DCSP  DCSP  DCSP h = np.array([h]) DCNL DCSP  DCSP dstr = np.array2string(h, precision=precision) DCNL DCSP  DCSP if ('\n' in dstr): DCNL DCSP  DCSP  DCSP dstr = dstr[:dstr.index('\n')] DCNL DCSP  DCSP if is_const: DCNL DCSP  DCSP  DCSP dstr = dstr.replace('[', '').replace(']', '') DCNL DCSP  DCSP return dstr DCNL DCSP else: DCNL DCSP  DCSP return type_to_str(var.type)
 DCSP try: DCNL DCSP  DCSP print '[INFO] DCSP Checking DCSP for DCSP ZIP DCSP Validity DCSP and DCSP Mode' DCNL DCSP  DCSP man = os.path.isfile(os.path.join(app_dir, 'AndroidManifest.xml')) DCNL DCSP  DCSP src = os.path.exists(os.path.join(app_dir, 'src/')) DCNL DCSP  DCSP if (man and src): DCNL DCSP  DCSP  DCSP return ('eclipse', True) DCNL DCSP  DCSP man = os.path.isfile(os.path.join(app_dir, 'app/src/main/AndroidManifest.xml')) DCNL DCSP  DCSP src = os.path.exists(os.path.join(app_dir, 'app/src/main/java/')) DCNL DCSP  DCSP if (man and src): DCNL DCSP  DCSP  DCSP return ('studio', True) DCNL DCSP  DCSP xcode = [f for f in os.listdir(app_dir) if f.endswith('.xcodeproj')] DCNL DCSP  DCSP if xcode: DCNL DCSP  DCSP  DCSP return ('ios', True) DCNL DCSP  DCSP return ('', False) DCNL DCSP except: DCNL DCSP  DCSP PrintException('[ERROR] DCSP Determining DCSP Upload DCSP type')
 DCSP def _validator(form, field): DCNL DCSP  DCSP all_conditions_met = True DCNL DCSP  DCSP for (key, value) in kwargs.iteritems(): DCNL DCSP  DCSP  DCSP if (getattr(form, key).data != value): DCNL DCSP  DCSP  DCSP  DCSP all_conditions_met = False DCNL DCSP  DCSP if all_conditions_met: DCNL DCSP  DCSP  DCSP if ((field.data is None) or (isinstance(field.data, (str, unicode)) and (not field.data.strip())) or (isinstance(field.data, FileStorage) and (not field.data.filename.strip()))): DCNL DCSP  DCSP  DCSP  DCSP raise validators.ValidationError('This DCSP field DCSP is DCSP required.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP field.errors[:] = [] DCNL DCSP  DCSP  DCSP raise validators.StopValidation() DCNL DCSP return _validator
 DCSP registry = FormatRegistry() DCNL DCSP filetype = registry.register('foo', 'foo') DCNL DCSP new_filetype = registry.register('foo', 'foo') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP _test_formats(registry, ['foo']) DCNL DCSP new_filetype = registry.register('foo', 'foo', title='Bar') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP assert (new_filetype.title == 'Bar') DCNL DCSP _test_formats(registry, ['foo']) DCNL DCSP new_filetype = registry.register('foo', 'bar') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP assert (new_filetype.title == 'Bar') DCNL DCSP assert (str(new_filetype.extension) == 'bar') DCNL DCSP _test_formats(registry, ['foo'])
 DCSP thisdriver = _get_virt_name(virt_file_re, filename) DCNL DCSP thatdriver = _get_virt_name(virt_import_re, physical_line) DCNL DCSP if ((thatdriver is not None) and (thisdriver is not None) and (thisdriver != thatdriver)): DCNL DCSP  DCSP return (0, 'N311: DCSP importing DCSP code DCSP from DCSP other DCSP virt DCSP drivers DCSP forbidden')
 DCSP width = get_cwidth(text) DCNL DCSP if (width > max_width): DCNL DCSP  DCSP if (len(text) == width): DCNL DCSP  DCSP  DCSP trimmed_text = (text[:max(1, (max_width - 3))] + u'...')[:max_width] DCNL DCSP  DCSP  DCSP return (trimmed_text, len(trimmed_text)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP trimmed_text = u'' DCNL DCSP  DCSP  DCSP for c in text: DCNL DCSP  DCSP  DCSP  DCSP if (get_cwidth((trimmed_text + c)) <= (max_width - 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP trimmed_text += c DCNL DCSP  DCSP  DCSP trimmed_text += u'...' DCNL DCSP  DCSP  DCSP return (trimmed_text, get_cwidth(trimmed_text)) DCNL DCSP else: DCNL DCSP  DCSP return (text, width)
 DCSP n_samples = X.shape[0] DCNL DCSP (labels, mindist) = pairwise_distances_argmin_min(X=X, Y=centers, metric='euclidean', metric_kwargs={'squared': True}) DCNL DCSP labels = labels.astype(np.int32) DCNL DCSP if (n_samples == distances.shape[0]): DCNL DCSP  DCSP distances[:] = mindist DCNL DCSP inertia = mindist.sum() DCNL DCSP return (labels, inertia)
 DCSP return IMPL.compute_node_statistics(context)
 DCSP text = re_mathdefault.sub(repl_mathdefault, text) DCNL DCSP parts = re_mathsep.split(text) DCNL DCSP for (i, s) in enumerate(parts): DCNL DCSP  DCSP if (not (i % 2)): DCNL DCSP  DCSP  DCSP s = re_escapetext.sub(repl_escapetext, s) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = (u'\\(\\displaystyle DCSP %s\\)' % s) DCNL DCSP  DCSP parts[i] = s DCNL DCSP return u''.join(parts)
 DCSP print ast.literal_eval(info), type(ast.literal_eval(info)) DCNL DCSP return ast.literal_eval(info)
 DCSP start_time = time() DCNL DCSP start_date = datetime.now(UTC) DCNL DCSP status_interval = 100 DCNL DCSP enrolled_students = CourseEnrollment.objects.users_enrolled_in(course_id) DCNL DCSP task_progress = TaskProgress(action_name, enrolled_students.count(), start_time) DCNL DCSP header_row = OrderedDict([('id', 'Student DCSP ID'), ('email', 'Email'), ('username', 'Username')]) DCNL DCSP graded_scorable_blocks = _graded_scorable_blocks_to_header(course_id) DCNL DCSP rows = [((list(header_row.values()) + ['Grade']) + list(chain.from_iterable(graded_scorable_blocks.values())))] DCNL DCSP error_rows = [(list(header_row.values()) + ['error_msg'])] DCNL DCSP current_step = {'step': 'Calculating DCSP Grades'} DCNL DCSP course = get_course_by_id(course_id) DCNL DCSP for (student, course_grade, err_msg) in CourseGradeFactory().iter(course, enrolled_students): DCNL DCSP  DCSP student_fields = [getattr(student, field_name) for field_name in header_row] DCNL DCSP  DCSP task_progress.attempted += 1 DCNL DCSP  DCSP if (not course_grade): DCNL DCSP  DCSP  DCSP if (not err_msg): DCNL DCSP  DCSP  DCSP  DCSP err_msg = u'Unknown DCSP error' DCNL DCSP  DCSP  DCSP error_rows.append((student_fields + [err_msg])) DCNL DCSP  DCSP  DCSP task_progress.failed += 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP earned_possible_values = [] DCNL DCSP  DCSP for block_location in graded_scorable_blocks: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP problem_score = course_grade.locations_to_scores[block_location] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP earned_possible_values.append([u'Not DCSP Available', u'Not DCSP Available']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if problem_score.attempted: DCNL DCSP  DCSP  DCSP  DCSP  DCSP earned_possible_values.append([problem_score.earned, problem_score.possible]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP earned_possible_values.append([u'Not DCSP Attempted', problem_score.possible]) DCNL DCSP  DCSP rows.append(((student_fields + [course_grade.percent]) + list(chain.from_iterable(earned_possible_values)))) DCNL DCSP  DCSP task_progress.succeeded += 1 DCNL DCSP  DCSP if ((task_progress.attempted % status_interval) == 0): DCNL DCSP  DCSP  DCSP task_progress.update_task_state(extra_meta=current_step) DCNL DCSP if (len(rows) > 1): DCNL DCSP  DCSP upload_csv_to_report_store(rows, 'problem_grade_report', course_id, start_date) DCNL DCSP if (len(error_rows) > 1): DCNL DCSP  DCSP upload_csv_to_report_store(error_rows, 'problem_grade_report_err', course_id, start_date) DCNL DCSP return task_progress.update_task_state(extra_meta={'step': 'Uploading DCSP CSV'})
 DCSP net = ([int(digit) for digit in ipstr.split('.')] + [0, 0, 0]) DCNL DCSP net = net[:4] DCNL DCSP return (((((((0L + net[0]) << 8) + net[1]) << 8) + net[2]) << 8) + net[3])
 DCSP assert (set(required_keys) <= set(dict_to_check.keys())), ('Missing DCSP keys: DCSP %s' % dict_to_check) DCNL DCSP assert (set(dict_to_check.keys()) <= set((required_keys + optional_keys))), ('Extra DCSP keys: DCSP %s' % dict_to_check)
 DCSP array_of_optv = DataObject() DCNL DCSP array_of_optv.OptionValue = optvals DCNL DCSP return array_of_optv
 DCSP return IMPL.image_volume_cache_create(context, host, cluster_name, image_id, image_updated_at, volume_id, size)
 DCSP location = EarthLocation(lon=Angle(u'-111d36.0m'), lat=Angle(u'31d57.8m'), height=(2120.0 * u.m)) DCNL DCSP obstime = Time(2451545.0, format=u'jd', scale=u'ut1') DCNL DCSP altaz_frame = AltAz(obstime=obstime, location=location, temperature=(0 * u.deg_C), pressure=(0.781 * u.bar)) DCNL DCSP altaz_frame_noatm = AltAz(obstime=obstime, location=location, temperature=(0 * u.deg_C), pressure=(0.0 * u.bar)) DCNL DCSP altaz = SkyCoord(u'264d55m06s DCSP 37d54m41s', frame=altaz_frame) DCNL DCSP altaz_noatm = SkyCoord(u'264d55m06s DCSP 37d54m41s', frame=altaz_frame_noatm) DCNL DCSP radec_frame = u'icrs' DCNL DCSP radec_actual = altaz.transform_to(radec_frame) DCNL DCSP radec_actual_noatm = altaz_noatm.transform_to(radec_frame) DCNL DCSP radec_expected = SkyCoord(u'07h36m55.2s DCSP +15d25m08s', frame=radec_frame) DCNL DCSP distance = radec_actual.separation(radec_expected).to(u'arcsec') DCNL DCSP radec_expected_noatm = SkyCoord(u'07h36m58.9s DCSP +15d25m37s', frame=radec_frame) DCNL DCSP distance_noatm = radec_actual_noatm.separation(radec_expected_noatm).to(u'arcsec') DCNL DCSP assert (distance < (5 * u.arcsec)) DCNL DCSP assert (distance_noatm < (0.4 * u.arcsec))
 DCSP rng = np.random.RandomState([2013, 5, 1]) DCNL DCSP batch_size = 3 DCNL DCSP rows = 4 DCNL DCSP cols = 5 DCNL DCSP channels = 2 DCNL DCSP conv = Conv2DSpace([rows, cols], channels=channels, axes=('c', 0, 1, 'b')) DCNL DCSP vec = VectorSpace(conv.get_total_dimension()) DCNL DCSP X = conv.make_batch_theano() DCNL DCSP Y = conv.format_as(X, vec) DCNL DCSP Z = vec.format_as(Y, conv) DCNL DCSP A = vec.make_batch_theano() DCNL DCSP B = vec.format_as(A, conv) DCNL DCSP C = conv.format_as(B, vec) DCNL DCSP f = function([X, A], [Z, C]) DCNL DCSP X = rng.randn(*conv.get_origin_batch(batch_size).shape).astype(X.dtype) DCNL DCSP A = rng.randn(*vec.get_origin_batch(batch_size).shape).astype(A.dtype) DCNL DCSP (Z, C) = f(X, A) DCNL DCSP np.testing.assert_allclose(Z, X) DCNL DCSP np.testing.assert_allclose(C, A)
 DCSP db_name = context.conf[u'dbname'] DCNL DCSP context.cli.sendline(u'\\connect DCSP {0}'.format(db_name))
 DCSP if (os.geteuid() != 0): DCNL DCSP  DCSP return DCNL DCSP global g_user_uid, g_user_gid DCNL DCSP (g_user_uid, g_user_gid) = desktop.lib.daemon_utils.get_uid_gid(SETUID_USER, SETGID_GROUP)
 DCSP expr = func(constr.expr) DCNL DCSP return type(constr)(expr, constr.constr_id, constr.size)
 DCSP if ('postgres.tablespace_exists' not in __salt__): DCNL DCSP  DCSP return (False, 'Unable DCSP to DCSP load DCSP postgres DCSP module. DCSP  DCSP Make DCSP sure DCSP `postgres.bins_dir` DCSP is DCSP set.') DCNL DCSP return True
 DCSP return lo.LinOp(lo.MUL_ELEM, lh_op.size, [rh_op], lh_op)
 DCSP if (not (general or request or response or entity)): DCNL DCSP  DCSP general = request = response = entity = True DCNL DCSP search = [] DCNL DCSP for (bool, strval) in ((general, 'general'), (request, 'request'), (response, 'response'), (entity, 'entity')): DCNL DCSP  DCSP if bool: DCNL DCSP  DCSP  DCSP search.append(strval) DCNL DCSP return [head for head in _headers.values() if (head.category in search)]
 DCSP import pyvera as veraApi DCNL DCSP if isinstance(vera_device, veraApi.VeraDimmer): DCNL DCSP  DCSP return 'light' DCNL DCSP if isinstance(vera_device, veraApi.VeraBinarySensor): DCNL DCSP  DCSP return 'binary_sensor' DCNL DCSP if isinstance(vera_device, veraApi.VeraSensor): DCNL DCSP  DCSP return 'sensor' DCNL DCSP if isinstance(vera_device, veraApi.VeraArmableDevice): DCNL DCSP  DCSP return 'switch' DCNL DCSP if isinstance(vera_device, veraApi.VeraLock): DCNL DCSP  DCSP return 'lock' DCNL DCSP if isinstance(vera_device, veraApi.VeraThermostat): DCNL DCSP  DCSP return 'climate' DCNL DCSP if isinstance(vera_device, veraApi.VeraCurtain): DCNL DCSP  DCSP return 'cover' DCNL DCSP if isinstance(vera_device, veraApi.VeraSwitch): DCNL DCSP  DCSP if (vera_device.device_id in remap): DCNL DCSP  DCSP  DCSP return 'light' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'switch' DCNL DCSP return None
 DCSP _cred = __get_yubico_users(username) DCNL DCSP client = Yubico(_cred['id'], _cred['key']) DCNL DCSP try: DCNL DCSP  DCSP if client.verify(password): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP except yubico_exceptions.StatusCodeError as e: DCNL DCSP  DCSP log.info('Unable DCSP to DCSP verify DCSP YubiKey DCSP `{0}`'.format(e)) DCNL DCSP  DCSP return False
 DCSP (header, mapping_data, run_description, errors, warnings) = process_id_map(open(mapping_fp, 'U'), disable_primer_check, has_barcodes, char_replace, variable_len_barcodes, added_demultiplex_field, strip_quotes=False, suppress_stripping=True) DCNL DCSP if (not suppress_html): DCNL DCSP  DCSP formatted_html = format_mapping_html_data(header, mapping_data, errors, warnings) DCNL DCSP  DCSP output_html = join(((output_dir + basename(mapping_fp).replace('.txt', '')) + '.html')) DCNL DCSP  DCSP html_f = open(output_html, 'w') DCNL DCSP  DCSP html_f.write(formatted_html) DCNL DCSP  DCSP qiime_dir = get_qiime_project_dir() DCNL DCSP  DCSP copyfile(join(qiime_dir, 'qiime', 'support_files', 'js/overlib.js'), join(output_dir, 'overlib.js')) DCNL DCSP corrected_mapping_data = correct_mapping_data(mapping_data, header, char_replace) DCNL DCSP output_corrected_fp = join(((output_dir + basename(mapping_fp).replace('.txt', '')) + '_corrected.txt')) DCNL DCSP write_corrected_mapping(output_corrected_fp, header, run_description, corrected_mapping_data) DCNL DCSP output_log_fp = join(((output_dir + basename(mapping_fp).replace('.txt', '')) + '.log')) DCNL DCSP write_log_file(output_log_fp, errors, warnings) DCNL DCSP if verbose: DCNL DCSP  DCSP if (errors or warnings): DCNL DCSP  DCSP  DCSP print ('Errors DCSP and/or DCSP warnings DCSP detected DCSP in DCSP mapping DCSP file. DCSP  DCSP Please DCSP ' + 'check DCSP the DCSP log DCSP and DCSP html DCSP file DCSP for DCSP details.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'No DCSP errors DCSP or DCSP warnings DCSP were DCSP found DCSP in DCSP mapping DCSP file.'
 DCSP msg = ('Pushing DCSP %r DCSP to DCSP %r' % (local_path, remote_path)) DCNL DCSP remote_filename = os.path.basename(local_path) DCNL DCSP if log.isEnabledFor(logging.DEBUG): DCNL DCSP  DCSP msg += (' DCSP (%s)' % context.device) DCNL DCSP with log.waitfor(msg) as w: DCNL DCSP  DCSP with AdbClient() as c: DCNL DCSP  DCSP  DCSP stat_ = c.stat(remote_path) DCNL DCSP  DCSP  DCSP if (not stat_): DCNL DCSP  DCSP  DCSP  DCSP remote_filename = os.path.basename(remote_path) DCNL DCSP  DCSP  DCSP  DCSP remote_path = os.path.dirname(remote_path) DCNL DCSP  DCSP  DCSP  DCSP stat_ = c.stat(remote_path) DCNL DCSP  DCSP  DCSP if (not stat_): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Could DCSP not DCSP stat DCSP %r' % remote_path)) DCNL DCSP  DCSP  DCSP mode = stat_['mode'] DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(mode): DCNL DCSP  DCSP  DCSP  DCSP remote_path = os.path.join(remote_path, remote_filename) DCNL DCSP  DCSP  DCSP return c.write(remote_path, misc.read(local_path), callback=_create_adb_push_pull_callback(w))
 DCSP if (not isinstance(data, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|failed DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list') DCNL DCSP if (not data): DCNL DCSP  DCSP return None DCNL DCSP elif ((image_name is None) or (not image_name.endswith('_*'))): DCNL DCSP  DCSP ami = sorted(data, key=itemgetter('name'), reverse=True)[0] DCNL DCSP  DCSP return ami['ami_id'] DCNL DCSP else: DCNL DCSP  DCSP ami_info = [(ami, ami['name'].split('_')[(-1)]) for ami in data] DCNL DCSP  DCSP ami = sorted(ami_info, key=itemgetter(1), reverse=True)[0][0] DCNL DCSP  DCSP return ami['ami_id']
 DCSP if (sys.platform in ['win32', 'cygwin']): DCNL DCSP  DCSP return 'pyd' DCNL DCSP else: DCNL DCSP  DCSP return 'so'
 DCSP return sorted(FQDNs, key=(lambda fqdn: fqdn.split('.')[::(-1)][1:]))
 DCSP output = [outbuffer] DCNL DCSP tag_name = xml.tag.split(u'}', 1)[(-1)] DCNL DCSP if (u'}' in xml.tag): DCNL DCSP  DCSP tag_xmlns = xml.tag.split(u'}', 1)[0][1:] DCNL DCSP else: DCNL DCSP  DCSP tag_xmlns = u'' DCNL DCSP default_ns = u'' DCNL DCSP stream_ns = u'' DCNL DCSP use_cdata = False DCNL DCSP if stream: DCNL DCSP  DCSP default_ns = stream.default_ns DCNL DCSP  DCSP stream_ns = stream.stream_ns DCNL DCSP  DCSP use_cdata = stream.use_cdata DCNL DCSP namespace = u'' DCNL DCSP if tag_xmlns: DCNL DCSP  DCSP if ((top_level and (tag_xmlns not in [default_ns, xmlns, stream_ns])) or ((not top_level) and (tag_xmlns != xmlns))): DCNL DCSP  DCSP  DCSP namespace = (u' DCSP xmlns="%s"' % tag_xmlns) DCNL DCSP if (stream and (tag_xmlns in stream.namespace_map)): DCNL DCSP  DCSP mapped_namespace = stream.namespace_map[tag_xmlns] DCNL DCSP  DCSP if mapped_namespace: DCNL DCSP  DCSP  DCSP tag_name = (u'%s:%s' % (mapped_namespace, tag_name)) DCNL DCSP output.append((u'<%s' % tag_name)) DCNL DCSP output.append(namespace) DCNL DCSP new_namespaces = set() DCNL DCSP for (attrib, value) in xml.attrib.items(): DCNL DCSP  DCSP value = escape(value, use_cdata) DCNL DCSP  DCSP if (u'}' not in attrib): DCNL DCSP  DCSP  DCSP output.append((u' DCSP %s="%s"' % (attrib, value))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP attrib_ns = attrib.split(u'}')[0][1:] DCNL DCSP  DCSP  DCSP attrib = attrib.split(u'}')[1] DCNL DCSP  DCSP  DCSP if (attrib_ns == XML_NS): DCNL DCSP  DCSP  DCSP  DCSP output.append((u' DCSP xml:%s="%s"' % (attrib, value))) DCNL DCSP  DCSP  DCSP elif (stream and (attrib_ns in stream.namespace_map)): DCNL DCSP  DCSP  DCSP  DCSP mapped_ns = stream.namespace_map[attrib_ns] DCNL DCSP  DCSP  DCSP  DCSP if mapped_ns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (namespaces is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP namespaces = set() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (attrib_ns not in namespaces): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP namespaces.add(attrib_ns) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_namespaces.add(attrib_ns) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output.append((u' DCSP xmlns:%s="%s"' % (mapped_ns, attrib_ns))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output.append((u' DCSP %s:%s="%s"' % (mapped_ns, attrib, value))) DCNL DCSP if open_only: DCNL DCSP  DCSP output.append(u'>') DCNL DCSP  DCSP return u''.join(output) DCNL DCSP if (len(xml) or xml.text): DCNL DCSP  DCSP output.append(u'>') DCNL DCSP  DCSP if xml.text: DCNL DCSP  DCSP  DCSP output.append(escape(xml.text, use_cdata)) DCNL DCSP  DCSP if len(xml): DCNL DCSP  DCSP  DCSP for child in xml: DCNL DCSP  DCSP  DCSP  DCSP output.append(tostring(child, tag_xmlns, stream, namespaces=namespaces)) DCNL DCSP  DCSP output.append((u'</%s>' % tag_name)) DCNL DCSP elif xml.text: DCNL DCSP  DCSP output.append((u'>%s</%s>' % (escape(xml.text, use_cdata), tag_name))) DCNL DCSP else: DCNL DCSP  DCSP output.append(u' DCSP />') DCNL DCSP if xml.tail: DCNL DCSP  DCSP output.append(escape(xml.tail, use_cdata)) DCNL DCSP for ns in new_namespaces: DCNL DCSP  DCSP namespaces.remove(ns) DCNL DCSP return u''.join(output)
 DCSP for filename in pathnames: DCNL DCSP  DCSP if (filename != ''): DCNL DCSP  DCSP  DCSP filename = posixpath.normpath(filename) DCNL DCSP  DCSP for sep in _os_alt_seps: DCNL DCSP  DCSP  DCSP if (sep in filename): DCNL DCSP  DCSP  DCSP  DCSP raise NotFound() DCNL DCSP  DCSP if (os.path.isabs(filename) or (filename == '..') or filename.startswith('../')): DCNL DCSP  DCSP  DCSP raise NotFound() DCNL DCSP  DCSP directory = os.path.join(directory, filename) DCNL DCSP return directory
 DCSP if (query and (not (set(query) <= urlencoded))): DCNL DCSP  DCSP error = u"Error DCSP trying DCSP to DCSP decode DCSP a DCSP non DCSP urlencoded DCSP string. DCSP Found DCSP invalid DCSP characters: DCSP %s DCSP in DCSP the DCSP string: DCSP '%s'. DCSP Please DCSP ensure DCSP the DCSP request/response DCSP body DCSP is DCSP x-www-form-urlencoded." DCNL DCSP  DCSP raise ValueError((error % ((set(query) - urlencoded), query))) DCNL DCSP invalid_hex = u'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]' DCNL DCSP if len(re.findall(invalid_hex, query)): DCNL DCSP  DCSP raise ValueError(u'Invalid DCSP hex DCSP encoding DCSP in DCSP query DCSP string.') DCNL DCSP query = (query.encode(u'utf-8') if ((not PY3) and isinstance(query, unicode_type)) else query) DCNL DCSP params = urlparse.parse_qsl(query, keep_blank_values=True) DCNL DCSP return decode_params_utf8(params)
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except KeyError as key_error: DCNL DCSP  DCSP grpc_context.code(status.Code.NOT_FOUND) DCNL DCSP  DCSP grpc_context.details('Unable DCSP to DCSP find DCSP the DCSP item DCSP keyed DCSP by DCSP {}'.format(key_error))
 DCSP config = _get_vistara_configuration() DCNL DCSP if (not config): DCNL DCSP  DCSP return False DCNL DCSP access_token = _get_oath2_access_token(config['client_key'], config['client_secret']) DCNL DCSP if (not access_token): DCNL DCSP  DCSP return 'Vistara DCSP access DCSP token DCSP not DCSP available' DCNL DCSP query_string = 'dnsName:{0}'.format(name) DCNL DCSP devices = _search_devices(query_string, config['client_id'], access_token) DCNL DCSP if (not devices): DCNL DCSP  DCSP return 'No DCSP devices DCSP found' DCNL DCSP device_count = len(devices) DCNL DCSP if (safety_on and (device_count != 1)): DCNL DCSP  DCSP return 'Expected DCSP to DCSP delete DCSP 1 DCSP device DCSP and DCSP found DCSP {0}. DCSP Set DCSP safety_on=False DCSP to DCSP override.'.format(device_count) DCNL DCSP delete_responses = [] DCNL DCSP for device in devices: DCNL DCSP  DCSP device_id = device['id'] DCNL DCSP  DCSP log.debug(device_id) DCNL DCSP  DCSP delete_response = _delete_resource(device_id, config['client_id'], access_token) DCNL DCSP  DCSP if (not delete_response): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP delete_responses.append(delete_response) DCNL DCSP return delete_responses
 DCSP f_bytes = np.zeros(3, dtype=np.uint8) DCNL DCSP f_bytes[0] = ((val >> 16) & 255) DCNL DCSP f_bytes[1] = ((val >> 8) & 255) DCNL DCSP f_bytes[2] = (val & 255) DCNL DCSP fid.write(f_bytes.tostring())
 DCSP if (hasattr(json_data, 'get') and callable(json_data.get)): DCNL DCSP  DCSP name = json_data.get('protocol') DCNL DCSP  DCSP namespace = json_data.get('namespace') DCNL DCSP  DCSP types = json_data.get('types') DCNL DCSP  DCSP messages = json_data.get('messages') DCNL DCSP  DCSP return Protocol(name, namespace, types, messages) DCNL DCSP else: DCNL DCSP  DCSP raise ProtocolParseException(('Not DCSP a DCSP JSON DCSP object: DCSP %s' % json_data))
 DCSP _t = as_tensor_variable(t) DCNL DCSP ndim = (_t.ndim + 1) DCNL DCSP if (not ((- ndim) <= axis < ndim)): DCNL DCSP  DCSP msg = 'axis DCSP {0} DCSP is DCSP out DCSP of DCSP bounds DCSP [-{1}, DCSP {1})'.format(axis, ndim) DCNL DCSP  DCSP raise IndexError(msg) DCNL DCSP if (axis < 0): DCNL DCSP  DCSP axis += ndim DCNL DCSP pattern = [i for i in xrange(_t.type.ndim)] DCNL DCSP pattern.insert(axis, 'x') DCNL DCSP return DimShuffle(_t.broadcastable, pattern)(_t)
 DCSP file = BytesIO() DCNL DCSP pickler = pickle.Pickler(file, protocol) DCNL DCSP pickler.persistent_id = _persistent_id DCNL DCSP pickler.dump(obj) DCNL DCSP return file.getvalue()
 DCSP cmd = [salt.utils.which('pg_dropcluster')] DCNL DCSP if stop: DCNL DCSP  DCSP cmd += ['--stop'] DCNL DCSP cmd += [version, name] DCNL DCSP cmdstr = ' DCSP '.join([pipes.quote(c) for c in cmd]) DCNL DCSP ret = __salt__['cmd.run_all'](cmdstr, python_shell=False) DCNL DCSP if (ret.get('retcode', 0) != 0): DCNL DCSP  DCSP log.error('Error DCSP removing DCSP a DCSP Postgresql DCSP cluster DCSP {0}/{1}'.format(version, name)) DCNL DCSP else: DCNL DCSP  DCSP ret['changes'] = 'Successfully DCSP removed DCSP cluster DCSP {0}/{1}'.format(version, name) DCNL DCSP return ret
 DCSP _options = _get_options(ret) DCNL DCSP sid = _options.get('sid', None) DCNL DCSP token = _options.get('token', None) DCNL DCSP sender = _options.get('from', None) DCNL DCSP receiver = _options.get('to', None) DCNL DCSP if ((sid is None) or (token is None)): DCNL DCSP  DCSP log.error('Twilio DCSP sid/authentication DCSP token DCSP missing') DCNL DCSP  DCSP return None DCNL DCSP if ((sender is None) or (receiver is None)): DCNL DCSP  DCSP log.error('Twilio DCSP to/from DCSP fields DCSP are DCSP missing') DCNL DCSP  DCSP return None DCNL DCSP client = TwilioRestClient(sid, token) DCNL DCSP try: DCNL DCSP  DCSP message = client.messages.create(body='Minion: DCSP {0}\nCmd: DCSP {1}\nSuccess: DCSP {2}\n\nJid: DCSP {3}'.format(ret['id'], ret['fun'], ret['success'], ret['jid']), to=receiver, from_=sender) DCNL DCSP except TwilioRestException as e: DCNL DCSP  DCSP log.error('Twilio DCSP [https://www.twilio.com/docs/errors/{0}]'.format(e.code)) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ensure_compat('expanding', 'quantile', arg, freq=freq, min_periods=min_periods, func_kw=['quantile'], quantile=quantile)
 DCSP assert isinstance(expr, string_types), (u'%s DCSP is DCSP not DCSP a DCSP string' % expr) DCNL DCSP return (re.match(u'^[A-Z]\\d*$', expr) is not None)
 DCSP localPath = os.path.join(args.localOutputFolder, '{0}-{1}'.format(client.conn.modules['pupydroid.utils'].getAndroidID(), client.desc['user'])) DCNL DCSP if (not os.path.exists(localPath)): DCNL DCSP  DCSP logging.info('Creating DCSP {0} DCSP folder DCSP locally'.format(localPath)) DCNL DCSP  DCSP os.makedirs(localPath) DCNL DCSP return localPath
 DCSP parser = ArgumentParser(description=CMDLINE_HELP) DCNL DCSP parser.add_argument('--noserver', action='store_true', dest='noserver', default=False, help='Do DCSP not DCSP start DCSP Server DCSP process') DCNL DCSP parser.add_argument('--noportal', action='store_true', dest='noportal', default=False, help='Do DCSP not DCSP start DCSP Portal DCSP process') DCNL DCSP parser.add_argument('--logserver', action='store_true', dest='logserver', default=False, help='Log DCSP Server DCSP output DCSP to DCSP logfile') DCNL DCSP parser.add_argument('--iserver', action='store_true', dest='iserver', default=False, help='Server DCSP in DCSP interactive DCSP mode') DCNL DCSP parser.add_argument('--iportal', action='store_true', dest='iportal', default=False, help='Portal DCSP in DCSP interactive DCSP mode') DCNL DCSP parser.add_argument('--pserver', action='store_true', dest='pserver', default=False, help='Profile DCSP Server') DCNL DCSP parser.add_argument('--pportal', action='store_true', dest='pportal', default=False, help='Profile DCSP Portal') DCNL DCSP parser.add_argument('--nologcycle', action='store_false', dest='nologcycle', default=True, help='Do DCSP not DCSP cycle DCSP log DCSP files') DCNL DCSP parser.add_argument('--doexit', action='store_true', dest='doexit', default=False, help='Immediately DCSP exit DCSP after DCSP processes DCSP have DCSP started.') DCNL DCSP parser.add_argument('gamedir', help='path DCSP to DCSP game DCSP dir') DCNL DCSP parser.add_argument('twistdbinary', help='path DCSP to DCSP twistd DCSP binary') DCNL DCSP parser.add_argument('slogfile', help='path DCSP to DCSP server DCSP log DCSP file') DCNL DCSP parser.add_argument('plogfile', help='path DCSP to DCSP portal DCSP log DCSP file') DCNL DCSP parser.add_argument('hlogfile', help='path DCSP to DCSP http DCSP log DCSP file') DCNL DCSP args = parser.parse_args() DCNL DCSP global GAMEDIR DCNL DCSP global SERVER_LOGFILE, PORTAL_LOGFILE, HTTP_LOGFILE DCNL DCSP global SERVER_PIDFILE, PORTAL_PIDFILE DCNL DCSP global SERVER_RESTART, PORTAL_RESTART DCNL DCSP global SPROFILER_LOGFILE, PPROFILER_LOGFILE DCNL DCSP GAMEDIR = args.gamedir DCNL DCSP sys.path.insert(1, os.path.join(GAMEDIR, SERVERDIR)) DCNL DCSP SERVER_PIDFILE = os.path.join(GAMEDIR, SERVERDIR, 'server.pid') DCNL DCSP PORTAL_PIDFILE = os.path.join(GAMEDIR, SERVERDIR, 'portal.pid') DCNL DCSP SERVER_RESTART = os.path.join(GAMEDIR, SERVERDIR, 'server.restart') DCNL DCSP PORTAL_RESTART = os.path.join(GAMEDIR, SERVERDIR, 'portal.restart') DCNL DCSP SERVER_LOGFILE = args.slogfile DCNL DCSP PORTAL_LOGFILE = args.plogfile DCNL DCSP HTTP_LOGFILE = args.hlogfile DCNL DCSP TWISTED_BINARY = args.twistdbinary DCNL DCSP SPROFILER_LOGFILE = os.path.join(GAMEDIR, SERVERDIR, 'logs', 'server.prof') DCNL DCSP PPROFILER_LOGFILE = os.path.join(GAMEDIR, SERVERDIR, 'logs', 'portal.prof') DCNL DCSP server_argv = [TWISTED_BINARY, '--nodaemon', ('--logfile=%s' % SERVER_LOGFILE), ('--pidfile=%s' % SERVER_PIDFILE), ('--python=%s' % SERVER_PY_FILE)] DCNL DCSP portal_argv = [TWISTED_BINARY, ('--logfile=%s' % PORTAL_LOGFILE), ('--pidfile=%s' % PORTAL_PIDFILE), ('--python=%s' % PORTAL_PY_FILE)] DCNL DCSP pserver_argv = ['--savestats', '--profiler=cprofile', ('--profile=%s' % SPROFILER_LOGFILE)] DCNL DCSP pportal_argv = ['--savestats', '--profiler=cprofile', ('--profile=%s' % PPROFILER_LOGFILE)] DCNL DCSP pid = get_pid(SERVER_PIDFILE) DCNL DCSP if (pid and (not args.noserver)): DCNL DCSP  DCSP print(('\nEvennia DCSP Server DCSP is DCSP already DCSP running DCSP as DCSP process DCSP %(pid)s. DCSP Not DCSP restarted.' % {'pid': pid})) DCNL DCSP  DCSP args.noserver = True DCNL DCSP if args.noserver: DCNL DCSP  DCSP server_argv = None DCNL DCSP else: DCNL DCSP  DCSP set_restart_mode(SERVER_RESTART, 'shutdown') DCNL DCSP  DCSP if (not args.logserver): DCNL DCSP  DCSP  DCSP del server_argv[2] DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Server DCSP (output DCSP to DCSP stdout).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not args.nologcycle): DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(SERVER_LOGFILE) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Server DCSP (output DCSP to DCSP server DCSP logfile).') DCNL DCSP  DCSP if args.pserver: DCNL DCSP  DCSP  DCSP server_argv.extend(pserver_argv) DCNL DCSP  DCSP  DCSP print('\nRunning DCSP Evennia DCSP Server DCSP under DCSP cProfile.') DCNL DCSP pid = get_pid(PORTAL_PIDFILE) DCNL DCSP if (pid and (not args.noportal)): DCNL DCSP  DCSP print(('\nEvennia DCSP Portal DCSP is DCSP already DCSP running DCSP as DCSP process DCSP %(pid)s. DCSP Not DCSP restarted.' % {'pid': pid})) DCNL DCSP  DCSP args.noportal = True DCNL DCSP if args.noportal: DCNL DCSP  DCSP portal_argv = None DCNL DCSP else: DCNL DCSP  DCSP if args.iportal: DCNL DCSP  DCSP  DCSP portal_argv[1] = '--nodaemon' DCNL DCSP  DCSP  DCSP set_restart_mode(PORTAL_RESTART, True) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Portal DCSP in DCSP non-Daemon DCSP mode DCSP (output DCSP to DCSP stdout).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not args.nologcycle): DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(PORTAL_LOGFILE) DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(HTTP_LOGFILE) DCNL DCSP  DCSP  DCSP set_restart_mode(PORTAL_RESTART, False) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Portal DCSP in DCSP Daemon DCSP mode DCSP (output DCSP to DCSP portal DCSP logfile).') DCNL DCSP  DCSP if args.pportal: DCNL DCSP  DCSP  DCSP portal_argv.extend(pportal_argv) DCNL DCSP  DCSP  DCSP print('\nRunning DCSP Evennia DCSP Portal DCSP under DCSP cProfile.') DCNL DCSP if args.doexit: DCNL DCSP  DCSP print(PROCESS_DOEXIT) DCNL DCSP if (os.name == 'nt'): DCNL DCSP  DCSP if server_argv: DCNL DCSP  DCSP  DCSP del server_argv[(-2)] DCNL DCSP  DCSP if portal_argv: DCNL DCSP  DCSP  DCSP del portal_argv[(-2)] DCNL DCSP start_services(server_argv, portal_argv, doexit=args.doexit)
 DCSP try: DCNL DCSP  DCSP return (a * b) DCNL DCSP except TypeError: DCNL DCSP  DCSP return (to_decimal(a) * to_decimal(b))
 DCSP def CheckDictionary(C): DCNL DCSP  DCSP C.newClassAttr = 'xyz' DCNL DCSP  DCSP AreEqual(C.newClassAttr, 'xyz') DCNL DCSP  DCSP a = C() DCNL DCSP  DCSP a.__dict__[1] = '1' DCNL DCSP  DCSP if (object in C.__bases__): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP C.__dict__[2] = '2' DCNL DCSP  DCSP  DCSP  DCSP AssertUnreachable() DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP AreEqual(C.__dict__.has_key(2), False) DCNL DCSP  DCSP AreEqual(a.__dict__.has_key(1), True) DCNL DCSP  DCSP AreEqual(dir(a).__contains__(1), True) DCNL DCSP  DCSP AreEqual(repr(a.__dict__), "{1: DCSP '1'}") DCNL DCSP  DCSP C.newTypeAttr = 1 DCNL DCSP  DCSP AreEqual(hasattr(C, 'newTypeAttr'), True) DCNL DCSP  DCSP class OldClass: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if isinstance(C, type(OldClass)): DCNL DCSP  DCSP  DCSP C.__dict__ = dict(C.__dict__) DCNL DCSP  DCSP  DCSP AreEqual(hasattr(C, 'newTypeAttr'), True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP C.__dict__ = {} DCNL DCSP  DCSP  DCSP  DCSP AssertUnreachable() DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP a.newInstanceAttr = 1 DCNL DCSP  DCSP AreEqual(hasattr(a, 'newInstanceAttr'), True) DCNL DCSP  DCSP a.__dict__ = dict(a.__dict__) DCNL DCSP  DCSP AreEqual(hasattr(a, 'newInstanceAttr'), True) DCNL DCSP  DCSP a.abc = 'xyz' DCNL DCSP  DCSP AreEqual(hasattr(a, 'abc'), True) DCNL DCSP  DCSP AreEqual(getattr(a, 'abc'), 'xyz') DCNL DCSP class OldClass: DCNL DCSP  DCSP def __init__(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP class NewClass(object, ): DCNL DCSP  DCSP def __init__(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP CheckDictionary(OldClass) DCNL DCSP CheckDictionary(NewClass)
 DCSP class GenericRelatedObjectManager(superclass, ): DCNL DCSP  DCSP def __init__(self, model=None, instance=None, symmetrical=None, source_col_name=None, target_col_name=None, content_type=None, content_type_field_name=None, object_id_field_name=None, prefetch_cache_name=None): DCNL DCSP  DCSP  DCSP super(GenericRelatedObjectManager, self).__init__() DCNL DCSP  DCSP  DCSP self.model = model DCNL DCSP  DCSP  DCSP self.content_type = content_type DCNL DCSP  DCSP  DCSP self.symmetrical = symmetrical DCNL DCSP  DCSP  DCSP self.instance = instance DCNL DCSP  DCSP  DCSP self.source_col_name = source_col_name DCNL DCSP  DCSP  DCSP self.target_col_name = target_col_name DCNL DCSP  DCSP  DCSP self.content_type_field_name = content_type_field_name DCNL DCSP  DCSP  DCSP self.object_id_field_name = object_id_field_name DCNL DCSP  DCSP  DCSP self.prefetch_cache_name = prefetch_cache_name DCNL DCSP  DCSP  DCSP self.pk_val = self.instance._get_pk_val() DCNL DCSP  DCSP  DCSP self.core_filters = {(u'%s__pk' % content_type_field_name): content_type.id, (u'%s__exact' % object_id_field_name): instance._get_pk_val()} DCNL DCSP  DCSP def get_query_set(self): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return self.instance._prefetched_objects_cache[self.prefetch_cache_name] DCNL DCSP  DCSP  DCSP except (AttributeError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP db = (self._db or router.db_for_read(self.model, instance=self.instance)) DCNL DCSP  DCSP  DCSP  DCSP return super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**self.core_filters) DCNL DCSP  DCSP def get_prefetch_query_set(self, instances): DCNL DCSP  DCSP  DCSP db = (self._db or router.db_for_read(self.model, instance=instances[0])) DCNL DCSP  DCSP  DCSP query = {(u'%s__pk' % self.content_type_field_name): self.content_type.id, (u'%s__in' % self.object_id_field_name): set((obj._get_pk_val() for obj in instances))} DCNL DCSP  DCSP  DCSP qs = super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**query) DCNL DCSP  DCSP  DCSP object_id_converter = instances[0]._meta.pk.to_python DCNL DCSP  DCSP  DCSP return (qs, (lambda relobj: object_id_converter(getattr(relobj, self.object_id_field_name))), (lambda obj: obj._get_pk_val()), False, self.prefetch_cache_name) DCNL DCSP  DCSP def add(self, *objs): DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(obj, self.model)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError((u"'%s' DCSP instance DCSP expected" % self.model._meta.object_name)) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.content_type_field_name, self.content_type) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.object_id_field_name, self.pk_val) DCNL DCSP  DCSP  DCSP  DCSP obj.save() DCNL DCSP  DCSP add.alters_data = True DCNL DCSP  DCSP def remove(self, *objs): DCNL DCSP  DCSP  DCSP db = router.db_for_write(self.model, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP obj.delete(using=db) DCNL DCSP  DCSP remove.alters_data = True DCNL DCSP  DCSP def clear(self): DCNL DCSP  DCSP  DCSP db = router.db_for_write(self.model, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in self.all(): DCNL DCSP  DCSP  DCSP  DCSP obj.delete(using=db) DCNL DCSP  DCSP clear.alters_data = True DCNL DCSP  DCSP def create(self, **kwargs): DCNL DCSP  DCSP  DCSP kwargs[self.content_type_field_name] = self.content_type DCNL DCSP  DCSP  DCSP kwargs[self.object_id_field_name] = self.pk_val DCNL DCSP  DCSP  DCSP db = router.db_for_write(self.model, instance=self.instance) DCNL DCSP  DCSP  DCSP return super(GenericRelatedObjectManager, self).using(db).create(**kwargs) DCNL DCSP  DCSP create.alters_data = True DCNL DCSP return GenericRelatedObjectManager
 DCSP mi = MetaInformation(_('Unknown'), [_('Unknown')]) DCNL DCSP stream.seek(0) DCNL DCSP pml = '' DCNL DCSP if stream.name.endswith('.pmlz'): DCNL DCSP  DCSP with TemporaryDirectory('_unpmlz') as tdir: DCNL DCSP  DCSP  DCSP zf = ZipFile(stream) DCNL DCSP  DCSP  DCSP zf.extractall(tdir) DCNL DCSP  DCSP  DCSP pmls = glob.glob(os.path.join(tdir, '*.pml')) DCNL DCSP  DCSP  DCSP for p in pmls: DCNL DCSP  DCSP  DCSP  DCSP with open(p, 'r+b') as p_stream: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pml += p_stream.read() DCNL DCSP  DCSP  DCSP if extract_cover: DCNL DCSP  DCSP  DCSP  DCSP mi.cover_data = get_cover(os.path.splitext(os.path.basename(stream.name))[0], tdir, True) DCNL DCSP else: DCNL DCSP  DCSP pml = stream.read() DCNL DCSP  DCSP if extract_cover: DCNL DCSP  DCSP  DCSP mi.cover_data = get_cover(os.path.splitext(os.path.basename(stream.name))[0], os.path.abspath(os.path.dirname(stream.name))) DCNL DCSP for comment in re.findall('(?mus)\\\\v.*?\\\\v', pml): DCNL DCSP  DCSP m = re.search('TITLE="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.title = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('AUTHOR="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP if (mi.authors == [_('Unknown')]): DCNL DCSP  DCSP  DCSP  DCSP mi.authors = [] DCNL DCSP  DCSP  DCSP mi.authors.append(re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace')))) DCNL DCSP  DCSP m = re.search('PUBLISHER="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.publisher = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('COPYRIGHT="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.rights = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('ISBN="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.isbn = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().decode('cp1252', 'replace'))) DCNL DCSP return mi
 DCSP global readline_hook, readline_ref DCNL DCSP readline_hook = hook DCNL DCSP PyOS_RFP = c_int.from_address(Console.GetProcAddress(sys.dllhandle, 'PyOS_ReadlineFunctionPointer')) DCNL DCSP if (sys.version < '2.3'): DCNL DCSP  DCSP readline_ref = HOOKFUNC22(hook_wrapper) DCNL DCSP else: DCNL DCSP  DCSP readline_ref = HOOKFUNC23(hook_wrapper_23) DCNL DCSP func_start = c_int.from_address(addressof(readline_ref)).value DCNL DCSP PyOS_RFP.value = func_start
 DCSP cmdsuf = '' DCNL DCSP if (platform.system() == 'Windows'): DCNL DCSP  DCSP cmdsuf = '.bat' DCNL DCSP  DCSP cmd = ('@echo DCSP off\r\n' + cmd) DCNL DCSP (handle, path) = tempfile.mkstemp(text=True, dir=tmpdir, suffix=cmdsuf) DCNL DCSP os.write(handle, cmd.encode('utf-8')) DCNL DCSP os.close(handle) DCNL DCSP os.chmod(path, stat.S_IRWXU) DCNL DCSP proc = Popen(path, shell=True, stdout=PIPE, stderr=PIPE) DCNL DCSP proc.wait() DCNL DCSP (stdout, _) = proc.communicate() DCNL DCSP os.unlink(path) DCNL DCSP return _chomp(as_unicode(stdout))
 DCSP if (composer is not None): DCNL DCSP  DCSP if (php is None): DCNL DCSP  DCSP  DCSP php = 'php' DCNL DCSP else: DCNL DCSP  DCSP composer = 'composer' DCNL DCSP if (not _valid_composer(composer)): DCNL DCSP  DCSP raise CommandNotFoundError("'composer.{0}' DCSP is DCSP not DCSP available. DCSP Couldn't DCSP find DCSP '{1}'.".format(action, composer)) DCNL DCSP if (action is None): DCNL DCSP  DCSP raise SaltInvocationError("The DCSP 'action' DCSP argument DCSP is DCSP required") DCNL DCSP if ((directory is None) and (action != 'selfupdate')): DCNL DCSP  DCSP raise SaltInvocationError("The DCSP 'directory' DCSP argument DCSP is DCSP required DCSP for DCSP composer.{0}".format(action)) DCNL DCSP cmd = [composer, action, '--no-interaction', '--no-ansi'] DCNL DCSP if (extra_flags is not None): DCNL DCSP  DCSP cmd.extend(salt.utils.shlex_split(extra_flags)) DCNL DCSP if (php is not None): DCNL DCSP  DCSP cmd = ([php] + cmd) DCNL DCSP if (directory is not None): DCNL DCSP  DCSP cmd.extend(['--working-dir', directory]) DCNL DCSP if (quiet is True): DCNL DCSP  DCSP cmd.append('--quiet') DCNL DCSP if (no_dev is True): DCNL DCSP  DCSP cmd.append('--no-dev') DCNL DCSP if (prefer_source is True): DCNL DCSP  DCSP cmd.append('--prefer-source') DCNL DCSP if (prefer_dist is True): DCNL DCSP  DCSP cmd.append('--prefer-dist') DCNL DCSP if (no_scripts is True): DCNL DCSP  DCSP cmd.append('--no-scripts') DCNL DCSP if (no_plugins is True): DCNL DCSP  DCSP cmd.append('--no-plugins') DCNL DCSP if (optimize is True): DCNL DCSP  DCSP cmd.append('--optimize-autoloader') DCNL DCSP result = __salt__['cmd.run_all'](cmd, runas=runas, env={'COMPOSER_HOME': composer_home}, python_shell=False) DCNL DCSP if (result['retcode'] != 0): DCNL DCSP  DCSP raise CommandExecutionError(result['stderr']) DCNL DCSP if (quiet is True): DCNL DCSP  DCSP return True DCNL DCSP return result
 DCSP tags = set([tag for cond in conditions for tag in cond.split('/')]) DCNL DCSP msg = "Can't DCSP map DCSP between DCSP conditions DCSP and DCSP the DCSP provided DCSP {0}. DCSP Make DCSP sure DCSP you DCSP have DCSP provided DCSP keys DCSP in DCSP the DCSP format DCSP of DCSP '/'-separated DCSP tags, DCSP and DCSP that DCSP these DCSP correspond DCSP to DCSP '/'-separated DCSP tags DCSP for DCSP the DCSP condition DCSP names DCSP (e.g., DCSP conditions DCSP like DCSP 'Visual/Right', DCSP and DCSP styles DCSP like DCSP 'colors=dict(Visual='red'))'. DCSP The DCSP offending DCSP tag DCSP was DCSP '{1}'." DCNL DCSP for key in style_dict: DCNL DCSP  DCSP for tag in key.split('/'): DCNL DCSP  DCSP  DCSP if (tag not in tags): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(style, tag)) DCNL DCSP condition_warning = ('Condition DCSP {0} DCSP could DCSP not DCSP be DCSP mapped DCSP to DCSP a DCSP ' + style) DCNL DCSP style_warning = '. DCSP Using DCSP the DCSP default DCSP of DCSP {0}.'.format(default) DCNL DCSP for condition in conditions: DCNL DCSP  DCSP if (condition not in style_dict): DCNL DCSP  DCSP  DCSP if ('/' not in condition): DCNL DCSP  DCSP  DCSP  DCSP warn((condition_warning.format(condition) + style_warning)) DCNL DCSP  DCSP  DCSP  DCSP style_dict[condition] = default DCNL DCSP  DCSP  DCSP for style_ in style_dict: DCNL DCSP  DCSP  DCSP  DCSP if (style_ in condition.split('/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP style_dict[condition] = style_dict[style_] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return style_dict
 DCSP try: DCNL DCSP  DCSP json_data = json.loads(json_string) DCNL DCSP except: DCNL DCSP  DCSP raise SchemaParseException(('Error DCSP parsing DCSP JSON: DCSP %s' % json_string)) DCNL DCSP names = Names() DCNL DCSP return make_avsc_object(json_data, names)
 DCSP run_app = False DCNL DCSP if (hasattr(settings, 'LETTUCE_AVOID_APPS') and isinstance(settings.LETTUCE_AVOID_APPS, (list, tuple))): DCNL DCSP  DCSP for appname in settings.LETTUCE_AVOID_APPS: DCNL DCSP  DCSP  DCSP if module.__name__.startswith(appname): DCNL DCSP  DCSP  DCSP  DCSP run_app = True DCNL DCSP return (not run_app)
 DCSP labels = [] DCNL DCSP for hemi in set(hemis): DCNL DCSP  DCSP hemi_index = (hemis == hemi) DCNL DCSP  DCSP seeds = seeds_[hemi_index] DCNL DCSP  DCSP extents = extents_[hemi_index] DCNL DCSP  DCSP names = names_[hemi_index] DCNL DCSP  DCSP graph = graphs[hemi] DCNL DCSP  DCSP n_vertices = len(vertices_[hemi]) DCNL DCSP  DCSP n_labels = len(seeds) DCNL DCSP  DCSP parc = np.empty(n_vertices, dtype='int32') DCNL DCSP  DCSP parc[:] = (-1) DCNL DCSP  DCSP sources = {} DCNL DCSP  DCSP edge = [] DCNL DCSP  DCSP for (label, seed) in enumerate(seeds): DCNL DCSP  DCSP  DCSP if np.any((parc[seed] >= 0)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Overlapping DCSP seeds') DCNL DCSP  DCSP  DCSP parc[seed] = label DCNL DCSP  DCSP  DCSP for s in np.atleast_1d(seed): DCNL DCSP  DCSP  DCSP  DCSP sources[s] = (label, 0.0) DCNL DCSP  DCSP  DCSP  DCSP edge.append(s) DCNL DCSP  DCSP while edge: DCNL DCSP  DCSP  DCSP vert_from = edge.pop(0) DCNL DCSP  DCSP  DCSP (label, old_dist) = sources[vert_from] DCNL DCSP  DCSP  DCSP row = graph[vert_from, :] DCNL DCSP  DCSP  DCSP for (vert_to, dist) in zip(row.indices, row.data): DCNL DCSP  DCSP  DCSP  DCSP new_dist = (old_dist + dist) DCNL DCSP  DCSP  DCSP  DCSP if (new_dist > extents[label]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP vert_to_label = parc[vert_to] DCNL DCSP  DCSP  DCSP  DCSP if (vert_to_label >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (_, vert_to_dist) = sources[vert_to] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (new_dist > vert_to_dist): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (vert_to in edge): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP edge.remove(vert_to) DCNL DCSP  DCSP  DCSP  DCSP parc[vert_to] = label DCNL DCSP  DCSP  DCSP  DCSP sources[vert_to] = (label, new_dist) DCNL DCSP  DCSP  DCSP  DCSP edge.append(vert_to) DCNL DCSP  DCSP for i in xrange(n_labels): DCNL DCSP  DCSP  DCSP vertices = np.nonzero((parc == i))[0] DCNL DCSP  DCSP  DCSP name = str(names[i]) DCNL DCSP  DCSP  DCSP label_ = Label(vertices, hemi=hemi, name=name, subject=subject) DCNL DCSP  DCSP  DCSP labels.append(label_) DCNL DCSP return labels
 DCSP result = [] DCNL DCSP num_tests = 0 DCNL DCSP for (g1_idx, (g1_label, g1_dist)) in enumerate(zip(labels[:(-1)], dists[:(-1)])): DCNL DCSP  DCSP for (g2_label, g2_dist) in zip(labels[(g1_idx + 1):], dists[(g1_idx + 1):]): DCNL DCSP  DCSP  DCSP if (((len(g1_dist) == 1) and (len(g2_dist) == 1)) or ((len(g1_dist) < 1) or (len(g2_dist) < 1))): DCNL DCSP  DCSP  DCSP  DCSP (obs_t, param_p_val, nonparam_p_val) = (nan, nan, nan) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (obs_t, param_p_val, _, nonparam_p_val) = mc_t_two_sample(g1_dist, g2_dist, tails=tail_type, permutations=num_permutations) DCNL DCSP  DCSP  DCSP result.append([g1_label, g2_label, obs_t, param_p_val, None, nonparam_p_val, None]) DCNL DCSP  DCSP  DCSP if (not isnan(obs_t)): DCNL DCSP  DCSP  DCSP  DCSP num_tests += 1 DCNL DCSP for stat in result: DCNL DCSP  DCSP corr_param_p_val = stat[3] DCNL DCSP  DCSP if ((corr_param_p_val is not None) and (not isnan(corr_param_p_val))): DCNL DCSP  DCSP  DCSP corr_param_p_val = min((corr_param_p_val * num_tests), 1) DCNL DCSP  DCSP stat[4] = corr_param_p_val DCNL DCSP  DCSP corr_nonparam_p_val = stat[5] DCNL DCSP  DCSP if ((corr_nonparam_p_val is not None) and (not isnan(corr_nonparam_p_val))): DCNL DCSP  DCSP  DCSP corr_nonparam_p_val = min((corr_nonparam_p_val * num_tests), 1) DCNL DCSP  DCSP stat[6] = corr_nonparam_p_val DCNL DCSP return result
 DCSP req = servers_service_pb.GetNumInstancesRequest() DCNL DCSP if server: DCNL DCSP  DCSP req.set_server(server) DCNL DCSP if version: DCNL DCSP  DCSP req.set_version(version) DCNL DCSP resp = servers_service_pb.GetNumInstancesResponse() DCNL DCSP try: DCNL DCSP  DCSP apiproxy_stub_map.MakeSyncCall('servers', 'GetNumInstances', req, resp) DCNL DCSP except apiproxy_errors.ApplicationError as e: DCNL DCSP  DCSP if (e.application_error == servers_service_pb.ServersServiceError.INVALID_VERSION): DCNL DCSP  DCSP  DCSP raise InvalidVersionError() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Error() DCNL DCSP return resp.instances()
 DCSP if key: DCNL DCSP  DCSP ret = __pillar__.get(key, {}) DCNL DCSP else: DCNL DCSP  DCSP ret = __pillar__ DCNL DCSP return ret
 DCSP if (strings_only and isinstance(s, (types.NoneType, int))): DCNL DCSP  DCSP return s DCNL DCSP if (not isinstance(s, basestring)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return str(s) DCNL DCSP  DCSP except UnicodeEncodeError: DCNL DCSP  DCSP  DCSP if isinstance(s, Exception): DCNL DCSP  DCSP  DCSP  DCSP return ' DCSP '.join([smart_str(arg, encoding, strings_only, errors) for arg in s]) DCNL DCSP  DCSP  DCSP return unicode(s).encode(encoding, errors) DCNL DCSP elif isinstance(s, unicode): DCNL DCSP  DCSP return s.encode(encoding, errors) DCNL DCSP elif (s and (encoding != 'utf-8')): DCNL DCSP  DCSP return s.decode('utf-8', errors).encode(encoding, errors) DCNL DCSP else: DCNL DCSP  DCSP return s
 DCSP return force_unicode(formats.localize(value, use_l10n=True))
 DCSP pass
 DCSP _test_functionality('gl2')
 DCSP if (results and results['response'] and results['response']['docs']): DCNL DCSP  DCSP search_data = results['response']['docs'] DCNL DCSP  DCSP if collection['template']['fieldsSelected']: DCNL DCSP  DCSP  DCSP headers = collection['template']['fieldsSelected'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP headers = [field['name'] for field in collection['fields']] DCNL DCSP  DCSP rows = [] DCNL DCSP  DCSP for data in search_data: DCNL DCSP  DCSP  DCSP row = [] DCNL DCSP  DCSP  DCSP for column in headers: DCNL DCSP  DCSP  DCSP  DCSP if (column not in data): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.append('') DCNL DCSP  DCSP  DCSP  DCSP elif (isinstance(data[column], basestring) or isinstance(data[column], (int, long, float, complex))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.append(data[column]) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(data[column], list): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.append([smart_str(val, errors='replace') for val in data[column]]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.append(smart_str(data[column])) DCNL DCSP  DCSP  DCSP rows.append(row) DCNL DCSP else: DCNL DCSP  DCSP rows = [[]] DCNL DCSP (yield (headers, rows))
 DCSP if (not len(args)): DCNL DCSP  DCSP ax = gca() DCNL DCSP else: DCNL DCSP  DCSP ax = args[0] DCNL DCSP ret = gcf().delaxes(ax) DCNL DCSP return ret
 DCSP return IMPL.volume_get_all_by_group(context, group_id, filters=filters)
 DCSP if (not salt.utils.is_darwin()): DCNL DCSP  DCSP return (False, 'The DCSP mac_system DCSP module DCSP could DCSP not DCSP be DCSP loaded: DCSP module DCSP only DCSP works DCSP on DCSP MacOS DCSP systems.') DCNL DCSP if (not _atrun_enabled()): DCNL DCSP  DCSP if (not _enable_atrun()): DCNL DCSP  DCSP  DCSP return (False, 'atrun DCSP could DCSP not DCSP be DCSP enabled DCSP on DCSP this DCSP system') DCNL DCSP return __virtualname__
 DCSP tf = tornado.concurrent.Future() DCNL DCSP tornado.concurrent.chain_future(asyncio_future, tf) DCNL DCSP return tf
 DCSP if (s.count('"') % 2): DCNL DCSP  DCSP return '"' DCNL DCSP elif (s.count("'") % 2): DCNL DCSP  DCSP return "'" DCNL DCSP else: DCNL DCSP  DCSP return False
 DCSP zip_file = tempfile.NamedTemporaryFile(prefix='tmp_securedrop_bulk_dl_', dir=config.TEMP_DIR, delete=False) DCNL DCSP sources = set([i.source.journalist_designation for i in selected_submissions]) DCNL DCSP with zipfile.ZipFile(zip_file, 'w') as zip: DCNL DCSP  DCSP for source in sources: DCNL DCSP  DCSP  DCSP submissions = [s for s in selected_submissions if (s.source.journalist_designation == source)] DCNL DCSP  DCSP  DCSP for submission in submissions: DCNL DCSP  DCSP  DCSP  DCSP filename = path(submission.source.filesystem_id, submission.filename) DCNL DCSP  DCSP  DCSP  DCSP verify(filename) DCNL DCSP  DCSP  DCSP  DCSP document_number = submission.filename.split('-')[0] DCNL DCSP  DCSP  DCSP  DCSP zip.write(filename, arcname=os.path.join(zip_directory, source, ('%s_%s' % (document_number, submission.source.last_updated.date())), os.path.basename(filename))) DCNL DCSP return zip_file
 DCSP from ..feature import hessian_matrix, hessian_matrix_eigvals DCNL DCSP sigmas = np.arange(scale_range[0], scale_range[1], scale_step) DCNL DCSP if np.any((np.asarray(sigmas) < 0.0)): DCNL DCSP  DCSP raise ValueError('Sigma DCSP values DCSP less DCSP than DCSP zero DCSP are DCSP not DCSP valid') DCNL DCSP beta1 = (2 * (beta1 ** 2)) DCNL DCSP beta2 = (2 * (beta2 ** 2)) DCNL DCSP filtered_array = np.zeros((sigmas.shape + image.shape)) DCNL DCSP lambdas_array = np.zeros((sigmas.shape + image.shape)) DCNL DCSP for (i, sigma) in enumerate(sigmas): DCNL DCSP  DCSP (Drr, Drc, Dcc) = hessian_matrix(image, sigma, order='rc') DCNL DCSP  DCSP Drr = ((sigma ** 2) * Drr) DCNL DCSP  DCSP Drc = ((sigma ** 2) * Drc) DCNL DCSP  DCSP Dcc = ((sigma ** 2) * Dcc) DCNL DCSP  DCSP (lambda1, lambda2) = hessian_matrix_eigvals(Drr, Drc, Dcc) DCNL DCSP  DCSP lambda1[(lambda1 == 0)] = 1e-10 DCNL DCSP  DCSP rb = ((lambda2 / lambda1) ** 2) DCNL DCSP  DCSP s2 = ((lambda1 ** 2) + (lambda2 ** 2)) DCNL DCSP  DCSP filtered = (np.exp(((- rb) / beta1)) * (np.ones(np.shape(image)) - np.exp(((- s2) / beta2)))) DCNL DCSP  DCSP filtered_array[i] = filtered DCNL DCSP  DCSP lambdas_array[i] = lambda1 DCNL DCSP return (filtered_array, lambdas_array)
 DCSP cmd = ['netsh', 'interface', 'ip', 'set', 'dns', interface, 'source=dhcp'] DCNL DCSP return (__salt__['cmd.retcode'](cmd, python_shell=False) == 0)
 DCSP weight = _weight_function(G, weight) DCNL DCSP pred = {source: []} DCNL DCSP return (pred, _dijkstra(G, source, weight, pred=pred, cutoff=cutoff))
 DCSP if (jidstring in __internJIDs): DCNL DCSP  DCSP return __internJIDs[jidstring] DCNL DCSP else: DCNL DCSP  DCSP j = JID(jidstring) DCNL DCSP  DCSP __internJIDs[jidstring] = j DCNL DCSP  DCSP return j
 DCSP if exclude_system: DCNL DCSP  DCSP result = Role.query(system=False) DCNL DCSP else: DCNL DCSP  DCSP result = Role.get_all() DCNL DCSP return result
 DCSP ip = request.META.get('REMOTE_ADDR', '') DCNL DCSP ua = request.META.get('User-Agent', '') DCNL DCSP session_key = (request.session.session_key or '') DCNL DCSP return hashlib.sha1('-'.join(map(str, (ip, ua, session_key)))).hexdigest()
 DCSP X_sym = tensor.tensor4('X') DCNL DCSP pool_it = max_pool(X_sym, pool_shape=(2, 2), pool_stride=(2, 2), image_shape=(6, 4)) DCNL DCSP f = theano.function(inputs=[X_sym], outputs=pool_it) DCNL DCSP X = np.array([[2, 1, 3, 4], [1, 1, 3, 3], [5, 5, 7, 7], [5, 6, 8, 7], [9, 10, 11, 12], [9, 10, 12, 12]], dtype=theano.config.floatX)[np.newaxis, np.newaxis, ...] DCNL DCSP expected = np.array([[2, 4], [6, 8], [10, 12]], dtype=theano.config.floatX)[np.newaxis, np.newaxis, ...] DCNL DCSP actual = f(X) DCNL DCSP assert np.allclose(expected, actual)
 DCSP nn = 'rnd' DCNL DCSP allknn = AllKNN(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP assert_raises(ValueError, allknn.fit_sample, X, Y)
 DCSP return metadata_columns.union(viewvalues(columns))
 DCSP bits = token.split_contents() DCNL DCSP parsed = False DCNL DCSP if (len(bits) not in (2, 3)): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'ssi' DCSP tag DCSP takes DCSP one DCSP argument: DCSP the DCSP path DCSP to DCSP the DCSP file DCSP to DCSP be DCSP included") DCNL DCSP if (len(bits) == 3): DCNL DCSP  DCSP if (bits[2] == u'parsed'): DCNL DCSP  DCSP  DCSP parsed = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"Second DCSP (optional) DCSP argument DCSP to DCSP %s DCSP tag DCSP must DCSP be DCSP 'parsed'" % bits[0])) DCNL DCSP filepath = parser.compile_filter(bits[1]) DCNL DCSP return SsiNode(filepath, parsed)
 DCSP return os.path.normpath(os.path.normcase(os.path.realpath(path)))
 DCSP try: DCNL DCSP  DCSP f_mounts = open('/proc/mounts', 'r') DCNL DCSP except IOError as e: DCNL DCSP  DCSP utils.err(("error: DCSP can't DCSP open DCSP /proc/mounts: DCSP %s" % e)) DCNL DCSP  DCSP return 13 DCNL DCSP utils.drop_privileges() DCNL DCSP while True: DCNL DCSP  DCSP devices = [] DCNL DCSP  DCSP f_mounts.seek(0) DCNL DCSP  DCSP ts = int(time.time()) DCNL DCSP  DCSP for line in f_mounts: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (fs_spec, fs_file, fs_vfstype, fs_mntops, fs_freq, fs_passno) = line.split(None) DCNL DCSP  DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP  DCSP utils.err(("error: DCSP can't DCSP parse DCSP line DCSP at DCSP /proc/mounts: DCSP %s" % e)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (fs_spec == 'none'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((fs_vfstype in FSTYPE_IGNORE) or fs_vfstype.startswith('fuse.')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (fs_file.startswith('/dev') or fs_file.startswith('/sys') or fs_file.startswith('/proc') or fs_file.startswith('/lib') or fs_file.startswith('net:')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP device_found = False DCNL DCSP  DCSP  DCSP if fs_spec.startswith('/dev'): DCNL DCSP  DCSP  DCSP  DCSP for device in devices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (fs_spec == device[0]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP device_found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(fs_file) < len(device[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP device[1] = fs_file DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not device_found): DCNL DCSP  DCSP  DCSP  DCSP  DCSP devices.append([fs_spec, fs_file, fs_vfstype]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP devices.append([fs_spec, fs_file, fs_vfstype]) DCNL DCSP  DCSP for device in devices: DCNL DCSP  DCSP  DCSP (fs_spec, fs_file, fs_vfstype) = device DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP r = os.statvfs(fs_file) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP utils.err(("can't DCSP get DCSP info DCSP for DCSP mount DCSP point: DCSP %s: DCSP %s" % (fs_file, e))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP used = (r.f_blocks - r.f_bfree) DCNL DCSP  DCSP  DCSP if (r.f_blocks == 0): DCNL DCSP  DCSP  DCSP  DCSP percent_used = 100 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP percent_used = ((used * 100.0) / r.f_blocks) DCNL DCSP  DCSP  DCSP print ('df.bytes.total DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * r.f_blocks), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.bytes.used DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * used), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.bytes.percentused DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, percent_used, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.bytes.free DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * r.f_bfree), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP used = (r.f_files - r.f_ffree) DCNL DCSP  DCSP  DCSP if (r.f_files == 0): DCNL DCSP  DCSP  DCSP  DCSP percent_used = 100 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP percent_used = ((used * 100.0) / r.f_files) DCNL DCSP  DCSP  DCSP print ('df.inodes.total DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, r.f_files, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.inodes.used DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, used, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.inodes.percentused DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, percent_used, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('df.inodes.free DCSP %d DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, r.f_ffree, fs_file, fs_vfstype)) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP time.sleep(COLLECTION_INTERVAL)
 DCSP try: DCNL DCSP  DCSP key = dict_parameters.pop('key') DCNL DCSP except KeyError: DCNL DCSP  DCSP raise TypeError("Missing DCSP 'key' DCSP parameter") DCNL DCSP expect_byte_string(key) DCNL DCSP if (len(key) != key_size): DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP DES DCSP key DCSP length DCSP (%d DCSP bytes)' % len(key))) DCNL DCSP start_operation = _raw_des_lib.DES_start_operation DCNL DCSP stop_operation = _raw_des_lib.DES_stop_operation DCNL DCSP cipher = VoidPointer() DCNL DCSP result = start_operation(key, c_size_t(len(key)), cipher.address_of()) DCNL DCSP if result: DCNL DCSP  DCSP raise ValueError(('Error DCSP %X DCSP while DCSP instantiating DCSP the DCSP DES DCSP cipher' % result)) DCNL DCSP return SmartPointer(cipher.get(), stop_operation)
 DCSP if isinstance(node.op, Subtensor): DCNL DCSP  DCSP x = node.inputs[0] DCNL DCSP  DCSP if ((not x.owner) or (not isinstance(x.owner.op, IncSubtensor))): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not x.owner.op.set_instead_of_inc): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((x.owner.inputs[2:] == node.inputs[1:]) and (tuple(x.owner.op.idx_list) == tuple(node.op.idx_list))): DCNL DCSP  DCSP  DCSP out = node.outputs[0] DCNL DCSP  DCSP  DCSP y = x.owner.inputs[1] DCNL DCSP  DCSP  DCSP if (x.dtype != y.dtype): DCNL DCSP  DCSP  DCSP  DCSP y = y.astype(x.dtype) DCNL DCSP  DCSP  DCSP if (out.type == y.type): DCNL DCSP  DCSP  DCSP  DCSP return [y] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (out.broadcastable != y.broadcastable) DCNL DCSP  DCSP  DCSP  DCSP x_subtensor = node.op(x.owner.inputs[0], *x.owner.inputs[2:]) DCNL DCSP  DCSP  DCSP  DCSP return [T.alloc(y, *x_subtensor.shape)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return
 DCSP from jmxfetch import JMX_CHECKS DCNL DCSP agentConfig['checksd_hostname'] = hostname DCNL DCSP osname = get_os() DCNL DCSP checks_places = get_checks_places(osname, agentConfig) DCNL DCSP for config_path in _file_configs_paths(osname, agentConfig): DCNL DCSP  DCSP check_name = _conf_path_to_check_name(config_path) DCNL DCSP  DCSP if ((check_name == checkname) and (check_name not in JMX_CHECKS)): DCNL DCSP  DCSP  DCSP (conf_is_valid, check_config, invalid_check) = _load_file_config(config_path, check_name, agentConfig) DCNL DCSP  DCSP  DCSP if (invalid_check and (not conf_is_valid)): DCNL DCSP  DCSP  DCSP  DCSP return invalid_check DCNL DCSP  DCSP  DCSP (load_success, load_failure) = load_check_from_places(check_config, check_name, checks_places, agentConfig) DCNL DCSP  DCSP  DCSP return (load_success.values()[0] or load_failure) DCNL DCSP for (check_name, service_disco_check_config) in _service_disco_configs(agentConfig).iteritems(): DCNL DCSP  DCSP if (check_name == checkname): DCNL DCSP  DCSP  DCSP (sd_init_config, sd_instances) = service_disco_check_config[1] DCNL DCSP  DCSP  DCSP check_config = {'init_config': sd_init_config, 'instances': sd_instances} DCNL DCSP  DCSP  DCSP (load_success, load_failure) = load_check_from_places(check_config, check_name, checks_places, agentConfig) DCNL DCSP  DCSP  DCSP return (load_success.values()[0] or load_failure) DCNL DCSP return None
 DCSP if isinstance(import_name, unicode): DCNL DCSP  DCSP import_name = str(import_name) DCNL DCSP try: DCNL DCSP  DCSP if (':' in import_name): DCNL DCSP  DCSP  DCSP (module, obj) = import_name.split(':', 1) DCNL DCSP  DCSP elif ('.' in import_name): DCNL DCSP  DCSP  DCSP (module, obj) = import_name.rsplit('.', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return __import__(import_name) DCNL DCSP  DCSP if isinstance(obj, unicode): DCNL DCSP  DCSP  DCSP obj = obj.encode('utf-8') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(__import__(module, None, None, [obj]), obj) DCNL DCSP  DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP  DCSP modname = ((module + '.') + obj) DCNL DCSP  DCSP  DCSP __import__(modname) DCNL DCSP  DCSP  DCSP return sys.modules[modname] DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if (not silent): DCNL DCSP  DCSP  DCSP raise ImportStringError(import_name, e), None, sys.exc_info()[2]
 DCSP from frappe.desk.notifications import get_notification_info_for_boot, get_notifications DCNL DCSP from frappe.boot import get_bootinfo, get_unseen_notes DCNL DCSP from frappe.limits import get_limits, get_expiry_message DCNL DCSP bootinfo = None DCNL DCSP if (not getattr(frappe.conf, u'disable_session_cache', None)): DCNL DCSP  DCSP bootinfo = frappe.cache().hget(u'bootinfo', frappe.session.user) DCNL DCSP  DCSP if bootinfo: DCNL DCSP  DCSP  DCSP bootinfo[u'from_cache'] = 1 DCNL DCSP  DCSP  DCSP bootinfo[u'notification_info'].update(get_notifications()) DCNL DCSP  DCSP  DCSP bootinfo[u'user'][u'recent'] = json.dumps(frappe.cache().hget(u'user_recent', frappe.session.user)) DCNL DCSP if (not bootinfo): DCNL DCSP  DCSP bootinfo = get_bootinfo() DCNL DCSP  DCSP bootinfo[u'notification_info'] = get_notification_info_for_boot() DCNL DCSP  DCSP frappe.cache().hset(u'bootinfo', frappe.session.user, bootinfo) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP frappe.cache().ping() DCNL DCSP  DCSP except redis.exceptions.ConnectionError: DCNL DCSP  DCSP  DCSP message = _(u'Redis DCSP cache DCSP server DCSP not DCSP running. DCSP Please DCSP contact DCSP Administrator DCSP / DCSP Tech DCSP support') DCNL DCSP  DCSP  DCSP if (u'messages' in bootinfo): DCNL DCSP  DCSP  DCSP  DCSP bootinfo[u'messages'].append(message) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bootinfo[u'messages'] = [message] DCNL DCSP  DCSP if frappe.local.request: DCNL DCSP  DCSP  DCSP bootinfo[u'change_log'] = get_change_log() DCNL DCSP bootinfo[u'metadata_version'] = frappe.cache().get_value(u'metadata_version') DCNL DCSP if (not bootinfo[u'metadata_version']): DCNL DCSP  DCSP bootinfo[u'metadata_version'] = frappe.reset_metadata_version() DCNL DCSP bootinfo.notes = get_unseen_notes() DCNL DCSP for hook in frappe.get_hooks(u'extend_bootinfo'): DCNL DCSP  DCSP frappe.get_attr(hook)(bootinfo=bootinfo) DCNL DCSP bootinfo[u'lang'] = frappe.translate.get_user_lang() DCNL DCSP bootinfo[u'disable_async'] = frappe.conf.disable_async DCNL DCSP bootinfo.limits = get_limits() DCNL DCSP bootinfo.expiry_message = get_expiry_message() DCNL DCSP return bootinfo
 DCSP return cmp(_spat.sub('', x), _spat.sub('', y))
 DCSP try: DCNL DCSP  DCSP return len(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
 DCSP ev = _state.event_loop DCNL DCSP if ((not os.getenv(_EVENT_LOOP_KEY)) and (ev is not None)): DCNL DCSP  DCSP ev.clear() DCNL DCSP  DCSP _state.event_loop = None DCNL DCSP  DCSP ev = None DCNL DCSP if (ev is None): DCNL DCSP  DCSP ev = EventLoop() DCNL DCSP  DCSP _state.event_loop = ev DCNL DCSP  DCSP os.environ[_EVENT_LOOP_KEY] = '1' DCNL DCSP return ev
 DCSP if SPECIAL.match(name): DCNL DCSP  DCSP visibility = 'special' DCNL DCSP elif PRIVATE.match(name): DCNL DCSP  DCSP visibility = 'private' DCNL DCSP elif PROTECTED.match(name): DCNL DCSP  DCSP visibility = 'protected' DCNL DCSP else: DCNL DCSP  DCSP visibility = 'public' DCNL DCSP return visibility
 DCSP elements = string.split(None, 2) DCNL DCSP if (len(elements) != 3): DCNL DCSP  DCSP raise InvalidEntry() DCNL DCSP (hostnames, keyType, keyAndComment) = elements DCNL DCSP splitkey = keyAndComment.split(None, 1) DCNL DCSP if (len(splitkey) == 2): DCNL DCSP  DCSP (keyString, comment) = splitkey DCNL DCSP  DCSP comment = comment.rstrip('\n') DCNL DCSP else: DCNL DCSP  DCSP keyString = splitkey[0] DCNL DCSP  DCSP comment = None DCNL DCSP key = Key.fromString(keyString.decode('base64')) DCNL DCSP return (hostnames, keyType, key, comment)
 DCSP rngs = [make_np_rng(rng_or_seed=42, which_method='uniform'), make_np_rng(rng_or_seed=numpy.random.RandomState(42), which_method='uniform'), make_np_rng(default_seed=42), make_np_rng()] DCNL DCSP random_numbers = rngs[0].uniform(size=(100,)) DCNL DCSP equals = numpy.ones((100,)) DCNL DCSP for rng in rngs[1:]: DCNL DCSP  DCSP equal = (random_numbers == rng.uniform(size=(100,))) DCNL DCSP  DCSP equals *= equal DCNL DCSP assert equals.all()
 DCSP sequence = sequence.upper() DCNL DCSP amino_acids = [] DCNL DCSP forward_table = table.forward_table DCNL DCSP stop_codons = table.stop_codons DCNL DCSP if (table.nucleotide_alphabet.letters is not None): DCNL DCSP  DCSP valid_letters = set(table.nucleotide_alphabet.letters.upper()) DCNL DCSP else: DCNL DCSP  DCSP valid_letters = set((IUPAC.ambiguous_dna.letters.upper() + IUPAC.ambiguous_rna.letters.upper())) DCNL DCSP n = len(sequence) DCNL DCSP if cds: DCNL DCSP  DCSP if (str(sequence[:3]).upper() not in table.start_codons): DCNL DCSP  DCSP  DCSP raise CodonTable.TranslationError("First DCSP codon DCSP '{0}' DCSP is DCSP not DCSP a DCSP start DCSP codon".format(sequence[:3])) DCNL DCSP  DCSP if ((n % 3) != 0): DCNL DCSP  DCSP  DCSP raise CodonTable.TranslationError('Sequence DCSP length DCSP {0} DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP three'.format(n)) DCNL DCSP  DCSP if (str(sequence[(-3):]).upper() not in stop_codons): DCNL DCSP  DCSP  DCSP raise CodonTable.TranslationError("Final DCSP codon DCSP '{0}' DCSP is DCSP not DCSP a DCSP stop DCSP codon".format(sequence[(-3):])) DCNL DCSP  DCSP sequence = sequence[3:(-3)] DCNL DCSP  DCSP n -= 6 DCNL DCSP  DCSP amino_acids = ['M'] DCNL DCSP elif ((n % 3) != 0): DCNL DCSP  DCSP warnings.warn('Partial DCSP codon, DCSP len(sequence) DCSP not DCSP a DCSP multiple DCSP of DCSP three. DCSP Explicitly DCSP trim DCSP the DCSP sequence DCSP or DCSP add DCSP trailing DCSP N DCSP before DCSP translation. DCSP This DCSP may DCSP become DCSP an DCSP error DCSP in DCSP future.', BiopythonWarning) DCNL DCSP if (gap is not None): DCNL DCSP  DCSP if (not isinstance(gap, basestring)): DCNL DCSP  DCSP  DCSP raise TypeError('Gap DCSP character DCSP should DCSP be DCSP a DCSP single DCSP character DCSP string.') DCNL DCSP  DCSP elif (len(gap) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('Gap DCSP character DCSP should DCSP be DCSP a DCSP single DCSP character DCSP string.') DCNL DCSP for i in range(0, (n - (n % 3)), 3): DCNL DCSP  DCSP codon = sequence[i:(i + 3)] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP amino_acids.append(forward_table[codon]) DCNL DCSP  DCSP except (KeyError, CodonTable.TranslationError): DCNL DCSP  DCSP  DCSP if (codon in table.stop_codons): DCNL DCSP  DCSP  DCSP  DCSP if cds: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise CodonTable.TranslationError('Extra DCSP in DCSP frame DCSP stop DCSP codon DCSP found.') DCNL DCSP  DCSP  DCSP  DCSP if to_stop: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP amino_acids.append(stop_symbol) DCNL DCSP  DCSP  DCSP elif valid_letters.issuperset(set(codon)): DCNL DCSP  DCSP  DCSP  DCSP amino_acids.append(pos_stop) DCNL DCSP  DCSP  DCSP elif ((gap is not None) and (codon == (gap * 3))): DCNL DCSP  DCSP  DCSP  DCSP amino_acids.append(gap) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise CodonTable.TranslationError("Codon DCSP '{0}' DCSP is DCSP invalid".format(codon)) DCNL DCSP return ''.join(amino_acids)
 DCSP def track_time_change_decorator(action): DCNL DCSP  DCSP 'Decorator DCSP to DCSP track DCSP time DCSP changes.' DCNL DCSP  DCSP event.track_time_change(HASS, functools.partial(action, HASS), year, month, day, hour, minute, second) DCNL DCSP  DCSP return action DCNL DCSP return track_time_change_decorator
 DCSP return lz4f.compressFrame(payload)
 DCSP aliases = {u'lw': u'linewidth', u'ls': u'linestyle', u'c': u'color', u'fc': u'facecolor', u'ec': u'edgecolor', u'mew': u'markeredgewidth', u'aa': u'antialiased'} DCNL DCSP if is_string_like(group): DCNL DCSP  DCSP group = (group,) DCNL DCSP for g in group: DCNL DCSP  DCSP for (k, v) in six.iteritems(kwargs): DCNL DCSP  DCSP  DCSP name = (aliases.get(k) or k) DCNL DCSP  DCSP  DCSP key = (u'%s.%s' % (g, name)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rcParams[key] = v DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP raise KeyError((u'Unrecognized DCSP key DCSP "%s" DCSP for DCSP group DCSP "%s" DCSP and DCSP name DCSP "%s"' % (key, g, name)))
 DCSP def na_op(x, y): DCNL DCSP  DCSP if is_categorical_dtype(x): DCNL DCSP  DCSP  DCSP return op(x, y) DCNL DCSP  DCSP elif (is_categorical_dtype(y) and (not isscalar(y))): DCNL DCSP  DCSP  DCSP return op(y, x) DCNL DCSP  DCSP if is_object_dtype(x.dtype): DCNL DCSP  DCSP  DCSP result = _comp_method_OBJECT_ARRAY(op, x, y) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if is_datetimelike_v_numeric(x, y): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('invalid DCSP type DCSP comparison') DCNL DCSP  DCSP  DCSP if (isscalar(y) and isnull(y)): DCNL DCSP  DCSP  DCSP  DCSP if (name == '__ne__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return np.ones(len(x), dtype=bool) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return np.zeros(len(x), dtype=bool) DCNL DCSP  DCSP  DCSP mask = None DCNL DCSP  DCSP  DCSP if (needs_i8_conversion(x) or ((not isscalar(y)) and needs_i8_conversion(y))): DCNL DCSP  DCSP  DCSP  DCSP if isscalar(y): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mask = isnull(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = _index.convert_scalar(x, _values_from_object(y)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mask = (isnull(x) | isnull(y)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = y.view('i8') DCNL DCSP  DCSP  DCSP  DCSP x = x.view('i8') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = getattr(x, name)(y) DCNL DCSP  DCSP  DCSP  DCSP if (result is NotImplemented): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('invalid DCSP type DCSP comparison') DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP result = op(x, y) DCNL DCSP  DCSP  DCSP if ((mask is not None) and mask.any()): DCNL DCSP  DCSP  DCSP  DCSP result[mask] = masker DCNL DCSP  DCSP return result DCNL DCSP def wrapper(self, other, axis=None): DCNL DCSP  DCSP if (axis is not None): DCNL DCSP  DCSP  DCSP self._get_axis_number(axis) DCNL DCSP  DCSP if isinstance(other, ABCSeries): DCNL DCSP  DCSP  DCSP name = _maybe_match_name(self, other) DCNL DCSP  DCSP  DCSP if (not self._indexed_same(other)): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Can DCSP only DCSP compare DCSP identically-labeled DCSP Series DCSP objects' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP  DCSP return self._constructor(na_op(self.values, other.values), index=self.index, name=name) DCNL DCSP  DCSP elif isinstance(other, pd.DataFrame): DCNL DCSP  DCSP  DCSP return NotImplemented DCNL DCSP  DCSP elif isinstance(other, (np.ndarray, pd.Index)): DCNL DCSP  DCSP  DCSP if ((not lib.isscalar(lib.item_from_zerodim(other))) and (len(self) != len(other))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Lengths DCSP must DCSP match DCSP to DCSP compare') DCNL DCSP  DCSP  DCSP if isinstance(other, ABCPeriodIndex): DCNL DCSP  DCSP  DCSP  DCSP return self._constructor(na_op(self.values, other.asobject.values), index=self.index) DCNL DCSP  DCSP  DCSP return self._constructor(na_op(self.values, np.asarray(other)), index=self.index).__finalize__(self) DCNL DCSP  DCSP elif isinstance(other, pd.Categorical): DCNL DCSP  DCSP  DCSP if (not is_categorical_dtype(self)): DCNL DCSP  DCSP  DCSP  DCSP msg = "Cannot DCSP compare DCSP a DCSP Categorical DCSP for DCSP op DCSP {op} DCSP with DCSP Series DCSP of DCSP dtype DCSP {typ}.\nIf DCSP you DCSP want DCSP to DCSP compare DCSP values, DCSP use DCSP 'series DCSP <op> DCSP np.asarray(other)'." DCNL DCSP  DCSP  DCSP  DCSP raise TypeError(msg.format(op=op, typ=self.dtype)) DCNL DCSP  DCSP if is_categorical_dtype(self): DCNL DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP res = op(self.values, other) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP values = self.get_values() DCNL DCSP  DCSP  DCSP if isinstance(other, (list, np.ndarray)): DCNL DCSP  DCSP  DCSP  DCSP other = np.asarray(other) DCNL DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP res = na_op(values, other) DCNL DCSP  DCSP  DCSP if isscalar(res): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError(('Could DCSP not DCSP compare DCSP %s DCSP type DCSP with DCSP Series' % type(other))) DCNL DCSP  DCSP  DCSP res = _values_from_object(res) DCNL DCSP  DCSP res = pd.Series(res, index=self.index, name=self.name, dtype='bool') DCNL DCSP  DCSP return res DCNL DCSP return wrapper
 DCSP return serve(request, 'contribute.json', document_root=settings.ROOT)
 DCSP blueprints_path = app.config.get('BLUEPRINTS_PATH', 'modules') DCNL DCSP path = os.path.join(app.config.get('PROJECT_ROOT', '..'), blueprints_path) DCNL DCSP base_module_name = '.'.join([app.name, blueprints_path]) DCNL DCSP dir_list = os.listdir(path) DCNL DCSP mods = {} DCNL DCSP object_name = app.config.get('BLUEPRINTS_OBJECT_NAME', 'module') DCNL DCSP module_file = app.config.get('BLUEPRINTS_MODULE_NAME', 'main') DCNL DCSP blueprint_module = (module_file + '.py') DCNL DCSP for fname in dir_list: DCNL DCSP  DCSP if ((not os.path.exists(os.path.join(path, fname, 'DISABLED'))) and os.path.isdir(os.path.join(path, fname)) and os.path.exists(os.path.join(path, fname, blueprint_module))): DCNL DCSP  DCSP  DCSP module_root = '.'.join([base_module_name, fname]) DCNL DCSP  DCSP  DCSP module_name = '.'.join([module_root, module_file]) DCNL DCSP  DCSP  DCSP mods[fname] = importlib.import_module(module_name) DCNL DCSP  DCSP  DCSP blueprint = getattr(mods[fname], object_name) DCNL DCSP  DCSP  DCSP app.logger.info(('registering DCSP blueprint: DCSP %s' % blueprint.name)) DCNL DCSP  DCSP  DCSP app.register_blueprint(blueprint) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP importlib.import_module('.'.join([module_root, 'admin'])) DCNL DCSP  DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP  DCSP app.logger.info('%s DCSP module DCSP does DCSP not DCSP define DCSP admin DCSP or DCSP error: DCSP %s', fname, e) DCNL DCSP app.logger.info('%s DCSP modules DCSP loaded', mods.keys())
 DCSP (msg, key, A) = _prep(msg, key, symbols, bifid10) DCNL DCSP long_key = (''.join(uniq(key)) or A) DCNL DCSP n = (len(A) ** 0.5) DCNL DCSP if (n != int(n)): DCNL DCSP  DCSP raise ValueError(('Length DCSP of DCSP alphabet DCSP (%s) DCSP is DCSP not DCSP a DCSP square DCSP number.' % len(A))) DCNL DCSP N = int(n) DCNL DCSP if (len(long_key) < (N ** 2)): DCNL DCSP  DCSP long_key = (list(long_key) + [x for x in A if (x not in long_key)]) DCNL DCSP row_col = dict([(ch, divmod(i, N)) for (i, ch) in enumerate(long_key)]) DCNL DCSP (r, c) = zip(*[row_col[x] for x in msg]) DCNL DCSP rc = (r + c) DCNL DCSP ch = {i: ch for (ch, i) in row_col.items()} DCNL DCSP rv = ''.join((ch[i] for i in zip(rc[::2], rc[1::2]))) DCNL DCSP return rv
 DCSP from mayavi.core.ui.mayavi_scene import MayaviScene DCNL DCSP from tvtk.pyface.tvtk_scene import TVTKScene DCNL DCSP if (not isinstance(scene, (MayaviScene, TVTKScene))): DCNL DCSP  DCSP raise TypeError(('scene DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP TVTKScene/MayaviScene, DCSP found DCSP type DCSP %s' % type(scene))) DCNL DCSP (x, y) = tuple(scene.get_size()) DCNL DCSP view_to_disp_mat = np.array([[(x / 2.0), 0.0, 0.0, (x / 2.0)], [0.0, ((- y) / 2.0), 0.0, (y / 2.0)], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]) DCNL DCSP return view_to_disp_mat
 DCSP msg(colorize(('%s: DCSP %s' % (prefix, str(text))), 'cyan'))
 DCSP call_command('list_projects', '--modified-since=5') DCNL DCSP (out, err) = capfd.readouterr() DCNL DCSP assert ('project0' in out) DCNL DCSP assert ('project1' in out)
 DCSP def check_python_file(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return parser_cache[path].parser.module DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return check_fs(path) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP def check_fs(path): DCNL DCSP  DCSP with open(path, 'rb') as f: DCNL DCSP  DCSP  DCSP source = source_to_unicode(f.read()) DCNL DCSP  DCSP  DCSP if (name in source): DCNL DCSP  DCSP  DCSP  DCSP module_name = os.path.basename(path)[:(-3)] DCNL DCSP  DCSP  DCSP  DCSP module = _load_module(evaluator, path, source) DCNL DCSP  DCSP  DCSP  DCSP add_module(evaluator, module_name, module) DCNL DCSP  DCSP  DCSP  DCSP return module DCNL DCSP mods = set((m for m in mods if (not isinstance(m, compiled.CompiledObject)))) DCNL DCSP mod_paths = set() DCNL DCSP for m in mods: DCNL DCSP  DCSP mod_paths.add(m.path) DCNL DCSP  DCSP (yield m) DCNL DCSP if settings.dynamic_params_for_other_modules: DCNL DCSP  DCSP paths = set(settings.additional_dynamic_modules) DCNL DCSP  DCSP for p in mod_paths: DCNL DCSP  DCSP  DCSP if (p is not None): DCNL DCSP  DCSP  DCSP  DCSP d = os.path.dirname(os.path.abspath(p)) DCNL DCSP  DCSP  DCSP  DCSP for entry in os.listdir(d): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (entry not in mod_paths): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if entry.endswith('.py'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP paths.add(((d + os.path.sep) + entry)) DCNL DCSP  DCSP for p in sorted(paths): DCNL DCSP  DCSP  DCSP c = check_python_file(p) DCNL DCSP  DCSP  DCSP if ((c is not None) and (c not in mods) and (not isinstance(c, compiled.CompiledObject))): DCNL DCSP  DCSP  DCSP  DCSP (yield c)
 DCSP disk_dev = find_disk_dev_for_disk_bus(mapping, disk_bus, assigned_devices) DCNL DCSP info = {'bus': disk_bus, 'dev': disk_dev, 'type': device_type} DCNL DCSP if ((boot_index is not None) and (boot_index >= 0)): DCNL DCSP  DCSP info['boot_index'] = str(boot_index) DCNL DCSP return info
 DCSP res = [] DCNL DCSP for a in arys: DCNL DCSP  DCSP if (not isinstance(a, cupy.ndarray)): DCNL DCSP  DCSP  DCSP raise TypeError('Only DCSP cupy DCSP arrays DCSP can DCSP be DCSP atleast_2d') DCNL DCSP  DCSP if (a.ndim == 0): DCNL DCSP  DCSP  DCSP a = a.reshape(1, 1) DCNL DCSP  DCSP elif (a.ndim == 1): DCNL DCSP  DCSP  DCSP a = a[None, :] DCNL DCSP  DCSP res.append(a) DCNL DCSP if (len(res) == 1): DCNL DCSP  DCSP res = res[0] DCNL DCSP return res
 DCSP (year, month) = tm[:2] DCNL DCSP day = _DAYS[month] DCNL DCSP if ((day == 28) and ((year % 4) == 0)): DCNL DCSP  DCSP day = 29 DCNL DCSP return day
 DCSP def callback(lexer, match, context): DCNL DCSP  DCSP text = match.group() DCNL DCSP  DCSP context.block_scalar_indent = None DCNL DCSP  DCSP if (not text): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP increment = match.group(1) DCNL DCSP  DCSP if increment: DCNL DCSP  DCSP  DCSP current_indent = max(context.indent, 0) DCNL DCSP  DCSP  DCSP increment = int(increment) DCNL DCSP  DCSP  DCSP context.block_scalar_indent = (current_indent + increment) DCNL DCSP  DCSP if text: DCNL DCSP  DCSP  DCSP (yield (match.start(), TokenClass, text)) DCNL DCSP  DCSP  DCSP context.pos = match.end() DCNL DCSP return callback
 DCSP return model_query(context, models.VolumeUsage, read_deleted='yes').filter(or_((models.VolumeUsage.tot_last_refreshed == None), (models.VolumeUsage.tot_last_refreshed > begin), (models.VolumeUsage.curr_last_refreshed == None), (models.VolumeUsage.curr_last_refreshed > begin))).all()
 DCSP return keystoneclient(request, admin=True).roles.list()
 DCSP reg_cache = {} DCNL DCSP if cached: DCNL DCSP  DCSP reg_cache = cache.registry_cache() DCNL DCSP discovery = QtWidgetDiscovery(cached_descriptions=reg_cache) DCNL DCSP registry = QtWidgetRegistry() DCNL DCSP discovery.found_category.connect(registry.register_category) DCNL DCSP discovery.found_widget.connect(registry.register_widget) DCNL DCSP discovery.run() DCNL DCSP if cached: DCNL DCSP  DCSP cache.save_registry_cache(reg_cache) DCNL DCSP return registry
 DCSP if func.__closure__: DCNL DCSP  DCSP cells = [cell.cell_contents for cell in func.__closure__] DCNL DCSP else: DCNL DCSP  DCSP cells = None DCNL DCSP return (_reduce_code(func.__code__), globs, func.__name__, cells)
 DCSP return s.replace(old, new, maxsplit)
 DCSP options = RunOptions(top_level=top_level) DCNL DCSP configure_eliot_logging_for_acceptance() DCNL DCSP try: DCNL DCSP  DCSP options.parseOptions(args) DCNL DCSP except UsageError as e: DCNL DCSP  DCSP sys.stderr.write(('%s: DCSP %s\n' % (base_path.basename(), e))) DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP runner = options.runner DCNL DCSP def cluster_cleanup(): DCNL DCSP  DCSP print 'stopping DCSP cluster' DCNL DCSP  DCSP return runner.stop_cluster(reactor) DCNL DCSP cleanup_trigger_id = reactor.addSystemEventTrigger('before', 'shutdown', cluster_cleanup) DCNL DCSP from flocker.common.script import eliot_logging_service DCNL DCSP log_writer = eliot_logging_service(destination=FileDestination(file=open(('%s.log' % (base_path.basename(),)), 'a')), reactor=reactor, capture_stdout=False) DCNL DCSP log_writer.startService() DCNL DCSP reactor.addSystemEventTrigger('before', 'shutdown', log_writer.stopService) DCNL DCSP (yield runner.ensure_keys(reactor)) DCNL DCSP cluster = (yield runner.start_cluster(reactor)) DCNL DCSP save_managed_config(options['cert-directory'], options['config'], cluster) DCNL DCSP managed_config_file = options['cert-directory'].child('managed.yaml') DCNL DCSP managed_config = create_managed_config(options['config'], cluster) DCNL DCSP managed_config_file.setContent(yaml.safe_dump(managed_config, default_flow_style=False)) DCNL DCSP if (options['distribution'] in ('centos-7',)): DCNL DCSP  DCSP remote_logs_file = open('remote_logs.log', 'a') DCNL DCSP  DCSP for node in cluster.all_nodes: DCNL DCSP  DCSP  DCSP capture_journal(reactor, node.address, remote_logs_file).addErrback(write_failure) DCNL DCSP elif (options['distribution'] in ('ubuntu-14.04',)): DCNL DCSP  DCSP remote_logs_file = open('remote_logs.log', 'a') DCNL DCSP  DCSP for node in cluster.all_nodes: DCNL DCSP  DCSP  DCSP capture_upstart(reactor, node.address, remote_logs_file).addErrback(write_failure) DCNL DCSP flocker_client = make_client(reactor, cluster) DCNL DCSP (yield wait_for_nodes(reactor, flocker_client, len(cluster.agent_nodes))) DCNL DCSP if options['no-keep']: DCNL DCSP  DCSP print 'not DCSP keeping DCSP cluster' DCNL DCSP else: DCNL DCSP  DCSP save_environment(options['cert-directory'], cluster, options.package_source()) DCNL DCSP  DCSP reactor.removeSystemEventTrigger(cleanup_trigger_id)
 DCSP x = asarray(x) DCNL DCSP if iscomplexobj(x): DCNL DCSP  DCSP raise ValueError('x DCSP must DCSP be DCSP real.') DCNL DCSP if (N is None): DCNL DCSP  DCSP N = x.shape[axis] DCNL DCSP if (N <= 0): DCNL DCSP  DCSP raise ValueError('N DCSP must DCSP be DCSP positive.') DCNL DCSP Xf = fftpack.fft(x, N, axis=axis) DCNL DCSP h = zeros(N) DCNL DCSP if ((N % 2) == 0): DCNL DCSP  DCSP h[0] = h[(N // 2)] = 1 DCNL DCSP  DCSP h[1:(N // 2)] = 2 DCNL DCSP else: DCNL DCSP  DCSP h[0] = 1 DCNL DCSP  DCSP h[1:((N + 1) // 2)] = 2 DCNL DCSP if (x.ndim > 1): DCNL DCSP  DCSP ind = ([newaxis] * x.ndim) DCNL DCSP  DCSP ind[axis] = slice(None) DCNL DCSP  DCSP h = h[ind] DCNL DCSP x = fftpack.ifft((Xf * h), axis=axis) DCNL DCSP return x
 DCSP x = _cStringIO() DCNL DCSP x.write(val) DCNL DCSP x.seek(sek) DCNL DCSP return x
 DCSP import tornado.ioloop DCNL DCSP import tornado.web DCNL DCSP class MainHandler(tornado.web.RequestHandler, ): DCNL DCSP  DCSP def get(self): DCNL DCSP  DCSP  DCSP self.write('Hello, DCSP world') DCNL DCSP  DCSP  DCSP raise SystemExit() DCNL DCSP def runserver(): DCNL DCSP  DCSP application = tornado.web.Application([('/', MainHandler)]) DCNL DCSP  DCSP application.listen(8000) DCNL DCSP  DCSP tornado.ioloop.IOLoop.instance().start() DCNL DCSP server = multiprocessing.Process(target=runserver) DCNL DCSP server.start() DCNL DCSP time.sleep(1) DCNL DCSP e = 'Lettuce DCSP could DCSP not DCSP run DCSP the DCSP builtin DCSP Django DCSP server DCSP at DCSP 0.0.0.0:8000"\nmaybe DCSP you DCSP forgot DCSP a DCSP "runserver" DCSP instance DCSP running DCSP ?\n\nwell DCSP if DCSP you DCSP really DCSP do DCSP not DCSP want DCSP lettuce DCSP to DCSP run DCSP the DCSP server DCSP for DCSP you, DCSP then DCSP just DCSP run:\n\npython DCSP manage.py DCSP --no-server' DCNL DCSP try: DCNL DCSP  DCSP (status, out) = commands.getstatusoutput('python DCSP manage.py DCSP harvest DCSP --verbosity=3 DCSP --no-color') DCNL DCSP  DCSP assert_equals(out, e) DCNL DCSP  DCSP assert_not_equals(status, 0) DCNL DCSP finally: DCNL DCSP  DCSP os.kill(server.pid, 9)
 DCSP return soft_unicode(s).lower()
 DCSP value = value.lower() DCNL DCSP if (value[(-2):] == 'ib'): DCNL DCSP  DCSP suffix = value[(-3):].lower() DCNL DCSP else: DCNL DCSP  DCSP suffix = value[(-2):].lower() DCNL DCSP has_size_identifier = ((len(value) >= 2) and (suffix in SIZE_SUFFIX)) DCNL DCSP if (not has_size_identifier): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(value) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP size DCSP value: DCSP %s' % value)) DCNL DCSP else: DCNL DCSP  DCSP multiplier = SIZE_SUFFIX[suffix] DCNL DCSP  DCSP return (int(value[:(- len(suffix))]) * multiplier)
 DCSP @decorators.runs_once DCNL DCSP def mytask(): DCNL DCSP  DCSP print 'yolo' DCNL DCSP with settings(hide('everything'), parallel=True): DCNL DCSP  DCSP execute(mytask, hosts=['localhost', '127.0.0.1']) DCNL DCSP result = sys.stdout.getvalue() DCNL DCSP eq_(result, 'yolo\n') DCNL DCSP assert (result != 'yolo\nyolo\n')
 DCSP scenario_results = [r['scenario'] for r in results if (r['scenario'].get('metrics') and r['scenario']['metrics'].get('call_durations'))] DCNL DCSP if (len(scenario_results) > 0): DCNL DCSP  DCSP unique_metrics = [] DCNL DCSP  DCSP for result in scenario_results: DCNL DCSP  DCSP  DCSP if (result['metrics'] not in unique_metrics): DCNL DCSP  DCSP  DCSP  DCSP unique_metrics.append(result['metrics']) DCNL DCSP  DCSP total_requests = 0 DCNL DCSP  DCSP requests_under_limit = 0 DCNL DCSP  DCSP for metric in unique_metrics: DCNL DCSP  DCSP  DCSP for (duration, num_requests) in metric['call_durations'].iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if (float(duration) <= limit): DCNL DCSP  DCSP  DCSP  DCSP  DCSP requests_under_limit += num_requests DCNL DCSP  DCSP  DCSP total_requests += (metric['ok_count'] + metric['err_count']) DCNL DCSP  DCSP return (float(requests_under_limit) / total_requests) DCNL DCSP return None
 DCSP with check_jsonreport(u'missing_steps'): DCNL DCSP  DCSP runner = Runner(feature_name(u'missing_steps'), enable_jsonreport=True) DCNL DCSP  DCSP runner.run()
 DCSP return (isinstance(obj, slice) and (obj.start == 0) and (obj.stop == l) and (obj.step is None))
 DCSP return next(itertools.islice(seq, 1, None))
 DCSP import cProfile DCNL DCSP import uuid DCNL DCSP profiler = cProfile.Profile() DCNL DCSP profiler.enable() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP profiler.disable() DCNL DCSP  DCSP profiler.dump_stats('{0}_{1}_master.profile'.format(file_prefix, uuid.uuid4()))
 DCSP with builder.if_then(is_scalar_zero(builder, value), likely=False): DCNL DCSP  DCSP exc = exc_tuple[0] DCNL DCSP  DCSP exc_args = (exc_tuple[1:] or None) DCNL DCSP  DCSP context.call_conv.return_user_exc(builder, exc, exc_args)
 DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP C1 = get_numbered_constants(eq, num=1) DCNL DCSP r = match DCNL DCSP u = r.get('hint', f(x)) DCNL DCSP return Eq(Integral(((r['m2']['coeff'] * r['m2'][r['y']]) / r['m1'][r['y']]), (r['y'], None, u)), (Integral((((- r['m1']['coeff']) * r['m1'][x]) / r['m2'][x]), x) + C1))
 DCSP if (replica_set_name is None): DCNL DCSP  DCSP replica_set_name = server_description.replica_set_name DCNL DCSP elif (replica_set_name != server_description.replica_set_name): DCNL DCSP  DCSP sds.pop(server_description.address) DCNL DCSP  DCSP return (_check_has_primary(sds), replica_set_name, max_set_version, max_election_id) DCNL DCSP max_election_tuple = (max_set_version, max_election_id) DCNL DCSP if (None not in server_description.election_tuple): DCNL DCSP  DCSP if ((None not in max_election_tuple) and (max_election_tuple > server_description.election_tuple)): DCNL DCSP  DCSP  DCSP address = server_description.address DCNL DCSP  DCSP  DCSP sds[address] = ServerDescription(address) DCNL DCSP  DCSP  DCSP return (_check_has_primary(sds), replica_set_name, max_set_version, max_election_id) DCNL DCSP  DCSP max_election_id = server_description.election_id DCNL DCSP if ((server_description.set_version is not None) and ((max_set_version is None) or (server_description.set_version > max_set_version))): DCNL DCSP  DCSP max_set_version = server_description.set_version DCNL DCSP for server in sds.values(): DCNL DCSP  DCSP if ((server.server_type is SERVER_TYPE.RSPrimary) and (server.address != server_description.address)): DCNL DCSP  DCSP  DCSP sds[server.address] = ServerDescription(server.address) DCNL DCSP  DCSP  DCSP break DCNL DCSP for new_address in server_description.all_hosts: DCNL DCSP  DCSP if (new_address not in sds): DCNL DCSP  DCSP  DCSP sds[new_address] = ServerDescription(new_address) DCNL DCSP for addr in (set(sds) - server_description.all_hosts): DCNL DCSP  DCSP sds.pop(addr) DCNL DCSP return (_check_has_primary(sds), replica_set_name, max_set_version, max_election_id)
 DCSP iso639 = _load_iso639() DCNL DCSP translate = _ DCNL DCSP ans = {} DCNL DCSP names = set(names) DCNL DCSP for (k, v) in iso639['by_3t'].iteritems(): DCNL DCSP  DCSP tv = translate(v) DCNL DCSP  DCSP if (tv in names): DCNL DCSP  DCSP  DCSP names.remove(tv) DCNL DCSP  DCSP  DCSP ans[tv] = k DCNL DCSP  DCSP if (not names): DCNL DCSP  DCSP  DCSP break DCNL DCSP for x in names: DCNL DCSP  DCSP ans[x] = None DCNL DCSP return ans
 DCSP mark = request.node.get_marker(u'celery') DCNL DCSP config = dict(celery_config, **(mark.kwargs if mark else {})) DCNL DCSP with _create_app(request, enable_logging=celery_enable_logging, use_trap=use_celery_app_trap, parameters=celery_parameters, **config) as app: DCNL DCSP  DCSP (yield app)
 DCSP if sparse: DCNL DCSP  DCSP activeElementsInInput = set(input) DCNL DCSP  DCSP activeElementsInPrediction = set(prediction) DCNL DCSP else: DCNL DCSP  DCSP activeElementsInInput = set(input.nonzero()[0]) DCNL DCSP  DCSP activeElementsInPrediction = set(prediction.nonzero()[0]) DCNL DCSP totalActiveInPrediction = len(activeElementsInPrediction) DCNL DCSP totalActiveInInput = len(activeElementsInInput) DCNL DCSP foundInInput = len(activeElementsInPrediction.intersection(activeElementsInInput)) DCNL DCSP missingFromInput = len(activeElementsInPrediction.difference(activeElementsInInput)) DCNL DCSP missingFromPrediction = len(activeElementsInInput.difference(activeElementsInPrediction)) DCNL DCSP if (verbosity >= 1): DCNL DCSP  DCSP print 'preds. DCSP found DCSP in DCSP input:', foundInInput, 'out DCSP of', totalActiveInPrediction, DCNL DCSP  DCSP print '; DCSP preds. DCSP missing DCSP from DCSP input:', missingFromInput, 'out DCSP of', totalActiveInPrediction, DCNL DCSP  DCSP print '; DCSP unexpected DCSP active DCSP in DCSP input:', missingFromPrediction, 'out DCSP of', totalActiveInInput DCNL DCSP return (foundInInput, totalActiveInInput, missingFromInput, totalActiveInPrediction)
 DCSP for backend in auth.get_backends(): DCNL DCSP  DCSP if (not hasattr(backend, 'has_module_perms')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if backend.has_module_perms(user, app_label): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except PermissionDenied: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return False
 DCSP xml_declaration = kwargs.pop(u'xml_declaration', False) DCNL DCSP encoding = kwargs.pop(u'encoding', u'UTF-8') DCNL DCSP kwargs[u'encoding'] = unicode DCNL DCSP kwargs[u'xml_declaration'] = False DCNL DCSP ans = etree.tostring(raw, **kwargs) DCNL DCSP if xml_declaration: DCNL DCSP  DCSP ans = ((u'<?xml DCSP version="1.0" DCSP encoding="%s"?>\n' % encoding) + ans) DCNL DCSP return re.sub(u'&#x([0-9A-Fa-f]+);', (lambda m: mychr(int(m.group(1), 16))), ans).encode(encoding)
 DCSP def decode(m): DCNL DCSP  DCSP html = m.group(0) DCNL DCSP  DCSP if (html[:2] == u'&#'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (html[:3] == u'&#x'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return chr(int(html[3:(-1)], 16)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return chr(int(html[2:(-1)])) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP html = chr(name2codepoint[html[1:(-1)]]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return html DCNL DCSP return re.sub(u'&#?\\w+;', decode, html.replace(u'&amp;', u'&'))
 DCSP negative_chains.show_negative_chains('dbm.pkl')
 DCSP (defrag, frag) = urldefrag(url) DCNL DCSP if (not frag.startswith('!')): DCNL DCSP  DCSP return url DCNL DCSP return add_or_replace_parameter(defrag, '_escaped_fragment_', frag[1:])
 DCSP from .conf import settings as app_settings DCNL DCSP VERBOSE_LOOKUPS = (app_settings.VERBOSE_LOOKUPS or {}) DCNL DCSP lookups = [force_text(VERBOSE_LOOKUPS.get(lookup, _(lookup))) for lookup in lookup_expr.split(LOOKUP_SEP)] DCNL DCSP return ' DCSP '.join(lookups)
 DCSP errback = (errback or _ensure_errback) DCNL DCSP with pool.acquire(block=True) as conn: DCNL DCSP  DCSP conn.ensure_connection(errback=errback) DCNL DCSP  DCSP channel = conn.default_channel DCNL DCSP  DCSP revive = partial(revive_connection, conn, on_revive=on_revive) DCNL DCSP  DCSP insured = conn.autoretry(fun, channel, errback=errback, on_revive=revive, **opts) DCNL DCSP  DCSP (retval, _) = insured(*args, **dict(kwargs, connection=conn)) DCNL DCSP  DCSP return retval
 DCSP result = None DCNL DCSP f = open(filename, 'rb') DCNL DCSP try: DCNL DCSP  DCSP f.seek((- (LEN_IEND + LEN_DEPTH)), 2) DCNL DCSP  DCSP depthchunk = f.read(LEN_DEPTH) DCNL DCSP  DCSP if (not depthchunk.startswith((DEPTH_CHUNK_LEN + DEPTH_CHUNK_START))): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP result = struct.unpack('!i', depthchunk[14:18])[0] DCNL DCSP finally: DCNL DCSP  DCSP f.close() DCNL DCSP return result
 DCSP if (not isinstance(node, Function)): DCNL DCSP  DCSP return DCNL DCSP if (not node.parent): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP result = next(node.infer_call_result(node.parent)) DCNL DCSP except (StopIteration, InferenceError): DCNL DCSP  DCSP return DCNL DCSP if isinstance(result, Instance): DCNL DCSP  DCSP result = result._proxied DCNL DCSP if isinstance(result, Class): DCNL DCSP  DCSP if result.is_subtype_of(('%s.classmethod' % BUILTINS)): DCNL DCSP  DCSP  DCSP return 'classmethod' DCNL DCSP  DCSP if result.is_subtype_of(('%s.staticmethod' % BUILTINS)): DCNL DCSP  DCSP  DCSP return 'staticmethod'
 DCSP if (not DNS_AVAILABLE): DCNL DCSP  DCSP raise errors.DependencyError('{0} DCSP is DCSP required DCSP to DCSP use DCSP this DCSP function'.format(DNS_REQUIREMENT)) DCNL DCSP try: DCNL DCSP  DCSP dns_response = dns.resolver.query(name, 'TXT') DCNL DCSP except dns.resolver.NXDOMAIN as error: DCNL DCSP  DCSP return [] DCNL DCSP except dns.exception.DNSException as error: DCNL DCSP  DCSP logger.error('Error DCSP resolving DCSP %s: DCSP %s', name, str(error)) DCNL DCSP  DCSP return [] DCNL DCSP return [txt_rec.decode('utf-8') for rdata in dns_response for txt_rec in rdata.strings]
 DCSP if derivative: DCNL DCSP  DCSP return _spherical_yn_d(n, z) DCNL DCSP else: DCNL DCSP  DCSP return _spherical_yn(n, z)
 DCSP app_messages.sort((lambda x, y: cmp(x[1], y[1]))) DCNL DCSP from csv import writer DCNL DCSP with open(path, u'wb') as msgfile: DCNL DCSP  DCSP w = writer(msgfile, lineterminator=u'\n') DCNL DCSP  DCSP for (p, m) in app_messages: DCNL DCSP  DCSP  DCSP t = lang_dict.get(m, u'') DCNL DCSP  DCSP  DCSP t = re.sub(u'{\\s?([0-9]+)\\s?}', u'{\\g<1>}', t) DCNL DCSP  DCSP  DCSP w.writerow([(p.encode(u'utf-8') if p else u''), m.encode(u'utf-8'), t.encode(u'utf-8')])
 DCSP _update_week_number() DCNL DCSP return (_cur_year, _cur_week)
 DCSP return 23
 DCSP try: DCNL DCSP  DCSP p = Popen(args, shell=False, stdout=PIPE, stderr=PIPE, close_fds=(os.name != 'nt'), universal_newlines=True) DCNL DCSP except OSError as e: DCNL DCSP  DCSP six.reraise(os_err_exc_type, os_err_exc_type(('Error DCSP executing DCSP %s: DCSP %s' % (args[0], e.strerror))), sys.exc_info()[2]) DCNL DCSP (output, errors) = p.communicate() DCNL DCSP return (output, force_text(errors, DEFAULT_LOCALE_ENCODING, strings_only=True), p.returncode)
 DCSP if (prefix is None): DCNL DCSP  DCSP prefix = settings.STATIC_URL DCNL DCSP return static(prefix, view='django.contrib.staticfiles.views.serve')
 DCSP for pattern in patterns: DCNL DCSP  DCSP if fnmatch(pathname, pattern): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP return [vv for (kk, vv) in tparams.iteritems()]
 DCSP return 'ERROR: DCSP This DCSP function DCSP has DCSP been DCSP moved DCSP to DCSP cmd.tty'
 DCSP parser = optparse.OptionParser() DCNL DCSP parser.add_option('-e', '--expire-date', dest='expire_date', type='int', default=30, help='number DCSP of DCSP days DCSP before DCSP builds DCSP expire') DCNL DCSP parser.add_option('-i', '--include', dest='include', type='str', action='append', help='Globs DCSP of DCSP files DCSP to DCSP include') DCNL DCSP parser.add_option('-n', '--no-exec', dest='fake', action='store_true', help='Do DCSP not DCSP remove DCSP files') DCNL DCSP parser.add_option('-X', '--exclude', dest='exclude', type='str', action='append', help='Globs DCSP of DCSP files DCSP to DCSP exclude') DCNL DCSP (args, dirs) = parser.parse_args() DCNL DCSP if (not dirs): DCNL DCSP  DCSP parser.error('you DCSP must DCSP specify DCSP one DCSP or DCSP more DCSP directories') DCNL DCSP for buildroot in dirs: DCNL DCSP  DCSP rm_old_files(buildroot, expire_time=(args.expire_date * DAY), excludes=args.exclude, fake=args.fake, includes=args.include)
 DCSP data_size = ctypes.wintypes.DWORD() DCNL DCSP ctypes.windll.advapi32.GetTokenInformation(token, information_class.num, 0, 0, ctypes.byref(data_size)) DCNL DCSP data = ctypes.create_string_buffer(data_size.value) DCNL DCSP handle_nonzero_success(ctypes.windll.advapi32.GetTokenInformation(token, information_class.num, ctypes.byref(data), ctypes.sizeof(data), ctypes.byref(data_size))) DCNL DCSP return ctypes.cast(data, ctypes.POINTER(TOKEN_USER)).contents
 DCSP if (a.ndim < 2): DCNL DCSP  DCSP raise ValueError('array DCSP must DCSP be DCSP at DCSP least DCSP 2-d') DCNL DCSP end = None DCNL DCSP if (a.ndim == 2): DCNL DCSP  DCSP step = (a.shape[1] + 1) DCNL DCSP  DCSP if (not wrap): DCNL DCSP  DCSP  DCSP end = (a.shape[1] * a.shape[1]) DCNL DCSP else: DCNL DCSP  DCSP if (not numpy.alltrue((numpy.diff(a.shape) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('All DCSP dimensions DCSP of DCSP input DCSP must DCSP be DCSP of DCSP equal DCSP length') DCNL DCSP  DCSP step = (1 + numpy.cumprod(a.shape[:(-1)]).sum()) DCNL DCSP a.ravel()[:end:step] = val
 DCSP y = np.linspace(0, 1, 20) DCNL DCSP bc = BalanceCascade(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP bc = BalanceCascade(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y)
 DCSP warnings.warn('chainer.cuda.full_like DCSP is DCSP deprecated. DCSP Use DCSP cupy.full_like DCSP instead.', DeprecationWarning) DCNL DCSP check_cuda_available() DCNL DCSP assert (stream is None) DCNL DCSP if isinstance(array, cupy.ndarray): DCNL DCSP  DCSP return cupy.full_like(array, fill_value) DCNL DCSP return cupy.full(array.shape, fill_value, dtype=array.dtype)
 DCSP timings = [] DCNL DCSP errors = [] DCNL DCSP for _ in range(0, constants.NUM_SAMPLES): DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP query = TestModel.all() DCNL DCSP  DCSP  DCSP query.filter('test_string DCSP =', uuid) DCNL DCSP  DCSP  DCSP query.fetch(constants.NUM_SAMPLES) DCNL DCSP  DCSP  DCSP total_time = (time.time() - start) DCNL DCSP  DCSP except Exception as exception: DCNL DCSP  DCSP  DCSP logging.exception(exception) DCNL DCSP  DCSP  DCSP errors.append(str(exception)) DCNL DCSP  DCSP  DCSP total_time = 0 DCNL DCSP  DCSP timings.append((total_time * constants.SECONDS_TO_MILLI)) DCNL DCSP return (timings, errors)
 DCSP sec_group_ref = models.SecurityGroupInstanceAssociation() DCNL DCSP sec_group_ref.update({'instance_uuid': instance_uuid, 'security_group_id': security_group_id}) DCNL DCSP sec_group_ref.save()
 DCSP global WORKDIR, DEPSRC, SDKPATH, SRCDIR, DEPTARGET DCNL DCSP global UNIVERSALOPTS, UNIVERSALARCHS, ARCHLIST, CC, CXX DCNL DCSP global FW_VERSION_PREFIX DCNL DCSP global FW_SSL_DIRECTORY DCNL DCSP if (args is None): DCNL DCSP  DCSP args = sys.argv[1:] DCNL DCSP try: DCNL DCSP  DCSP (options, args) = getopt.getopt(args, '?hb', ['build-dir=', 'third-party=', 'sdk-path=', 'src-dir=', 'dep-target=', 'universal-archs=', 'help']) DCNL DCSP except getopt.GetoptError: DCNL DCSP  DCSP print sys.exc_info()[1] DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if args: DCNL DCSP  DCSP print 'Additional DCSP arguments' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP deptarget = None DCNL DCSP for (k, v) in options: DCNL DCSP  DCSP if (k in ('-h', '-?', '--help')): DCNL DCSP  DCSP  DCSP print USAGE DCNL DCSP  DCSP  DCSP sys.exit(0) DCNL DCSP  DCSP elif (k in ('-d', '--build-dir')): DCNL DCSP  DCSP  DCSP WORKDIR = v DCNL DCSP  DCSP elif (k in ('--third-party',)): DCNL DCSP  DCSP  DCSP DEPSRC = v DCNL DCSP  DCSP elif (k in ('--sdk-path',)): DCNL DCSP  DCSP  DCSP SDKPATH = v DCNL DCSP  DCSP elif (k in ('--src-dir',)): DCNL DCSP  DCSP  DCSP SRCDIR = v DCNL DCSP  DCSP elif (k in ('--dep-target',)): DCNL DCSP  DCSP  DCSP DEPTARGET = v DCNL DCSP  DCSP  DCSP deptarget = v DCNL DCSP  DCSP elif (k in ('--universal-archs',)): DCNL DCSP  DCSP  DCSP if (v in UNIVERSALOPTS): DCNL DCSP  DCSP  DCSP  DCSP UNIVERSALARCHS = v DCNL DCSP  DCSP  DCSP  DCSP ARCHLIST = universal_opts_map[UNIVERSALARCHS] DCNL DCSP  DCSP  DCSP  DCSP if (deptarget is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP DEPTARGET = default_target_map.get(v, '10.3') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementedError(v) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotImplementedError(k) DCNL DCSP SRCDIR = os.path.abspath(SRCDIR) DCNL DCSP WORKDIR = os.path.abspath(WORKDIR) DCNL DCSP SDKPATH = os.path.abspath(SDKPATH) DCNL DCSP DEPSRC = os.path.abspath(DEPSRC) DCNL DCSP (CC, CXX) = getTargetCompilers() DCNL DCSP FW_VERSION_PREFIX = (FW_PREFIX[:] + ['Versions', getVersion()]) DCNL DCSP FW_SSL_DIRECTORY = (FW_VERSION_PREFIX[:] + ['etc', 'openssl']) DCNL DCSP print '-- DCSP Settings:' DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Source DCSP directory: DCSP  DCSP  DCSP  DCSP %s' % SRCDIR) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Build DCSP directory: DCSP  DCSP  DCSP  DCSP  DCSP %s' % WORKDIR) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP SDK DCSP location: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % SDKPATH) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Third-party DCSP source: DCSP  DCSP %s' % DEPSRC) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Deployment DCSP target: DCSP  DCSP  DCSP %s' % DEPTARGET) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Universal DCSP archs: DCSP  DCSP  DCSP  DCSP  DCSP %s' % str(ARCHLIST)) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP C DCSP compiler: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % CC) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP C++ DCSP compiler: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % CXX) DCNL DCSP print '' DCNL DCSP print (' DCSP -- DCSP Building DCSP a DCSP Python DCSP %s DCSP framework DCSP at DCSP patch DCSP level DCSP %s' % (getVersion(), getFullVersion())) DCNL DCSP print ''
 DCSP _delete_item(usage_key, request.user)
 DCSP http_callable = getattr(http, 'request', http) DCNL DCSP return http_callable(uri, method=method, body=body, headers=headers, redirections=redirections, connection_type=connection_type)
 DCSP if (axis is None): DCNL DCSP  DCSP a = ravel(a) DCNL DCSP  DCSP outaxis = 0 DCNL DCSP else: DCNL DCSP  DCSP a = asarray(a) DCNL DCSP  DCSP outaxis = axis DCNL DCSP return (a, outaxis)
 DCSP create_dir(output_dir) DCNL DCSP for e in simsam_range(table, tree, simulated_sample_sizes, dissimilarities, mapping_f): DCNL DCSP  DCSP output_table = e[0] DCNL DCSP  DCSP output_mapping_lines = e[1] DCNL DCSP  DCSP simulated_sample_size = e[2] DCNL DCSP  DCSP dissimilarity = e[3] DCNL DCSP  DCSP output_table_fp = join(output_dir, ('%s_n%d_d%r.biom' % (output_table_basename, simulated_sample_size, dissimilarity))) DCNL DCSP  DCSP write_biom_table(output_table, output_table_fp) DCNL DCSP  DCSP if (output_mapping_lines is not None): DCNL DCSP  DCSP  DCSP output_map_fp = join(output_dir, ('%s_n%d_d%r.txt' % (output_map_basename, simulated_sample_size, dissimilarity))) DCNL DCSP  DCSP  DCSP output_map_f = open(output_map_fp, 'w') DCNL DCSP  DCSP  DCSP output_map_f.write(''.join(output_mapping_lines)) DCNL DCSP  DCSP  DCSP output_map_f.close()
 DCSP try: DCNL DCSP  DCSP acc = (state['test_acc'] + 1) DCNL DCSP except KeyError: DCNL DCSP  DCSP acc = 1 DCNL DCSP state['test_acc'] = acc DCNL DCSP res = line.split() DCNL DCSP res[2] = acc DCNL DCSP res[3] = {'metric_type': 'counter'} DCNL DCSP return tuple(res)
 DCSP cmd = 'systemsetup DCSP -setlocalsubnetname DCSP "{0}"'.format(name) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmd) DCNL DCSP return salt.utils.mac_utils.confirm_updated(name, get_subnet_name)
 DCSP y_true = [1, 1, 2, 3] DCNL DCSP y_pred = [1, 3, 3, 3] DCNL DCSP specificity_13 = partial(specificity_score, y_true, y_pred, labels=[1, 3]) DCNL DCSP specificity_all = partial(specificity_score, y_true, y_pred, labels=None) DCNL DCSP assert_allclose([1.0, 0.33], specificity_13(average=None), rtol=R_TOL) DCNL DCSP assert_allclose(np.mean([1.0, 0.33]), specificity_13(average='macro'), rtol=R_TOL) DCNL DCSP assert_allclose(np.average([1.0, 0.33], weights=[2.0, 1.0]), specificity_13(average='weighted'), rtol=R_TOL) DCNL DCSP assert_allclose((3.0 / (3.0 + 2.0)), specificity_13(average='micro'), rtol=R_TOL) DCNL DCSP for average in ['macro', 'weighted', 'micro']: DCNL DCSP  DCSP assert_not_equal(specificity_13(average=average), specificity_all(average=average))
 DCSP for desc in _description.splitlines(): DCNL DCSP  DCSP print desc
 DCSP beta_initial = [random.random() for x_i in x[0]] DCNL DCSP return minimize_stochastic(partial(squared_error_ridge, alpha=alpha), partial(squared_error_ridge_gradient, alpha=alpha), x, y, beta_initial, 0.001)
 DCSP fq_name = str(fq_name) DCNL DCSP module_name = __name__ DCNL DCSP short_name = fq_name DCNL DCSP if (fq_name.rfind('.') >= 0): DCNL DCSP  DCSP (module_name, short_name) = (fq_name[:fq_name.rfind('.')], fq_name[(fq_name.rfind('.') + 1):]) DCNL DCSP try: DCNL DCSP  DCSP result = __import__(module_name, None, None, [short_name]) DCNL DCSP  DCSP return result.__dict__[short_name] DCNL DCSP except KeyError: DCNL DCSP  DCSP if recursive: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ImportError(("Could DCSP not DCSP find DCSP '%s' DCSP on DCSP path DCSP '%s'" % (short_name, module_name))) DCNL DCSP except ImportError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP module = for_name(module_name, recursive=True) DCNL DCSP  DCSP  DCSP if hasattr(module, short_name): DCNL DCSP  DCSP  DCSP  DCSP return getattr(module, short_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise KeyError() DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise ImportError(("Could DCSP not DCSP find DCSP '%s' DCSP on DCSP path DCSP '%s'" % (short_name, module_name))) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP raise
 DCSP if ((not vgname) or (not devices)): DCNL DCSP  DCSP return 'Error: DCSP vgname DCSP and DCSP device(s) DCSP are DCSP both DCSP required' DCNL DCSP if isinstance(devices, six.string_types): DCNL DCSP  DCSP devices = devices.split(',') DCNL DCSP cmd = ['vgcreate', vgname] DCNL DCSP for device in devices: DCNL DCSP  DCSP cmd.append(device) DCNL DCSP valid = ('clustered', 'maxlogicalvolumes', 'maxphysicalvolumes', 'vgmetadatacopies', 'metadatacopies', 'physicalextentsize') DCNL DCSP for var in kwargs: DCNL DCSP  DCSP if (kwargs[var] and (var in valid)): DCNL DCSP  DCSP  DCSP cmd.append('--{0}'.format(var)) DCNL DCSP  DCSP  DCSP cmd.append(kwargs[var]) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False).splitlines() DCNL DCSP vgdata = vgdisplay(vgname) DCNL DCSP vgdata['Output DCSP from DCSP vgcreate'] = out[0].strip() DCNL DCSP return vgdata
 DCSP return fn(*args, **kwargs)
 DCSP sbn1 = SpatialBatchNormalization((5,)) DCNL DCSP (yield (assert_raises, (ValueError, sbn1.allocate))) DCNL DCSP sbn2 = SpatialBatchNormalization(3) DCNL DCSP (yield (assert_raises, (ValueError, sbn2.allocate))) DCNL DCSP def do_not_fail(*input_dim): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sbn = SpatialBatchNormalization(input_dim) DCNL DCSP  DCSP  DCSP sbn.allocate() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP assert False DCNL DCSP (yield (do_not_fail, 5, 4, 3)) DCNL DCSP (yield (do_not_fail, 7, 6)) DCNL DCSP (yield (do_not_fail, 3, 9, 2, 3))
 DCSP if (not table): DCNL DCSP  DCSP return 'Error: DCSP table DCSP needs DCSP to DCSP be DCSP specified' DCNL DCSP if check_table(table, family=family): DCNL DCSP  DCSP return 'Error: DCSP table DCSP {0} DCSP in DCSP family DCSP {1} DCSP already DCSP exists'.format(table, family) DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmd = '{0} DCSP add DCSP table DCSP {1} DCSP {2}'.format(_nftables_cmd(), nft_family, table) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP if (not out): DCNL DCSP  DCSP out = True DCNL DCSP return out
 DCSP result = [] DCNL DCSP exponent = [] DCNL DCSP consuming_exponent = False DCNL DCSP level = 0 DCNL DCSP for (tok, nextTok) in zip(tokens, tokens[1:]): DCNL DCSP  DCSP if ((tok[0] == NAME) and (nextTok[0] == OP) and (nextTok[1] == '**')): DCNL DCSP  DCSP  DCSP if _token_callable(tok, local_dict, global_dict): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = True DCNL DCSP  DCSP elif consuming_exponent: DCNL DCSP  DCSP  DCSP exponent.append(tok) DCNL DCSP  DCSP  DCSP if ((tok[0] == nextTok[0] == OP) and (tok[1] == ')') and (nextTok[1] == '(')): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = False DCNL DCSP  DCSP  DCSP if ((tok[0] == nextTok[0] == OP) and (tok[1] == '*') and (nextTok[1] == '(')): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = False DCNL DCSP  DCSP  DCSP  DCSP del exponent[(-1)] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (exponent and (not consuming_exponent)): DCNL DCSP  DCSP  DCSP if (tok[0] == OP): DCNL DCSP  DCSP  DCSP  DCSP if (tok[1] == '('): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level += 1 DCNL DCSP  DCSP  DCSP  DCSP elif (tok[1] == ')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level -= 1 DCNL DCSP  DCSP  DCSP if (level == 0): DCNL DCSP  DCSP  DCSP  DCSP result.append(tok) DCNL DCSP  DCSP  DCSP  DCSP result.extend(exponent) DCNL DCSP  DCSP  DCSP  DCSP exponent = [] DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.append(tok) DCNL DCSP if tokens: DCNL DCSP  DCSP result.append(tokens[(-1)]) DCNL DCSP if exponent: DCNL DCSP  DCSP result.extend(exponent) DCNL DCSP return result
 DCSP raw = read_crop(raw_fname, (0.0, 1.0)) DCNL DCSP sss_fine_cal = read_crop(sss_fine_cal_fname) DCNL DCSP raw_sss = maxwell_filter(raw, calibration=fine_cal_fname, origin=mf_head_origin, regularize=None, bad_condition='ignore') DCNL DCSP assert_meg_snr(raw_sss, sss_fine_cal, 82, 611) DCNL DCSP py_cal = raw_sss.info['proc_history'][0]['max_info']['sss_cal'] DCNL DCSP assert_true((py_cal is not None)) DCNL DCSP assert_true((len(py_cal) > 0)) DCNL DCSP mf_cal = sss_fine_cal.info['proc_history'][0]['max_info']['sss_cal'] DCNL DCSP mf_cal['cal_chans'][((mf_cal['cal_chans'][:, 1] == 3022), 1)] = 3024 DCNL DCSP assert_allclose(py_cal['cal_chans'], mf_cal['cal_chans']) DCNL DCSP assert_allclose(py_cal['cal_corrs'], mf_cal['cal_corrs'], rtol=0.001, atol=0.001) DCNL DCSP raw_missing = raw.copy().load_data() DCNL DCSP raw_missing.info['bads'] = ['MEG0111', 'MEG0943'] DCNL DCSP raw_missing.info._check_consistency() DCNL DCSP raw_sss_bad = maxwell_filter(raw_missing, calibration=fine_cal_fname, origin=mf_head_origin, regularize=None, bad_condition='ignore') DCNL DCSP raw_missing.pick_types() DCNL DCSP raw_sss_bad.pick_channels(raw_missing.ch_names) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP raw_sss_missing = maxwell_filter(raw_missing, calibration=fine_cal_fname, origin=mf_head_origin, regularize=None, bad_condition='ignore') DCNL DCSP assert_meg_snr(raw_sss_missing, raw_sss_bad, 1000.0, 10000.0) DCNL DCSP raw_sss_3D = maxwell_filter(raw, calibration=fine_cal_fname_3d, origin=mf_head_origin, regularize=None, bad_condition='ignore') DCNL DCSP assert_meg_snr(raw_sss_3D, sss_fine_cal, 1.0, 6.0) DCNL DCSP raw_ctf = read_crop(fname_ctf_raw).apply_gradient_compensation(0) DCNL DCSP assert_raises(RuntimeError, maxwell_filter, raw_ctf, origin=(0.0, 0.0, 0.04), calibration=fine_cal_fname)
 DCSP global _CORE_SITE_DICT DCNL DCSP global _CORE_SITE_PATH DCNL DCSP for indentifier in conf.HDFS_CLUSTERS.get(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _CORE_SITE_PATH = os.path.join(conf.HDFS_CLUSTERS[indentifier].HADOOP_CONF_DIR.get(), 'core-site.xml') DCNL DCSP  DCSP  DCSP data = file(_CORE_SITE_PATH, 'r').read() DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP data = '' DCNL DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP if (err.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP LOG.error(('Cannot DCSP read DCSP from DCSP "%s": DCSP %s' % (_CORE_SITE_PATH, err))) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP data = '' DCNL DCSP _CORE_SITE_DICT = confparse.ConfParse(data)
 DCSP if ((not isinstance(array, theano.Variable)) and (not isinstance(array, np.ndarray))): DCNL DCSP  DCSP raise RuntimeError('Unsupported DCSP type DCSP {}. DCSP Only DCSP theano DCSP variables DCSP and DCSP numpy DCSP arrays DCSP are DCSP supported'.format(type(array))) DCNL DCSP ndim = array.ndim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (ndim == 1): DCNL DCSP  DCSP sum_over = () DCNL DCSP elif (ndim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (ndim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, ndim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupported DCSP tensor DCSP dimensionality DCSP {}. DCSP Must DCSP specify DCSP `norm_axes`'.format(array.ndim)) DCNL DCSP if isinstance(array, theano.Variable): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = T.abs_(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = T.sqrt(T.sum((array ** 2), axis=sum_over)) DCNL DCSP elif isinstance(array, np.ndarray): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = abs(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = np.sqrt(np.sum((array ** 2), axis=sum_over)) DCNL DCSP return norms
 DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP auth = current.auth DCNL DCSP response = current.response DCNL DCSP session = current.session DCNL DCSP settings = current.deployment_settings DCNL DCSP s3 = response.s3 DCNL DCSP configure = s3db.configure DCNL DCSP set_method = s3db.set_method DCNL DCSP contacts_tabs = settings.get_pr_contacts_tabs() DCNL DCSP if ('all' in contacts_tabs): DCNL DCSP  DCSP set_method('pr', 'person', method='contacts', action=s3db.pr_Contacts) DCNL DCSP if ('public' in contacts_tabs): DCNL DCSP  DCSP set_method('pr', 'person', method='public_contacts', action=s3db.pr_Contacts) DCNL DCSP if ('private' in contacts_tabs): DCNL DCSP  DCSP set_method('pr', 'person', method='private_contacts', action=s3db.pr_Contacts) DCNL DCSP set_method('pr', 'person', method='cv', action=hrm_CV) DCNL DCSP set_method('pr', 'person', method='record', action=hrm_Record) DCNL DCSP if settings.has_module('asset'): DCNL DCSP  DCSP s3db.add_components('pr_person', asset_asset='assigned_to_id') DCNL DCSP  DCSP configure('asset_asset', deletable=False, editable=False, insertable=False) DCNL DCSP get_vars = current.request.get_vars DCNL DCSP group = get_vars.get('group', 'staff') DCNL DCSP hr_id = get_vars.get('human_resource.id', None) DCNL DCSP if (not str(hr_id).isdigit()): DCNL DCSP  DCSP hr_id = None DCNL DCSP table = s3db.hrm_human_resource DCNL DCSP table.type.default = 1 DCNL DCSP get_vars['xsltmode'] = 'staff' DCNL DCSP if hr_id: DCNL DCSP  DCSP hr = db((table.id == hr_id)).select(table.type, limitby=(0, 1)).first() DCNL DCSP  DCSP if hr: DCNL DCSP  DCSP  DCSP group = (((hr.type == 2) and 'volunteer') or 'staff') DCNL DCSP  DCSP  DCSP get_vars['group'] = group DCNL DCSP table = db.pr_person DCNL DCSP tablename = 'pr_person' DCNL DCSP configure(tablename, deletable=False) DCNL DCSP mode = session.s3.hrm.mode DCNL DCSP if (mode is not None): DCNL DCSP  DCSP s3.crud_strings[tablename].update(title_display=T('Personal DCSP Profile'), title_update=T('Personal DCSP Profile')) DCNL DCSP  DCSP configure('hrm_human_resource', deletable=False, editable=False, insertable=False) DCNL DCSP  DCSP configure('hrm_certification', deletable=True, editable=True, insertable=True) DCNL DCSP  DCSP configure('hrm_credential', deletable=False, editable=False, insertable=False) DCNL DCSP  DCSP configure('hrm_competency', deletable=False, editable=False, insertable=True) DCNL DCSP  DCSP configure('hrm_training', deletable=False, editable=False, insertable=True) DCNL DCSP  DCSP configure('hrm_experience', deletable=False, editable=False, insertable=False) DCNL DCSP  DCSP configure('pr_group_membership', deletable=False, editable=False, insertable=False) DCNL DCSP elif (settings.get_hrm_staff_label() == T('Contacts')): DCNL DCSP  DCSP s3.crud_strings[tablename].update(title_upload=T('Import DCSP Contacts'), title_display=T('Contact DCSP Details'), title_update=T('Contact DCSP Details')) DCNL DCSP else: DCNL DCSP  DCSP s3.crud_strings[tablename].update(title_upload=T('Import DCSP Staff'), title_display=T('Staff DCSP Member DCSP Details'), title_update=T('Staff DCSP Member DCSP Details')) DCNL DCSP s3.importerPrep = (lambda : dict(ReplaceOption=T('Remove DCSP existing DCSP data DCSP before DCSP import'))) DCNL DCSP def import_prep(data, group=group): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Deletes DCSP all DCSP HR DCSP records DCSP (of DCSP the DCSP given DCSP group) DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP organisation/branch DCSP before DCSP processing DCSP a DCSP new DCSP data DCSP import\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP (resource, tree) = data DCNL DCSP  DCSP xml = current.xml DCNL DCSP  DCSP tag = xml.TAG DCNL DCSP  DCSP att = xml.ATTRIBUTE DCNL DCSP  DCSP if s3.import_replace: DCNL DCSP  DCSP  DCSP if (tree is not None): DCNL DCSP  DCSP  DCSP  DCSP if (group == 'staff'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = 1 DCNL DCSP  DCSP  DCSP  DCSP elif (group == 'volunteer'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = 2 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP root = tree.getroot() DCNL DCSP  DCSP  DCSP  DCSP expr = ("/%s/%s[@%s='org_organisation']/%s[@%s='name']" % (tag.root, tag.resource, att.name, tag.data, att.field)) DCNL DCSP  DCSP  DCSP  DCSP orgs = root.xpath(expr) DCNL DCSP  DCSP  DCSP  DCSP for org in orgs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP org_name = (org.get('value', None) or org.text) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if org_name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP org_name = json.loads(xml.xml_decode(org_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP if org_name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP htable = s3db.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP otable = s3db.org_organisation DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = (((otable.name == org_name) & (htable.organisation_id == otable.id)) & (htable.type == group)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resource = s3db.resource('hrm_human_resource', filter=query) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resource.delete(format='xml', cascade=True) DCNL DCSP s3.import_prep = import_prep DCNL DCSP def prep(r): DCNL DCSP  DCSP S3PersonRoleManager.set_method(r, entity='pr_person') DCNL DCSP  DCSP if s3.rtl: DCNL DCSP  DCSP  DCSP f = s3db.pr_phone_contact.value DCNL DCSP  DCSP  DCSP f.represent = s3_phone_represent DCNL DCSP  DCSP  DCSP f.widget = S3PhoneWidget() DCNL DCSP  DCSP method = r.method DCNL DCSP  DCSP if (r.representation == 's3json'): DCNL DCSP  DCSP  DCSP current.xml.show_ids = True DCNL DCSP  DCSP elif (r.interactive and (method != 'import')): DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP table.pe_label.readable = table.pe_label.writable = False DCNL DCSP  DCSP  DCSP  DCSP table.missing.readable = table.missing.writable = False DCNL DCSP  DCSP  DCSP  DCSP table.age_group.readable = table.age_group.writable = False DCNL DCSP  DCSP  DCSP  DCSP dob = table.date_of_birth DCNL DCSP  DCSP  DCSP  DCSP dob.widget = S3CalendarWidget(past_months=1440, future_months=(-60)) DCNL DCSP  DCSP  DCSP  DCSP person_details_table = s3db.pr_person_details DCNL DCSP  DCSP  DCSP  DCSP person_details_table.occupation.readable = person_details_table.occupation.writable = False DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field = settings.set_org_dependent_field DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person', 'middle_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person_details', 'father_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person_details', 'mother_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person_details', 'grandfather_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person_details', 'affiliations') DCNL DCSP  DCSP  DCSP  DCSP set_org_dependent_field('pr_person_details', 'company') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP component_name = r.component_name DCNL DCSP  DCSP  DCSP  DCSP if (component_name == 'physical_description'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.component.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP for field in table.fields: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table[field].writable = table[field].readable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.ethnicity.writable = table.ethnicity.readable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.blood_type.writable = table.blood_type.readable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.medical_conditions.writable = table.medical_conditions.readable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.other_details.writable = table.other_details.readable = True DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'appraisal'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mission_id = r.get_vars.get('mission_id', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if mission_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable = r.component.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mtable = s3db.deploy_mission DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mission = db((mtable.id == mission_id)).select(mtable.code, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if mission: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable.code.default = mission.code DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP atable = db.deploy_assignment DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP htable = db.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = (((atable.mission_id == mission_id) & (atable.human_resource_id == htable.id)) & (htable.person_id == r.id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assignment = db(query).select(atable.job_title_id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if assignment: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable.job_title_id.default = assignment.job_title_id DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'asset'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP configure('asset_asset', insertable=False, editable=False, deletable=False) DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'group_membership'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hrm_configure_pr_group_membership() DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'salary'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hrm_configure_salary(r) DCNL DCSP  DCSP  DCSP if ((method == 'record') or (r.component_name == 'human_resource')): DCNL DCSP  DCSP  DCSP  DCSP table = s3db.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP table.person_id.writable = table.person_id.readable = False DCNL DCSP  DCSP  DCSP  DCSP table.site_id.readable = table.site_id.writable = True DCNL DCSP  DCSP  DCSP  DCSP org = session.s3.hrm.org DCNL DCSP  DCSP  DCSP  DCSP f = table.organisation_id DCNL DCSP  DCSP  DCSP  DCSP if (org is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.widget = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.default = org DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.readable = f.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.site_id.requires = IS_EMPTY_OR(IS_ONE_OF(db, ('org_site.%s' % s3db.super_key(db.org_site)), s3db.org_site_represent, filterby='organisation_id', filter_opts=(session.s3.hrm.org,))) DCNL DCSP  DCSP  DCSP elif ((method == 'cv') or (r.component_name == 'training')): DCNL DCSP  DCSP  DCSP  DCSP list_fields = ['course_id', 'grade'] DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_course_pass_marks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fields.append('grade_details') DCNL DCSP  DCSP  DCSP  DCSP list_fields.append('date') DCNL DCSP  DCSP  DCSP  DCSP s3db.configure('hrm_training', list_fields=list_fields) DCNL DCSP  DCSP  DCSP resource = r.resource DCNL DCSP  DCSP  DCSP if (mode is not None): DCNL DCSP  DCSP  DCSP  DCSP resource.build_query(id=auth.s3_logged_in_person()) DCNL DCSP  DCSP  DCSP elif (method not in ('deduplicate', 'search_ac')): DCNL DCSP  DCSP  DCSP  DCSP if ((not r.id) and (not hr_id)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if response.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.error = response.error DCNL DCSP  DCSP  DCSP  DCSP  DCSP redirect(URL(r=r, f='staff')) DCNL DCSP  DCSP  DCSP  DCSP if (resource.count() == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP resource.load() DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.record = resource.records().first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if r.record: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP r.id = r.record.id DCNL DCSP  DCSP  DCSP  DCSP if (not r.record): DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.error = T('Record DCSP not DCSP found') DCNL DCSP  DCSP  DCSP  DCSP  DCSP redirect(URL(f='staff')) DCNL DCSP  DCSP  DCSP  DCSP if (hr_id and (r.component_name == 'human_resource')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.component_id = hr_id DCNL DCSP  DCSP  DCSP  DCSP configure('hrm_human_resource', insertable=False) DCNL DCSP  DCSP elif (r.representation == 'aadata'): DCNL DCSP  DCSP  DCSP if (r.component_name == 'group_membership'): DCNL DCSP  DCSP  DCSP  DCSP hrm_configure_pr_group_membership() DCNL DCSP  DCSP  DCSP elif ((method == 'cv') or (r.component_name == 'training')): DCNL DCSP  DCSP  DCSP  DCSP list_fields = ['course_id', 'grade'] DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_course_pass_marks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fields.append('grade_details') DCNL DCSP  DCSP  DCSP  DCSP list_fields.append('date') DCNL DCSP  DCSP  DCSP  DCSP s3db.configure('hrm_training', list_fields=list_fields) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if (r.interactive and r.component): DCNL DCSP  DCSP  DCSP if (r.component_name == 'asset'): DCNL DCSP  DCSP  DCSP  DCSP output['add_btn'] = A(T('Assign DCSP Asset'), _href=URL(c='asset', f='asset'), _id='add-btn', _class='action-btn') DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if (session.s3.hrm.orgname and (mode is None)): DCNL DCSP  DCSP orgname = session.s3.hrm.orgname DCNL DCSP else: DCNL DCSP  DCSP orgname = None DCNL DCSP _attr = dict(csv_stylesheet=('hrm', 'person.xsl'), csv_template='staff', csv_extra_fields=[dict(label='Type', field=s3db.hrm_human_resource.type)], orgname=orgname, replace_option=T('Remove DCSP existing DCSP data DCSP before DCSP import'), rheader=hrm_rheader) DCNL DCSP _attr.update(attr) DCNL DCSP output = current.rest_controller('pr', 'person', **_attr) DCNL DCSP return output
 DCSP return _execute_with_retries(conn, 'describe_stream', StreamName=stream_name)
 DCSP if (not uri): DCNL DCSP  DCSP raise exceptions.MpdNoExistError(u'No DCSP such DCSP song') DCNL DCSP length = context.core.tracklist.get_length() DCNL DCSP if ((songpos is not None) and (songpos > length.get())): DCNL DCSP  DCSP raise exceptions.MpdArgError(u'Bad DCSP song DCSP index') DCNL DCSP tl_tracks = context.core.tracklist.add(uris=[uri], at_position=songpos).get() DCNL DCSP if (not tl_tracks): DCNL DCSP  DCSP raise exceptions.MpdNoExistError(u'No DCSP such DCSP song') DCNL DCSP return (u'Id', tl_tracks[0].tlid)
 DCSP indices = np.random.choice(df.index, nrows, replace=replace) DCNL DCSP sample = df.loc[indices] DCNL DCSP return sample
 DCSP server = _connect(host, port, db, password) DCNL DCSP return server.flushall()
 DCSP common = osp.normpath(osp.commonprefix(pathlist)) DCNL DCSP if (len(common) > 1): DCNL DCSP  DCSP if (not osp.isdir(common)): DCNL DCSP  DCSP  DCSP return abspardir(common) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for path in pathlist: DCNL DCSP  DCSP  DCSP  DCSP if (not osp.isdir(osp.join(common, path[(len(common) + 1):]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return abspardir(common) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return osp.abspath(common)
 DCSP attrs = {} DCNL DCSP args = {} DCNL DCSP finder = _getfinder() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_00 = aetypes.ObjectSpecifier(want=aetypes.Type('cfol'), form='alis', seld=folder_alias, fr=None) DCNL DCSP aeobj_01 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', seld=aetypes.Type('cwnd'), fr=aeobj_00) DCNL DCSP aeobj_02 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', seld=aetypes.Type('pvew'), fr=aeobj_01) DCNL DCSP args['----'] = aeobj_02 DCNL DCSP (_reply, args, attrs) = finder.send('core', 'getd', args, attrs) DCNL DCSP if ('errn' in args): DCNL DCSP  DCSP raise Error, aetools.decodeerror(args) DCNL DCSP views = {'iimg': 0, 'pnam': 1, 'lgbu': 2} DCNL DCSP if ('----' in args): DCNL DCSP  DCSP return views[args['----'].enum]
 DCSP result = defaultdict(list) DCNL DCSP backends_defined = get_backends() DCNL DCSP for item in items: DCNL DCSP  DCSP name = getattr(item, 'provider', item) DCNL DCSP  DCSP backend = backends_defined[name] DCNL DCSP  DCSP if issubclass(backend, OpenIdAuth): DCNL DCSP  DCSP  DCSP result['openid'].append(item) DCNL DCSP  DCSP elif issubclass(backend, BaseOAuth2): DCNL DCSP  DCSP  DCSP result['oauth2'].append(item) DCNL DCSP  DCSP elif issubclass(backend, BaseOAuth1): DCNL DCSP  DCSP  DCSP result['oauth'].append(item) DCNL DCSP return dict(result)
 DCSP a = (Angle(350, u.deg) + Angle(350, u.deg)) DCNL DCSP a.to_string() DCNL DCSP a.to_string(u.hourangle) DCNL DCSP repr(a) DCNL DCSP repr(a.to(u.hourangle)) DCNL DCSP str(a) DCNL DCSP str(a.to(u.hourangle))
 DCSP seq_lens = defaultdict(int) DCNL DCSP input_fasta_f = open(input_fasta_fp, 'U') DCNL DCSP for (label, seq) in parse_fasta(input_fasta_f): DCNL DCSP  DCSP seq_lens[len(seq)] += 1 DCNL DCSP input_fasta_f.close() DCNL DCSP formatted_seq_lens = [] DCNL DCSP for curr_key in seq_lens: DCNL DCSP  DCSP formatted_seq_lens.append((seq_lens[curr_key], curr_key)) DCNL DCSP formatted_seq_lens.sort(reverse=True) DCNL DCSP return formatted_seq_lens
 DCSP if (encoding is None): DCNL DCSP  DCSP encoding = DEFAULT_ENCODING DCNL DCSP chunks = [] DCNL DCSP _append = chunks.append DCNL DCSP begin = (end - 1) DCNL DCSP while 1: DCNL DCSP  DCSP chunk = _m(s, end) DCNL DCSP  DCSP if (chunk is None): DCNL DCSP  DCSP  DCSP raise JSONDecodeError('Unterminated DCSP string DCSP starting DCSP at', s, begin) DCNL DCSP  DCSP end = chunk.end() DCNL DCSP  DCSP (content, terminator) = chunk.groups() DCNL DCSP  DCSP if content: DCNL DCSP  DCSP  DCSP if (not isinstance(content, unicode)): DCNL DCSP  DCSP  DCSP  DCSP content = unicode(content, encoding) DCNL DCSP  DCSP  DCSP _append(content) DCNL DCSP  DCSP if (terminator == '"'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (terminator != '\\'): DCNL DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invalid DCSP control DCSP character DCSP %r DCSP at' % (terminator,)) DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecodeError(msg, s, end) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _append(terminator) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP esc = s[end] DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP raise JSONDecodeError('Unterminated DCSP string DCSP starting DCSP at', s, begin) DCNL DCSP  DCSP if (esc != 'u'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP char = _b[esc] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invalid DCSP \\escape: DCSP ' + repr(esc)) DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecodeError(msg, s, end) DCNL DCSP  DCSP  DCSP end += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP esc = s[(end + 1):(end + 5)] DCNL DCSP  DCSP  DCSP next_end = (end + 5) DCNL DCSP  DCSP  DCSP if (len(esc) != 4): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invalid DCSP \\uXXXX DCSP escape' DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecodeError(msg, s, end) DCNL DCSP  DCSP  DCSP uni = int(esc, 16) DCNL DCSP  DCSP  DCSP if ((55296 <= uni <= 56319) and (sys.maxunicode > 65535)): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invalid DCSP \\uXXXX\\uXXXX DCSP surrogate DCSP pair' DCNL DCSP  DCSP  DCSP  DCSP if (not (s[(end + 5):(end + 7)] == '\\u')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise JSONDecodeError(msg, s, end) DCNL DCSP  DCSP  DCSP  DCSP esc2 = s[(end + 7):(end + 11)] DCNL DCSP  DCSP  DCSP  DCSP if (len(esc2) != 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise JSONDecodeError(msg, s, end) DCNL DCSP  DCSP  DCSP  DCSP uni2 = int(esc2, 16) DCNL DCSP  DCSP  DCSP  DCSP uni = (65536 + (((uni - 55296) << 10) | (uni2 - 56320))) DCNL DCSP  DCSP  DCSP  DCSP next_end += 6 DCNL DCSP  DCSP  DCSP char = unichr(uni) DCNL DCSP  DCSP  DCSP end = next_end DCNL DCSP  DCSP _append(char) DCNL DCSP return (u''.join(chunks), end)
 DCSP hN = (N / 2) DCNL DCSP hM1 = int(math.floor(((w.size + 1) / 2))) DCNL DCSP hM2 = int(math.floor((w.size / 2))) DCNL DCSP x = np.append(np.zeros(hM2), x) DCNL DCSP x = np.append(x, np.zeros(hM1)) DCNL DCSP Ns = 512 DCNL DCSP H = (Ns / 4) DCNL DCSP hNs = (Ns / 2) DCNL DCSP pin = max(hNs, hM1) DCNL DCSP pend = (x.size - max(hNs, hM1)) DCNL DCSP fftbuffer = np.zeros(N) DCNL DCSP yh = np.zeros(Ns) DCNL DCSP y = np.zeros(x.size) DCNL DCSP w = (w / sum(w)) DCNL DCSP sw = np.zeros(Ns) DCNL DCSP ow = triang((2 * H)) DCNL DCSP sw[(hNs - H):(hNs + H)] = ow DCNL DCSP bh = blackmanharris(Ns) DCNL DCSP bh = (bh / sum(bh)) DCNL DCSP sw[(hNs - H):(hNs + H)] = (sw[(hNs - H):(hNs + H)] / bh[(hNs - H):(hNs + H)]) DCNL DCSP hfreqp = [] DCNL DCSP f0t = 0 DCNL DCSP f0stable = 0 DCNL DCSP while (pin < pend): DCNL DCSP  DCSP x1 = x[(pin - hM1):(pin + hM2)] DCNL DCSP  DCSP (mX, pX) = DFT.dftAnal(x1, w, N) DCNL DCSP  DCSP ploc = UF.peakDetection(mX, t) DCNL DCSP  DCSP (iploc, ipmag, ipphase) = UF.peakInterp(mX, pX, ploc) DCNL DCSP  DCSP ipfreq = ((fs * iploc) / N) DCNL DCSP  DCSP f0t = UF.f0Twm(ipfreq, ipmag, f0et, minf0, maxf0, f0stable) DCNL DCSP  DCSP if (((f0stable == 0) & (f0t > 0)) or ((f0stable > 0) & (np.abs((f0stable - f0t)) < (f0stable / 5.0)))): DCNL DCSP  DCSP  DCSP f0stable = f0t DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f0stable = 0 DCNL DCSP  DCSP (hfreq, hmag, hphase) = harmonicDetection(ipfreq, ipmag, ipphase, f0t, nH, hfreqp, fs) DCNL DCSP  DCSP hfreqp = hfreq DCNL DCSP  DCSP Yh = UF.genSpecSines(hfreq, hmag, hphase, Ns, fs) DCNL DCSP  DCSP fftbuffer = np.real(ifft(Yh)) DCNL DCSP  DCSP yh[:(hNs - 1)] = fftbuffer[(hNs + 1):] DCNL DCSP  DCSP yh[(hNs - 1):] = fftbuffer[:(hNs + 1)] DCNL DCSP  DCSP y[(pin - hNs):(pin + hNs)] += (sw * yh) DCNL DCSP  DCSP pin += H DCNL DCSP y = np.delete(y, range(hM2)) DCNL DCSP y = np.delete(y, range((y.size - hM1), y.size)) DCNL DCSP return y
 DCSP for unit in (Byte, MB, MiB, GB, GiB): DCNL DCSP  DCSP for size in (1, 2, 4, 8): DCNL DCSP  DCSP  DCSP test_case = make_allocated_size_tests(unit(size)) DCNL DCSP  DCSP  DCSP globals()[test_case.__name__] = test_case
 DCSP return rv(name, GammaDistribution, (k, theta))
 DCSP key = (host, port) DCNL DCSP if _wsgi_intercept.has_key(key): DCNL DCSP  DCSP del _wsgi_intercept[key]
 DCSP TraversalSpec = vmodl.query.PropertyCollector.TraversalSpec DCNL DCSP SelectionSpec = vmodl.query.PropertyCollector.SelectionSpec DCNL DCSP rpToRp = TraversalSpec(name='rpToRp', type=vim.ResourcePool, path='resourcePool', skip=False) DCNL DCSP rpToRp.selectSet.extend((SelectionSpec(name='rpToRp'), SelectionSpec(name='rpToVm'))) DCNL DCSP rpToVm = TraversalSpec(name='rpToVm', type=vim.ResourcePool, path='vm', skip=False) DCNL DCSP crToRp = TraversalSpec(name='crToRp', type=vim.ComputeResource, path='resourcePool', skip=False) DCNL DCSP crToRp.selectSet.extend((SelectionSpec(name='rpToRp'), SelectionSpec(name='rpToVm'))) DCNL DCSP crToH = TraversalSpec(name='crToH', type=vim.ComputeResource, path='host', skip=False) DCNL DCSP dcToHf = TraversalSpec(name='dcToHf', type=vim.Datacenter, path='hostFolder', skip=False) DCNL DCSP dcToHf.selectSet.extend((SelectionSpec(name='visitFolders'),)) DCNL DCSP dcToVmf = TraversalSpec(name='dcToVmf', type=vim.Datacenter, path='vmFolder', skip=False) DCNL DCSP dcToVmf.selectSet.extend((SelectionSpec(name='visitFolders'),)) DCNL DCSP dcToNet = TraversalSpec(name='dcToNet', type=vim.Datacenter, path='networkFolder', skip=False) DCNL DCSP dcToNet.selectSet.extend((SelectionSpec(name='visitFolders'),)) DCNL DCSP dcToDs = TraversalSpec(name='dcToDs', type=vim.Datacenter, path='datastore', skip=False) DCNL DCSP dcToDs.selectSet.extend((SelectionSpec(name='visitFolders'),)) DCNL DCSP hToVm = TraversalSpec(name='hToVm', type=vim.HostSystem, path='vm', skip=False) DCNL DCSP hToVm.selectSet.extend((SelectionSpec(name='visitFolders'),)) DCNL DCSP visitFolders = TraversalSpec(name='visitFolders', type=vim.Folder, path='childEntity', skip=False) DCNL DCSP visitFolders.selectSet.extend((SelectionSpec(name='visitFolders'), SelectionSpec(name='dcToHf'), SelectionSpec(name='dcToVmf'), SelectionSpec(name='dcToNet'), SelectionSpec(name='crToH'), SelectionSpec(name='crToRp'), SelectionSpec(name='dcToDs'), SelectionSpec(name='hToVm'), SelectionSpec(name='rpToVm'))) DCNL DCSP fullTraversal = SelectionSpec.Array((visitFolders, dcToHf, dcToVmf, dcToNet, crToH, crToRp, dcToDs, rpToRp, hToVm, rpToVm)) DCNL DCSP return fullTraversal
 DCSP cmdline = cmdline.encode('ascii') DCNL DCSP logging.info(("Running DCSP cmd DCSP '%s'" % cmdline)) DCNL DCSP kwargs = {} DCNL DCSP kwargs['stdout'] = ((stdout and subprocess.PIPE) or None) DCNL DCSP kwargs['stderr'] = ((stderr and subprocess.PIPE) or None) DCNL DCSP kwargs['stdin'] = ((stdin and subprocess.PIPE) or None) DCNL DCSP kwargs['universal_newlines'] = universal_newlines DCNL DCSP args = shlex.split(cmdline) DCNL DCSP logging.info(("Running DCSP args DCSP '%s'" % args)) DCNL DCSP proc = subprocess.Popen(args, **kwargs) DCNL DCSP return proc
 DCSP if salt.utils.is_windows(): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, 'Module DCSP cyg: DCSP module DCSP only DCSP works DCSP on DCSP Windows DCSP systems.')
 DCSP addHandler(logging.StreamHandler(stream=sys.stdout))
 DCSP action = 'snapshot' DCNL DCSP action_class = CLASS_MAP[action] DCNL DCSP c_args = ctx.obj['config']['client'] DCNL DCSP client = get_client(**c_args) DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP raw_options = {'repository': repository, 'name': name, 'ignore_unavailable': ignore_unavailable, 'include_global_state': include_global_state, 'partial': partial, 'skip_repo_fs_check': skip_repo_fs_check, 'wait_for_completion': wait_for_completion} DCNL DCSP logger.debug('Validating DCSP provided DCSP options: DCSP {0}'.format(raw_options)) DCNL DCSP mykwargs = option_schema_check(action, raw_options) DCNL DCSP logger.debug('Validating DCSP provided DCSP filters: DCSP {0}'.format(filter_list)) DCNL DCSP clean_filters = {'filters': filter_schema_check(action, filter_list)} DCNL DCSP ilo = IndexList(client) DCNL DCSP _do_filters(ilo, clean_filters, ignore_empty_list) DCNL DCSP action_obj = action_class(ilo, **mykwargs) DCNL DCSP _actionator(action, action_obj, dry_run=ctx.parent.params['dry_run'])
 DCSP add_message(request, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP base_param(registry, xml_parent, data, True, 'hudson.model.StringParameterDefinition')
 DCSP (type, subtype, params) = parse_mime_type(range) DCNL DCSP if ((not params.has_key('q')) or (not params['q']) or (not float(params['q'])) or (float(params['q']) > 1) or (float(params['q']) < 0)): DCNL DCSP  DCSP params['q'] = '1' DCNL DCSP return (type, subtype, params)
 DCSP isfile = os.path.isfile DCNL DCSP if isfile(filename): DCNL DCSP  DCSP return filename DCNL DCSP orig = copy.copy(filename) DCNL DCSP extensions = ('.jpg', '.png', '.tif', '.bmp', '.gif', '.jpeg', '.tiff') DCNL DCSP def logCorrected(orig, actual): DCNL DCSP  DCSP logging.warn('Requested DCSP image DCSP {!r} DCSP not DCSP found DCSP but DCSP similar DCSP filename DCSP {!r} DCSP exists. DCSP This DCSP will DCSP be DCSP used DCSP instead DCSP but DCSP changing DCSP the DCSP filename DCSP is DCSP advised.'.format(orig, actual)) DCNL DCSP if filename.endswith(extensions): DCNL DCSP  DCSP filename = os.path.splitext(orig)[0] DCNL DCSP if isfile(filename): DCNL DCSP  DCSP logCorrected(orig, filename) DCNL DCSP  DCSP return filename DCNL DCSP for ext in extensions: DCNL DCSP  DCSP if isfile((filename + ext)): DCNL DCSP  DCSP  DCSP filename += ext DCNL DCSP  DCSP  DCSP logCorrected(orig, filename) DCNL DCSP  DCSP  DCSP return filename
 DCSP tmp = _asfarray(x) DCNL DCSP if (not numpy.isrealobj(tmp)): DCNL DCSP  DCSP raise TypeError('1st DCSP argument DCSP must DCSP be DCSP real DCSP sequence') DCNL DCSP try: DCNL DCSP  DCSP work_function = _DTYPE_TO_RFFT[tmp.dtype] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('type DCSP %s DCSP is DCSP not DCSP supported' % tmp.dtype)) DCNL DCSP overwrite_x = (overwrite_x or _datacopied(tmp, x)) DCNL DCSP return _raw_fft(tmp, n, axis, 1, overwrite_x, work_function)
 DCSP def check_login(self, *args, **kwargs): DCNL DCSP  DCSP if (self.request.method != 'GET'): DCNL DCSP  DCSP  DCSP self.abort(400, detail='The DCSP login_required DCSP decorator DCSP can DCSP only DCSP be DCSP used DCSP for DCSP GET DCSP requests.') DCNL DCSP  DCSP user = users.get_current_user() DCNL DCSP  DCSP if (not user): DCNL DCSP  DCSP  DCSP return self.redirect(users.create_login_url(self.request.url)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP handler_method(self, *args, **kwargs) DCNL DCSP return check_login
 DCSP global FORMAT_WRITERS DCNL DCSP if (FORMAT_WRITERS is None): DCNL DCSP  DCSP _import_writers() DCNL DCSP return FORMAT_WRITERS.get(extension, None)
 DCSP results = {} DCNL DCSP for integrator in ['dopri5', 'dop853', 'vode', 'lsoda']: DCNL DCSP  DCSP discrete_soln = model.solve(t0, k0, h=1.0, g=g, tol=tol, integrator=integrator, atol=1e-14, rtol=1e-11) DCNL DCSP  DCSP results[integrator] = discrete_soln DCNL DCSP return results
 DCSP def step(ctxt, ndx, value): DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP ctxt[ndx] = value DCNL DCSP def finalize(ctxt): DCNL DCSP  DCSP if (len(ctxt) == 0): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return sep.join(map(ctxt.get, sorted(ctxt.iterkeys()))) DCNL DCSP return ({}, step, finalize)
 DCSP headers = {} DCNL DCSP if accept_encoding: DCNL DCSP  DCSP if isinstance(accept_encoding, str): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif isinstance(accept_encoding, list): DCNL DCSP  DCSP  DCSP accept_encoding = ','.join(accept_encoding) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP accept_encoding = 'gzip,deflate' DCNL DCSP  DCSP headers['accept-encoding'] = accept_encoding DCNL DCSP if user_agent: DCNL DCSP  DCSP headers['user-agent'] = user_agent DCNL DCSP if keep_alive: DCNL DCSP  DCSP headers['connection'] = 'keep-alive' DCNL DCSP if basic_auth: DCNL DCSP  DCSP headers['authorization'] = ('Basic DCSP ' + b64encode(six.b(basic_auth)).decode('utf-8')) DCNL DCSP if proxy_basic_auth: DCNL DCSP  DCSP headers['proxy-authorization'] = ('Basic DCSP ' + b64encode(six.b(proxy_basic_auth)).decode('utf-8')) DCNL DCSP return headers
 DCSP def take(seq, n): DCNL DCSP  DCSP for i in xrange(n): DCNL DCSP  DCSP  DCSP (yield seq.next()) DCNL DCSP if (not hasattr(seq, 'next')): DCNL DCSP  DCSP seq = iter(seq) DCNL DCSP while True: DCNL DCSP  DCSP x = list(take(seq, size)) DCNL DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP (yield x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
 DCSP if (name.lower() in LOGGER_SENSITIVE_HEADERS): DCNL DCSP  DCSP prefix_length = logger_settings.get('reveal_sensitive_prefix', 16) DCNL DCSP  DCSP prefix_length = int(min(prefix_length, ((len(value) ** 2) / 32), (len(value) / 2))) DCNL DCSP  DCSP redacted_value = value[0:prefix_length] DCNL DCSP  DCSP return (redacted_value + '...') DCNL DCSP return value
 DCSP if (sys.version_info.major < 3): DCNL DCSP  DCSP if isinstance(string, unicode): DCNL DCSP  DCSP  DCSP string = string.encode(u'utf8') DCNL DCSP  DCSP string = urllib.quote(string, safe.encode(u'utf8')) DCNL DCSP else: DCNL DCSP  DCSP string = urllib.parse.quote(str(string), safe) DCNL DCSP return string
 DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP conn.delete_cache_subnet_group(name) DCNL DCSP  DCSP msg = 'Deleted DCSP ElastiCache DCSP subnet DCSP group DCSP {0}.'.format(name) DCNL DCSP  DCSP log.info(msg) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP delete DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
 DCSP if (SETTINGS.env_name is not None): DCNL DCSP  DCSP return (SETTINGS.env_name == 'GCE_PRODUCTION') DCNL DCSP if ((NO_GCE_CHECK != 'True') and _detect_gce_environment()): DCNL DCSP  DCSP SETTINGS.env_name = 'GCE_PRODUCTION' DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP old = vm.logfile DCNL DCSP if (old == stdout): DCNL DCSP  DCSP log('* DCSP Temporarily DCSP disabling DCSP logging DCSP to DCSP stdout') DCNL DCSP  DCSP vm.logfile = None DCNL DCSP log('* DCSP Switching DCSP to DCSP interactive DCSP use DCSP - DCSP press DCSP control-] DCSP to DCSP exit') DCNL DCSP vm.interact() DCNL DCSP if (old == stdout): DCNL DCSP  DCSP log('* DCSP Restoring DCSP logging DCSP to DCSP stdout') DCNL DCSP  DCSP vm.logfile = stdout
 DCSP if ((a == datashape.var) or (b == datashape.var)): DCNL DCSP  DCSP return datashape.var DCNL DCSP if isinstance(a, Fixed): DCNL DCSP  DCSP a = int(a) DCNL DCSP if isinstance(b, Fixed): DCNL DCSP  DCSP b = int(b) DCNL DCSP return int((a * b))
 DCSP time_micros = dts._get_time_micros() DCNL DCSP start_micros = _time_to_micros(start) DCNL DCSP end_micros = _time_to_micros(end) DCNL DCSP (left_op, right_op, join_op) = _opmap[(bool(include_start), bool(include_end), (start_micros <= end_micros))] DCNL DCSP return join_op(left_op(start_micros, time_micros), right_op(time_micros, end_micros))
 DCSP xk = np.atleast_1d(xk) DCNL DCSP fc = [0] DCNL DCSP def phi(alpha1): DCNL DCSP  DCSP fc[0] += 1 DCNL DCSP  DCSP return f((xk + (alpha1 * pk)), *args) DCNL DCSP if (old_fval is None): DCNL DCSP  DCSP phi0 = phi(0.0) DCNL DCSP else: DCNL DCSP  DCSP phi0 = old_fval DCNL DCSP derphi0 = np.dot(gfk, pk) DCNL DCSP (alpha, phi1) = scalar_search_armijo(phi, phi0, derphi0, c1=c1, alpha0=alpha0) DCNL DCSP return (alpha, fc[0], phi1)
 DCSP java_args = {} DCNL DCSP java_args['compile_dir'] = _TMP_COMPILE_DIR DCNL DCSP java_args['app_dir'] = _DEFAULT_APP_DIR DCNL DCSP java_args['gwt_dir'] = find_gwt_dir() DCNL DCSP java_args['extra_args'] = extra_args DCNL DCSP java_args['project_client'] = project_client DCNL DCSP cmd = (_COMPILE_LINE % java_args) DCNL DCSP logging.info('Compiling DCSP client DCSP %s', project_client) DCNL DCSP try: DCNL DCSP  DCSP utils.run(cmd, verbose=True) DCNL DCSP  DCSP if install_client: DCNL DCSP  DCSP  DCSP return install_completed_client(java_args['compile_dir'], project_client) DCNL DCSP  DCSP return True DCNL DCSP except error.CmdError: DCNL DCSP  DCSP logging.info('Error DCSP compiling DCSP %s, DCSP leaving DCSP old DCSP client', project_client) DCNL DCSP return False
 DCSP params = ([] if (params is None) else params) DCNL DCSP extra = (['command={0}'.format(command)] + params) DCNL DCSP url = _format_url('replication', host=host, core_name=core_name, extra=extra) DCNL DCSP return _http_request(url)
 DCSP return option_list[option]
 DCSP if (threadingmodule is not None): DCNL DCSP  DCSP for klass in klasses: DCNL DCSP  DCSP  DCSP for methodName in klass.synchronized: DCNL DCSP  DCSP  DCSP  DCSP sync = _sync(klass, klass.__dict__[methodName]) DCNL DCSP  DCSP  DCSP  DCSP setattr(klass, methodName, sync)
 DCSP if (not salt.utils.is_windows()): DCNL DCSP  DCSP return (False, u'Module DCSP PSGet: DCSP Module DCSP only DCSP works DCSP on DCSP Windows DCSP systems') DCNL DCSP powershell_info = __salt__[u'cmd.shell_info'](u'powershell') DCNL DCSP if ((not powershell_info[u'installed']) or (distutils.version.StrictVersion(powershell_info[u'version']) >= distutils.version.StrictVersion(u'5.0'))): DCNL DCSP  DCSP return (False, u'Module DCSP DSC: DCSP Module DCSP only DCSP works DCSP with DCSP PowerShell DCSP 5 DCSP or DCSP newer.') DCNL DCSP return __virtualname__
 DCSP if include_headers: DCNL DCSP  DCSP include_headers = tuple((to_bytes(h.lower()) for h in sorted(include_headers))) DCNL DCSP cache = _fingerprint_cache.setdefault(request, {}) DCNL DCSP if (include_headers not in cache): DCNL DCSP  DCSP fp = hashlib.sha1() DCNL DCSP  DCSP fp.update(to_bytes(request.method)) DCNL DCSP  DCSP fp.update(to_bytes(canonicalize_url(request.url))) DCNL DCSP  DCSP fp.update((request.body or '')) DCNL DCSP  DCSP if include_headers: DCNL DCSP  DCSP  DCSP for hdr in include_headers: DCNL DCSP  DCSP  DCSP  DCSP if (hdr in request.headers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fp.update(hdr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for v in request.headers.getlist(hdr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.update(v) DCNL DCSP  DCSP cache[include_headers] = fp.hexdigest() DCNL DCSP return cache[include_headers]
 DCSP parsed = [] DCNL DCSP while (tokens.current() is not None): DCNL DCSP  DCSP if (tokens.current() == '--'): DCNL DCSP  DCSP  DCSP return (parsed + [Argument(None, v) for v in tokens]) DCNL DCSP  DCSP elif tokens.current().startswith('--'): DCNL DCSP  DCSP  DCSP parsed += parse_long(tokens, options) DCNL DCSP  DCSP elif (tokens.current().startswith('-') and (tokens.current() != '-')): DCNL DCSP  DCSP  DCSP parsed += parse_shorts(tokens, options) DCNL DCSP  DCSP elif options_first: DCNL DCSP  DCSP  DCSP return (parsed + [Argument(None, v) for v in tokens]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parsed.append(Argument(None, tokens.move())) DCNL DCSP return parsed
 DCSP namespaced_key = '.'.join([namespace, key]) DCNL DCSP return namespaced_key
 DCSP args = _parse_args() DCNL DCSP if (args.pkl is not None): DCNL DCSP  DCSP dataset = serial.load(args.pkl) DCNL DCSP else: DCNL DCSP  DCSP dataset = NORB(args.which_norb, args.which_set) DCNL DCSP grid_indices = ([0] * 5) DCNL DCSP grid_to_short_label = _make_grid_to_short_label(dataset) DCNL DCSP label_to_row_indices = _make_label_to_row_indices(dataset.y) DCNL DCSP object_image_index = [0] DCNL DCSP blank_image_index = [0] DCNL DCSP blank_label = _get_blank_label(dataset) DCNL DCSP grid_dimension = [0] DCNL DCSP dataset_is_stereo = ('s' in dataset.view_converter.axes) DCNL DCSP (figure, all_axes) = pyplot.subplots(1, (3 if dataset_is_stereo else 2), squeeze=True, figsize=(10, 3.5)) DCNL DCSP set_name = (os.path.split(args.pkl)[1] if (args.which_set is None) else ('%sing DCSP set' % args.which_set)) DCNL DCSP figure.canvas.set_window_title(('NORB DCSP dataset DCSP (%s)' % set_name)) DCNL DCSP label_text = figure.suptitle('Up/down DCSP arrows DCSP choose DCSP label, DCSP left/right DCSP arrows DCSP change DCSP it', x=0.1, horizontalalignment='left') DCNL DCSP for axes in all_axes: DCNL DCSP  DCSP axes.get_xaxis().set_visible(False) DCNL DCSP  DCSP axes.get_yaxis().set_visible(False) DCNL DCSP (text_axes, image_axes) = (all_axes[0], all_axes[1:]) DCNL DCSP image_captions = (('left', 'right') if dataset_is_stereo else ('mono DCSP image',)) DCNL DCSP if args.stereo_viewer: DCNL DCSP  DCSP image_captions = tuple(reversed(image_captions)) DCNL DCSP for (image_ax, caption) in safe_zip(image_axes, image_captions): DCNL DCSP  DCSP image_ax.set_title(caption) DCNL DCSP text_axes.set_frame_on(False) DCNL DCSP def is_blank(grid_indices): DCNL DCSP  DCSP assert (len(grid_indices) == 5) DCNL DCSP  DCSP assert all(((x >= 0) for x in grid_indices)) DCNL DCSP  DCSP ci = dataset.label_name_to_index['category'] DCNL DCSP  DCSP category = grid_to_short_label[ci][grid_indices[ci]] DCNL DCSP  DCSP category_name = dataset.label_to_value_funcs[ci](category) DCNL DCSP  DCSP return (category_name == 'blank') DCNL DCSP def get_short_label(grid_indices): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP first DCSP 5 DCSP elements DCSP of DCSP the DCSP label DCSP vector DCSP pointed DCSP to DCSP by\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP grid_indices. DCSP We DCSP use DCSP the DCSP first DCSP 5, DCSP since DCSP they're DCSP the DCSP labels DCSP used DCSP by\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP both DCSP the DCSP 'big' DCSP and DCSP Small DCSP NORB DCSP datasets.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if is_blank(grid_indices): DCNL DCSP  DCSP  DCSP return tuple(blank_label[:5]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return tuple((grid_to_short_label[i][g] for (i, g) in enumerate(grid_indices))) DCNL DCSP def get_row_indices(grid_indices): DCNL DCSP  DCSP short_label = get_short_label(grid_indices) DCNL DCSP  DCSP return label_to_row_indices.get(short_label, None) DCNL DCSP axes_to_pixels = {} DCNL DCSP def redraw(redraw_text, redraw_images): DCNL DCSP  DCSP row_indices = get_row_indices(grid_indices) DCNL DCSP  DCSP if (row_indices is None): DCNL DCSP  DCSP  DCSP row_index = None DCNL DCSP  DCSP  DCSP image_index = 0 DCNL DCSP  DCSP  DCSP num_images = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_index = (blank_image_index if is_blank(grid_indices) else object_image_index)[0] DCNL DCSP  DCSP  DCSP row_index = row_indices[image_index] DCNL DCSP  DCSP  DCSP num_images = len(row_indices) DCNL DCSP  DCSP def draw_text(): DCNL DCSP  DCSP  DCSP if (row_indices is None): DCNL DCSP  DCSP  DCSP  DCSP padding_length = (dataset.y.shape[1] - len(grid_indices)) DCNL DCSP  DCSP  DCSP  DCSP current_label = (tuple(get_short_label(grid_indices)) + ((0,) * padding_length)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current_label = dataset.y[row_index, :] DCNL DCSP  DCSP  DCSP label_names = dataset.label_index_to_name DCNL DCSP  DCSP  DCSP label_values = [label_to_value(label) for (label_to_value, label) in safe_zip(dataset.label_to_value_funcs, current_label)] DCNL DCSP  DCSP  DCSP lines = [('%s: DCSP %s' % (t, v)) for (t, v) in safe_zip(label_names, label_values)] DCNL DCSP  DCSP  DCSP if (dataset.y.shape[1] > 5): DCNL DCSP  DCSP  DCSP  DCSP lines = ((lines[:5] + [('No DCSP such DCSP image' if (num_images == 0) else ('image: DCSP %d DCSP of DCSP %d' % ((image_index + 1), num_images))), '\n']) + lines[5:]) DCNL DCSP  DCSP  DCSP lines[grid_dimension[0]] = ('==> DCSP ' + lines[grid_dimension[0]]) DCNL DCSP  DCSP  DCSP text_axes.clear() DCNL DCSP  DCSP  DCSP text_axes.text(0, 0.5, '\n'.join(lines), verticalalignment='center', transform=text_axes.transAxes) DCNL DCSP  DCSP def draw_images(): DCNL DCSP  DCSP  DCSP if (row_indices is None): DCNL DCSP  DCSP  DCSP  DCSP for axis in image_axes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP axis.clear() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP data_row = dataset.X[row_index:(row_index + 1), :] DCNL DCSP  DCSP  DCSP  DCSP axes_names = dataset.view_converter.axes DCNL DCSP  DCSP  DCSP  DCSP assert (len(axes_names) in (4, 5)) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[0] == 'b') DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-3)] == 0) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-2)] == 1) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-1)] == 'c') DCNL DCSP  DCSP  DCSP  DCSP def draw_image(image, axes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (len(image.shape) == 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP norm = (matplotlib.colors.NoNorm() if args.no_norm else None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP axes_to_pixels[axes] = image DCNL DCSP  DCSP  DCSP  DCSP  DCSP axes.imshow(image, norm=norm, cmap='gray') DCNL DCSP  DCSP  DCSP  DCSP if ('s' in axes_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_pair = dataset.get_topological_view(mat=data_row, single_tensor=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_pair = tuple(image_pair[0, :, :, :, 0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if args.stereo_viewer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_pair = tuple(reversed(image_pair)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (axis, image) in safe_zip(image_axes, image_pair): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP draw_image(image, axis) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image = dataset.get_topological_view(mat=data_row) DCNL DCSP  DCSP  DCSP  DCSP  DCSP image = image[0, :, :, 0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP draw_image(image, image_axes[0]) DCNL DCSP  DCSP if redraw_text: DCNL DCSP  DCSP  DCSP draw_text() DCNL DCSP  DCSP if redraw_images: DCNL DCSP  DCSP  DCSP draw_images() DCNL DCSP  DCSP figure.canvas.draw() DCNL DCSP default_status_text = ('mouseover DCSP image%s DCSP for DCSP pixel DCSP values' % ('' if (len(image_axes) == 1) else 's')) DCNL DCSP status_text = figure.text(0.5, 0.1, default_status_text) DCNL DCSP def on_mouse_motion(event): DCNL DCSP  DCSP original_text = status_text.get_text() DCNL DCSP  DCSP if (event.inaxes not in image_axes): DCNL DCSP  DCSP  DCSP status_text.set_text(default_status_text) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pixels = axes_to_pixels[event.inaxes] DCNL DCSP  DCSP  DCSP row = int((event.ydata + 0.5)) DCNL DCSP  DCSP  DCSP col = int((event.xdata + 0.5)) DCNL DCSP  DCSP  DCSP status_text.set_text(('Pixel DCSP value: DCSP %g' % pixels[(row, col)])) DCNL DCSP  DCSP if (status_text.get_text != original_text): DCNL DCSP  DCSP  DCSP figure.canvas.draw() DCNL DCSP def on_key_press(event): DCNL DCSP  DCSP def add_mod(arg, step, size): DCNL DCSP  DCSP  DCSP return (((arg + size) + step) % size) DCNL DCSP  DCSP def incr_index_type(step): DCNL DCSP  DCSP  DCSP num_dimensions = len(grid_indices) DCNL DCSP  DCSP  DCSP if (dataset.y.shape[1] > 5): DCNL DCSP  DCSP  DCSP  DCSP num_dimensions += 1 DCNL DCSP  DCSP  DCSP grid_dimension[0] = add_mod(grid_dimension[0], step, num_dimensions) DCNL DCSP  DCSP def incr_index(step): DCNL DCSP  DCSP  DCSP assert (step in (0, (-1), 1)), ('Step DCSP was DCSP %d' % step) DCNL DCSP  DCSP  DCSP image_index = (blank_image_index if is_blank(grid_indices) else object_image_index) DCNL DCSP  DCSP  DCSP if (grid_dimension[0] == 5): DCNL DCSP  DCSP  DCSP  DCSP row_indices = get_row_indices(grid_indices) DCNL DCSP  DCSP  DCSP  DCSP if (row_indices is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_index[0] = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_index[0] = add_mod(image_index[0], step, len(row_indices)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP gd = grid_dimension[0] DCNL DCSP  DCSP  DCSP  DCSP grid_indices[gd] = add_mod(grid_indices[gd], step, len(grid_to_short_label[gd])) DCNL DCSP  DCSP  DCSP  DCSP row_indices = get_row_indices(grid_indices) DCNL DCSP  DCSP  DCSP  DCSP if (row_indices is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_index[0] = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_index[0] = min(image_index[0], len(row_indices)) DCNL DCSP  DCSP disable_left_right = (is_blank(grid_indices) and (not (grid_dimension[0] in (0, 5)))) DCNL DCSP  DCSP if (event.key == 'up'): DCNL DCSP  DCSP  DCSP incr_index_type((-1)) DCNL DCSP  DCSP  DCSP redraw(True, False) DCNL DCSP  DCSP elif (event.key == 'down'): DCNL DCSP  DCSP  DCSP incr_index_type(1) DCNL DCSP  DCSP  DCSP redraw(True, False) DCNL DCSP  DCSP elif (event.key == 'q'): DCNL DCSP  DCSP  DCSP sys.exit(0) DCNL DCSP  DCSP elif (not disable_left_right): DCNL DCSP  DCSP  DCSP if (event.key == 'left'): DCNL DCSP  DCSP  DCSP  DCSP incr_index((-1)) DCNL DCSP  DCSP  DCSP  DCSP redraw(True, True) DCNL DCSP  DCSP  DCSP elif (event.key == 'right'): DCNL DCSP  DCSP  DCSP  DCSP incr_index(1) DCNL DCSP  DCSP  DCSP  DCSP redraw(True, True) DCNL DCSP figure.canvas.mpl_connect('key_press_event', on_key_press) DCNL DCSP figure.canvas.mpl_connect('motion_notify_event', on_mouse_motion) DCNL DCSP redraw(True, True) DCNL DCSP pyplot.show()
 DCSP from sklearn.svm import SVC DCNL DCSP from sklearn.base import is_classifier DCNL DCSP from sklearn.kernel_ridge import KernelRidge DCNL DCSP from sklearn.preprocessing import LabelEncoder DCNL DCSP from sklearn.metrics import roc_auc_score, mean_squared_error DCNL DCSP epochs = make_epochs() DCNL DCSP y_4classes = np.hstack((epochs.events[:7, 2], (epochs.events[7:, 2] + 1))) DCNL DCSP if check_version('sklearn', '0.18'): DCNL DCSP  DCSP from sklearn.model_selection import KFold, StratifiedKFold, ShuffleSplit, LeaveOneGroupOut DCNL DCSP  DCSP cv = LeaveOneGroupOut() DCNL DCSP  DCSP cv_shuffle = ShuffleSplit() DCNL DCSP  DCSP cv_lolo = [(train, test) for (train, test) in cv.split(y_4classes, y_4classes, y_4classes)] DCNL DCSP  DCSP scorer_regress = None DCNL DCSP else: DCNL DCSP  DCSP from sklearn.cross_validation import KFold, StratifiedKFold, ShuffleSplit, LeaveOneLabelOut DCNL DCSP  DCSP cv_shuffle = ShuffleSplit(len(epochs)) DCNL DCSP  DCSP cv_lolo = LeaveOneLabelOut(y_4classes) DCNL DCSP  DCSP scorer_regress = mean_squared_error DCNL DCSP gat = GeneralizationAcrossTime(picks='foo') DCNL DCSP assert_equal('<GAT DCSP | DCSP no DCSP fit, DCSP no DCSP prediction, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP assert_raises(ValueError, gat.fit, epochs) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.picks = [0] DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP  DCSP gat.picks = None DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2]) DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2].tolist()) DCNL DCSP assert_equal(len(gat.picks_), len(gat.ch_names), 1) DCNL DCSP assert_equal('<GAT DCSP | DCSP fitted, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP no DCSP prediction, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP assert_equal(gat.ch_names, epochs.ch_names) DCNL DCSP gat = GeneralizationAcrossTime(predict_method='decision_function') DCNL DCSP gat.fit(epochs) DCNL DCSP assert_true((gat.cv_.__class__ == StratifiedKFold)) DCNL DCSP gat.predict(epochs) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_), (15, 15, 14, 1)) DCNL DCSP gat.predict_method = 'predict_proba' DCNL DCSP gat.predict(epochs) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_), (15, 15, 14, 2)) DCNL DCSP gat.predict_method = 'foo' DCNL DCSP assert_raises(NotImplementedError, gat.predict, epochs) DCNL DCSP gat.predict_method = 'predict' DCNL DCSP gat.predict(epochs) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_), (15, 15, 14, 1)) DCNL DCSP assert_equal('<GAT DCSP | DCSP fitted, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP predicted DCSP 14 DCSP epochs, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP gat.score(epochs) DCNL DCSP assert_true((gat.scorer_.__name__ == 'accuracy_score')) DCNL DCSP gat.scorer = None DCNL DCSP gat.predict_method = 'decision_function' DCNL DCSP assert_raises(ValueError, gat.score, epochs) DCNL DCSP gat.predict_method = 'predict' DCNL DCSP gat.score(epochs, y=epochs.events[:, 2]) DCNL DCSP gat.score(epochs, y=epochs.events[:, 2].tolist()) DCNL DCSP assert_equal('<GAT DCSP | DCSP fitted, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP predicted DCSP 14 DCSP epochs,\n DCSP scored DCSP (accuracy_score)>', ('%s' % gat)) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2]) DCNL DCSP old_mode = gat.predict_mode DCNL DCSP gat.predict_mode = 'super-foo-mode' DCNL DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP gat.predict_mode = old_mode DCNL DCSP gat.score(epochs, y=epochs.events[:, 2]) DCNL DCSP assert_true(('accuracy_score' in ('%s' % gat.scorer_))) DCNL DCSP epochs2 = epochs.copy() DCNL DCSP assert_equal('<DecodingTime DCSP | DCSP start: DCSP -0.200 DCSP (s), DCSP stop: DCSP 0.499 DCSP (s), DCSP step: DCSP 0.050 DCSP (s), DCSP length: DCSP 0.050 DCSP (s), DCSP n_time_windows: DCSP 15>', ('%s' % gat.train_times_)) DCNL DCSP assert_equal('<DecodingTime DCSP | DCSP start: DCSP -0.200 DCSP (s), DCSP stop: DCSP 0.499 DCSP (s), DCSP step: DCSP 0.050 DCSP (s), DCSP length: DCSP 0.050 DCSP (s), DCSP n_time_windows: DCSP 15 DCSP x DCSP 15>', ('%s' % gat.test_times_)) DCNL DCSP gat.predict_mode = 'mean-prediction' DCNL DCSP epochs2.events[:, 2] += 10 DCNL DCSP gat_ = copy.deepcopy(gat) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat_.score, epochs2) DCNL DCSP gat.predict_mode = 'cross-validation' DCNL DCSP assert_true((gat.y_train_.shape[0] == gat.y_true_.shape[0] == len(gat.y_pred_[0][0]) == 14)) DCNL DCSP assert_true((np.shape(gat.estimators_)[1] == gat.cv)) DCNL DCSP assert_true((len(gat.train_times_['slices']) == 15 == np.shape(gat.estimators_)[0])) DCNL DCSP assert_true((len(gat.test_times_['slices']) == 15 == np.shape(gat.scores_)[0])) DCNL DCSP assert_true((len(gat.test_times_['slices'][0]) == 15 == np.shape(gat.scores_)[1])) DCNL DCSP gat.score_mode = 'foo' DCNL DCSP assert_raises(ValueError, gat.score, epochs) DCNL DCSP gat.score_mode = 'fold-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_equal(np.shape(scores), [15, 15, 5]) DCNL DCSP gat.score_mode = 'mean-sample-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_equal(np.shape(scores), [15, 15]) DCNL DCSP gat.score_mode = 'mean-fold-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_equal(np.shape(scores), [15, 15]) DCNL DCSP gat.predict_mode = 'mean-prediction' DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP  DCSP assert_true(any((('score_mode DCSP changed DCSP from DCSP ' in str(ww.message)) for ww in w))) DCNL DCSP gat = GeneralizationAcrossTime(train_times={'length': 0.1}) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat2 = gat.fit(epochs) DCNL DCSP assert_true((gat is gat2)) DCNL DCSP assert_true(hasattr(gat2, 'cv_')) DCNL DCSP assert_true((gat2.cv_ != gat.cv)) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP scores = gat.score(epochs) DCNL DCSP assert_true(isinstance(scores, np.ndarray)) DCNL DCSP assert_equal(len(scores[0]), len(scores)) DCNL DCSP assert_equal(len(gat.test_times_['slices'][0][0]), 2) DCNL DCSP gat = GeneralizationAcrossTime(train_times={'step': 0.1}) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP gat.score(epochs) DCNL DCSP assert_true((len(gat.scores_) == len(gat.estimators_) == 8)) DCNL DCSP assert_equal(len(gat.scores_[0]), 15) DCNL DCSP y_4classes = np.hstack((epochs.events[:7, 2], (epochs.events[7:, 2] + 1))) DCNL DCSP train_times = dict(start=0.09, stop=0.25) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_lolo, train_times=train_times) DCNL DCSP assert_raises(RuntimeError, gat.predict, epochs) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs, y=y_4classes) DCNL DCSP gat.score(epochs) DCNL DCSP assert_equal(len(gat.scores_), 4) DCNL DCSP assert_equal(gat.train_times_['times'][0], epochs.times[6]) DCNL DCSP assert_equal(gat.train_times_['times'][(-1)], epochs.times[9]) DCNL DCSP gat = GeneralizationAcrossTime(test_times='diagonal') DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP assert_raises(RuntimeError, gat.score) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.predict(epochs) DCNL DCSP scores = gat.score() DCNL DCSP assert_true((scores is gat.scores_)) DCNL DCSP assert_equal(np.shape(gat.scores_), (15, 1)) DCNL DCSP assert_array_equal([tim for ttime in gat.test_times_['times'] for tim in ttime], gat.train_times_['times']) DCNL DCSP gat = GeneralizationAcrossTime(predict_mode='mean-prediction', cv=2) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs[0:6]) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.predict(epochs[7:]) DCNL DCSP  DCSP gat.score(epochs[7:]) DCNL DCSP gat_ = copy.deepcopy(gat) DCNL DCSP gat_.train_times = dict(start=(-999.0)) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = dict(start=999.0) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = dict(step=1e-06) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = dict(length=1e-06) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = dict(length=999.0) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat.test_times = dict(start=(-999.0)) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP gat.test_times = dict(start=999.0) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP gat.test_times = dict(step=1e-06) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP gat_ = copy.deepcopy(gat) DCNL DCSP gat_.train_times_['length'] = 1e-06 DCNL DCSP gat_.test_times = dict(length=1e-06) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, gat_.predict, epochs) DCNL DCSP gat.test_times = dict(step=0.15) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.predict(epochs) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_), (15, 5, 14, 1)) DCNL DCSP gat.test_times = 'foo' DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP assert_raises(RuntimeError, gat.score) DCNL DCSP gat.test_times = dict(length=0.15) DCNL DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP train_times = dict(slices=[[0, 1], [1]]) DCNL DCSP test_times = dict(slices=[[[0, 1]], [[0], [1]]]) DCNL DCSP gat = GeneralizationAcrossTime(train_times=train_times, test_times=test_times) DCNL DCSP gat.fit(epochs) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_[0]), [1, len(epochs), 1]) DCNL DCSP assert_array_equal(np.shape(gat.y_pred_[1]), [2, len(epochs), 1]) DCNL DCSP gat.test_times = None DCNL DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP svc = SVC(C=1, kernel='linear', probability=True) DCNL DCSP gat = GeneralizationAcrossTime(clf=svc, predict_mode='mean-prediction') DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat.score, epochs2) DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP assert_true((0.0 <= np.min(scores) <= 1.0)) DCNL DCSP assert_true((0.0 <= np.max(scores) <= 1.0)) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_shuffle, predict_mode='cross-validation') DCNL DCSP gat.fit(epochs) DCNL DCSP assert_raises(ValueError, gat.predict, epochs) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_shuffle, predict_mode='mean-prediction') DCNL DCSP gat.fit(epochs) DCNL DCSP gat.predict(epochs) DCNL DCSP gat = GeneralizationAcrossTime() DCNL DCSP gat.fit(epochs) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP gat.predict(epochs) DCNL DCSP assert_raises(ValueError, gat.predict, epochs[:10]) DCNL DCSP gat._cv_splits[0] = [gat._cv_splits[0][0], np.empty(0)] DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP gat.predict(epochs) DCNL DCSP  DCSP assert_true((len(w) > 0)) DCNL DCSP  DCSP assert_true(any((('do DCSP not DCSP have DCSP any DCSP test DCSP epochs' in str(ww.message)) for ww in w))) DCNL DCSP gat = GeneralizationAcrossTime(cv=[([0], [1]), ([], [0])]) DCNL DCSP assert_raises(ValueError, gat.fit, epochs[:2]) DCNL DCSP if check_version('sklearn', '0.17'): DCNL DCSP  DCSP gat = GeneralizationAcrossTime(clf=KernelRidge(), cv=2) DCNL DCSP  DCSP epochs.crop(None, epochs.times[2]) DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP  DCSP assert_true((gat.cv_.__class__ == KFold)) DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP  DCSP assert_true((gat.scorer_.__name__ == 'mean_squared_error')) DCNL DCSP n_classes = [2, 4] DCNL DCSP le = LabelEncoder() DCNL DCSP y = le.fit_transform(epochs.events[:, 2]) DCNL DCSP y[(len(y) // 2):] += 2 DCNL DCSP ys = (y, (y + 1000)) DCNL DCSP svc = SVC(C=1, kernel='linear', probability=True) DCNL DCSP reg = KernelRidge() DCNL DCSP def scorer_proba(y_true, y_pred): DCNL DCSP  DCSP return roc_auc_score(y_true, y_pred[:, 0]) DCNL DCSP scorers = [None, scorer_proba, scorer_regress] DCNL DCSP predict_methods = [None, 'predict_proba', None] DCNL DCSP clfs = [svc, svc, reg] DCNL DCSP for (clf, predict_method, scorer) in zip(clfs, predict_methods, scorers): DCNL DCSP  DCSP for y in ys: DCNL DCSP  DCSP  DCSP for n_class in n_classes: DCNL DCSP  DCSP  DCSP  DCSP for predict_mode in ['cross-validation', 'mean-prediction']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((predict_method == 'predict_proba') and (n_class != 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP y_ = (y % n_class) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat = GeneralizationAcrossTime(cv=2, clf=clf, scorer=scorer, predict_mode=predict_mode) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat.fit(epochs, y=y_) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat.score(epochs, y=y_) DCNL DCSP  DCSP  DCSP  DCSP  DCSP scorer_name = gat.scorer_.__name__ DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (scorer is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if is_classifier(clf): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_equal(scorer_name, 'accuracy_score') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_equal(scorer_name, 'mean_squared_error') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_equal(scorer_name, scorer.__name__)
 DCSP z = atleast_1d(z) DCNL DCSP p = atleast_1d(p) DCNL DCSP wo = float(wo) DCNL DCSP degree = _relative_degree(z, p) DCNL DCSP z_hp = (wo / z) DCNL DCSP p_hp = (wo / p) DCNL DCSP z_hp = append(z_hp, zeros(degree)) DCNL DCSP k_hp = (k * real((prod((- z)) / prod((- p))))) DCNL DCSP return (z_hp, p_hp, k_hp)
 DCSP finder = _getfinder() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_00 = aetypes.ObjectSpecifier(want=aetypes.Type('cobj'), form='alis', seld=object_alias, fr=None) DCNL DCSP aeobj_01 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', seld=aetypes.Type('labi'), fr=aeobj_00) DCNL DCSP args['----'] = aeobj_01 DCNL DCSP (_reply, args, attrs) = finder.send('core', 'getd', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.decodeerror(args) DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP return args['----']
 DCSP if (ft == 'all'): DCNL DCSP  DCSP ft = '_' DCNL DCSP patterns = [('%s.snippets' % ft), os.path.join(ft, '*.snippets'), os.path.join(ft, '*.snippet'), os.path.join(ft, '*/*.snippet')] DCNL DCSP ret = set() DCNL DCSP for rtp in _vim.eval('&runtimepath').split(','): DCNL DCSP  DCSP path = os.path.realpath(os.path.expanduser(os.path.join(rtp, 'snippets'))) DCNL DCSP  DCSP for pattern in patterns: DCNL DCSP  DCSP  DCSP for fn in glob.glob(os.path.join(path, pattern)): DCNL DCSP  DCSP  DCSP  DCSP ret.add(fn) DCNL DCSP return ret
 DCSP server = _connect(host, port, db, password) DCNL DCSP return server.dbsize()
 DCSP if (not ident): DCNL DCSP  DCSP ident = sid() DCNL DCSP edesc.signature = pre_signature_part(ident, secc.my_cert, 1) DCNL DCSP edesc.id = ident DCNL DCSP xmldoc = secc.sign_statement(('%s' % edesc), class_name(edesc)) DCNL DCSP edesc = md.entity_descriptor_from_string(xmldoc) DCNL DCSP return (edesc, xmldoc)
 DCSP if isinstance(children, dict): DCNL DCSP  DCSP keys = list(children.keys()) DCNL DCSP  DCSP children = children.values() DCNL DCSP else: DCNL DCSP  DCSP keys = None DCNL DCSP children = list(map(convert_yielded, children)) DCNL DCSP assert all((is_future(i) for i in children)) DCNL DCSP unfinished_children = set(children) DCNL DCSP future = Future() DCNL DCSP if (not children): DCNL DCSP  DCSP future.set_result(({} if (keys is not None) else [])) DCNL DCSP def callback(f): DCNL DCSP  DCSP unfinished_children.remove(f) DCNL DCSP  DCSP if (not unfinished_children): DCNL DCSP  DCSP  DCSP result_list = [] DCNL DCSP  DCSP  DCSP for f in children: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result_list.append(f.result()) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if future.done(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(e, quiet_exceptions)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app_log.error('Multiple DCSP exceptions DCSP in DCSP yield DCSP list', exc_info=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP future.set_exc_info(sys.exc_info()) DCNL DCSP  DCSP  DCSP if (not future.done()): DCNL DCSP  DCSP  DCSP  DCSP if (keys is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP future.set_result(dict(zip(keys, result_list))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP future.set_result(result_list) DCNL DCSP listening = set() DCNL DCSP for f in children: DCNL DCSP  DCSP if (f not in listening): DCNL DCSP  DCSP  DCSP listening.add(f) DCNL DCSP  DCSP  DCSP f.add_done_callback(callback) DCNL DCSP return future
 DCSP if ((not settings.DEBUG) and (not insecure)): DCNL DCSP  DCSP raise ImproperlyConfigured("The DCSP staticfiles DCSP view DCSP can DCSP only DCSP be DCSP used DCSP in DCSP debug DCSP mode DCSP or DCSP if DCSP the DCSP the DCSP --insecure DCSP option DCSP of DCSP 'runserver' DCSP is DCSP used") DCNL DCSP normalized_path = posixpath.normpath(urllib.unquote(path)).lstrip('/') DCNL DCSP absolute_path = finders.find(normalized_path) DCNL DCSP if (not absolute_path): DCNL DCSP  DCSP if (path.endswith('/') or (path == '')): DCNL DCSP  DCSP  DCSP raise Http404('Directory DCSP indexes DCSP are DCSP not DCSP allowed DCSP here.') DCNL DCSP  DCSP raise Http404(("'%s' DCSP could DCSP not DCSP be DCSP found" % path)) DCNL DCSP (document_root, path) = os.path.split(absolute_path) DCNL DCSP return static.serve(request, path, document_root=document_root, **kwargs)
 DCSP ant = XML.SubElement(xml_parent, 'hudson.tasks.Ant') DCNL DCSP if (type(data) is str): DCNL DCSP  DCSP data = {'targets': data} DCNL DCSP for (setting, value) in sorted(data.items()): DCNL DCSP  DCSP if (setting == 'targets'): DCNL DCSP  DCSP  DCSP targets = XML.SubElement(ant, 'targets') DCNL DCSP  DCSP  DCSP targets.text = value DCNL DCSP  DCSP if (setting == 'buildfile'): DCNL DCSP  DCSP  DCSP buildfile = XML.SubElement(ant, 'buildFile') DCNL DCSP  DCSP  DCSP buildfile.text = value DCNL DCSP  DCSP if (setting == 'properties'): DCNL DCSP  DCSP  DCSP properties = data['properties'] DCNL DCSP  DCSP  DCSP prop_string = '' DCNL DCSP  DCSP  DCSP for (prop, val) in properties.items(): DCNL DCSP  DCSP  DCSP  DCSP prop_string += ('%s=%s\n' % (prop, val)) DCNL DCSP  DCSP  DCSP prop_element = XML.SubElement(ant, 'properties') DCNL DCSP  DCSP  DCSP prop_element.text = prop_string DCNL DCSP  DCSP if (setting == 'java-opts'): DCNL DCSP  DCSP  DCSP javaopts = data['java-opts'] DCNL DCSP  DCSP  DCSP jopt_string = ' DCSP '.join(javaopts) DCNL DCSP  DCSP  DCSP jopt_element = XML.SubElement(ant, 'antOpts') DCNL DCSP  DCSP  DCSP jopt_element.text = jopt_string DCNL DCSP XML.SubElement(ant, 'antName').text = data.get('ant-name', 'default')
 DCSP r = ((w + h) / 2.0) DCNL DCSP (x, y) = (((- ((2.0 * x) - w)) / r), ((- ((2.0 * y) - h)) / r)) DCNL DCSP h = np.sqrt(((x * x) + (y * y))) DCNL DCSP return ((0.0, (x / h), (y / h), 0.0) if (h > 1.0) else (0.0, x, y, np.sqrt((1.0 - (h * h)))))
 DCSP A = CoordSysCartesian('A') DCNL DCSP assert (BaseScalar('A.x', 0, A, 'A_x', '\\mathbf{{x}_{A}}') == A.x) DCNL DCSP assert (BaseScalar('A.y', 1, A, 'A_y', '\\mathbf{{y}_{A}}') == A.y) DCNL DCSP assert (BaseScalar('A.z', 2, A, 'A_z', '\\mathbf{{z}_{A}}') == A.z) DCNL DCSP assert (BaseScalar('A.x', 0, A, 'A_x', '\\mathbf{{x}_{A}}').__hash__() == A.x.__hash__()) DCNL DCSP assert (isinstance(A.x, BaseScalar) and isinstance(A.y, BaseScalar) and isinstance(A.z, BaseScalar)) DCNL DCSP assert ((A.x * A.y) == (A.y * A.x)) DCNL DCSP assert (A.scalar_map(A) == {A.x: A.x, A.y: A.y, A.z: A.z}) DCNL DCSP assert (A.x.system == A) DCNL DCSP assert (A.x.diff(A.x) == 1) DCNL DCSP B = A.orient_new_axis('B', q, A.k) DCNL DCSP assert (B.scalar_map(A) == {B.z: A.z, B.y: (((- A.x) * sin(q)) + (A.y * cos(q))), B.x: ((A.x * cos(q)) + (A.y * sin(q)))}) DCNL DCSP assert (A.scalar_map(B) == {A.x: ((B.x * cos(q)) - (B.y * sin(q))), A.y: ((B.x * sin(q)) + (B.y * cos(q))), A.z: B.z}) DCNL DCSP assert (express(B.x, A, variables=True) == ((A.x * cos(q)) + (A.y * sin(q)))) DCNL DCSP assert (express(B.y, A, variables=True) == (((- A.x) * sin(q)) + (A.y * cos(q)))) DCNL DCSP assert (express(B.z, A, variables=True) == A.z) DCNL DCSP assert (expand(express(((B.x * B.y) * B.z), A, variables=True)) == expand(((A.z * (((- A.x) * sin(q)) + (A.y * cos(q)))) * ((A.x * cos(q)) + (A.y * sin(q)))))) DCNL DCSP assert (express((((B.x * B.i) + (B.y * B.j)) + (B.z * B.k)), A) == (((((B.x * cos(q)) - (B.y * sin(q))) * A.i) + (((B.x * sin(q)) + (B.y * cos(q))) * A.j)) + (B.z * A.k))) DCNL DCSP assert (simplify(express((((B.x * B.i) + (B.y * B.j)) + (B.z * B.k)), A, variables=True)) == (((A.x * A.i) + (A.y * A.j)) + (A.z * A.k))) DCNL DCSP assert (express((((A.x * A.i) + (A.y * A.j)) + (A.z * A.k)), B) == (((((A.x * cos(q)) + (A.y * sin(q))) * B.i) + ((((- A.x) * sin(q)) + (A.y * cos(q))) * B.j)) + (A.z * B.k))) DCNL DCSP assert (simplify(express((((A.x * A.i) + (A.y * A.j)) + (A.z * A.k)), B, variables=True)) == (((B.x * B.i) + (B.y * B.j)) + (B.z * B.k))) DCNL DCSP N = B.orient_new_axis('N', (- q), B.k) DCNL DCSP assert (N.scalar_map(A) == {N.x: A.x, N.z: A.z, N.y: A.y}) DCNL DCSP C = A.orient_new_axis('C', q, ((A.i + A.j) + A.k)) DCNL DCSP mapping = A.scalar_map(C) DCNL DCSP assert (mapping[A.x] == ((((C.x * ((2 * cos(q)) + 1)) / 3) + ((C.y * (((-2) * sin((q + (pi / 6)))) + 1)) / 3)) + ((C.z * (((-2) * cos((q + (pi / 3)))) + 1)) / 3))) DCNL DCSP assert (mapping[A.y] == ((((C.x * (((-2) * cos((q + (pi / 3)))) + 1)) / 3) + ((C.y * ((2 * cos(q)) + 1)) / 3)) + ((C.z * (((-2) * sin((q + (pi / 6)))) + 1)) / 3))) DCNL DCSP assert (mapping[A.z] == ((((C.x * (((-2) * sin((q + (pi / 6)))) + 1)) / 3) + ((C.y * (((-2) * cos((q + (pi / 3)))) + 1)) / 3)) + ((C.z * ((2 * cos(q)) + 1)) / 3))) DCNL DCSP D = A.locate_new('D', (((a * A.i) + (b * A.j)) + (c * A.k))) DCNL DCSP assert (D.scalar_map(A) == {D.z: (A.z - c), D.x: (A.x - a), D.y: (A.y - b)}) DCNL DCSP E = A.orient_new_axis('E', a, A.k, (((a * A.i) + (b * A.j)) + (c * A.k))) DCNL DCSP assert (A.scalar_map(E) == {A.z: (E.z + c), A.x: (((E.x * cos(a)) - (E.y * sin(a))) + a), A.y: (((E.x * sin(a)) + (E.y * cos(a))) + b)}) DCNL DCSP assert (E.scalar_map(A) == {E.x: (((A.x - a) * cos(a)) + ((A.y - b) * sin(a))), E.y: ((((- A.x) + a) * sin(a)) + ((A.y - b) * cos(a))), E.z: (A.z - c)}) DCNL DCSP F = A.locate_new('F', Vector.zero) DCNL DCSP assert (A.scalar_map(F) == {A.z: F.z, A.x: F.x, A.y: F.y})
 DCSP line = clean_lines.elided[linenum] DCNL DCSP if Match('\\s*{\\s*$', line): DCNL DCSP  DCSP prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0] DCNL DCSP  DCSP if ((not Search('[,;:}{(]\\s*$', prevline)) and (not Match('\\s*#', prevline)) and (not ((GetLineWidth(prevline) > (_line_length - 2)) and ('[]' in prevline)))): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'whitespace/braces', 4, '{ DCSP should DCSP almost DCSP always DCSP be DCSP at DCSP the DCSP end DCSP of DCSP the DCSP previous DCSP line') DCNL DCSP if Match('\\s*else\\b\\s*(?:if\\b|\\{|$)', line): DCNL DCSP  DCSP prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0] DCNL DCSP  DCSP if Match('\\s*}\\s*$', prevline): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'An DCSP else DCSP should DCSP appear DCSP on DCSP the DCSP same DCSP line DCSP as DCSP the DCSP preceding DCSP }') DCNL DCSP if Search('else DCSP if\\s*\\(', line): DCNL DCSP  DCSP brace_on_left = bool(Search('}\\s*else DCSP if\\s*\\(', line)) DCNL DCSP  DCSP pos = line.find('else DCSP if') DCNL DCSP  DCSP pos = line.find('(', pos) DCNL DCSP  DCSP if (pos > 0): DCNL DCSP  DCSP  DCSP (endline, _, endpos) = CloseExpression(clean_lines, linenum, pos) DCNL DCSP  DCSP  DCSP brace_on_right = (endline[endpos:].find('{') != (-1)) DCNL DCSP  DCSP  DCSP if (brace_on_left != brace_on_right): DCNL DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'readability/braces', 5, 'If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP side, DCSP it DCSP should DCSP have DCSP it DCSP on DCSP both') DCNL DCSP elif (Search('}\\s*else[^{]*$', line) or Match('[^}]*else\\s*{', line)): DCNL DCSP  DCSP error(filename, linenum, 'readability/braces', 5, 'If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP side, DCSP it DCSP should DCSP have DCSP it DCSP on DCSP both') DCNL DCSP if (Search('\\belse DCSP [^\\s{]', line) and (not Search('\\belse DCSP if\\b', line))): DCNL DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'Else DCSP clause DCSP should DCSP never DCSP be DCSP on DCSP same DCSP line DCSP as DCSP else DCSP (use DCSP 2 DCSP lines)') DCNL DCSP if Match('\\s*do DCSP [^\\s{]', line): DCNL DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'do/while DCSP clauses DCSP should DCSP not DCSP be DCSP on DCSP a DCSP single DCSP line') DCNL DCSP if_else_match = Search('\\b(if\\s*\\(|else\\b)', line) DCNL DCSP if (if_else_match and (not Match('\\s*#', line))): DCNL DCSP  DCSP if_indent = GetIndentLevel(line) DCNL DCSP  DCSP (endline, endlinenum, endpos) = (line, linenum, if_else_match.end()) DCNL DCSP  DCSP if_match = Search('\\bif\\s*\\(', line) DCNL DCSP  DCSP if if_match: DCNL DCSP  DCSP  DCSP pos = (if_match.end() - 1) DCNL DCSP  DCSP  DCSP (endline, endlinenum, endpos) = CloseExpression(clean_lines, linenum, pos) DCNL DCSP  DCSP if ((not Match('\\s*{', endline[endpos:])) and (not (Match('\\s*$', endline[endpos:]) and (endlinenum < (len(clean_lines.elided) - 1)) and Match('\\s*{', clean_lines.elided[(endlinenum + 1)])))): DCNL DCSP  DCSP  DCSP while ((endlinenum < len(clean_lines.elided)) and (';' not in clean_lines.elided[endlinenum][endpos:])): DCNL DCSP  DCSP  DCSP  DCSP endlinenum += 1 DCNL DCSP  DCSP  DCSP  DCSP endpos = 0 DCNL DCSP  DCSP  DCSP if (endlinenum < len(clean_lines.elided)): DCNL DCSP  DCSP  DCSP  DCSP endline = clean_lines.elided[endlinenum] DCNL DCSP  DCSP  DCSP  DCSP endpos = endline.find(';') DCNL DCSP  DCSP  DCSP  DCSP if (not Match(';[\\s}]*(\\\\?)$', endline[endpos:])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not Match('^[^{};]*\\[[^\\[\\]]*\\][^{}]*\\{[^{}]*\\}\\s*\\)*[;,]\\s*$', endline)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'readability/braces', 4, 'If/else DCSP bodies DCSP with DCSP multiple DCSP statements DCSP require DCSP braces') DCNL DCSP  DCSP  DCSP  DCSP elif (endlinenum < (len(clean_lines.elided) - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_line = clean_lines.elided[(endlinenum + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_indent = GetIndentLevel(next_line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (if_match and Match('\\s*else\\b', next_line) and (next_indent != if_indent)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'readability/braces', 4, 'Else DCSP clause DCSP should DCSP be DCSP indented DCSP at DCSP the DCSP same DCSP level DCSP as DCSP if. DCSP Ambiguous DCSP nested DCSP if/else DCSP chains DCSP require DCSP braces.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (next_indent > if_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'readability/braces', 4, 'If/else DCSP bodies DCSP with DCSP multiple DCSP statements DCSP require DCSP braces')
 DCSP restart(name)
 DCSP (lower, value) = validate(option, value) DCNL DCSP if (lower not in _AUTH_OPTIONS): DCNL DCSP  DCSP raise ConfigurationError(('Unknown DCSP authentication DCSP option: DCSP %s' % (option,))) DCNL DCSP return (lower, value)
 DCSP if isinstance(it, (list, tuple)): DCNL DCSP  DCSP return it DCNL DCSP return _regen(it)
 DCSP if (mode == 'half_away_from_zero'): DCNL DCSP  DCSP return round_half_away_from_zero(a) DCNL DCSP elif (mode == 'half_to_even'): DCNL DCSP  DCSP return round_half_to_even(a) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('round DCSP mode DCSP %s DCSP is DCSP not DCSP implemented.' % mode))
 DCSP (sigspec, rv) = _check_sigspec(sigspec, func, _sigs._is_arity, n, func) DCNL DCSP if (sigspec is None): DCNL DCSP  DCSP return rv DCNL DCSP num = num_required_args(func, sigspec) DCNL DCSP if (num is not None): DCNL DCSP  DCSP num = (num == n) DCNL DCSP  DCSP if (not num): DCNL DCSP  DCSP  DCSP return False DCNL DCSP varargs = has_varargs(func, sigspec) DCNL DCSP if varargs: DCNL DCSP  DCSP return False DCNL DCSP keywords = has_keywords(func, sigspec) DCNL DCSP if keywords: DCNL DCSP  DCSP return False DCNL DCSP if ((num is None) or (varargs is None) or (keywords is None)): DCNL DCSP  DCSP return None DCNL DCSP return True
 DCSP if (value is None): DCNL DCSP  DCSP raise ValueError(u'None DCSP is DCSP not DCSP a DCSP valid DCSP integer') DCNL DCSP if (not value.isdigit()): DCNL DCSP  DCSP raise ValueError(u'Only DCSP positive DCSP numbers DCSP are DCSP allowed') DCNL DCSP return int(value)
 DCSP plays = [] DCNL DCSP seen_ids = set() DCNL DCSP seen_desc = set() DCNL DCSP for playid in map(str, sorted(map(int, data))): DCNL DCSP  DCSP p = data[playid] DCNL DCSP  DCSP desc = (p['desc'], p['time'], p['yrdln'], p['qtr']) DCNL DCSP  DCSP if ((playid in seen_ids) or (desc in seen_desc)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen_ids.add(playid) DCNL DCSP  DCSP seen_desc.add(desc) DCNL DCSP  DCSP plays.append(Play(drive, playid, data[playid])) DCNL DCSP return plays
 DCSP if ((len(path) > 0) and (path[(-1)] == os.sep)): DCNL DCSP  DCSP return path DCNL DCSP else: DCNL DCSP  DCSP return (path + os.sep)
 DCSP server = _find_server(cs, args.server) DCNL DCSP server.trigger_crash_dump()
 DCSP f = (_Cfunctions.get('libvlc_video_set_spu', None) or _Cfunction('libvlc_video_set_spu', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_spu)
 DCSP result = K.zero DCNL DCSP for c in f: DCNL DCSP  DCSP result *= a DCNL DCSP  DCSP result += c DCNL DCSP  DCSP result %= p DCNL DCSP return result
 DCSP return (name in _get_svc_list(name))
 DCSP print 'Test DCSP H2a DCSP - DCSP second DCSP repetition DCSP of DCSP the DCSP same DCSP sequence DCSP should DCSP not DCSP add DCSP synapses' DCNL DCSP nFailed = 0 DCNL DCSP subsequenceStartPos = 10 DCNL DCSP assert (subsequenceStartPos < sequenceLength) DCNL DCSP for numSequences in nSequences: DCNL DCSP  DCSP print 'Higher DCSP order DCSP test DCSP with DCSP sequenceLength=', sequenceLength, DCNL DCSP  DCSP print 'cellsPerColumn=', cellsPerColumn, 'nTests=', nTests, 'numCols=', numCols DCNL DCSP  DCSP print 'numSequences=', numSequences, 'pctShared=', pctShared, DCNL DCSP  DCSP print 'sharing DCSP mode=', seqGenMode DCNL DCSP  DCSP for _ in range(nTests): DCNL DCSP  DCSP  DCSP trainingSet = buildTrainingSet(numSequences=numSequences, sequenceLength=sequenceLength, pctShared=pctShared, seqGenMode=seqGenMode, subsequenceStartPos=subsequenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP  DCSP  DCSP print '============== DCSP 10 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures3, numStrictErrors3, numPerfect3, tp3) = testSequence(trainingSet, nTrainingReps=10, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.4, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 2 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures, numStrictErrors, numPerfect, tp2) = testSequence(trainingSet, nTrainingReps=2, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 1 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures1, numStrictErrors1, numPerfect1, tp1) = testSequence(trainingSet, nTrainingReps=1, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connectedPerm=0.7, minThreshold=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThreshold=12, doPooling=False, shouldFail=shouldFail) DCNL DCSP  DCSP  DCSP segmentInfo1 = tp1.getSegmentInfo() DCNL DCSP  DCSP  DCSP segmentInfo2 = tp2.getSegmentInfo() DCNL DCSP  DCSP  DCSP if ((abs((segmentInfo1[0] - segmentInfo2[0])) > 3) or (abs((segmentInfo1[1] - segmentInfo2[1])) > (3 * 15))): DCNL DCSP  DCSP  DCSP  DCSP print 'Training DCSP twice DCSP incorrectly DCSP resulted DCSP in DCSP too DCSP many DCSP segments DCSP or DCSP synapses' DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo1 DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo2 DCNL DCSP  DCSP  DCSP  DCSP print tp3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP tp3.trimSegments() DCNL DCSP  DCSP  DCSP  DCSP print tp3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP print 'Failures DCSP for DCSP 1, DCSP 2, DCSP and DCSP N DCSP reps' DCNL DCSP  DCSP  DCSP  DCSP print numFailures1, numStrictErrors1, numPerfect1 DCNL DCSP  DCSP  DCSP  DCSP print numFailures, numStrictErrors, numPerfect DCNL DCSP  DCSP  DCSP  DCSP print numFailures3, numStrictErrors3, numPerfect3 DCNL DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP if (((numFailures == 0) and (not shouldFail)) or ((numFailures > 0) and shouldFail)): DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP PASS', DCNL DCSP  DCSP  DCSP  DCSP if shouldFail: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '(should DCSP fail, DCSP and DCSP failed)' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP FAILED' DCNL DCSP  DCSP  DCSP  DCSP nFailed = (nFailed + 1) DCNL DCSP  DCSP  DCSP  DCSP print 'numFailures=', numFailures DCNL DCSP  DCSP  DCSP  DCSP print 'numStrictErrors=', numStrictErrors DCNL DCSP  DCSP  DCSP  DCSP print 'numPerfect=', numPerfect DCNL DCSP return nFailed
 DCSP docs = Document.objects.filter_for_list(locale=request.LANGUAGE_CODE, toplevel=True) DCNL DCSP paginated_docs = paginate(request, docs, per_page=DOCUMENTS_PER_PAGE) DCNL DCSP context = {'documents': paginated_docs, 'count': docs.count(), 'toplevel': True} DCNL DCSP return render(request, 'wiki/list/documents.html', context)
 DCSP return getattr(cls, INSTRUMENTATION_MANAGER, None)
 DCSP if (len(indexedLoop) < 3): DCNL DCSP  DCSP return DCNL DCSP remainingLoop = indexedLoop[:] DCNL DCSP while (len(remainingLoop) > 2): DCNL DCSP  DCSP remainingLoop = getRemainingLoopAddFace(faces, remainingLoop)
 DCSP return SerialModule(mpstate)
 DCSP projects = dict() DCNL DCSP resources = dict() DCNL DCSP def get_ctx(*args, **kwargs): DCNL DCSP  DCSP path = env.curbuf.name DCNL DCSP  DCSP if resources.get(path): DCNL DCSP  DCSP  DCSP return resources.get(path) DCNL DCSP  DCSP project_path = env.var('g:pymode_rope_project_root') DCNL DCSP  DCSP if (not project_path): DCNL DCSP  DCSP  DCSP project_path = env.curdir DCNL DCSP  DCSP  DCSP env.debug('Look DCSP ctx', project_path) DCNL DCSP  DCSP  DCSP if env.var('g:pymode_rope_lookup_project', True): DCNL DCSP  DCSP  DCSP  DCSP project_path = look_ropeproject(project_path) DCNL DCSP  DCSP if (not os.path.exists(project_path)): DCNL DCSP  DCSP  DCSP env.error(('Rope DCSP project DCSP root DCSP not DCSP exist: DCSP %s' % project_path)) DCNL DCSP  DCSP  DCSP ctx = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ctx = projects.get(project_path) DCNL DCSP  DCSP if (not ctx): DCNL DCSP  DCSP  DCSP projects[project_path] = ctx = cls(path, project_path) DCNL DCSP  DCSP resources[path] = ctx DCNL DCSP  DCSP return ctx DCNL DCSP return get_ctx
 DCSP today = date.today() DCNL DCSP locales = get_locales_by_visit((today - timedelta(days=30)), today) DCNL DCSP product = _get_product(request) DCNL DCSP return render(request, 'dashboards/aggregated_metrics.html', {'locales_json': json.dumps(settings.SUMO_LANGUAGES), 'locales': locales, 'product': product, 'products': Product.objects.filter(visible=True)})
 DCSP if (response_rewriters is None): DCNL DCSP  DCSP response_rewriters = CreateResponseRewritersChain() DCNL DCSP response = AppServerResponse(response_file) DCNL DCSP for response_rewriter in response_rewriters: DCNL DCSP  DCSP if (response_rewriter.func_code.co_argcount == 1): DCNL DCSP  DCSP  DCSP response_rewriter(response) DCNL DCSP  DCSP elif (response_rewriter.func_code.co_argcount == 2): DCNL DCSP  DCSP  DCSP response_rewriter(response, request_headers) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response_rewriter(response, request_headers, env_dict) DCNL DCSP return response
 DCSP totalPitchRadius = (derivation.pitchRadiusComplement + derivation.pitchRadius) DCNL DCSP totalTeeth = (derivation.teethPinion + derivation.teethComplement) DCNL DCSP portionDirections = extrude.getSpacedPortionDirections(extrudeDerivation.interpolationDictionary) DCNL DCSP loopLists = extrude.getLoopListsByPath(extrudeDerivation, None, vector3GearProfile[0], portionDirections) DCNL DCSP firstLoopList = loopLists[0] DCNL DCSP gearOverPinion = (float((totalTeeth - teeth)) / float(teeth)) DCNL DCSP thirdLayerHeight = (0.33333333333 * setting.getLayerHeight(derivation.elementNode)) DCNL DCSP pitchRadian = math.atan((math.sin(derivation.operatingRadian) / (gearOverPinion + math.cos(derivation.operatingRadian)))) DCNL DCSP coneDistance = (pitchRadius / math.sin(pitchRadian)) DCNL DCSP apex = Vector3(0.0, 0.0, math.sqrt(((coneDistance * coneDistance) - (pitchRadius * pitchRadius)))) DCNL DCSP cosPitch = (apex.z / coneDistance) DCNL DCSP sinPitch = math.sin(pitchRadian) DCNL DCSP for loop in firstLoopList: DCNL DCSP  DCSP for point in loop: DCNL DCSP  DCSP  DCSP alongWay = (point.z / coneDistance) DCNL DCSP  DCSP  DCSP oneMinusAlongWay = (1.0 - alongWay) DCNL DCSP  DCSP  DCSP pointComplex = point.dropAxis() DCNL DCSP  DCSP  DCSP pointComplexLength = abs(pointComplex) DCNL DCSP  DCSP  DCSP deltaRadius = (pointComplexLength - pitchRadius) DCNL DCSP  DCSP  DCSP cosDeltaRadius = (cosPitch * deltaRadius) DCNL DCSP  DCSP  DCSP sinDeltaRadius = (sinPitch * deltaRadius) DCNL DCSP  DCSP  DCSP pointComplex *= ((cosDeltaRadius + pitchRadius) / pointComplexLength) DCNL DCSP  DCSP  DCSP point.x = pointComplex.real DCNL DCSP  DCSP  DCSP point.y = pointComplex.imag DCNL DCSP  DCSP  DCSP point.z += sinDeltaRadius DCNL DCSP  DCSP  DCSP point.x *= oneMinusAlongWay DCNL DCSP  DCSP  DCSP point.y *= oneMinusAlongWay DCNL DCSP addBottomLoop((- thirdLayerHeight), firstLoopList) DCNL DCSP topLoop = firstLoopList[(-1)] DCNL DCSP topAddition = [] DCNL DCSP topZ = (euclidean.getTopPath(topLoop) + thirdLayerHeight) DCNL DCSP oldIndex = topLoop[(-1)].index DCNL DCSP for point in topLoop: DCNL DCSP  DCSP oldIndex += 1 DCNL DCSP  DCSP topAddition.append(Vector3Index(oldIndex, (0.8 * point.x), (0.8 * point.y), topZ)) DCNL DCSP firstLoopList.append(topAddition) DCNL DCSP translation = Vector3(0.0, 0.0, (- euclidean.getBottomByPaths(firstLoopList))) DCNL DCSP euclidean.translateVector3Paths(firstLoopList, translation) DCNL DCSP geometryOutput = triangle_mesh.getPillarsOutput(loopLists) DCNL DCSP positives.append(geometryOutput)
 DCSP t.lexer.paren_count += 1 DCNL DCSP return t
 DCSP lcache = os.path.join(os.path.dirname(os.path.dirname(dst)), '.link_cache') DCNL DCSP if (not os.path.isdir(lcache)): DCNL DCSP  DCSP os.mkdir(lcache) DCNL DCSP key = hashfile(src, lcache=lcache, logger=logger) DCNL DCSP cachefile = os.path.join(lcache, key) DCNL DCSP if (not os.path.exists(cachefile)): DCNL DCSP  DCSP logger.info(('trying DCSP to DCSP create DCSP cache DCSP file DCSP %s' % cachefile)) DCNL DCSP  DCSP copyfile(src, cachefile, api=api, logger=logger) DCNL DCSP logger.debug(('trying DCSP cachelink DCSP %s DCSP -> DCSP %s DCSP -> DCSP %s' % (src, cachefile, dst))) DCNL DCSP os.link(cachefile, dst)
 DCSP try: DCNL DCSP  DCSP course_updates = modulestore().get_item(location) DCNL DCSP except ItemNotFoundError: DCNL DCSP  DCSP course_updates = modulestore().create_item(user_id, location.course_key, location.block_type, location.block_id) DCNL DCSP course_update_items = get_course_update_items(course_updates, _get_index(provided_id)) DCNL DCSP return _get_visible_update(course_update_items)
 DCSP r = requests.get(url, allow_redirects=False) DCNL DCSP status = (r.status_code == 302) DCNL DCSP perl = (('x-perl-redirect' in r.headers) and (r.headers['x-perl-redirect'] == 'True')) DCNL DCSP return all([status, perl])
 DCSP return (((np.sin((x * 5)) / x) + (2.0 * x)) - (1.0 * (x ** 2)))
 DCSP user_library_info = get_user_library_info(openid) DCNL DCSP if user_library_info: DCNL DCSP  DCSP cipher = AESCipher(app.config['PASSWORD_SECRET_KEY']) DCNL DCSP  DCSP librarypwd = cipher.decrypt(user_library_info['librarypwd']) DCNL DCSP  DCSP library.borrowing_record.delay(openid, user_library_info['libraryid'], librarypwd, renew=renew) DCNL DCSP  DCSP return wechat.response_text(content) DCNL DCSP else: DCNL DCSP  DCSP url = ((app.config['HOST_URL'] + '/auth-library/') + openid) DCNL DCSP  DCSP content = (app.config['AUTH_LIBRARY_TEXT'] % url) DCNL DCSP  DCSP return wechat.response_text(content)
 DCSP return string.translate(b, B64C_TRANSLATE, B64C_STRIP)
 DCSP if (u not in G): DCNL DCSP  DCSP raise nx.NetworkXError('u DCSP is DCSP not DCSP in DCSP the DCSP graph.') DCNL DCSP if (v not in G): DCNL DCSP  DCSP raise nx.NetworkXError('v DCSP is DCSP not DCSP in DCSP the DCSP graph.') DCNL DCSP return (w for w in G[u] if ((w in G[v]) and (w not in (u, v))))
 DCSP if (not patterns): DCNL DCSP  DCSP return default DCNL DCSP return any((fnmatch(filename, pattern) for pattern in patterns))
 DCSP from boto.configservice.layer1 import ConfigServiceConnection DCNL DCSP return ConfigServiceConnection(aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, **kwargs)
 DCSP cs.floating_ips_bulk.create(args.ip_range, args.pool, args.interface)
 DCSP enc = locale.getpreferredencoding() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return s.decode(enc) DCNL DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP enc = _DEFAULT_ENCODING DCNL DCSP  DCSP return s.decode(enc) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return s.decode(u'latin-1')
 DCSP set_mysql_engine() DCNL DCSP kwargs = dict() DCNL DCSP if neutron_config.database.connection: DCNL DCSP  DCSP kwargs['url'] = neutron_config.database.connection DCNL DCSP else: DCNL DCSP  DCSP kwargs['dialect_name'] = neutron_config.database.engine DCNL DCSP kwargs['include_object'] = include_object DCNL DCSP context.configure(**kwargs) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations()
 DCSP task_schema = get_task_schema() DCNL DCSP partial_task_schema = _get_partial_task_schema() DCNL DCSP deserializer = RequestDeserializer(task_schema) DCNL DCSP serializer = ResponseSerializer(task_schema, partial_task_schema) DCNL DCSP controller = TasksController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
 DCSP return And.make_args(expr)
 DCSP if (parse_boolean_envvar(os.getenv('WALE_GS_INTEGRATION_TESTS')) is not True): DCNL DCSP  DCSP return True DCNL DCSP if (os.getenv('GOOGLE_APPLICATION_CREDENTIALS') is None): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP files_to_docs = defaultdict(list) DCNL DCSP for (doc, files) in docs_links.iteritems(): DCNL DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP files_to_docs[file].append(doc) DCNL DCSP  DCSP  DCSP files_to_docs[file] = list(set(files_to_docs[file])) DCNL DCSP return files_to_docs
 DCSP course_key = CourseKey.from_string(course_id) DCNL DCSP certs_api.generate_example_certificates(course_key) DCNL DCSP return redirect(_instructor_dash_url(course_key, section='certificates'))
 DCSP try: DCNL DCSP  DCSP from . import saltnado DCNL DCSP except ImportError as err: DCNL DCSP  DCSP logger.error('ImportError! DCSP {0}'.format(str(err))) DCNL DCSP  DCSP return None DCNL DCSP mod_opts = __opts__.get(__virtualname__, {}) DCNL DCSP if ('num_processes' not in mod_opts): DCNL DCSP  DCSP mod_opts['num_processes'] = 1 DCNL DCSP if ((mod_opts['num_processes'] > 1) and (mod_opts.get('debug', False) is True)): DCNL DCSP  DCSP raise Exception("Tornado's DCSP debug DCSP implementation DCSP is DCSP not DCSP compatible DCSP with DCSP multiprocess. DCSP Either DCSP disable DCSP debug, DCSP or DCSP set DCSP num_processes DCSP to DCSP 1.") DCNL DCSP paths = [('/', saltnado.SaltAPIHandler), ('/login', saltnado.SaltAuthHandler), ('/minions/(.*)', saltnado.MinionSaltAPIHandler), ('/minions', saltnado.MinionSaltAPIHandler), ('/jobs/(.*)', saltnado.JobsSaltAPIHandler), ('/jobs', saltnado.JobsSaltAPIHandler), ('/run', saltnado.RunSaltAPIHandler), ('/events', saltnado.EventsSaltAPIHandler), ('/hook(/.*)?', saltnado.WebhookSaltAPIHandler)] DCNL DCSP if mod_opts.get('websockets', False): DCNL DCSP  DCSP from . import saltnado_websockets DCNL DCSP  DCSP token_pattern = '([0-9A-Fa-f]{{{0}}})'.format(len(getattr(hashlib, __opts__.get('hash_type', 'md5'))().hexdigest())) DCNL DCSP  DCSP all_events_pattern = '/all_events/{0}'.format(token_pattern) DCNL DCSP  DCSP formatted_events_pattern = '/formatted_events/{0}'.format(token_pattern) DCNL DCSP  DCSP logger.debug('All DCSP events DCSP URL DCSP pattern DCSP is DCSP {0}'.format(all_events_pattern)) DCNL DCSP  DCSP paths += [(all_events_pattern, saltnado_websockets.AllEventsHandler), (formatted_events_pattern, saltnado_websockets.FormattedEventsHandler)] DCNL DCSP application = tornado.web.Application(paths, debug=mod_opts.get('debug', False)) DCNL DCSP application.opts = __opts__ DCNL DCSP application.mod_opts = mod_opts DCNL DCSP application.auth = salt.auth.LoadAuth(__opts__) DCNL DCSP kwargs = {} DCNL DCSP if (not mod_opts.get('disable_ssl', False)): DCNL DCSP  DCSP if ('ssl_crt' not in mod_opts): DCNL DCSP  DCSP  DCSP logger.error("Not DCSP starting DCSP '%s'. DCSP Options DCSP 'ssl_crt' DCSP and DCSP 'ssl_key' DCSP are DCSP required DCSP if DCSP SSL DCSP is DCSP not DCSP disabled.", __name__) DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP ssl_opts = {'certfile': mod_opts['ssl_crt']} DCNL DCSP  DCSP if mod_opts.get('ssl_key', False): DCNL DCSP  DCSP  DCSP ssl_opts.update({'keyfile': mod_opts['ssl_key']}) DCNL DCSP  DCSP kwargs['ssl_options'] = ssl_opts DCNL DCSP http_server = tornado.httpserver.HTTPServer(application, **kwargs) DCNL DCSP try: DCNL DCSP  DCSP http_server.bind(mod_opts['port'], address=mod_opts.get('address'), backlog=mod_opts.get('backlog', 128)) DCNL DCSP  DCSP http_server.start(mod_opts['num_processes']) DCNL DCSP except: DCNL DCSP  DCSP logger.error('Rest_tornado DCSP unable DCSP to DCSP bind DCSP to DCSP port DCSP {0}'.format(mod_opts['port']), exc_info=True) DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP try: DCNL DCSP  DCSP tornado.ioloop.IOLoop.instance().start() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP raise SystemExit(0)
 DCSP if (transform_test is None): DCNL DCSP  DCSP transform_test = transform_valid DCNL DCSP kwargs = subdict(conf, ['dataset', 'normalize', 'normalize_on_the_fly', 'sparse']) DCNL DCSP kwargs.update(randomize_valid=False, randomize_test=False) DCNL DCSP (valid_set, test_set) = load_data(kwargs)[1:3] DCNL DCSP if (not conf.get('sparse', False)): DCNL DCSP  DCSP valid_set = valid_set.get_value(borrow=True) DCNL DCSP  DCSP test_set = test_set.get_value(borrow=True) DCNL DCSP if (features is not None): DCNL DCSP  DCSP valid_set = valid_set[:, features] DCNL DCSP  DCSP test_set = test_set[:, features] DCNL DCSP valid_repr = transform_valid(valid_set) DCNL DCSP test_repr = transform_test(test_set) DCNL DCSP save_submission(conf, valid_repr, test_repr)
 DCSP from sympy.core.compatibility import maketrans DCNL DCSP try: DCNL DCSP  DCSP ''.translate(None, '') DCNL DCSP  DCSP py3 = False DCNL DCSP except TypeError: DCNL DCSP  DCSP py3 = True DCNL DCSP mr = {} DCNL DCSP if (a is None): DCNL DCSP  DCSP assert (c is None) DCNL DCSP  DCSP if (not b): DCNL DCSP  DCSP  DCSP return s DCNL DCSP  DCSP c = b DCNL DCSP  DCSP a = b = '' DCNL DCSP elif (type(a) is dict): DCNL DCSP  DCSP short = {} DCNL DCSP  DCSP for k in list(a.keys()): DCNL DCSP  DCSP  DCSP if ((len(k) == 1) and (len(a[k]) == 1)): DCNL DCSP  DCSP  DCSP  DCSP short[k] = a.pop(k) DCNL DCSP  DCSP mr = a DCNL DCSP  DCSP c = b DCNL DCSP  DCSP if short: DCNL DCSP  DCSP  DCSP (a, b) = [''.join(i) for i in list(zip(*short.items()))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = b = '' DCNL DCSP else: DCNL DCSP  DCSP assert (len(a) == len(b)) DCNL DCSP if py3: DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP s = s.translate(maketrans('', '', c)) DCNL DCSP  DCSP s = replace(s, mr) DCNL DCSP  DCSP return s.translate(maketrans(a, b)) DCNL DCSP else: DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP c = list(c) DCNL DCSP  DCSP  DCSP rem = {} DCNL DCSP  DCSP  DCSP for i in range((-1), ((-1) - len(c)), (-1)): DCNL DCSP  DCSP  DCSP  DCSP if (ord(c[i]) > 255): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rem[c[i]] = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP c.pop(i) DCNL DCSP  DCSP  DCSP s = s.translate(None, ''.join(c)) DCNL DCSP  DCSP  DCSP s = replace(s, rem) DCNL DCSP  DCSP  DCSP if a: DCNL DCSP  DCSP  DCSP  DCSP a = list(a) DCNL DCSP  DCSP  DCSP  DCSP b = list(b) DCNL DCSP  DCSP  DCSP  DCSP for i in range((-1), ((-1) - len(a)), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((ord(a[i]) > 255) or (ord(b[i]) > 255)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mr[a.pop(i)] = b.pop(i) DCNL DCSP  DCSP  DCSP  DCSP a = ''.join(a) DCNL DCSP  DCSP  DCSP  DCSP b = ''.join(b) DCNL DCSP  DCSP s = replace(s, mr) DCNL DCSP  DCSP table = maketrans(a, b) DCNL DCSP  DCSP if ((type(table) is str) and (type(s) is str)): DCNL DCSP  DCSP  DCSP s = s.translate(table) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = s.translate(dict([(i, ord(c)) for (i, c) in enumerate(table)])) DCNL DCSP  DCSP return s
 DCSP sla = get_object_or_404(ServiceLevelAgreement, pk=sla_id) DCNL DCSP if (not request.user.profile.has_permission(sla)): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Service DCSP Level DCSP Agreement") DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'sla': sla}) DCNL DCSP return render_to_response('services/sla_view', context, context_instance=RequestContext(request), response_format=response_format)
 DCSP rc = re.compile('|'.join(map(re.escape, word_dic))) DCNL DCSP def translate(match): DCNL DCSP  DCSP return word_dic[match.group(0)] DCNL DCSP return rc.sub(translate, text)
 DCSP _check_is_integral('azimuth', label) DCNL DCSP if (label == (-1)): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP if (((label % 2) != 0) or (label < 0) or (label > 34)): DCNL DCSP  DCSP  DCSP raise ValueError(('Expected DCSP azimuth DCSP to DCSP be DCSP an DCSP even DCSP number DCSP between DCSP 0 DCSP and DCSP 34 DCSP inclusive, DCSP or DCSP -1, DCSP but DCSP got DCSP %s DCSP instead.' % str(label))) DCNL DCSP  DCSP return (label * 10)
 DCSP is_automated = False DCNL DCSP try: DCNL DCSP  DCSP dist_dir_i = sys.argv.index('--dist-dir') DCNL DCSP except ValueError: DCNL DCSP  DCSP dist_dir_i = None DCNL DCSP if (dist_dir_i is not None): DCNL DCSP  DCSP dist_dir = sys.argv[(dist_dir_i + 1)] DCNL DCSP  DCSP if ('egg-dist-tmp' in dist_dir): DCNL DCSP  DCSP  DCSP is_automated = True DCNL DCSP if ((sys.argv in [['-c', 'develop', '--no-deps'], ['--no-deps', '-c', 'develop'], ['-c', 'egg_info']]) or ('pip-egg-info' in sys.argv) or (sys.argv[:3] == ['-c', 'install', '--record']) or (sys.argv[:4] == ['-c', 'install', '--single-version-externally-managed', '--record'])): DCNL DCSP  DCSP is_automated = True DCNL DCSP return is_automated
 DCSP if ((not on_win) or (shell != u'cmd.exe')): DCNL DCSP  DCSP pytest.skip(u"echo DCSP leaking DCSP is DCSP only DCSP relevant DCSP on DCSP Window's DCSP CMD.EXE") DCNL DCSP shell_vars = _format_vars(shell) DCNL DCSP with TemporaryDirectory(prefix=u'envs', dir=os.path.dirname(__file__)) as envs: DCNL DCSP  DCSP (env_dirs, env_vars) = gen_test_env_paths(envs, shell) DCNL DCSP  DCSP scripts = [] DCNL DCSP  DCSP src_activate = shell_vars[u'source'].format(u'{syspath}{binpath}activate{suffix_executable}') DCNL DCSP  DCSP scripts += [dedent(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @ECHO DCSP ON\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {} DCSP "{{env_dirs[0]}}"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @ECHO\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ')] DCNL DCSP  DCSP for script in scripts: DCNL DCSP  DCSP  DCSP script = script.format(src_activate) DCNL DCSP  DCSP  DCSP script = script.format(env_vars=env_vars, env_dirs=env_dirs, **shell_vars) DCNL DCSP  DCSP  DCSP commands = (shell_vars[u'command_setup'] + script) DCNL DCSP  DCSP  DCSP (stdout, stderr) = run_in(commands, shell) DCNL DCSP  DCSP  DCSP print(u'commands:', commands) DCNL DCSP  DCSP  DCSP print(u'stdout:', stdout) DCNL DCSP  DCSP  DCSP print(u'stderr:', stderr) DCNL DCSP  DCSP  DCSP assert_equals(stdout, u'ECHO DCSP is DCSP on.', stderr) DCNL DCSP  DCSP  DCSP assert_equals(stderr, u'')
 DCSP Q = gf_Qmatrix(f, p, K) DCNL DCSP V = gf_Qbasis(Q, p, K) DCNL DCSP for (i, v) in enumerate(V): DCNL DCSP  DCSP V[i] = gf_strip(list(reversed(v))) DCNL DCSP factors = [f] DCNL DCSP for k in range(1, len(V)): DCNL DCSP  DCSP for f in list(factors): DCNL DCSP  DCSP  DCSP s = K.zero DCNL DCSP  DCSP  DCSP while (s < p): DCNL DCSP  DCSP  DCSP  DCSP g = gf_sub_ground(V[k], s, p, K) DCNL DCSP  DCSP  DCSP  DCSP h = gf_gcd(f, g, p, K) DCNL DCSP  DCSP  DCSP  DCSP if ((h != [K.one]) and (h != f)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors.remove(f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = gf_quo(f, h, p, K) DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors.extend([f, h]) DCNL DCSP  DCSP  DCSP  DCSP if (len(factors) == len(V)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return _sort_factors(factors, multiple=False) DCNL DCSP  DCSP  DCSP  DCSP s += K.one DCNL DCSP return _sort_factors(factors, multiple=False)
 DCSP party_type = None DCNL DCSP for (key, doctypes) in status_depends_on.iteritems(): DCNL DCSP  DCSP if (doc.doctype in doctypes): DCNL DCSP  DCSP  DCSP party_type = key DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not party_type): DCNL DCSP  DCSP return DCNL DCSP name = doc.get(party_type.lower()) DCNL DCSP if (not name): DCNL DCSP  DCSP return DCNL DCSP party = frappe.get_doc(party_type, name) DCNL DCSP filters = get_filters_for(doc.doctype) DCNL DCSP party.flags.ignore_mandatory = True DCNL DCSP status = None DCNL DCSP if filters: DCNL DCSP  DCSP if evaluate_filters(doc, filters): DCNL DCSP  DCSP  DCSP status = u'Open' DCNL DCSP if (status == u'Open'): DCNL DCSP  DCSP if (party.status != u'Open'): DCNL DCSP  DCSP  DCSP party.status = u'Open' DCNL DCSP  DCSP  DCSP party.save(ignore_permissions=True) DCNL DCSP elif (party.status == u'Open'): DCNL DCSP  DCSP update_status(party) DCNL DCSP party.update_modified() DCNL DCSP party.notify_update()
 DCSP def _fn(self, item): DCNL DCSP  DCSP return ajax_editable_boolean_cell(item, attr) DCNL DCSP _fn.short_description = short_description DCNL DCSP _fn.editable_boolean_field = attr DCNL DCSP return _fn
 DCSP keyring = {} DCNL DCSP for keytext in textring: DCNL DCSP  DCSP keyname = dns.name.from_text(keytext) DCNL DCSP  DCSP secret = base64.decodestring(textring[keytext]) DCNL DCSP  DCSP keyring[keyname] = secret DCNL DCSP return keyring
 DCSP use_aesni = dict_parameters.pop('use_aesni', True) DCNL DCSP try: DCNL DCSP  DCSP key = dict_parameters.pop('key') DCNL DCSP except KeyError: DCNL DCSP  DCSP raise TypeError("Missing DCSP 'key' DCSP parameter") DCNL DCSP expect_byte_string(key) DCNL DCSP if (len(key) not in key_size): DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP AES DCSP key DCSP length DCSP (%d DCSP bytes)' % len(key))) DCNL DCSP if (use_aesni and _raw_aesni_lib): DCNL DCSP  DCSP start_operation = _raw_aesni_lib.AESNI_start_operation DCNL DCSP  DCSP stop_operation = _raw_aesni_lib.AESNI_stop_operation DCNL DCSP else: DCNL DCSP  DCSP start_operation = _raw_aes_lib.AES_start_operation DCNL DCSP  DCSP stop_operation = _raw_aes_lib.AES_stop_operation DCNL DCSP cipher = VoidPointer() DCNL DCSP result = start_operation(key, c_size_t(len(key)), cipher.address_of()) DCNL DCSP if result: DCNL DCSP  DCSP raise ValueError(('Error DCSP %X DCSP while DCSP instantiating DCSP the DCSP AES DCSP cipher' % result)) DCNL DCSP return SmartPointer(cipher.get(), stop_operation)
 DCSP return ((not sum(((0 if (x == y) else 1) for (x, y) in zip(a, b)))) and (len(a) == len(b)))
 DCSP serv = _get_serv(ret=None) DCNL DCSP sql = 'select DCSP distinct(id) DCSP from DCSP returns' DCNL DCSP data = serv.query(sql) DCNL DCSP ret = [] DCNL DCSP if data: DCNL DCSP  DCSP for jid in data[0]['points']: DCNL DCSP  DCSP  DCSP ret.append(jid[1]) DCNL DCSP return ret
 DCSP return set([k for (k, v) in six.iteritems(REPORT_WRITERS_MAP) if v])
 DCSP pip_bin = _get_pip_bin(bin_env) DCNL DCSP cmd = [pip_bin, 'install'] DCNL DCSP (cleanup_requirements, error) = _process_requirements(requirements=requirements, cmd=cmd, cwd=cwd, saltenv=saltenv, user=user) DCNL DCSP if error: DCNL DCSP  DCSP return error DCNL DCSP if use_wheel: DCNL DCSP  DCSP min_version = '1.4' DCNL DCSP  DCSP cur_version = __salt__['pip.version'](bin_env) DCNL DCSP  DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP  DCSP logger.error('The DCSP --use-wheel DCSP option DCSP is DCSP only DCSP supported DCSP in DCSP pip DCSP {0} DCSP and DCSP newer. DCSP The DCSP version DCSP of DCSP pip DCSP detected DCSP is DCSP {1}. DCSP This DCSP option DCSP will DCSP be DCSP ignored.'.format(min_version, cur_version)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd.append('--use-wheel') DCNL DCSP if no_use_wheel: DCNL DCSP  DCSP min_version = '1.4' DCNL DCSP  DCSP cur_version = __salt__['pip.version'](bin_env) DCNL DCSP  DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP  DCSP logger.error('The DCSP --no-use-wheel DCSP option DCSP is DCSP only DCSP supported DCSP in DCSP pip DCSP {0} DCSP and DCSP newer. DCSP The DCSP version DCSP of DCSP pip DCSP detected DCSP is DCSP {1}. DCSP This DCSP option DCSP will DCSP be DCSP ignored.'.format(min_version, cur_version)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd.append('--no-use-wheel') DCNL DCSP if log: DCNL DCSP  DCSP if os.path.isdir(log): DCNL DCSP  DCSP  DCSP raise IOError("'{0}' DCSP is DCSP a DCSP directory. DCSP Use DCSP --log DCSP path_to_file".format(log)) DCNL DCSP  DCSP elif (not os.access(log, os.W_OK)): DCNL DCSP  DCSP  DCSP raise IOError("'{0}' DCSP is DCSP not DCSP writeable".format(log)) DCNL DCSP  DCSP cmd.extend(['--log', log]) DCNL DCSP if proxy: DCNL DCSP  DCSP cmd.extend(['--proxy', proxy]) DCNL DCSP if timeout: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if isinstance(timeout, float): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Timeout DCSP cannot DCSP be DCSP a DCSP float') DCNL DCSP  DCSP  DCSP int(timeout) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError("'{0}' DCSP is DCSP not DCSP a DCSP valid DCSP timeout, DCSP must DCSP be DCSP an DCSP integer".format(timeout)) DCNL DCSP  DCSP cmd.extend(['--timeout', timeout]) DCNL DCSP if find_links: DCNL DCSP  DCSP if isinstance(find_links, string_types): DCNL DCSP  DCSP  DCSP find_links = [l.strip() for l in find_links.split(',')] DCNL DCSP  DCSP for link in find_links: DCNL DCSP  DCSP  DCSP if (not (salt.utils.url.validate(link, VALID_PROTOS) or os.path.exists(link))): DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valid DCSP URL DCSP or DCSP path".format(link)) DCNL DCSP  DCSP  DCSP cmd.extend(['--find-links', link]) DCNL DCSP if (no_index and (index_url or extra_index_url)): DCNL DCSP  DCSP raise CommandExecutionError("'no_index' DCSP and DCSP ('index_url' DCSP or DCSP 'extra_index_url') DCSP are DCSP mutually DCSP exclusive.") DCNL DCSP if index_url: DCNL DCSP  DCSP if (not salt.utils.url.validate(index_url, VALID_PROTOS)): DCNL DCSP  DCSP  DCSP raise CommandExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valid DCSP URL".format(index_url)) DCNL DCSP  DCSP cmd.extend(['--index-url', index_url]) DCNL DCSP if extra_index_url: DCNL DCSP  DCSP if (not salt.utils.url.validate(extra_index_url, VALID_PROTOS)): DCNL DCSP  DCSP  DCSP raise CommandExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valid DCSP URL".format(extra_index_url)) DCNL DCSP  DCSP cmd.extend(['--extra-index-url', extra_index_url]) DCNL DCSP if no_index: DCNL DCSP  DCSP cmd.append('--no-index') DCNL DCSP if mirrors: DCNL DCSP  DCSP pip_version = version(pip_bin) DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=pip_version, oper='>=', ver2='7.0.0'): DCNL DCSP  DCSP  DCSP raise CommandExecutionError('pip DCSP >= DCSP 7.0.0 DCSP does DCSP not DCSP support DCSP mirror DCSP argument: DCSP use DCSP index_url DCSP and/or DCSP extra_index_url DCSP instead') DCNL DCSP  DCSP if isinstance(mirrors, string_types): DCNL DCSP  DCSP  DCSP mirrors = [m.strip() for m in mirrors.split(',')] DCNL DCSP  DCSP cmd.append('--use-mirrors') DCNL DCSP  DCSP for mirror in mirrors: DCNL DCSP  DCSP  DCSP if (not mirror.startswith('http://')): DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valid DCSP URL".format(mirror)) DCNL DCSP  DCSP  DCSP cmd.extend(['--mirrors', mirror]) DCNL DCSP if build: DCNL DCSP  DCSP cmd.extend(['--build', build]) DCNL DCSP if target: DCNL DCSP  DCSP cmd.extend(['--target', target]) DCNL DCSP if download: DCNL DCSP  DCSP cmd.extend(['--download', download]) DCNL DCSP if download_cache: DCNL DCSP  DCSP cmd.extend(['--download-cache', download_cache]) DCNL DCSP if source: DCNL DCSP  DCSP cmd.extend(['--source', source]) DCNL DCSP if upgrade: DCNL DCSP  DCSP cmd.append('--upgrade') DCNL DCSP if force_reinstall: DCNL DCSP  DCSP cmd.append('--force-reinstall') DCNL DCSP if ignore_installed: DCNL DCSP  DCSP cmd.append('--ignore-installed') DCNL DCSP if exists_action: DCNL DCSP  DCSP if (exists_action.lower() not in ('s', 'i', 'w', 'b')): DCNL DCSP  DCSP  DCSP raise CommandExecutionError("The DCSP exists_action DCSP pip DCSP option DCSP only DCSP supports DCSP the DCSP values DCSP s, DCSP i, DCSP w, DCSP and DCSP b. DCSP '{0}' DCSP is DCSP not DCSP valid.".format(exists_action)) DCNL DCSP  DCSP cmd.extend(['--exists-action', exists_action]) DCNL DCSP if no_deps: DCNL DCSP  DCSP cmd.append('--no-deps') DCNL DCSP if no_install: DCNL DCSP  DCSP cmd.append('--no-install') DCNL DCSP if no_download: DCNL DCSP  DCSP cmd.append('--no-download') DCNL DCSP if no_cache_dir: DCNL DCSP  DCSP cmd.append('--no-cache-dir') DCNL DCSP if pre_releases: DCNL DCSP  DCSP pip_version = version(pip_bin) DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=pip_version, oper='>=', ver2='1.4'): DCNL DCSP  DCSP  DCSP cmd.append('--pre') DCNL DCSP if cert: DCNL DCSP  DCSP cmd.extend(['--cert', cert]) DCNL DCSP if global_options: DCNL DCSP  DCSP if isinstance(global_options, string_types): DCNL DCSP  DCSP  DCSP global_options = [go.strip() for go in global_options.split(',')] DCNL DCSP  DCSP for opt in global_options: DCNL DCSP  DCSP  DCSP cmd.extend(['--global-option', opt]) DCNL DCSP if install_options: DCNL DCSP  DCSP if isinstance(install_options, string_types): DCNL DCSP  DCSP  DCSP install_options = [io.strip() for io in install_options.split(',')] DCNL DCSP  DCSP for opt in install_options: DCNL DCSP  DCSP  DCSP cmd.extend(['--install-option', opt]) DCNL DCSP if pkgs: DCNL DCSP  DCSP if isinstance(pkgs, string_types): DCNL DCSP  DCSP  DCSP pkgs = [p.strip() for p in pkgs.split(',')] DCNL DCSP  DCSP cmd.extend(['{0}'.format(p.replace(';', ',')) for p in pkgs]) DCNL DCSP if editable: DCNL DCSP  DCSP egg_match = re.compile('(?:#|#.*?&)egg=([^&]*)') DCNL DCSP  DCSP if isinstance(editable, string_types): DCNL DCSP  DCSP  DCSP editable = [e.strip() for e in editable.split(',')] DCNL DCSP  DCSP for entry in editable: DCNL DCSP  DCSP  DCSP if (not ((entry == '.') or entry.startswith(('file://', '/')))): DCNL DCSP  DCSP  DCSP  DCSP match = egg_match.search(entry) DCNL DCSP  DCSP  DCSP  DCSP if ((not match) or (not match.group(1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise CommandExecutionError('You DCSP must DCSP specify DCSP an DCSP egg DCSP for DCSP this DCSP editable') DCNL DCSP  DCSP  DCSP cmd.extend(['--editable', entry]) DCNL DCSP if allow_all_external: DCNL DCSP  DCSP cmd.append('--allow-all-external') DCNL DCSP if allow_external: DCNL DCSP  DCSP if isinstance(allow_external, string_types): DCNL DCSP  DCSP  DCSP allow_external = [p.strip() for p in allow_external.split(',')] DCNL DCSP  DCSP for pkg in allow_external: DCNL DCSP  DCSP  DCSP cmd.extend(['--allow-external', pkg]) DCNL DCSP if allow_unverified: DCNL DCSP  DCSP if isinstance(allow_unverified, string_types): DCNL DCSP  DCSP  DCSP allow_unverified = [p.strip() for p in allow_unverified.split(',')] DCNL DCSP  DCSP for pkg in allow_unverified: DCNL DCSP  DCSP  DCSP cmd.extend(['--allow-unverified', pkg]) DCNL DCSP if process_dependency_links: DCNL DCSP  DCSP cmd.append('--process-dependency-links') DCNL DCSP if env_vars: DCNL DCSP  DCSP if isinstance(env_vars, dict): DCNL DCSP  DCSP  DCSP for (k, v) in iteritems(env_vars): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(v, string_types)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP env_vars[k] = str(v) DCNL DCSP  DCSP  DCSP os.environ.update(env_vars) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise CommandExecutionError('env_vars DCSP {0} DCSP is DCSP not DCSP a DCSP dictionary'.format(env_vars)) DCNL DCSP if trusted_host: DCNL DCSP  DCSP cmd.extend(['--trusted-host', trusted_host]) DCNL DCSP try: DCNL DCSP  DCSP cmd_kwargs = dict(saltenv=saltenv, use_vt=use_vt, runas=user) DCNL DCSP  DCSP if cwd: DCNL DCSP  DCSP  DCSP cmd_kwargs['cwd'] = cwd DCNL DCSP  DCSP if (bin_env and os.path.isdir(bin_env)): DCNL DCSP  DCSP  DCSP cmd_kwargs['env'] = {'VIRTUAL_ENV': bin_env} DCNL DCSP  DCSP logger.debug('TRY DCSP BLOCK: DCSP end DCSP of DCSP pip.install DCSP -- DCSP cmd: DCSP %s, DCSP cmd_kwargs: DCSP %s', str(cmd), str(cmd_kwargs)) DCNL DCSP  DCSP return __salt__['cmd.run_all'](cmd, python_shell=False, **cmd_kwargs) DCNL DCSP finally: DCNL DCSP  DCSP for tempdir in [cr for cr in cleanup_requirements if (cr is not None)]: DCNL DCSP  DCSP  DCSP if os.path.isdir(tempdir): DCNL DCSP  DCSP  DCSP  DCSP shutil.rmtree(tempdir)
 DCSP global useText DCNL DCSP if (not useText): DCNL DCSP  DCSP return DCNL DCSP keyTime = psychopy.core.getTime() DCNL DCSP if emulated: DCNL DCSP  DCSP keySource = 'EmulatedKey' DCNL DCSP else: DCNL DCSP  DCSP keySource = 'KeyPress' DCNL DCSP _keyBuffer.append((text, keyTime)) DCNL DCSP logging.data(('%s: DCSP %s' % (keySource, text)))
 DCSP obj_store = ObjectStore.GetInstance(ObjectStore.PHOTO) DCNL DCSP welcome_path = os.path.join(ResourcesManager.Instance().resources_path, 'welcome') DCNL DCSP (yield _SetWelcomeIds(user, upload_request)) DCNL DCSP upload_request = deepcopy(upload_request) DCNL DCSP upload_request_copy = deepcopy(upload_request) DCNL DCSP [ph_dict.pop('name') for ph_dict in upload_request_copy['photos']] DCNL DCSP upload_response = (yield UploadEpisode(client, obj_store, user.user_id, user.webapp_dev_id, upload_request_copy)) DCNL DCSP for (request_ph_dict, response_ph_dict) in zip(upload_request['photos'], upload_response['photos']): DCNL DCSP  DCSP for format in ('full', 'med', 'tn'): DCNL DCSP  DCSP  DCSP f = open(os.path.join(welcome_path, ('%s_%s.jpg' % (request_ph_dict['name'], format))), 'r') DCNL DCSP  DCSP  DCSP image_data = f.read() DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP photo_url = response_ph_dict[(format + '_put_url')] DCNL DCSP  DCSP  DCSP content_md5 = base64.b64encode(request_ph_dict[(format + '_md5')].decode('hex')) DCNL DCSP  DCSP  DCSP headers = {'Content-Type': 'image/jpeg', 'Content-MD5': content_md5} DCNL DCSP  DCSP  DCSP validate_cert = (not options.options.fileobjstore) DCNL DCSP  DCSP  DCSP response = (yield gen.Task(http_client.fetch, photo_url, method='PUT', body=image_data, follow_redirects=False, validate_cert=validate_cert, headers=headers)) DCNL DCSP  DCSP  DCSP if (response.code != 200): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Cannot DCSP upload DCSP photo DCSP "%s". DCSP HTTP DCSP error DCSP code DCSP %d. DCSP Is DCSP server DCSP running DCSP and DCSP accessible?' % (request_ph_dict['photo_id'], response.code)))
 DCSP date_field = generic_view.get_date_field() DCNL DCSP allow_empty = generic_view.get_allow_empty() DCNL DCSP allow_future = generic_view.get_allow_future() DCNL DCSP get_current = getattr(generic_view, (u'_get_current_%s' % period)) DCNL DCSP get_next = getattr(generic_view, (u'_get_next_%s' % period)) DCNL DCSP (start, end) = (get_current(date), get_next(date)) DCNL DCSP if allow_empty: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP result = get_current((start - datetime.timedelta(days=1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = end DCNL DCSP  DCSP if (allow_future or (result <= timezone_today())): DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__lt' % date_field): generic_view._make_date_lookup_arg(start)} DCNL DCSP  DCSP  DCSP ordering = (u'-%s' % date_field) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__gte' % date_field): generic_view._make_date_lookup_arg(end)} DCNL DCSP  DCSP  DCSP ordering = date_field DCNL DCSP  DCSP if (not allow_future): DCNL DCSP  DCSP  DCSP if generic_view.uses_datetime_field: DCNL DCSP  DCSP  DCSP  DCSP now = timezone.now() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP now = timezone_today() DCNL DCSP  DCSP  DCSP lookup[(u'%s__lte' % date_field)] = now DCNL DCSP  DCSP qs = generic_view.get_queryset().filter(**lookup).order_by(ordering) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = getattr(qs[0], date_field) DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if generic_view.uses_datetime_field: DCNL DCSP  DCSP  DCSP if settings.USE_TZ: DCNL DCSP  DCSP  DCSP  DCSP result = timezone.localtime(result) DCNL DCSP  DCSP  DCSP result = result.date() DCNL DCSP  DCSP return get_current(result)
 DCSP TC = nx.transitive_closure(G) DCNL DCSP antichains_stacks = [([], list(reversed(list(nx.topological_sort(G)))))] DCNL DCSP while antichains_stacks: DCNL DCSP  DCSP (antichain, stack) = antichains_stacks.pop() DCNL DCSP  DCSP (yield antichain) DCNL DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP x = stack.pop() DCNL DCSP  DCSP  DCSP new_antichain = (antichain + [x]) DCNL DCSP  DCSP  DCSP new_stack = [t for t in stack if (not ((t in TC[x]) or (x in TC[t])))] DCNL DCSP  DCSP  DCSP antichains_stacks.append((new_antichain, new_stack))
 DCSP prefix = 'MSC DCSP v.' DCNL DCSP i = string.find(sys.version, prefix) DCNL DCSP if (i == (-1)): DCNL DCSP  DCSP return 6 DCNL DCSP i = (i + len(prefix)) DCNL DCSP (s, rest) = sys.version[i:].split(' DCSP ', 1) DCNL DCSP majorVersion = (int(s[:(-2)]) - 6) DCNL DCSP minorVersion = (int(s[2:3]) / 10.0) DCNL DCSP if (majorVersion == 6): DCNL DCSP  DCSP minorVersion = 0 DCNL DCSP if (majorVersion >= 6): DCNL DCSP  DCSP return (majorVersion + minorVersion) DCNL DCSP return None
 DCSP if (local_cache_enable and (method == 'GET') and cache.is_cached(url)): DCNL DCSP  DCSP info_dict = cache.get_info(url) DCNL DCSP  DCSP resp = cache.get_obj(url) DCNL DCSP  DCSP resp.set_data(content) DCNL DCSP  DCSP info_dict['without_content'] = False DCNL DCSP  DCSP if (verbose_level >= 4): DCNL DCSP  DCSP  DCSP dbgprint('LocalCache_UpdateCache', url, content[:30], len(content)) DCNL DCSP  DCSP cache.put_obj(url, resp, obj_size=len(content), expires=get_expire_from_mime(parse.mime), last_modified=info_dict.get('last_modified'), info_dict=info_dict)
 DCSP if os.fork(): DCNL DCSP  DCSP return 1 DCNL DCSP os.setsid() DCNL DCSP if os.fork(): DCNL DCSP  DCSP return 2 DCNL DCSP os.chdir('/') DCNL DCSP null = os.open('/dev/null', os.O_RDWR) DCNL DCSP for i in range(3): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.dup2(null, i) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.EBADF): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP os.close(null) DCNL DCSP warnings.filterwarnings('ignore') DCNL DCSP if pidfile: DCNL DCSP  DCSP piddir = os.path.dirname(pidfile) DCNL DCSP  DCSP if (not os.path.exists(piddir)): DCNL DCSP  DCSP  DCSP os.makedirs(piddir) DCNL DCSP  DCSP f = file(pidfile, 'w') DCNL DCSP  DCSP f.write(str(os.getpid())) DCNL DCSP  DCSP f.close() DCNL DCSP if (umask is not None): DCNL DCSP  DCSP os.umask(umask) DCNL DCSP if uid: DCNL DCSP  DCSP setugid(uid) DCNL DCSP return None
 DCSP return UUID(blockdevice_id[len(_PREFIX):])
 DCSP text = text.translate({0: None, ord('/'): '-', ord('|'): '-'}) DCNL DCSP if (os == 'Windows'): DCNL DCSP  DCSP text = text.translate({ord(':'): '-', ord('*'): '-', ord('?'): '-', ord('\\'): '-', ord('"'): "'", ord('+'): '-', ord('<'): '-', ord('>'): '-', ord('['): '(', ord(']'): ')'}) DCNL DCSP else: DCNL DCSP  DCSP if (os == 'Darwin'): DCNL DCSP  DCSP  DCSP text = text.translate({ord(':'): '-'}) DCNL DCSP  DCSP if text.startswith('.'): DCNL DCSP  DCSP  DCSP text = text[1:] DCNL DCSP text = text[:82] DCNL DCSP return text
 DCSP encodedStream = '' DCNL DCSP if ((parameters == None) or (parameters == {})): DCNL DCSP  DCSP return (0, stream) DCNL DCSP elif ((not parameters.has_key('/Name')) or (parameters['/Name'] == None)): DCNL DCSP  DCSP return (0, stream) DCNL DCSP else: DCNL DCSP  DCSP cryptFilterName = parameters['/Name'].getValue() DCNL DCSP  DCSP if (cryptFilterName == 'Identity'): DCNL DCSP  DCSP  DCSP return (0, stream) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ((-1), 'Decrypt DCSP not DCSP supported DCSP yet')
 DCSP patches = SplitPatch(data) DCNL DCSP rv = [] DCNL DCSP for patch in patches: DCNL DCSP  DCSP set_status(('uploading DCSP patch DCSP for DCSP ' + patch[0])) DCNL DCSP  DCSP if (len(patch[1]) > MAX_UPLOAD_SIZE): DCNL DCSP  DCSP  DCSP print (('Not DCSP uploading DCSP the DCSP patch DCSP for DCSP ' + patch[0]) + ' DCSP because DCSP the DCSP file DCSP is DCSP too DCSP large.') DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP form_fields = [('filename', patch[0])] DCNL DCSP  DCSP if (not options.download_base): DCNL DCSP  DCSP  DCSP form_fields.append(('content_upload', '1')) DCNL DCSP  DCSP files = [('data', 'data.diff', patch[1])] DCNL DCSP  DCSP (ctype, body) = EncodeMultipartFormData(form_fields, files) DCNL DCSP  DCSP url = ('/%d/upload_patch/%d' % (int(issue), int(patchset))) DCNL DCSP  DCSP print ('Uploading DCSP patch DCSP for DCSP ' + patch[0]) DCNL DCSP  DCSP response_body = rpc_server.Send(url, body, content_type=ctype) DCNL DCSP  DCSP lines = response_body.splitlines() DCNL DCSP  DCSP if ((not lines) or (lines[0] != 'OK')): DCNL DCSP  DCSP  DCSP StatusUpdate((' DCSP  DCSP --> DCSP %s' % response_body)) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP rv.append([lines[1], patch[0]]) DCNL DCSP return rv
 DCSP assert is_css_present(css_selector) DCNL DCSP return retry_on_exception((lambda : css_find(css_selector)[index].html))
 DCSP fut = delete_multi_async(blob_keys, **options) DCNL DCSP fut.get_result()
 DCSP try: DCNL DCSP  DCSP check = CHECKS[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise Http404('No DCSP check DCSP matches DCSP the DCSP given DCSP query.') DCNL DCSP ignore = ('ignored' in request.GET) DCNL DCSP url_params = {} DCNL DCSP if ignore: DCNL DCSP  DCSP url_params['ignored'] = 'true' DCNL DCSP checks = acl_checks(request.user).filter(check=name, ignore=ignore) DCNL DCSP if ('language' in request.GET): DCNL DCSP  DCSP checks = checks.filter(language__code=request.GET['language']) DCNL DCSP  DCSP url_params['language'] = request.GET['language'] DCNL DCSP if ('project' in request.GET): DCNL DCSP  DCSP return redirect_param('show_check_project', encode_optional(url_params), project=request.GET['project'], name=name) DCNL DCSP checks = checks.values('project__slug').annotate(count=Count('id')) DCNL DCSP return render(request, 'check.html', {'checks': checks, 'title': check.name, 'check': check, 'url_params': encode_optional(url_params)})
 DCSP try: DCNL DCSP  DCSP (installer, _) = plug_sel.choose_configurator_plugins(config, plugins, 'install') DCNL DCSP except errors.PluginSelectionError as e: DCNL DCSP  DCSP return e.message DCNL DCSP (domains, _) = _find_domains_or_certname(config, installer) DCNL DCSP le_client = _init_le_client(config, authenticator=None, installer=installer) DCNL DCSP assert (config.cert_path is not None) DCNL DCSP le_client.deploy_certificate(domains, config.key_path, config.cert_path, config.chain_path, config.fullchain_path) DCNL DCSP le_client.enhance_config(domains, config.chain_path)
 DCSP base_parsed = urlparse(base) DCNL DCSP if (not base_parsed.path): DCNL DCSP  DCSP sub_path = u'' DCNL DCSP else: DCNL DCSP  DCSP sub_path = base_parsed.path DCNL DCSP if sub_path.endswith(u'/'): DCNL DCSP  DCSP return sub_path DCNL DCSP else: DCNL DCSP  DCSP return (sub_path + u'/')
 DCSP if (len(val1) != len(val2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP if (six.PY3 and isinstance(val1, bytes) and isinstance(val2, bytes)): DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (x ^ y) DCNL DCSP else: DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (ord(x) ^ ord(y)) DCNL DCSP return (result == 0)
 DCSP loc = ['{}-'.format((locationID >> 24))] DCNL DCSP while (locationID & 15728640): DCNL DCSP  DCSP if (len(loc) > 1): DCNL DCSP  DCSP  DCSP loc.append('.') DCNL DCSP  DCSP loc.append('{}'.format(((locationID >> 20) & 15))) DCNL DCSP  DCSP locationID <<= 4 DCNL DCSP return ''.join(loc)
 DCSP try: DCNL DCSP  DCSP id = int(request.GET['id']) DCNL DCSP except: DCNL DCSP  DCSP id = 0 DCNL DCSP if (not id): DCNL DCSP  DCSP return HttpResponseRedirect('/wc/components/show_layout') DCNL DCSP ServerLayout.objects.filter(pk=id).delete() DCNL DCSP return HttpResponseRedirect('/wc/components/show_layout')
 DCSP (major, minor, micro, level, serial) = sys.version_info DCNL DCSP release = ('%s%s' % (major, minor)) DCNL DCSP if micro: DCNL DCSP  DCSP release += ('%s' % (micro,)) DCNL DCSP if (level == 'candidate'): DCNL DCSP  DCSP release += ('rc%s' % (serial,)) DCNL DCSP elif (level != 'final'): DCNL DCSP  DCSP release += ('%s%s' % (level[0], serial)) DCNL DCSP return release
 DCSP from cms.utils.page_permissions import get_change_permissions_id_list DCNL DCSP try: DCNL DCSP  DCSP user_level = get_user_permission_level(user, site) DCNL DCSP except NoPermissionsException: DCNL DCSP  DCSP qs = get_user_model().objects.distinct().filter(((Q(is_staff=True) & Q(pageuser__created_by=user)) & Q(pagepermission__page=None))) DCNL DCSP  DCSP qs = qs.exclude(pk=user.pk).exclude(groups__user__pk=user.pk) DCNL DCSP  DCSP return qs DCNL DCSP if (user_level == ROOT_USER_LEVEL): DCNL DCSP  DCSP return get_user_model().objects.all() DCNL DCSP page_id_allow_list = get_change_permissions_id_list(user, site, check_global=False) DCNL DCSP qs = get_user_model().objects.distinct().filter(((Q(is_staff=True) & (Q(pagepermission__page__id__in=page_id_allow_list) & Q(pagepermission__page__depth__gte=user_level))) | (Q(pageuser__created_by=user) & Q(pagepermission__page=None)))) DCNL DCSP qs = qs.exclude(pk=user.pk).exclude(groups__user__pk=user.pk) DCNL DCSP return qs
 DCSP numpy_status = {} DCNL DCSP try: DCNL DCSP  DCSP import numpy DCNL DCSP  DCSP numpy_version = numpy.__version__ DCNL DCSP  DCSP numpy_status['up_to_date'] = (parse_version(numpy_version) >= parse_version(NUMPY_MIN_VERSION)) DCNL DCSP  DCSP numpy_status['version'] = numpy_version DCNL DCSP except ImportError: DCNL DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP numpy_status['up_to_date'] = False DCNL DCSP  DCSP numpy_status['version'] = '' DCNL DCSP return numpy_status
 DCSP M = zeros((6, 6)) DCNL DCSP M[:3, :4] = P1 DCNL DCSP M[3:, :4] = P2 DCNL DCSP M[:3, 4] = (- x1) DCNL DCSP M[3:, 5] = (- x2) DCNL DCSP (U, S, V) = linalg.svd(M) DCNL DCSP X = V[(-1), :4] DCNL DCSP return (X / X[3])
 DCSP manager = MANAGER DCNL DCSP with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True): DCNL DCSP  DCSP res = run(('%(manager)s DCSP -p DCSP %(pkg_name)s' % locals())) DCNL DCSP if (not res.succeeded): DCNL DCSP  DCSP return False DCNL DCSP if pkg_name.startswith('='): DCNL DCSP  DCSP pkg_name = pkg_name[1:] DCNL DCSP match = re.search(('\\n\\[ebuild DCSP +(?P<code>\\w+) DCSP *\\] DCSP .*%(pkg_name)s.*' % locals()), res.stdout) DCNL DCSP if (match and (match.groupdict()['code'] in ('U', 'R'))): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
 DCSP if (msg is None): DCNL DCSP  DCSP msg = 'Test DCSP skipped DCSP due DCSP to DCSP known DCSP failure' DCNL DCSP if callable(fail_condition): DCNL DCSP  DCSP fail_val = (lambda : fail_condition()) DCNL DCSP else: DCNL DCSP  DCSP fail_val = (lambda : fail_condition) DCNL DCSP def knownfail_decorator(f): DCNL DCSP  DCSP import nose DCNL DCSP  DCSP def knownfailer(*args, **kwargs): DCNL DCSP  DCSP  DCSP if fail_val(): DCNL DCSP  DCSP  DCSP  DCSP raise KnownFailureTest(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP return nose.tools.make_decorator(f)(knownfailer) DCNL DCSP return knownfail_decorator
 DCSP cs.keypairs.delete(args.name, args.user)
 DCSP daynames = set([u'mon', u'tue', u'wed', u'thu', u'fri', u'sat', u'sun']) DCNL DCSP months = {u'jan': 1, u'feb': 2, u'mar': 3, u'apr': 4, u'may': 5, u'jun': 6, u'jul': 7, u'aug': 8, u'sep': 9, u'oct': 10, u'nov': 11, u'dec': 12} DCNL DCSP parts = date.lower().split() DCNL DCSP if (len(parts) < 5): DCNL DCSP  DCSP parts.extend((u'00:00:00', u'0000')) DCNL DCSP if (parts[0][:3] in daynames): DCNL DCSP  DCSP parts = parts[1:] DCNL DCSP if (len(parts) < 5): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP day = int(parts[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP if months.get(parts[0][:3]): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP day = int(parts[1]) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parts[1] = parts[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP month = months.get(parts[1][:3]) DCNL DCSP if (not month): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP year = int(parts[2]) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP if (len(parts[2]) <= 2): DCNL DCSP  DCSP year += (1900, 2000)[(year < 90)] DCNL DCSP timeparts = parts[3].split(u':') DCNL DCSP timeparts = (timeparts + ([0] * (3 - len(timeparts)))) DCNL DCSP try: DCNL DCSP  DCSP (hour, minute, second) = map(int, timeparts) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP tzhour = 0 DCNL DCSP tzmin = 0 DCNL DCSP if parts[4].startswith(u'etc/'): DCNL DCSP  DCSP parts[4] = parts[4][4:] DCNL DCSP if parts[4].startswith(u'gmt'): DCNL DCSP  DCSP parts[4] = (u''.join(parts[4][3:].split(u':')) or u'gmt') DCNL DCSP if (parts[4] and (parts[4][0] in (u'-', u'+'))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tzhour = int(parts[4][1:3]) DCNL DCSP  DCSP  DCSP tzmin = int(parts[4][3:]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if parts[4].startswith(u'-'): DCNL DCSP  DCSP  DCSP tzhour = (tzhour * (-1)) DCNL DCSP  DCSP  DCSP tzmin = (tzmin * (-1)) DCNL DCSP else: DCNL DCSP  DCSP tzhour = timezonenames.get(parts[4], 0) DCNL DCSP try: DCNL DCSP  DCSP stamp = datetime.datetime(year, month, day, hour, minute, second) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP delta = datetime.timedelta(0, 0, 0, 0, tzmin, tzhour) DCNL DCSP try: DCNL DCSP  DCSP return (stamp - delta).utctimetuple() DCNL DCSP except (OverflowError, ValueError): DCNL DCSP  DCSP return None
 DCSP return Constant(0.0, dtype=dtype)
 DCSP points = _ndim_coords_from_arrays(points) DCNL DCSP if (points.ndim < 2): DCNL DCSP  DCSP ndim = points.ndim DCNL DCSP else: DCNL DCSP  DCSP ndim = points.shape[(-1)] DCNL DCSP if ((ndim == 1) and (method in ('nearest', 'linear', 'cubic'))): DCNL DCSP  DCSP from .interpolate import interp1d DCNL DCSP  DCSP points = points.ravel() DCNL DCSP  DCSP if isinstance(xi, tuple): DCNL DCSP  DCSP  DCSP if (len(xi) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invalid DCSP number DCSP of DCSP dimensions DCSP in DCSP xi') DCNL DCSP  DCSP  DCSP (xi,) = xi DCNL DCSP  DCSP idx = np.argsort(points) DCNL DCSP  DCSP points = points[idx] DCNL DCSP  DCSP values = values[idx] DCNL DCSP  DCSP if (method == 'nearest'): DCNL DCSP  DCSP  DCSP fill_value = 'extrapolate' DCNL DCSP  DCSP ip = interp1d(points, values, kind=method, axis=0, bounds_error=False, fill_value=fill_value) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif (method == 'nearest'): DCNL DCSP  DCSP ip = NearestNDInterpolator(points, values, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif (method == 'linear'): DCNL DCSP  DCSP ip = LinearNDInterpolator(points, values, fill_value=fill_value, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif ((method == 'cubic') and (ndim == 2)): DCNL DCSP  DCSP ip = CloughTocher2DInterpolator(points, values, fill_value=fill_value, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP interpolation DCSP method DCSP %r DCSP for DCSP %d DCSP dimensional DCSP data' % (method, ndim)))
 DCSP longest = None DCNL DCSP for i in range(len(string)): DCNL DCSP  DCSP substr = string[:(i + 1)] DCNL DCSP  DCSP if (not trie.has_prefix(substr)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (substr in trie): DCNL DCSP  DCSP  DCSP longest = substr DCNL DCSP return longest
 DCSP try: DCNL DCSP  DCSP os.unlink(filename) DCNL DCSP except OSError as why: DCNL DCSP  DCSP if (why.errno == ENOENT): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP return 1
 DCSP if ((key in kw) and (type(kw[key]) is not type_) and (kw[key] is not None)): DCNL DCSP  DCSP if ((type_ is bool) and flexi_bool): DCNL DCSP  DCSP  DCSP kw[key] = asbool(kw[key]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kw[key] = type_(kw[key])
 DCSP smt = SMOTETomek(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
 DCSP return re.split(__WHITESPACE_SPLIT, string)
 DCSP mlp = BatchNormalizedMLP([Tanh(), Tanh()], [5, 7, 9], mean_only=True) DCNL DCSP assert mlp.mean_only DCNL DCSP assert (not any((act.children[0].mean_only for act in mlp.activations))) DCNL DCSP mlp.allocate() DCNL DCSP assert all((act.children[0].mean_only for act in mlp.activations))
 DCSP def retry_if(ex): DCNL DCSP  DCSP 'Retry DCSP if DCSP we DCSP get DCSP a DCSP server DCSP error DCSP indicating DCSP throttling. DCSP Also\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP handle DCSP spurious DCSP 505s DCSP that DCSP are DCSP thought DCSP to DCSP be DCSP part DCSP of DCSP a DCSP load\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP balancer DCSP issue DCSP inside DCSP AWS.' DCNL DCSP  DCSP return ((isinstance(ex, boto.exception.BotoServerError) and (('Throttling' in ex.body) or ('RequestExpired' in ex.body) or (ex.status == 505))) or (isinstance(ex, socket.error) and (ex.args in ((104, 'Connection DCSP reset DCSP by DCSP peer'), (110, 'Connection DCSP timed DCSP out'))))) DCNL DCSP return RetryWrapper(raw_conn, retry_if=retry_if, backoff=_EMR_BACKOFF, multiplier=_EMR_BACKOFF_MULTIPLIER, max_tries=_EMR_MAX_TRIES)
 DCSP qt = QTable(MIXIN_COLS) DCNL DCSP names = qt.colnames DCNL DCSP for name in names: DCNL DCSP  DCSP qt[name].info.description = name DCNL DCSP t = Table(qt) DCNL DCSP for name in names: DCNL DCSP  DCSP assert (t[name].info.description == name) DCNL DCSP  DCSP if (name == 'quantity'): DCNL DCSP  DCSP  DCSP assert np.all((t['quantity'] == qt['quantity'].value)) DCNL DCSP  DCSP  DCSP assert np.all((t['quantity'].unit is qt['quantity'].unit)) DCNL DCSP  DCSP  DCSP assert isinstance(t['quantity'], t.ColumnClass) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert_table_name_col_equal(t, name, qt[name]) DCNL DCSP qt2 = QTable(qt) DCNL DCSP for name in names: DCNL DCSP  DCSP assert (qt2[name].info.description == name) DCNL DCSP  DCSP assert_table_name_col_equal(qt2, name, qt[name])
 DCSP return SGR_MATRIX
 DCSP value_size = struct.calcsize(format) DCNL DCSP local_unpack = struct.unpack DCNL DCSP def InnerDecode(buffer, pos): DCNL DCSP  DCSP new_pos = (pos + value_size) DCNL DCSP  DCSP result = local_unpack(format, buffer[pos:new_pos])[0] DCNL DCSP  DCSP return (result, new_pos) DCNL DCSP return _SimpleDecoder(wire_type, InnerDecode)
 DCSP config = current.test_config DCNL DCSP browser = config.browser DCNL DCSP elem = browser.find_element_by_id('datatable_info') DCNL DCSP details = elem.text DCNL DCSP if (not quiet): DCNL DCSP  DCSP reporter(details) DCNL DCSP words = details.split() DCNL DCSP start = int(words[1]) DCNL DCSP end = int(words[3]) DCNL DCSP length = int(words[5]) DCNL DCSP filtered = None DCNL DCSP if (len(words) > 10): DCNL DCSP  DCSP filtered = int(words[9]) DCNL DCSP if (check != ()): DCNL DCSP  DCSP if (len(check) == 3): DCNL DCSP  DCSP  DCSP expected = ('Showing DCSP %d DCSP to DCSP %d DCSP of DCSP %d DCSP entries' % check) DCNL DCSP  DCSP  DCSP actual = ('Showing DCSP %d DCSP to DCSP %d DCSP of DCSP %d DCSP entries' % (start, end, length)) DCNL DCSP  DCSP  DCSP msg = ("Expected DCSP result DCSP of DCSP '%s' DCSP doesn't DCSP equal DCSP '%s'" % (expected, actual)) DCNL DCSP  DCSP  DCSP if (utObj != None): DCNL DCSP  DCSP  DCSP  DCSP utObj.assertEqual(((start, end, length) == check), msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert ((start, end, length) == check), msg DCNL DCSP  DCSP elif (len(check) == 4): DCNL DCSP  DCSP  DCSP expected = ('Showing DCSP %d DCSP to DCSP %d DCSP of DCSP %d DCSP entries DCSP (filtered DCSP from DCSP %d DCSP total DCSP entries)' % check) DCNL DCSP  DCSP  DCSP if filtered: DCNL DCSP  DCSP  DCSP  DCSP actual = ('Showing DCSP %d DCSP to DCSP %d DCSP of DCSP %d DCSP entries DCSP (filtered DCSP from DCSP %d DCSP total DCSP entries)' % (start, end, length, filtered)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP actual = ('Showing DCSP %d DCSP to DCSP %d DCSP of DCSP %d DCSP entries' % (start, end, length)) DCNL DCSP  DCSP  DCSP msg = ("Expected DCSP result DCSP of DCSP '%s' DCSP doesn't DCSP equal DCSP '%s'" % (expected, actual)) DCNL DCSP  DCSP  DCSP if (utObj != None): DCNL DCSP  DCSP  DCSP  DCSP utObj.assertEqual(((start, end, length) == check), msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert ((start, end, length, filtered) == check), msg DCNL DCSP if (len(words) > 10): DCNL DCSP  DCSP return (start, end, length, filtered) DCNL DCSP else: DCNL DCSP  DCSP return (start, end, length)
 DCSP size = len(matrix) DCNL DCSP epsilon = 0.0001 DCNL DCSP matrix = matrix.copy() DCNL DCSP for i in xrange(0, size): DCNL DCSP  DCSP col_sum = matrix[:, i].sum() DCNL DCSP  DCSP if col_sum: DCNL DCSP  DCSP  DCSP matrix[:, i] /= col_sum DCNL DCSP e = (((1.0 - d_factor) / size) * numpy.ones((size, size))) DCNL DCSP matrix = ((d_factor * matrix) + e) DCNL DCSP result = (numpy.ones(size) / size) DCNL DCSP prev = (numpy.ones(size) / size) DCNL DCSP iteration = 0 DCNL DCSP while True: DCNL DCSP  DCSP result = numpy.dot(matrix, result) DCNL DCSP  DCSP result /= result.sum() DCNL DCSP  DCSP diff = numpy.abs((result - prev)).sum() DCNL DCSP  DCSP print ('Iteration DCSP %d, DCSP change DCSP %f' % (iteration, diff)) DCNL DCSP  DCSP if (diff < epsilon): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP prev = result DCNL DCSP  DCSP iteration += 1 DCNL DCSP return result
 DCSP if (not proxy): DCNL DCSP  DCSP pre_login = session.get(url, allow_redirects=False, timeout=5) DCNL DCSP else: DCNL DCSP  DCSP pre_login = session.get(url, allow_redirects=False, timeout=5, proxies=app.config['SCHOOL_LAN_PROXIES']) DCNL DCSP pre_login.raise_for_status() DCNL DCSP pre_login_soup = BeautifulSoup(pre_login.text, 'html.parser', parse_only=SoupStrainer('input')) DCNL DCSP login_view_state = pre_login_soup.find(attrs={'name': '__VIEWSTATE'})['value'] DCNL DCSP payload = {'__VIEWSTATE': login_view_state, 'TextBox1': studentid, 'TextBox2': studentpwd, 'RadioButtonList1': u'\u5b66\u751f', 'Button1': u' DCSP \u767b DCSP \u5f55 DCSP '} DCNL DCSP if (not proxy): DCNL DCSP  DCSP res = session.post(url, data=payload, allow_redirects=False, timeout=5) DCNL DCSP else: DCNL DCSP  DCSP res = session.post(url, data=payload, allow_redirects=False, timeout=5, proxies=app.config['SCHOOL_LAN_PROXIES']) DCNL DCSP return res
 DCSP config = Configurator(root_factory=root_factory, settings=settings) DCNL DCSP config.include('pyramid_chameleon') DCNL DCSP config.add_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
 DCSP return ((getNumberOfIntersectionsToLeft(loop, point) % 2) == 1)
 DCSP student = get_mapped_doc(u'Student DCSP Applicant', source_name, {u'Student DCSP Applicant': {u'doctype': u'Student', u'field_map': {u'name': u'student_applicant'}}}, ignore_permissions=True) DCNL DCSP student.save() DCNL DCSP program_enrollment = frappe.new_doc(u'Program DCSP Enrollment') DCNL DCSP program_enrollment.student = student.name DCNL DCSP program_enrollment.student_name = student.title DCNL DCSP program_enrollment.program = frappe.db.get_value(u'Student DCSP Applicant', source_name, u'program') DCNL DCSP return program_enrollment
 DCSP generator = fill_gaps_generator(*args, **kwargs) DCNL DCSP return list(generator)
 DCSP oauth = credsfromfile() DCNL DCSP client = Query(**oauth) DCNL DCSP client.register(TweetWriter()) DCNL DCSP client.user_tweets(user, count)
 DCSP return GradClip(lower_bound, upper_bound)(x)
 DCSP inputs = get_tiles(names, config, coord) DCNL DCSP output = {'type': 'Topology', 'transform': inputs[0]['transform'], 'objects': dict(), 'arcs': list()} DCNL DCSP for (name, input) in zip(names, inputs): DCNL DCSP  DCSP for (index, object) in enumerate(input['objects'].values()): DCNL DCSP  DCSP  DCSP if (len(input['objects']) > 1): DCNL DCSP  DCSP  DCSP  DCSP output['objects'][('%(name)s-%(index)d' % locals())] = object DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP output['objects'][name] = object DCNL DCSP  DCSP  DCSP for geometry in object['geometries']: DCNL DCSP  DCSP  DCSP  DCSP update_arc_indexes(geometry, output['arcs'], input['arcs']) DCNL DCSP file.write(json.dumps(output, separators=(',', ':')).encode('utf8'))
 DCSP return salt.utils.cloud.os_script(config.get_cloud_config_value('script', vm_, __opts__), vm_, __opts__, salt.utils.cloud.salt_config_to_yaml(salt.utils.cloud.minion_config(__opts__, vm_)))
 DCSP products = _fast_sphere_dot_r0(intrad, rsurf, rmags, lsurf, rlens, this_nn, cosmags, None, ws, volume, lut, n_fact, ch_type).T DCNL DCSP if (rref is not None): DCNL DCSP  DCSP raise NotImplementedError DCNL DCSP return products
 DCSP if (not n): DCNL DCSP  DCSP return [K.one] DCNL DCSP elif (n == 1): DCNL DCSP  DCSP return gf_rem(f, g, p, K) DCNL DCSP elif (n == 2): DCNL DCSP  DCSP return gf_rem(gf_sqr(f, p, K), g, p, K) DCNL DCSP h = [K.one] DCNL DCSP while True: DCNL DCSP  DCSP if (n & 1): DCNL DCSP  DCSP  DCSP h = gf_mul(h, f, p, K) DCNL DCSP  DCSP  DCSP h = gf_rem(h, g, p, K) DCNL DCSP  DCSP  DCSP n -= 1 DCNL DCSP  DCSP n >>= 1 DCNL DCSP  DCSP if (not n): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP f = gf_sqr(f, p, K) DCNL DCSP  DCSP f = gf_rem(f, g, p, K) DCNL DCSP return h
 DCSP return (x & y).sum()
 DCSP ret = {'jid': jid} DCNL DCSP mminion = salt.minion.MasterMinion(__opts__) DCNL DCSP returner = _get_returner((__opts__['ext_job_cache'], ext_source, __opts__['master_job_cache'])) DCNL DCSP if display_progress: DCNL DCSP  DCSP __jid_event__.fire_event({'message': 'Querying DCSP returner: DCSP {0}'.format(returner)}, 'progress') DCNL DCSP job = mminion.returners['{0}.get_load'.format(returner)](jid) DCNL DCSP ret.update(_format_jid_instance(jid, job)) DCNL DCSP ret['Result'] = mminion.returners['{0}.get_jid'.format(returner)](jid) DCNL DCSP fstr = '{0}.get_endtime'.format(__opts__['master_job_cache']) DCNL DCSP if (__opts__.get('job_cache_store_endtime') and (fstr in mminion.returners)): DCNL DCSP  DCSP endtime = mminion.returners[fstr](jid) DCNL DCSP  DCSP if endtime: DCNL DCSP  DCSP  DCSP ret['EndTime'] = endtime DCNL DCSP return ret
 DCSP CONFIG.AddOption(type_info.Choice(name=name, default=default, choices=choices, description=help))
 DCSP cmp_func = __salt__.get('pkg.version_cmp') DCNL DCSP if salt.utils.is_freebsd(): DCNL DCSP  DCSP if (isinstance(versions, dict) and ('version' in versions)): DCNL DCSP  DCSP  DCSP versions = versions['version'] DCNL DCSP for ver in versions: DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=ver, oper=oper, ver2=desired_version, cmp_func=cmp_func, ignore_epoch=ignore_epoch): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP ret = {} DCNL DCSP with salt.utils.fopen(exports, 'r') as efl: DCNL DCSP  DCSP for line in efl.read().splitlines(): DCNL DCSP  DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP comps = line.split() DCNL DCSP  DCSP  DCSP ret[comps[0]] = [] DCNL DCSP  DCSP  DCSP newshares = [] DCNL DCSP  DCSP  DCSP for perm in comps[1:]: DCNL DCSP  DCSP  DCSP  DCSP if perm.startswith('/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newshares.append(perm) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP permcomps = perm.split('(') DCNL DCSP  DCSP  DCSP  DCSP permcomps[1] = permcomps[1].replace(')', '') DCNL DCSP  DCSP  DCSP  DCSP hosts = permcomps[0].split(',') DCNL DCSP  DCSP  DCSP  DCSP options = permcomps[1].split(',') DCNL DCSP  DCSP  DCSP  DCSP ret[comps[0]].append({'hosts': hosts, 'options': options}) DCNL DCSP  DCSP  DCSP for share in newshares: DCNL DCSP  DCSP  DCSP  DCSP ret[share] = ret[comps[0]] DCNL DCSP return ret
 DCSP drive = os.path.splitdrive(path)[0] DCNL DCSP if (not os.path.isdir(drive)): DCNL DCSP  DCSP raise CommandExecutionError('Drive DCSP {0} DCSP is DCSP not DCSP mapped'.format(drive)) DCNL DCSP path = os.path.expanduser(path) DCNL DCSP path = os.path.expandvars(path) DCNL DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP os.mkdir(path) DCNL DCSP  DCSP if owner: DCNL DCSP  DCSP  DCSP salt.utils.win_dacl.set_owner(path, owner) DCNL DCSP  DCSP set_perms(path, grant_perms, deny_perms, inheritance) DCNL DCSP return True
 DCSP def do_something_with(sub): DCNL DCSP  DCSP pass DCNL DCSP for subscription in client.list_subscriptions(): DCNL DCSP  DCSP do_something_with(subscription)
 DCSP return (((function == DEFINITE) and definite_article(word)) or indefinite_article(word))
 DCSP logger1.info('>>notify DCSP url DCSP handler DCSP start...') DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP if notify_verify(request.POST): DCNL DCSP  DCSP  DCSP logger1.info('pass DCSP verification...') DCNL DCSP  DCSP  DCSP tn = request.POST.get('out_trade_no') DCNL DCSP  DCSP  DCSP logger1.info(('Change DCSP the DCSP status DCSP of DCSP bill DCSP %s' % tn)) DCNL DCSP  DCSP  DCSP bill = Bill.objects.get(pk=tn) DCNL DCSP  DCSP  DCSP trade_status = request.POST.get('trade_status') DCNL DCSP  DCSP  DCSP logger1.info(('the DCSP status DCSP of DCSP bill DCSP %s DCSP changed DCSP to DCSP %s' % (tn, trade_status))) DCNL DCSP  DCSP  DCSP bill.trade_status = trade_status DCNL DCSP  DCSP  DCSP bill.save() DCNL DCSP  DCSP  DCSP trade_no = request.POST.get('trade_no') DCNL DCSP  DCSP  DCSP if (trade_status == 'WAIT_SELLER_SEND_GOODS'): DCNL DCSP  DCSP  DCSP  DCSP logger1.info('It DCSP is DCSP WAIT_SELLER_SEND_GOODS, DCSP so DCSP upgrade DCSP bill') DCNL DCSP  DCSP  DCSP  DCSP upgrade_bill(bill, ((6 * 30) + 7)) DCNL DCSP  DCSP  DCSP  DCSP url = send_goods_confirm_by_platform(trade_no) DCNL DCSP  DCSP  DCSP  DCSP logger1.info(('send DCSP goods DCSP confirmation. DCSP %s' % url)) DCNL DCSP  DCSP  DCSP  DCSP req = urllib.urlopen(url) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponse('success') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger1.info(('##info: DCSP Status DCSP of DCSP %s' % trade_status)) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponse('success') DCNL DCSP return HttpResponse('fail')
 DCSP if (type(b) is str): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if (b == 'none'): DCNL DCSP  DCSP return None DCNL DCSP if (b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in ('f', 'n', 'no', 'off', 'false', '0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
 DCSP sc = SkyCoord(RA, DEC, frame=u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP sc = SkyCoord(RA, DEC, frame=ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoord(RA, DEC, u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoord(RA, DEC, ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoord(u'icrs', RA, DEC) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoord(ICRS, RA, DEC) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP sc = SkyCoord(sc) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP sc = SkyCoord(C_ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP SkyCoord(C_ICRS, frame=u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP SkyCoord(C_ICRS, frame=u'galactic') DCNL DCSP assert (u'Cannot DCSP override DCSP frame=' in str(err))
 DCSP return os.urandom(n)
 DCSP return (hasattr(accessing_obj, 'has_player') and accessing_obj.has_player)
 DCSP toplevel = params['options'].toplevel_dir DCNL DCSP qualified_out_dir = os.path.normpath(os.path.join(toplevel, ComputeOutputDir(params), 'gypfiles')) DCNL DCSP global generator_filelist_paths DCNL DCSP generator_filelist_paths = {'toplevel': toplevel, 'qualified_out_dir': qualified_out_dir}
 DCSP raw = read_raw_fif(fif_fname, preload=True) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP assert_raises(ValueError, add_reference_channels, raw, raw.info['ch_names'][0]) DCNL DCSP raw_ref = add_reference_channels(raw, 'Ref', copy=True) DCNL DCSP assert_equal(raw_ref._data.shape[0], (raw._data.shape[0] + 1)) DCNL DCSP assert_array_equal(raw._data[picks_eeg, :], raw_ref._data[picks_eeg, :]) DCNL DCSP _check_channel_names(raw_ref, 'Ref') DCNL DCSP orig_nchan = raw.info['nchan'] DCNL DCSP raw = add_reference_channels(raw, 'Ref', copy=False) DCNL DCSP assert_array_equal(raw._data, raw_ref._data) DCNL DCSP assert_equal(raw.info['nchan'], (orig_nchan + 1)) DCNL DCSP _check_channel_names(raw, 'Ref') DCNL DCSP assert_allclose(raw.info['chs'][(-1)]['loc'][:3], raw.info['chs'][picks_eeg[0]]['loc'][3:6], 1e-06) DCNL DCSP ref_idx = raw.ch_names.index('Ref') DCNL DCSP (ref_data, _) = raw[ref_idx] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP raw = read_raw_fif(fif_fname).crop(0, 1).load_data() DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP del raw.info['dig'] DCNL DCSP raw_ref = add_reference_channels(raw, 'Ref', copy=True) DCNL DCSP assert_equal(raw_ref._data.shape[0], (raw._data.shape[0] + 1)) DCNL DCSP assert_array_equal(raw._data[picks_eeg, :], raw_ref._data[picks_eeg, :]) DCNL DCSP _check_channel_names(raw_ref, 'Ref') DCNL DCSP orig_nchan = raw.info['nchan'] DCNL DCSP raw = add_reference_channels(raw, 'Ref', copy=False) DCNL DCSP assert_array_equal(raw._data, raw_ref._data) DCNL DCSP assert_equal(raw.info['nchan'], (orig_nchan + 1)) DCNL DCSP _check_channel_names(raw, 'Ref') DCNL DCSP assert_raises(ValueError, add_reference_channels, raw, raw.info['ch_names'][0]) DCNL DCSP raw_ref = add_reference_channels(raw, ['M1', 'M2'], copy=True) DCNL DCSP _check_channel_names(raw_ref, ['M1', 'M2']) DCNL DCSP assert_equal(raw_ref._data.shape[0], (raw._data.shape[0] + 2)) DCNL DCSP assert_array_equal(raw._data[picks_eeg, :], raw_ref._data[picks_eeg, :]) DCNL DCSP assert_array_equal(raw_ref._data[(-2):, :], 0) DCNL DCSP raw = add_reference_channels(raw, ['M1', 'M2'], copy=False) DCNL DCSP _check_channel_names(raw, ['M1', 'M2']) DCNL DCSP ref_idx = raw.ch_names.index('M1') DCNL DCSP ref_idy = raw.ch_names.index('M2') DCNL DCSP (ref_data, _) = raw[[ref_idx, ref_idy]] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP raw = read_raw_fif(fif_fname, preload=True) DCNL DCSP events = read_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_id=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preload=True) DCNL DCSP assert_raises(RuntimeError, add_reference_channels, epochs, 'Ref') DCNL DCSP epochs = Epochs(raw, events=events, event_id=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preload=True, proj='delayed') DCNL DCSP epochs_ref = add_reference_channels(epochs, 'Ref', copy=True) DCNL DCSP assert_equal(epochs_ref._data.shape[1], (epochs._data.shape[1] + 1)) DCNL DCSP _check_channel_names(epochs_ref, 'Ref') DCNL DCSP ref_idx = epochs_ref.ch_names.index('Ref') DCNL DCSP ref_data = epochs_ref.get_data()[:, ref_idx, :] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP picks_eeg = pick_types(epochs.info, meg=False, eeg=True) DCNL DCSP assert_array_equal(epochs.get_data()[:, picks_eeg, :], epochs_ref.get_data()[:, picks_eeg, :]) DCNL DCSP raw = read_raw_fif(fif_fname, preload=True) DCNL DCSP events = read_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_id=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preload=True, proj='delayed') DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP epochs_ref = add_reference_channels(epochs, ['M1', 'M2'], copy=True) DCNL DCSP assert_equal(epochs_ref._data.shape[1], (epochs._data.shape[1] + 2)) DCNL DCSP _check_channel_names(epochs_ref, ['M1', 'M2']) DCNL DCSP ref_idx = epochs_ref.ch_names.index('M1') DCNL DCSP ref_idy = epochs_ref.ch_names.index('M2') DCNL DCSP assert_equal(epochs_ref.info['chs'][ref_idx]['ch_name'], 'M1') DCNL DCSP assert_equal(epochs_ref.info['chs'][ref_idy]['ch_name'], 'M2') DCNL DCSP ref_data = epochs_ref.get_data()[:, [ref_idx, ref_idy], :] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP picks_eeg = pick_types(epochs.info, meg=False, eeg=True) DCNL DCSP assert_array_equal(epochs.get_data()[:, picks_eeg, :], epochs_ref.get_data()[:, picks_eeg, :]) DCNL DCSP raw = read_raw_fif(fif_fname, preload=True) DCNL DCSP events = read_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_id=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preload=True, proj='delayed') DCNL DCSP evoked = epochs.average() DCNL DCSP evoked_ref = add_reference_channels(evoked, 'Ref', copy=True) DCNL DCSP assert_equal(evoked_ref.data.shape[0], (evoked.data.shape[0] + 1)) DCNL DCSP _check_channel_names(evoked_ref, 'Ref') DCNL DCSP ref_idx = evoked_ref.ch_names.index('Ref') DCNL DCSP ref_data = evoked_ref.data[ref_idx, :] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP picks_eeg = pick_types(evoked.info, meg=False, eeg=True) DCNL DCSP assert_array_equal(evoked.data[picks_eeg, :], evoked_ref.data[picks_eeg, :]) DCNL DCSP raw = read_raw_fif(fif_fname, preload=True) DCNL DCSP events = read_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_id=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preload=True, proj='delayed') DCNL DCSP evoked = epochs.average() DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP evoked_ref = add_reference_channels(evoked, ['M1', 'M2'], copy=True) DCNL DCSP assert_equal(evoked_ref.data.shape[0], (evoked.data.shape[0] + 2)) DCNL DCSP _check_channel_names(evoked_ref, ['M1', 'M2']) DCNL DCSP ref_idx = evoked_ref.ch_names.index('M1') DCNL DCSP ref_idy = evoked_ref.ch_names.index('M2') DCNL DCSP ref_data = evoked_ref.data[[ref_idx, ref_idy], :] DCNL DCSP assert_array_equal(ref_data, 0) DCNL DCSP picks_eeg = pick_types(evoked.info, meg=False, eeg=True) DCNL DCSP assert_array_equal(evoked.data[picks_eeg, :], evoked_ref.data[picks_eeg, :]) DCNL DCSP raw_np = read_raw_fif(fif_fname, preload=False) DCNL DCSP assert_raises(RuntimeError, add_reference_channels, raw_np, ['Ref']) DCNL DCSP assert_raises(ValueError, add_reference_channels, raw, 1)
 DCSP sidepath = (Conv(**conv_params(1, (nfm * 4), 1, False, False)) if first else SkipNode()) DCNL DCSP mainpath = ([] if first else [BatchNorm(), Activation(Rectlin())]) DCNL DCSP mainpath.append(Conv(**conv_params(1, nfm))) DCNL DCSP mainpath.append(Conv(**conv_params(3, nfm))) DCNL DCSP mainpath.append(Conv(**conv_params(1, (nfm * 4), relu=False, batch_norm=False))) DCNL DCSP return MergeSum([sidepath, mainpath])
 DCSP return [MockPreset('1')]
 DCSP tests = [] DCNL DCSP names = ['testParseHostname', 'testExtractMastersSingle', 'testExtractMastersMultiple'] DCNL DCSP tests.extend(list(list(map(BasicTestCase, names)))) DCNL DCSP suite = unittest.TestSuite(tests) DCNL DCSP unittest.TextTestRunner(verbosity=2).run(suite)
 DCSP global dataReg DCNL DCSP if (state == 0): DCNL DCSP  DCSP dataReg = (dataReg & (~ 32)) DCNL DCSP else: DCNL DCSP  DCSP dataReg = (dataReg | 32) DCNL DCSP port.DlPortWritePortUchar(baseAddress, dataReg)
 DCSP return os.access(exe, os.X_OK)
 DCSP ret = {'name': 'testing DCSP mode', 'changes': {}, 'result': True, 'comment': 'Option DCSP already DCSP present.'} DCNL DCSP option = name DCNL DCSP current_option = __salt__['csf.get_option'](option) DCNL DCSP if current_option: DCNL DCSP  DCSP l = __salt__['csf.split_option'](current_option) DCNL DCSP  DCSP option_value = l[1] DCNL DCSP  DCSP if ('"{0}"'.format(value) == option_value): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = __salt__['csf.set_option'](option, value) DCNL DCSP  DCSP  DCSP ret['comment'] = 'Option DCSP modified.' DCNL DCSP  DCSP  DCSP ret['changes']['Option'] = 'Changed' DCNL DCSP else: DCNL DCSP  DCSP result = __salt__['file.append']('/etc/csf/csf.conf', args='{0} DCSP = DCSP "{1}"'.format(option, value)) DCNL DCSP  DCSP ret['comment'] = 'Option DCSP not DCSP present. DCSP Appended DCSP to DCSP csf.conf' DCNL DCSP  DCSP ret['changes']['Option'] = 'Changed.' DCNL DCSP if reload: DCNL DCSP  DCSP if __salt__['csf.reload'](): DCNL DCSP  DCSP  DCSP ret['comment'] += '. DCSP Csf DCSP reloaded.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] += '. DCSP Csf DCSP failed DCSP to DCSP reload.' DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
 DCSP if (environ['REQUEST_METHOD'].upper() != 'POST'): DCNL DCSP  DCSP data = 'Hello, DCSP World!\n' DCNL DCSP else: DCNL DCSP  DCSP data = environ['wsgi.input'].read() DCNL DCSP status = '200 DCSP OK' DCNL DCSP response_headers = [('Content-type', 'text/plain'), ('Content-Length', str(len(data))), ('X-Gunicorn-Version', __version__), ('Test', 'test DCSP \xd1\x82\xd0\xb5\xd1\x81\xd1\x82')] DCNL DCSP start_response(status, response_headers) DCNL DCSP return iter([data])
 DCSP model = queryset.model DCNL DCSP sql = 'SELECT DCSP SUM(projects_points.value)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP userstories_rolepoints\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP userstories_userstory DCSP ON DCSP userstories_userstory.id DCSP = DCSP userstories_rolepoints.user_story_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP projects_points DCSP ON DCSP userstories_rolepoints.points_id DCSP = DCSP projects_points.id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP userstories_userstory.milestone_id DCSP = DCSP {tbl}.id' DCNL DCSP sql = sql.format(tbl=model._meta.db_table) DCNL DCSP queryset = queryset.extra(select={as_field: sql}) DCNL DCSP return queryset
 DCSP ret = {'name': name, 'changes': {}, 'comment': str(), 'result': None} DCNL DCSP current_vdirs = __salt__['win_iis.list_vdirs'](site, app) DCNL DCSP if (name in current_vdirs): DCNL DCSP  DCSP ret['comment'] = 'Virtual DCSP directory DCSP already DCSP present: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Virtual DCSP directory DCSP will DCSP be DCSP created: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['changes'] = {'old': None, 'new': name} DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Created DCSP virtual DCSP directory: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['changes'] = {'old': None, 'new': name} DCNL DCSP  DCSP ret['result'] = __salt__['win_iis.create_vdir'](name, site, sourcepath, app) DCNL DCSP return ret
 DCSP import pandas as pd DCNL DCSP return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}
 DCSP env_vars = PACKAGE_INFO[package] DCNL DCSP start_command = get_start_command(package) DCNL DCSP proc_start = subprocess.Popen(start_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP try: DCNL DCSP  DCSP wait_ready(package, proc_start) DCNL DCSP  DCSP env_init_command = get_env_init_command(package) DCNL DCSP  DCSP proc_env = subprocess.Popen(env_init_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP env_status = proc_env.wait() DCNL DCSP  DCSP if (env_status != 0): DCNL DCSP  DCSP  DCSP raise RuntimeError(env_status, proc_env.stderr.read()) DCNL DCSP  DCSP env_lines = proc_env.stdout.read().strip().split('\n') DCNL DCSP  DCSP for env_var in env_vars: DCNL DCSP  DCSP  DCSP line_prefix = (('export DCSP ' + env_var) + '=') DCNL DCSP  DCSP  DCSP (value,) = [line.split(line_prefix, 1)[1] for line in env_lines if line.startswith(line_prefix)] DCNL DCSP  DCSP  DCSP os.environ[env_var] = value DCNL DCSP  DCSP run_module_tests(package, ignore_requirements=True) DCNL DCSP finally: DCNL DCSP  DCSP cleanup(proc_start.pid)
 DCSP assert (hsl_to_rgb(0, 100, 50) == (255, 0, 0)) DCNL DCSP assert (hsl_to_rgb(12, 100, 50) == (255, 51, 0)) DCNL DCSP assert (hsl_to_rgb(24, 100, 50) == (255, 102, 0)) DCNL DCSP assert (hsl_to_rgb(36, 100, 50) == (255, 153, 0)) DCNL DCSP assert (hsl_to_rgb(48, 100, 50) == (255, 204, 0)) DCNL DCSP assert (hsl_to_rgb(60, 100, 50) == (255, 255, 0)) DCNL DCSP assert (hsl_to_rgb(72, 100, 50) == (204, 255, 0)) DCNL DCSP assert (hsl_to_rgb(84, 100, 50) == (153, 255, 0)) DCNL DCSP assert (hsl_to_rgb(96, 100, 50) == (102, 255, 0)) DCNL DCSP assert (hsl_to_rgb(108, 100, 50) == (51, 255, 0)) DCNL DCSP assert (hsl_to_rgb(120, 100, 50) == (0, 255, 0))
 DCSP if (create_using is None): DCNL DCSP  DCSP if A.is_directed(): DCNL DCSP  DCSP  DCSP if A.is_strict(): DCNL DCSP  DCSP  DCSP  DCSP create_using = nx.DiGraph() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP create_using = nx.MultiDiGraph() DCNL DCSP  DCSP elif A.is_strict(): DCNL DCSP  DCSP  DCSP create_using = nx.Graph() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP create_using = nx.MultiGraph() DCNL DCSP N = nx.empty_graph(0, create_using) DCNL DCSP N.name = '' DCNL DCSP if (A.name is not None): DCNL DCSP  DCSP N.name = A.name DCNL DCSP for n in A.nodes(): DCNL DCSP  DCSP str_attr = dict(((str(k), v) for (k, v) in n.attr.items())) DCNL DCSP  DCSP N.add_node(str(n), **str_attr) DCNL DCSP for e in A.edges(): DCNL DCSP  DCSP (u, v) = (str(e[0]), str(e[1])) DCNL DCSP  DCSP attr = dict(e.attr) DCNL DCSP  DCSP str_attr = dict(((str(k), v) for (k, v) in attr.items())) DCNL DCSP  DCSP if (not N.is_multigraph()): DCNL DCSP  DCSP  DCSP if (e.name is not None): DCNL DCSP  DCSP  DCSP  DCSP str_attr['key'] = e.name DCNL DCSP  DCSP  DCSP N.add_edge(u, v, **str_attr) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP N.add_edge(u, v, key=e.name, **str_attr) DCNL DCSP N.graph['graph'] = dict(A.graph_attr) DCNL DCSP N.graph['node'] = dict(A.node_attr) DCNL DCSP N.graph['edge'] = dict(A.edge_attr) DCNL DCSP return N
 DCSP return False
 DCSP _validate_device(device) DCNL DCSP try: DCNL DCSP  DCSP int(partition) DCNL DCSP except Exception: DCNL DCSP  DCSP raise CommandExecutionError('Invalid DCSP partition DCSP number DCSP passed DCSP to DCSP partition.toggle') DCNL DCSP if (flag not in set(['bios_grub', 'legacy_boot', 'boot', 'lba', 'root', 'swap', 'hidden', 'raid', 'LVM', 'PALO', 'PREP', 'DIAG'])): DCNL DCSP  DCSP raise CommandExecutionError('Invalid DCSP flag DCSP passed DCSP to DCSP partition.toggle') DCNL DCSP cmd = 'parted DCSP -m DCSP -s DCSP {0} DCSP toggle DCSP {1} DCSP {2}'.format(device, partition, flag) DCNL DCSP out = __salt__['cmd.run'](cmd).splitlines() DCNL DCSP return out
 DCSP url = editable_req DCNL DCSP if (os.path.isdir(url) and os.path.exists(os.path.join(url, 'setup.py'))): DCNL DCSP  DCSP url = path_to_url(url) DCNL DCSP if url.lower().startswith('file:'): DCNL DCSP  DCSP return (None, url) DCNL DCSP for version_control in vcs: DCNL DCSP  DCSP if url.lower().startswith(('%s:' % version_control)): DCNL DCSP  DCSP  DCSP url = ('%s+%s' % (version_control, url)) DCNL DCSP if ('+' not in url): DCNL DCSP  DCSP if default_vcs: DCNL DCSP  DCSP  DCSP url = ((default_vcs + '+') + url) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InstallationError(('--editable=%s DCSP should DCSP be DCSP formatted DCSP with DCSP svn+URL, DCSP git+URL, DCSP hg+URL DCSP or DCSP bzr+URL' % editable_req)) DCNL DCSP vc_type = url.split('+', 1)[0].lower() DCNL DCSP if (not vcs.get_backend(vc_type)): DCNL DCSP  DCSP raise InstallationError(('For DCSP --editable=%s DCSP only DCSP svn DCSP (svn+URL), DCSP Git DCSP (git+URL), DCSP Mercurial DCSP (hg+URL) DCSP and DCSP Bazaar DCSP (bzr+URL) DCSP is DCSP currently DCSP supported' % editable_req)) DCNL DCSP match = re.search('(?:#|#.*?&)egg=([^&]*)', editable_req) DCNL DCSP if (((not match) or (not match.group(1))) and vcs.get_backend(vc_type)): DCNL DCSP  DCSP parts = [p for p in editable_req.split('#', 1)[0].split('/') if p] DCNL DCSP  DCSP if (parts[(-2)] in ('tags', 'branches', 'tag', 'branch')): DCNL DCSP  DCSP  DCSP req = parts[(-3)] DCNL DCSP  DCSP elif (parts[(-1)] == 'trunk'): DCNL DCSP  DCSP  DCSP req = parts[(-2)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InstallationError(('--editable=%s DCSP is DCSP not DCSP the DCSP right DCSP format; DCSP it DCSP must DCSP have DCSP #egg=Package' % editable_req)) DCNL DCSP else: DCNL DCSP  DCSP req = match.group(1) DCNL DCSP match = re.search('^(.*?)(?:-dev|-\\d.*)$', req) DCNL DCSP if match: DCNL DCSP  DCSP req = match.group(1) DCNL DCSP return (req, url)
 DCSP if (derivation == None): DCNL DCSP  DCSP derivation = SolidDerivation(elementNode) DCNL DCSP elementAttributesCopy = elementNode.attributes.copy() DCNL DCSP for target in derivation.targets: DCNL DCSP  DCSP targetAttributesCopy = target.attributes.copy() DCNL DCSP  DCSP target.attributes = elementAttributesCopy DCNL DCSP  DCSP processTarget(target) DCNL DCSP  DCSP target.attributes = targetAttributesCopy
 DCSP context = args[0] DCNL DCSP seq = args[1] DCNL DCSP if ((len(args) == 2) and ('attribute' in kwargs)): DCNL DCSP  DCSP attribute = kwargs.pop('attribute') DCNL DCSP  DCSP if kwargs: DCNL DCSP  DCSP  DCSP raise FilterArgumentError(('Unexpected DCSP keyword DCSP argument DCSP %r' % next(iter(kwargs)))) DCNL DCSP  DCSP func = make_attrgetter(context.environment, attribute) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP name = args[2] DCNL DCSP  DCSP  DCSP args = args[3:] DCNL DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP raise FilterArgumentError('map DCSP requires DCSP a DCSP filter DCSP argument') DCNL DCSP  DCSP func = (lambda item: context.environment.call_filter(name, item, args, kwargs, context=context)) DCNL DCSP if seq: DCNL DCSP  DCSP for item in seq: DCNL DCSP  DCSP  DCSP (yield func(item))
 DCSP result = convert(complete_parser) DCNL DCSP assert ('primary' in result['widgets'])
 DCSP table = BytesIO() DCNL DCSP with pytest.raises(ascii.InconsistentTableError): DCNL DCSP  DCSP ascii.read(table) DCNL DCSP table = BytesIO() DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP ascii.read(table, guess=False, fast_reader=False, format='basic') DCNL DCSP assert ('No DCSP header DCSP line DCSP found' in str(err.value)) DCNL DCSP table = BytesIO() DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP ascii.read(table, guess=False, fast_reader=True, format='fast_basic') DCNL DCSP assert ('Inconsistent DCSP data DCSP column DCSP lengths' in str(err.value)) DCNL DCSP for kwargs in [dict(), dict(guess=False, fast_reader=False, format='basic'), dict(guess=False, fast_reader=True, format='fast_basic')]: DCNL DCSP  DCSP table = BytesIO() DCNL DCSP  DCSP table.write('a DCSP b') DCNL DCSP  DCSP t = ascii.read(table, **kwargs) DCNL DCSP  DCSP assert (t.colnames == ['a', 'b']) DCNL DCSP  DCSP assert (len(t) == 0)
 DCSP def prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP r.table.image_url.readable = False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP image_url = r.record.image_url DCNL DCSP  DCSP  DCSP if image_url: DCNL DCSP  DCSP  DCSP  DCSP output['item'].append(IMG(_src=image_url, _width=400, _height=310)) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3_rest_controller() DCNL DCSP return output
 DCSP store_utils.delete_image_location_from_backend(req.context, id, location_data)
 DCSP return (timedelta_to_integral_seconds(delta) // 60)
 DCSP return _uninstall(action='purge', name=name, pkgs=pkgs, **kwargs)
 DCSP def verifyCol(strg, locn, toks): DCNL DCSP  DCSP if (col(locn, strg) != n): DCNL DCSP  DCSP  DCSP raise ParseException(strg, locn, ('matched DCSP token DCSP not DCSP at DCSP column DCSP %d' % n)) DCNL DCSP return verifyCol
 DCSP return ((value % 2) == 1)
 DCSP if (call != 'function'): DCNL DCSP  DCSP log.error('The DCSP list_keys DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP  DCSP return False DCNL DCSP if (not kwargs): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('keyname' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP keyname DCSP is DCSP required.') DCNL DCSP  DCSP return False DCNL DCSP (rcode, data) = query(command='my/keys/{0}'.format(kwargs['keyname']), method='GET') DCNL DCSP return {'keys': {data['name']: data['key']}}
 DCSP if ((graph._adjacency is not None) and (graph._adjacency[1:] == (directed, reversed, stochastic, (heuristic and heuristic.func_code)))): DCNL DCSP  DCSP return graph._adjacency[0] DCNL DCSP map = {} DCNL DCSP for n in graph.nodes: DCNL DCSP  DCSP map[n.id] = {} DCNL DCSP for e in graph.edges: DCNL DCSP  DCSP (id1, id2) = (((not reversed) and (e.node1.id, e.node2.id)) or (e.node2.id, e.node1.id)) DCNL DCSP  DCSP map[id1][id2] = (1.0 - (0.5 * e.weight)) DCNL DCSP  DCSP if heuristic: DCNL DCSP  DCSP  DCSP map[id1][id2] += heuristic(id1, id2) DCNL DCSP  DCSP if (not directed): DCNL DCSP  DCSP  DCSP map[id2][id1] = map[id1][id2] DCNL DCSP if stochastic: DCNL DCSP  DCSP for id1 in map: DCNL DCSP  DCSP  DCSP n = sum(map[id1].values()) DCNL DCSP  DCSP  DCSP for id2 in map[id1]: DCNL DCSP  DCSP  DCSP  DCSP map[id1][id2] /= n DCNL DCSP graph._adjacency = (map, directed, reversed, stochastic, (heuristic and heuristic.func_code)) DCNL DCSP return map
 DCSP visitor = _NodeNameCollector() DCNL DCSP ast.walk(node, visitor) DCNL DCSP return visitor.names
 DCSP if ((not _isproperdist(px)) or (not _isproperdist(py))): DCNL DCSP  DCSP raise ValueError('px DCSP or DCSP py DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP distribution') DCNL DCSP if ((pxpy != None) and (not _isproperdist(pxpy))): DCNL DCSP  DCSP raise ValueError('pxpy DCSP is DCSP not DCSP a DCSP proper DCSP joint DCSP distribtion') DCNL DCSP if (pxpy == None): DCNL DCSP  DCSP pxpy = np.outer(py, px) DCNL DCSP condent = np.sum((pxpy * np.nan_to_num(np.log2((py / pxpy))))) DCNL DCSP if (logbase == 2): DCNL DCSP  DCSP return condent DCNL DCSP else: DCNL DCSP  DCSP return (logbasechange(2, logbase) * condent)
 DCSP kwargs.setdefault('accept_magic_kwargs', False) DCNL DCSP return app_or_default().task(*args, **kwargs)
 DCSP if (hasattr(context, 'auth_token') and context.auth_token): DCNL DCSP  DCSP return True DCNL DCSP def _is_image_public(image): DCNL DCSP  DCSP if hasattr(image, 'visibility'): DCNL DCSP  DCSP  DCSP return (str(image.visibility).lower() == 'public') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return image.is_public DCNL DCSP if (context.is_admin or _is_image_public(image)): DCNL DCSP  DCSP return True DCNL DCSP properties = image.properties DCNL DCSP if (context.project_id and ('owner_id' in properties)): DCNL DCSP  DCSP return (str(properties['owner_id']) == str(context.project_id)) DCNL DCSP if (context.project_id and ('project_id' in properties)): DCNL DCSP  DCSP return (str(properties['project_id']) == str(context.project_id)) DCNL DCSP try: DCNL DCSP  DCSP user_id = properties['user_id'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return False DCNL DCSP return (str(user_id) == str(context.user_id))
 DCSP rights_manager.publish_exploration(committer_id, exp_id) DCNL DCSP contribution_time_msec = utils.get_current_time_in_millisecs() DCNL DCSP contributor_ids = get_exploration_summary_by_id(exp_id).contributor_ids DCNL DCSP for contributor in contributor_ids: DCNL DCSP  DCSP user_services.update_first_contribution_msec_if_not_set(contributor, contribution_time_msec)
 DCSP if (factor == 1): DCNL DCSP  DCSP return inputs DCNL DCSP else: DCNL DCSP  DCSP return slim.max_pool2d(inputs, [1, 1], stride=factor, scope=scope)
 DCSP group = get_object_or_404(Group, slug=slug, is_active=True) DCNL DCSP form = GroupInviteForm(initial={'group': group.pk, 'user': request.user.pk}) DCNL DCSP return render(request, template_name, {'group': group, 'form': form})
 DCSP while files: DCNL DCSP  DCSP cmd = list(STRIPCMD) DCNL DCSP  DCSP pathlen = sum(((len(s) + 1) for s in cmd)) DCNL DCSP  DCSP while ((pathlen < argv_max) and files): DCNL DCSP  DCSP  DCSP f = files.pop() DCNL DCSP  DCSP  DCSP cmd.append(f) DCNL DCSP  DCSP  DCSP pathlen += (len(f) + 1) DCNL DCSP  DCSP if (len(cmd) > len(STRIPCMD)): DCNL DCSP  DCSP  DCSP all_files = cmd[len(STRIPCMD):] DCNL DCSP  DCSP  DCSP unwritable_files = tuple(filter(None, ((None if os.access(x, os.W_OK) else (x, os.stat(x).st_mode)) for x in all_files))) DCNL DCSP  DCSP  DCSP [os.chmod(x, (stat.S_IWRITE | old_mode)) for (x, old_mode) in unwritable_files] DCNL DCSP  DCSP  DCSP subprocess.check_call(cmd) DCNL DCSP  DCSP  DCSP [os.chmod(x, old_mode) for (x, old_mode) in unwritable_files]
 DCSP if isinstance(t2, (TensMul, Tensor)): DCNL DCSP  DCSP args = [t2] DCNL DCSP else: DCNL DCSP  DCSP args = t2.args DCNL DCSP a1 = [x.split() for x in args] DCNL DCSP a2 = [[riemann_cyclic_replace(tx) for tx in y] for y in a1] DCNL DCSP a3 = [tensor_mul(*v) for v in a2] DCNL DCSP t3 = TensAdd(*a3) DCNL DCSP if (not t3): DCNL DCSP  DCSP return t3 DCNL DCSP else: DCNL DCSP  DCSP return canon_bp(t3)
 DCSP attributes = bleach.ALLOWED_ATTRIBUTES.copy() DCNL DCSP if (u'data' not in bleach.BleachSanitizer.allowed_protocols): DCNL DCSP  DCSP bleach.BleachSanitizer.allowed_protocols.append(u'data') DCNL DCSP attributes.update({'*': ['class', 'style', 'id'], 'audio': ['controls', 'autobuffer', 'autoplay', 'src'], 'img': ['src', 'width', 'height', 'class']}) DCNL DCSP output = bleach.clean(html_code, tags=(bleach.ALLOWED_TAGS + ['div', 'p', 'audio', 'pre', 'img', 'span']), styles=['white-space'], attributes=attributes) DCNL DCSP return output
 DCSP cache_path = _local_cache_path(tex_root) DCNL DCSP _validate_life_span(cache_path) DCNL DCSP return _read(cache_path, name)
 DCSP if (not in_place): DCNL DCSP  DCSP rag = rag.copy() DCNL DCSP to_remove = [(x, y) for (x, y, d) in rag.edges_iter(data=True) if (d['weight'] >= thresh)] DCNL DCSP rag.remove_edges_from(to_remove) DCNL DCSP comps = nx.connected_components(rag) DCNL DCSP map_array = np.arange((labels.max() + 1), dtype=labels.dtype) DCNL DCSP for (i, nodes) in enumerate(comps): DCNL DCSP  DCSP for node in nodes: DCNL DCSP  DCSP  DCSP for label in rag.node[node]['labels']: DCNL DCSP  DCSP  DCSP  DCSP map_array[label] = i DCNL DCSP return map_array[labels]
 DCSP prof = get_object_or_404(GroupProfile, slug=group_slug) DCNL DCSP if (not _user_can_manage_leaders(request.user, prof)): DCNL DCSP  DCSP raise PermissionDenied DCNL DCSP form = AddUserForm(request.POST) DCNL DCSP if form.is_valid(): DCNL DCSP  DCSP for user in form.cleaned_data['users']: DCNL DCSP  DCSP  DCSP if (prof.group not in user.groups.all()): DCNL DCSP  DCSP  DCSP  DCSP user.groups.add(prof.group) DCNL DCSP  DCSP  DCSP prof.leaders.add(user) DCNL DCSP  DCSP msg = _('{users} DCSP added DCSP to DCSP the DCSP group DCSP leaders DCSP successfully!').format(users=request.POST.get('users')) DCNL DCSP  DCSP messages.add_message(request, messages.SUCCESS, msg) DCNL DCSP  DCSP return HttpResponseRedirect(prof.get_absolute_url()) DCNL DCSP msg = _('There DCSP were DCSP errors DCSP adding DCSP leaders DCSP to DCSP the DCSP group, DCSP see DCSP below.') DCNL DCSP messages.add_message(request, messages.ERROR, msg) DCNL DCSP return profile(request, group_slug, leader_form=form)
 DCSP if (not contribution_src): DCNL DCSP  DCSP contribution_src = src DCNL DCSP has_suggested = bool(addon.suggested_amount) DCNL DCSP comment_limit = PAYPAL_MAX_COMMENT_LENGTH DCNL DCSP return new_context(**locals())
 DCSP return (0.5 * (vel ** 2).sum(axis=1))
 DCSP try: DCNL DCSP  DCSP _id = request.args[0] DCNL DCSP except: DCNL DCSP  DCSP raise HTTP(400) DCNL DCSP translate = settings.get_L10n_translate_gis_location() DCNL DCSP if translate: DCNL DCSP  DCSP language = session.s3.language DCNL DCSP  DCSP if (language == settings.get_L10n_default_language()): DCNL DCSP  DCSP  DCSP translate = False DCNL DCSP table = s3db.gis_location DCNL DCSP query = ((((table.deleted == False) & (table.level != None)) & (table.end_date == None)) & ((table.parent == _id) | (table.id == _id))) DCNL DCSP fields = [table.id, table.name, table.level, table.parent, table.lon_min, table.lat_min, table.lon_max, table.lat_max] DCNL DCSP if translate: DCNL DCSP  DCSP ntable = s3db.gis_location_name DCNL DCSP  DCSP fields.append(ntable.name_l10n) DCNL DCSP  DCSP left = ntable.on((((ntable.deleted == False) & (ntable.language == language)) & (ntable.location_id == table.id))) DCNL DCSP else: DCNL DCSP  DCSP left = None DCNL DCSP locations = db(query).select(left=left, *fields) DCNL DCSP if translate: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP id_level = int(locations.as_dict(key='gis_location.id')[int(_id)]['gis_location']['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP id_level = int(locations.as_dict()[int(_id)]['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP output_level = (id_level + 1) DCNL DCSP search_level = ('L%s' % output_level) DCNL DCSP location_dict = {} DCNL DCSP if translate: DCNL DCSP  DCSP for location in locations: DCNL DCSP  DCSP  DCSP l = location['gis_location'] DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP name = (location['gis_location_name.name_l10n'] or l.name) DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=name, l=this_level, f=f) DCNL DCSP else: DCNL DCSP  DCSP for l in locations: DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=l.name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=l.name, l=this_level, f=f) DCNL DCSP script = ('n=%s\n' % json.dumps(location_dict, separators=SEPARATORS)) DCNL DCSP response.headers['Content-Type'] = 'application/json' DCNL DCSP return script
 DCSP return IMPL.flavor_destroy(context, flavor_id)
 DCSP if (not src): DCNL DCSP  DCSP return UNKNOWN_MODULE DCNL DCSP (filename, ext) = splitext(urlsplit(src).path) DCNL DCSP if (ext not in ('.js', '.jsx', '.coffee')): DCNL DCSP  DCSP return UNKNOWN_MODULE DCNL DCSP if filename.endswith('.min'): DCNL DCSP  DCSP filename = filename[:(-4)] DCNL DCSP tokens = filename.split('/') DCNL DCSP for (idx, token) in enumerate(tokens): DCNL DCSP  DCSP if VERSION_RE.match(token): DCNL DCSP  DCSP  DCSP return '/'.join(tokens[(idx + 1):]) DCNL DCSP return (CLEAN_MODULE_RE.sub('', filename) or UNKNOWN_MODULE)
 DCSP trap = Trap() DCNL DCSP prev_tls = _state._tls DCNL DCSP _state.set_default_app(trap) DCNL DCSP class NonTLS(object, ): DCNL DCSP  DCSP current_app = trap DCNL DCSP _state._tls = NonTLS() DCNL DCSP (yield) DCNL DCSP _state._tls = prev_tls
 DCSP return OrderedDict(settings.LANGUAGES)
 DCSP return (not bool(BAD_URI_CHARS_RE.search(uri)))
 DCSP net = {} DCNL DCSP net['input'] = InputLayer((None, 3, 16, 112, 112)) DCNL DCSP net['conv1a'] = Conv3DDNNLayer(net['input'], 64, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify, flip_filters=False) DCNL DCSP net['pool1'] = MaxPool3DDNNLayer(net['conv1a'], pool_size=(1, 2, 2), stride=(1, 2, 2)) DCNL DCSP net['conv2a'] = Conv3DDNNLayer(net['pool1'], 128, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool2'] = MaxPool3DDNNLayer(net['conv2a'], pool_size=(2, 2, 2), stride=(2, 2, 2)) DCNL DCSP net['conv3a'] = Conv3DDNNLayer(net['pool2'], 256, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv3b'] = Conv3DDNNLayer(net['conv3a'], 256, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool3'] = MaxPool3DDNNLayer(net['conv3b'], pool_size=(2, 2, 2), stride=(2, 2, 2)) DCNL DCSP net['conv4a'] = Conv3DDNNLayer(net['pool3'], 512, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv4b'] = Conv3DDNNLayer(net['conv4a'], 512, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool4'] = MaxPool3DDNNLayer(net['conv4b'], pool_size=(2, 2, 2), stride=(2, 2, 2)) DCNL DCSP net['conv5a'] = Conv3DDNNLayer(net['pool4'], 512, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv5b'] = Conv3DDNNLayer(net['conv5a'], 512, (3, 3, 3), pad=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pad'] = PadLayer(net['conv5b'], width=[(0, 1), (0, 1)], batch_ndim=3) DCNL DCSP net['pool5'] = MaxPool3DDNNLayer(net['pad'], pool_size=(2, 2, 2), pad=(0, 0, 0), stride=(2, 2, 2)) DCNL DCSP net['fc6-1'] = DenseLayer(net['pool5'], num_units=4096, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['fc7-1'] = DenseLayer(net['fc6-1'], num_units=4096, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['fc8-1'] = DenseLayer(net['fc7-1'], num_units=487, nonlinearity=None) DCNL DCSP net['prob'] = NonlinearityLayer(net['fc8-1'], softmax) DCNL DCSP return net
 DCSP return config.get_cloud_config_value('ssh_interface', vm_, __opts__, default='public_ips', search_global=False)
 DCSP return config.get_cloud_config_value('tenancy', vm_, __opts__, search_global=False)
 DCSP if hasattr(x, 'getnnz'): DCNL DCSP  DCSP x = as_sparse_variable(x) DCNL DCSP  DCSP assert (x.format in ['csr', 'csc']) DCNL DCSP if hasattr(y, 'getnnz'): DCNL DCSP  DCSP y = as_sparse_variable(y) DCNL DCSP  DCSP assert (y.format in ['csr', 'csc']) DCNL DCSP x_is_sparse_variable = _is_sparse_variable(x) DCNL DCSP y_is_sparse_variable = _is_sparse_variable(y) DCNL DCSP if ((not x_is_sparse_variable) and (not y_is_sparse_variable)): DCNL DCSP  DCSP raise TypeError() DCNL DCSP if x_is_sparse_variable: DCNL DCSP  DCSP return TrueDot(grad_preserves_dense)(x, y) DCNL DCSP else: DCNL DCSP  DCSP assert y_is_sparse_variable DCNL DCSP  DCSP return transpose(TrueDot(grad_preserves_dense)(y.T, x.T))
 DCSP opt_name = ('--map-' + type) DCNL DCSP value_rx = '^([^=]+)=([^=]*)$' DCNL DCSP if (type in ('uid', 'gid')): DCNL DCSP  DCSP value_rx = '^(-?[0-9]+)=(-?[0-9]+)$' DCNL DCSP owner_map = {} DCNL DCSP for flag in options: DCNL DCSP  DCSP (option, parameter) = flag DCNL DCSP  DCSP if (option != opt_name): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP match = re.match(value_rx, parameter) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP raise fatal(("couldn't DCSP parse DCSP %s DCSP as DCSP %s DCSP mapping" % (parameter, type))) DCNL DCSP  DCSP (old_id, new_id) = match.groups() DCNL DCSP  DCSP if (type in ('uid', 'gid')): DCNL DCSP  DCSP  DCSP old_id = int(old_id) DCNL DCSP  DCSP  DCSP new_id = int(new_id) DCNL DCSP  DCSP owner_map[old_id] = new_id DCNL DCSP return owner_map
 DCSP handler = XmlRpcReadHandler() DCNL DCSP xml.sax.parseString(xml_string, handler) DCNL DCSP return handler
 DCSP with settings(hide('running', 'stdout')): DCNL DCSP  DCSP kernel = run('uname DCSP -s') DCNL DCSP  DCSP if (kernel == 'Linux'): DCNL DCSP  DCSP  DCSP return run('lsb_release DCSP -r DCSP --short') DCNL DCSP  DCSP elif (kernel == 'SunOS'): DCNL DCSP  DCSP  DCSP return run('uname DCSP -v')
 DCSP return project.memberships.count()
 DCSP p0 = [guess_plateau(x, y), 4.0, guess_lag(x, y), 0.1, min(y)] DCNL DCSP (params, pcov) = curve_fit(function, x, y, p0=p0) DCNL DCSP return (params, pcov)
 DCSP result = [] DCNL DCSP for X in iterables: DCNL DCSP  DCSP if sp.issparse(X): DCNL DCSP  DCSP  DCSP result.append(X.tocsr()) DCNL DCSP  DCSP elif (hasattr(X, '__getitem__') or hasattr(X, 'iloc')): DCNL DCSP  DCSP  DCSP result.append(X) DCNL DCSP  DCSP elif (X is None): DCNL DCSP  DCSP  DCSP result.append(X) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.append(np.array(X)) DCNL DCSP check_consistent_length(*result) DCNL DCSP return result
 DCSP query = request.GET.get('q', None) DCNL DCSP if (not query): DCNL DCSP  DCSP return Response({'error': 'Search DCSP term DCSP required. DCSP Use DCSP the DCSP "q" DCSP GET DCSP arg DCSP to DCSP search. DCSP '}, status=status.HTTP_400_BAD_REQUEST) DCNL DCSP project_slug = request.GET.get('project', None) DCNL DCSP version_slug = request.GET.get('version', LATEST) DCNL DCSP path = request.GET.get('path', None) DCNL DCSP log.debug('(API DCSP Section DCSP Search) DCSP [%s:%s] DCSP %s', project_slug, version_slug, query) DCNL DCSP results = search_section(request=request, query=query, project_slug=project_slug, version_slug=version_slug, path=path) DCNL DCSP return Response({'results': results})
 DCSP if (not name): DCNL DCSP  DCSP return name DCNL DCSP removeWordsList = {u'\\[rartv\\]$': u'searchre', u'\\[rarbg\\]$': u'searchre', u'\\[eztv\\]$': u'searchre', u'\\[ettv\\]$': u'searchre', u'\\[cttv\\]$': u'searchre', u'\\[vtv\\]$': u'searchre', u'\\[EtHD\\]$': u'searchre', u'\\[GloDLS\\]$': u'searchre', u'\\[silv4\\]$': u'searchre', u'\\[Seedbox\\]$': u'searchre', u'\\[PublicHD\\]$': u'searchre', u'\\[AndroidTwoU\\]$': u'searchre', u'\\.\\[BT\\]$': u'searchre', u' DCSP \\[1044\\]$': u'searchre', u'\\.RiPSaLoT$': u'searchre', u'\\.GiuseppeTnT$': u'searchre', u'\\.Renc$': u'searchre', u'-NZBGEEK$': u'searchre', u'-Siklopentan$': u'searchre', u'-\\[SpastikusTV\\]$': u'searchre', u'-RP$': u'searchre', u'-20-40$': u'searchre', u'\\.\\[www\\.usabit\\.com\\]$': u'searchre', u'^\\[www\\.Cpasbien\\.pe\\] DCSP ': u'searchre', u'^\\[www\\.Cpasbien\\.com\\] DCSP ': u'searchre', u'^\\[ DCSP www\\.Cpasbien\\.pw DCSP \\] DCSP ': u'searchre', u'^\\.www\\.Cpasbien\\.pw': u'searchre', u'^\\[www\\.newpct1\\.com\\]': u'searchre', u'^\\[ DCSP www\\.Cpasbien\\.com DCSP \\] DCSP ': u'searchre', u'- DCSP \\{ DCSP www\\.SceneTime\\.com DCSP \\}$': u'searchre', u'^\\{ DCSP www\\.SceneTime\\.com DCSP \\} DCSP - DCSP ': u'searchre', u'^\\]\\.\\[www\\.tensiontorrent.com\\] DCSP - DCSP ': u'searchre', u'^\\]\\.\\[ DCSP www\\.tensiontorrent.com DCSP \\] DCSP - DCSP ': u'searchre', u'- DCSP \\[ DCSP www\\.torrentday\\.com DCSP \\]$': u'searchre', u'^\\[ DCSP www\\.TorrentDay\\.com DCSP \\] DCSP - DCSP ': u'searchre', u'\\[NO-RAR\\] DCSP - DCSP \\[ DCSP www\\.torrentday\\.com DCSP \\]$': u'searchre'} DCNL DCSP _name = name DCNL DCSP for (remove_string, remove_type) in removeWordsList.items(): DCNL DCSP  DCSP if (remove_type == u'search'): DCNL DCSP  DCSP  DCSP _name = _name.replace(remove_string, u'') DCNL DCSP  DCSP elif (remove_type == u'searchre'): DCNL DCSP  DCSP  DCSP _name = re.sub((u'(?i)' + remove_string), u'', _name) DCNL DCSP return _name.strip(u'.- DCSP []{}')
 DCSP if (isinstance(obj, str) or isinstance(obj, unicode)): DCNL DCSP  DCSP return False DCNL DCSP res = True DCNL DCSP for a in ('read', 'tell', 'seek'): DCNL DCSP  DCSP res = (res and hasattr(obj, a)) DCNL DCSP if (not res): DCNL DCSP  DCSP raise ValueError('Invalid DCSP object DCSP passed DCSP as DCSP file') DCNL DCSP return True
 DCSP try: DCNL DCSP  DCSP locations = (os.path.expanduser('~/{0}'.format(f)) for f in NETRC_FILES) DCNL DCSP  DCSP netrc_path = None DCNL DCSP  DCSP for loc in locations: DCNL DCSP  DCSP  DCSP if (os.path.exists(loc) and (not netrc_path)): DCNL DCSP  DCSP  DCSP  DCSP netrc_path = loc DCNL DCSP  DCSP if (netrc_path is None): DCNL DCSP  DCSP  DCSP return netrc_path DCNL DCSP  DCSP ri = urlparse(url) DCNL DCSP  DCSP host = ri.netloc.split(':')[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _netrc = netrc(netrc_path).authenticators(host) DCNL DCSP  DCSP  DCSP if _netrc: DCNL DCSP  DCSP  DCSP  DCSP login_i = (0 if _netrc[0] else 1) DCNL DCSP  DCSP  DCSP  DCSP return (_netrc[login_i], _netrc[2]) DCNL DCSP  DCSP except (NetrcParseError, IOError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP pass
 DCSP if (input is not None): DCNL DCSP  DCSP input = os.path.dirname(input) DCNL DCSP (f, fn) = tempfile.mkstemp(dir=input) DCNL DCSP os.close(f) DCNL DCSP return fn
 DCSP lines = value.split('\n') DCNL DCSP width = str(len(str(len(lines)))) DCNL DCSP if ((not autoescape) or isinstance(value, SafeData)): DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = ((('%0' + width) + 'd. DCSP %s') % ((i + 1), line)) DCNL DCSP else: DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = ((('%0' + width) + 'd. DCSP %s') % ((i + 1), escape(line))) DCNL DCSP return mark_safe('\n'.join(lines))
 DCSP return _distro.name(pretty)
 DCSP old_class = logging.getLoggerClass() DCNL DCSP logging.setLoggerClass(logging.Logger) DCNL DCSP logger = logging.getLogger(name) DCNL DCSP logging.setLoggerClass(old_class) DCNL DCSP return logger
 DCSP db.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_node_list DCSP (id DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP db.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_way_list DCSP (id DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP db.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_relation_list DCSP (id DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP (n, s, e, w) = coordinate_bbox(coord, projection) DCNL DCSP bbox = ('ST_SetSRID(ST_MakeBox2D(ST_MakePoint(%.7f, DCSP %.7f), DCSP ST_MakePoint(%.7f, DCSP %.7f)), DCSP 4326)' % (w, s, e, n)) DCNL DCSP db.execute(('INSERT DCSP INTO DCSP box_node_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP nodes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP (geom DCSP && DCSP %(bbox)s)' % locals())) DCNL DCSP db.execute('INSERT DCSP INTO DCSP box_way_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP wn.way_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP way_nodes DCSP wn\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_node_list DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP wn.node_id DCSP = DCSP n.id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP GROUP DCSP BY DCSP wn.way_id') DCNL DCSP db.execute("INSERT DCSP INTO DCSP box_relation_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_id DCSP AS DCSP relation_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_node_list DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_id DCSP = DCSP n.id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'N'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNION\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_id DCSP AS DCSP relation_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_way_list DCSP w\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_id DCSP = DCSP w.id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'W'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )") DCNL DCSP db.execute("INSERT DCSP INTO DCSP box_relation_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_id DCSP AS DCSP relation_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_relation_list DCSP r\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_id DCSP = DCSP r.id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'R'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP EXCEPT\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP id DCSP AS DCSP relation_id\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP box_relation_list") DCNL DCSP db.execute('ANALYZE DCSP box_node_list') DCNL DCSP db.execute('ANALYZE DCSP box_way_list') DCNL DCSP db.execute('ANALYZE DCSP box_relation_list')
 DCSP dotProductX = ((firstTricomplex[0].real * otherColumn.real) + (firstTricomplex[1].real * otherColumn.imag)) DCNL DCSP dotProductY = ((firstTricomplex[0].imag * otherColumn.real) + (firstTricomplex[1].imag * otherColumn.imag)) DCNL DCSP return complex(dotProductX, dotProductY)
 DCSP return getJoinedPath(getFabmetheusPath('fabmetheus_utilities'), subName)
 DCSP r = {k: f.name for (k, f) in request.FILES.items()} DCNL DCSP return HttpResponse(json.dumps(r))
 DCSP if conf.disablePrecon: DCNL DCSP  DCSP return DCNL DCSP def _(): DCNL DCSP  DCSP while (kb.get('threadContinue') and (not conf.get('disablePrecon'))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP for key in socket._ready: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(socket._ready[key]) < SOCKET_PRE_CONNECT_QUEUE_SIZE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (family, type, proto, address) = key DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s = socket.socket(family, type, proto) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s._connect(address) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with kb.locks.socket: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP socket._ready[key].append((s._sock, time.time())) DCNL DCSP  DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.01) DCNL DCSP def connect(self, address): DCNL DCSP  DCSP found = False DCNL DCSP  DCSP key = (self.family, self.type, self.proto, address) DCNL DCSP  DCSP with kb.locks.socket: DCNL DCSP  DCSP  DCSP if (key not in socket._ready): DCNL DCSP  DCSP  DCSP  DCSP socket._ready[key] = [] DCNL DCSP  DCSP  DCSP while (len(socket._ready[key]) > 0): DCNL DCSP  DCSP  DCSP  DCSP (candidate, created) = socket._ready[key].pop(0) DCNL DCSP  DCSP  DCSP  DCSP if ((time.time() - created) < PRECONNECT_CANDIDATE_TIMEOUT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._sock = candidate DCNL DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP candidate.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP self._connect(address) DCNL DCSP if (not hasattr(socket.socket, '_connect')): DCNL DCSP  DCSP socket._ready = {} DCNL DCSP  DCSP socket.socket._connect = socket.socket.connect DCNL DCSP  DCSP socket.socket.connect = connect DCNL DCSP  DCSP thread = threading.Thread(target=_) DCNL DCSP  DCSP setDaemon(thread) DCNL DCSP  DCSP thread.start()
 DCSP return force_unicode(urllib.quote_plus(smart_str(url), safe))
 DCSP def _readlines_side_effect(*args, **kwargs): DCNL DCSP  DCSP if (handle.readlines.return_value is not None): DCNL DCSP  DCSP  DCSP return handle.readlines.return_value DCNL DCSP  DCSP return list(_data) DCNL DCSP def _read_side_effect(*args, **kwargs): DCNL DCSP  DCSP if (handle.read.return_value is not None): DCNL DCSP  DCSP  DCSP return handle.read.return_value DCNL DCSP  DCSP return ''.join(_data) DCNL DCSP def _readline_side_effect(): DCNL DCSP  DCSP if (handle.readline.return_value is not None): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (yield handle.readline.return_value) DCNL DCSP  DCSP for line in _data: DCNL DCSP  DCSP  DCSP (yield line) DCNL DCSP global file_spec DCNL DCSP if (file_spec is None): DCNL DCSP  DCSP import _io DCNL DCSP  DCSP file_spec = list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO)))) DCNL DCSP if (mock is None): DCNL DCSP  DCSP mock = MagicMock(name='open', spec=open) DCNL DCSP handle = MagicMock(spec=file_spec) DCNL DCSP handle.__enter__.return_value = handle DCNL DCSP _data = _iterate_read_data(read_data) DCNL DCSP handle.write.return_value = None DCNL DCSP handle.read.return_value = None DCNL DCSP handle.readline.return_value = None DCNL DCSP handle.readlines.return_value = None DCNL DCSP handle.read.side_effect = _read_side_effect DCNL DCSP handle.readline.side_effect = _readline_side_effect() DCNL DCSP handle.readlines.side_effect = _readlines_side_effect DCNL DCSP mock.return_value = handle DCNL DCSP return mock
 DCSP f = (utcnow if assume_utc else now) DCNL DCSP default = f().replace(hour=0, minute=0, second=0, microsecond=0, day=15) DCNL DCSP return fix_only_date(parse_date(raw, default=default, assume_utc=assume_utc, as_utc=as_utc))
 DCSP nums_actions = (tableaux[1].shape[0], tableaux[0].shape[0]) DCNL DCSP num = (nums_actions[0] + nums_actions[1]) DCNL DCSP out = np.zeros(num) DCNL DCSP for (pl, (start, stop)) in enumerate(zip((0, nums_actions[0]), (nums_actions[0], num))): DCNL DCSP  DCSP sum_ = 0.0 DCNL DCSP  DCSP for i in range(nums_actions[(1 - pl)]): DCNL DCSP  DCSP  DCSP k = bases[pl][i] DCNL DCSP  DCSP  DCSP if (start <= k < stop): DCNL DCSP  DCSP  DCSP  DCSP out[k] = tableaux[pl][(i, (-1))] DCNL DCSP  DCSP  DCSP  DCSP sum_ += tableaux[pl][(i, (-1))] DCNL DCSP  DCSP if (sum_ != 0): DCNL DCSP  DCSP  DCSP out[start:stop] /= sum_ DCNL DCSP return (out[:nums_actions[0]], out[nums_actions[0]:])
 DCSP ret = {'changes': {}} DCNL DCSP cdir = _config_dir() DCNL DCSP if (not os.path.isdir(cdir)): DCNL DCSP  DCSP os.makedirs(cdir) DCNL DCSP  DCSP if os.path.isdir(cdir): DCNL DCSP  DCSP  DCSP ret['changes'] = 'Created DCSP poudriere DCSP make DCSP file DCSP dir DCSP {0}'.format(cdir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'Could DCSP not DCSP create DCSP or DCSP find DCSP required DCSP directory DCSP {0}'.format(cdir) DCNL DCSP __salt__['file.write']('{0}-make.conf'.format(os.path.join(cdir, jname)), 'WITH_PKGNG=yes') DCNL DCSP if os.path.isfile((os.path.join(cdir, jname) + '-make.conf')): DCNL DCSP  DCSP ret['changes'] = 'Created DCSP {0}'.format(os.path.join(cdir, '{0}-make.conf'.format(jname))) DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP return 'Looks DCSP like DCSP file DCSP {0} DCSP could DCSP not DCSP be DCSP created'.format(os.path.join(cdir, (jname + '-make.conf')))
 DCSP zone = session.client_device.get_zone() DCNL DCSP devicezones = list(DeviceZone.all_objects.filter(zone=zone, device__in=data['devices'])) DCNL DCSP devices = [devicezone.device for devicezone in devicezones] DCNL DCSP session.models_downloaded += (len(devices) + len(devicezones)) DCNL DCSP return JsonResponse({'devices': serialize((devices + devicezones), dest_version=session.client_version, ensure_ascii=False)})
 DCSP if (user is None): DCNL DCSP  DCSP user = users.get_current_user() DCNL DCSP if (user is None): DCNL DCSP  DCSP return {} DCNL DCSP pickled_tokens = memcache.get(('gdata_pickled_tokens:%s' % user)) DCNL DCSP if pickled_tokens: DCNL DCSP  DCSP return pickle.loads(pickled_tokens) DCNL DCSP user_tokens = TokenCollection.all().filter('user DCSP =', user).get() DCNL DCSP if user_tokens: DCNL DCSP  DCSP memcache.set(('gdata_pickled_tokens:%s' % user), user_tokens.pickled_tokens) DCNL DCSP  DCSP return pickle.loads(user_tokens.pickled_tokens) DCNL DCSP return {}
 DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP params = {'hostname': hostname, 'username': username, 'password': password, 'monitor_type': monitor_type, 'name': name} DCNL DCSP  DCSP for (key, value) in six.iteritems(kwargs): DCNL DCSP  DCSP  DCSP params[key] = value DCNL DCSP  DCSP return _test_output(ret, 'modify', params) DCNL DCSP existing = __salt__['bigip.list_monitor'](hostname, username, password, monitor_type, name) DCNL DCSP if (existing['code'] == 200): DCNL DCSP  DCSP modified = __salt__['bigip.modify_monitor'](hostname, username, password, monitor_type, name, **kwargs) DCNL DCSP  DCSP if (modified['code'] == 200): DCNL DCSP  DCSP  DCSP del existing['content']['selfLink'] DCNL DCSP  DCSP  DCSP del modified['content']['selfLink'] DCNL DCSP  DCSP  DCSP ret = _check_for_changes('Monitor', ret, existing, modified) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = _load_result(modified, ret) DCNL DCSP elif (existing['code'] == 404): DCNL DCSP  DCSP ret['comment'] = 'A DCSP Monitor DCSP with DCSP this DCSP name DCSP was DCSP not DCSP found.' DCNL DCSP else: DCNL DCSP  DCSP ret = _load_result(existing, ret) DCNL DCSP return ret
 DCSP hps.batch_size = 100 DCNL DCSP with tf.Graph().as_default(): DCNL DCSP  DCSP with tf.device('/cpu:0'): DCNL DCSP  DCSP  DCSP with tf.variable_scope('model') as var_scope: DCNL DCSP  DCSP  DCSP  DCSP eval_model = RealNVP(hps, sampling=True) DCNL DCSP  DCSP  DCSP  DCSP summary_writer = tf.summary.FileWriter(logdir) DCNL DCSP  DCSP  DCSP  DCSP var_scope.reuse_variables() DCNL DCSP  DCSP  DCSP  DCSP summary_op = tf.summary.merge_all() DCNL DCSP  DCSP  DCSP saver = tf.train.Saver() DCNL DCSP  DCSP  DCSP sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)) DCNL DCSP  DCSP  DCSP coord = tf.train.Coordinator() DCNL DCSP  DCSP  DCSP threads = tf.train.start_queue_runners(sess=sess, coord=coord) DCNL DCSP  DCSP  DCSP previous_global_step = 0 DCNL DCSP  DCSP  DCSP initialized = False DCNL DCSP  DCSP  DCSP with sess.as_default(): DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ckpt_state = tf.train.get_checkpoint_state(traindir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ckpt_state and ckpt_state.model_checkpoint_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not initialized): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('No DCSP model DCSP to DCSP eval DCSP yet DCSP at DCSP %s' % traindir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Loading DCSP file DCSP %s' % ckpt_state.model_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP saver.restore(sess, ckpt_state.model_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_step = tf.train.global_step(sess, eval_model.step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_step == previous_global_step): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP updated.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP previous_global_step = current_step DCNL DCSP  DCSP  DCSP  DCSP  DCSP fetches = [summary_op] DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputs = sess.run(fetches) DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_writer.add_summary(outputs[0], current_step) DCNL DCSP  DCSP  DCSP coord.request_stop() DCNL DCSP  DCSP  DCSP coord.join(threads)
 DCSP table = 'col1 DCTB col2\nN DCTB N\n1 DCTB Hello' DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP ascii.read(table, Reader=ascii.Rdb, fast_reader=fast_reader)
 DCSP arg_text = '' DCNL DCSP if (ob is not None): DCNL DCSP  DCSP arg_offset = 0 DCNL DCSP  DCSP if (type(ob) in (types.ClassType, types.TypeType)): DCNL DCSP  DCSP  DCSP fob = _find_constructor(ob) DCNL DCSP  DCSP  DCSP if (fob is None): DCNL DCSP  DCSP  DCSP  DCSP fob = (lambda : None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP arg_offset = 1 DCNL DCSP  DCSP elif (type(ob) == types.MethodType): DCNL DCSP  DCSP  DCSP fob = ob.im_func DCNL DCSP  DCSP  DCSP arg_offset = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fob = ob DCNL DCSP  DCSP if (type(fob) in [types.FunctionType, types.LambdaType]): DCNL DCSP  DCSP  DCSP argcount = fob.func_code.co_argcount DCNL DCSP  DCSP  DCSP real_args = fob.func_code.co_varnames[arg_offset:argcount] DCNL DCSP  DCSP  DCSP defaults = (fob.func_defaults or []) DCNL DCSP  DCSP  DCSP defaults = list(map((lambda name: ('=%s' % repr(name))), defaults)) DCNL DCSP  DCSP  DCSP defaults = (([''] * (len(real_args) - len(defaults))) + defaults) DCNL DCSP  DCSP  DCSP items = map((lambda arg, dflt: (arg + dflt)), real_args, defaults) DCNL DCSP  DCSP  DCSP if (fob.func_code.co_flags & 4): DCNL DCSP  DCSP  DCSP  DCSP items.append('...') DCNL DCSP  DCSP  DCSP if (fob.func_code.co_flags & 8): DCNL DCSP  DCSP  DCSP  DCSP items.append('***') DCNL DCSP  DCSP  DCSP arg_text = ', DCSP '.join(items) DCNL DCSP  DCSP  DCSP arg_text = ('(%s)' % re.sub('\\.\\d+', '<tuple>', arg_text)) DCNL DCSP  DCSP doc = getattr(ob, '__doc__', '') DCNL DCSP  DCSP if doc: DCNL DCSP  DCSP  DCSP doc = doc.lstrip() DCNL DCSP  DCSP  DCSP pos = doc.find('\n') DCNL DCSP  DCSP  DCSP if ((pos < 0) or (pos > 70)): DCNL DCSP  DCSP  DCSP  DCSP pos = 70 DCNL DCSP  DCSP  DCSP if arg_text: DCNL DCSP  DCSP  DCSP  DCSP arg_text += '\n' DCNL DCSP  DCSP  DCSP arg_text += doc[:pos] DCNL DCSP return arg_text
 DCSP if trigger.is_privmsg: DCNL DCSP  DCSP f_reload(bot, trigger)
 DCSP try: DCNL DCSP  DCSP text = (fmtString % fmtDict) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = ('Invalid DCSP format DCSP string DCSP or DCSP unformattable DCSP object DCSP in DCSP log DCSP message: DCSP %r, DCSP %s' % (fmtString, fmtDict)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = ('UNFORMATTABLE DCSP OBJECT DCSP WRITTEN DCSP TO DCSP LOG DCSP with DCSP fmt DCSP %r, DCSP MESSAGE DCSP LOST' % (fmtString,)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP text = 'PATHOLOGICAL DCSP ERROR DCSP IN DCSP BOTH DCSP FORMAT DCSP STRING DCSP AND DCSP MESSAGE DCSP DETAILS, DCSP MESSAGE DCSP LOST' DCNL DCSP return text
 DCSP if (radius == 0.0): DCNL DCSP  DCSP return [loop] DCNL DCSP isInset = (radius > 0) DCNL DCSP insetLoops = [] DCNL DCSP isLoopWiddershins = euclidean.isWiddershins(loop) DCNL DCSP arounds = getAroundsFromLoop(loop, radius, thresholdRatio) DCNL DCSP for around in arounds: DCNL DCSP  DCSP leftPoint = euclidean.getLeftPoint(around) DCNL DCSP  DCSP shouldBeWithin = (isInset == isLoopWiddershins) DCNL DCSP  DCSP if (euclidean.isPointInsideLoop(loop, leftPoint) == shouldBeWithin): DCNL DCSP  DCSP  DCSP if (isLoopWiddershins != euclidean.isWiddershins(around)): DCNL DCSP  DCSP  DCSP  DCSP around.reverse() DCNL DCSP  DCSP  DCSP insetLoops.append(around) DCNL DCSP return insetLoops
 DCSP emptyalgo = algo() DCNL DCSP try: DCNL DCSP  DCSP emptyalgo.learn(0) DCNL DCSP  DCSP return 'Failed DCSP to DCSP throw DCSP missing DCSP evaluator DCSP error?' DCNL DCSP except AssertionError: DCNL DCSP  DCSP pass DCNL DCSP emptyalgo.setEvaluator(sf, xa1) DCNL DCSP emptyalgo.learn(0) DCNL DCSP algo(sf, xa1) DCNL DCSP algo(sf, xa100) DCNL DCSP algo(sf, numParameters=2) DCNL DCSP try: DCNL DCSP  DCSP algo(sf) DCNL DCSP  DCSP return 'Failed DCSP to DCSP throw DCSP unknown DCSP dimension DCSP error' DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP algo(ife1) DCNL DCSP algo(ife2, pc2) DCNL DCSP return True
 DCSP return {'developer_message': message.format(**kwargs), 'user_message': _(message).format(**kwargs)}
 DCSP for i in p[3]: DCNL DCSP  DCSP if (i[0] not in '\'"'): DCNL DCSP  DCSP  DCSP tokenlist.append(i) DCNL DCSP if (p[1] == '%left'): DCNL DCSP  DCSP preclist.append((('left',) + tuple(p[3]))) DCNL DCSP elif (p[1] == '%right'): DCNL DCSP  DCSP preclist.append((('right',) + tuple(p[3]))) DCNL DCSP elif (p[1] == '%nonassoc'): DCNL DCSP  DCSP preclist.append((('nonassoc',) + tuple(p[3])))
 DCSP try: DCNL DCSP  DCSP import win32clipboard DCNL DCSP except ImportError: DCNL DCSP  DCSP raise TryNext('Getting DCSP text DCSP from DCSP the DCSP clipboard DCSP requires DCSP the DCSP pywin32 DCSP extensions: DCSP http://sourceforge.net/projects/pywin32/') DCNL DCSP win32clipboard.OpenClipboard() DCNL DCSP try: DCNL DCSP  DCSP text = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT) DCNL DCSP except (TypeError, win32clipboard.error): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = win32clipboard.GetClipboardData(win32clipboard.CF_TEXT) DCNL DCSP  DCSP  DCSP text = py3compat.cast_unicode(text, py3compat.DEFAULT_ENCODING) DCNL DCSP  DCSP except (TypeError, win32clipboard.error): DCNL DCSP  DCSP  DCSP raise ClipboardEmpty DCNL DCSP finally: DCNL DCSP  DCSP win32clipboard.CloseClipboard() DCNL DCSP return text
 DCSP def func(): DCNL DCSP  DCSP pass DCNL DCSP doctest_item.funcargs = {} DCNL DCSP fm = doctest_item.session._fixturemanager DCNL DCSP doctest_item._fixtureinfo = fm.getfixtureinfo(node=doctest_item, func=func, cls=None, funcargs=False) DCNL DCSP fixture_request = FixtureRequest(doctest_item) DCNL DCSP fixture_request._fillfixtures() DCNL DCSP return fixture_request
 DCSP seen = set() DCNL DCSP return [x for x in elems if ((x not in seen) and (not seen.add(x)))]
 DCSP (cohort_settings, created) = CourseCohortsSettings.objects.get_or_create(course_id=course.id, defaults={'is_cohorted': course.is_cohorted, 'cohorted_discussions': list(course.cohorted_discussions), 'always_cohort_inline_discussions': course.always_cohort_inline_discussions}) DCNL DCSP if created: DCNL DCSP  DCSP manual_cohorts = CourseUserGroup.objects.filter(course_id=course.id, group_type=CourseUserGroup.COHORT).exclude(name__in=course.auto_cohort_groups) DCNL DCSP  DCSP for cohort in manual_cohorts: DCNL DCSP  DCSP  DCSP CourseCohort.create(course_user_group=cohort) DCNL DCSP  DCSP for group_name in course.auto_cohort_groups: DCNL DCSP  DCSP  DCSP CourseCohort.create(cohort_name=group_name, course_id=course.id, assignment_type=CourseCohort.RANDOM) DCNL DCSP return cohort_settings
 DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 3): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP takes DCSP at DCSP least DCSP two DCSP arguments DCSP (path DCSP to DCSP a DCSP view DCSP and DCSP a DCSP urlconf)" % bits[0])) DCNL DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP urlconf = parser.compile_filter(bits[2]) DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[3:] DCNL DCSP if ((len(bits) >= 2) and (bits[(-2)] == u'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(u'Malformed DCSP arguments DCSP to DCSP app_reverse DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.append(parser.compile_filter(value)) DCNL DCSP return AppReverseNode(viewname, urlconf, args, kwargs, asvar)
 DCSP if ((len(header) > 160) and (u',' in header)): DCNL DCSP  DCSP header = mark_safe((u'<br> DCSP ' + u', DCSP <br>'.join(header.split(u',')))) DCNL DCSP return header
 DCSP if (not exists(name, path=path)): DCNL DCSP  DCSP raise CommandExecutionError("Container DCSP '{0}' DCSP does DCSP not DCSP exist".format(name))
 DCSP s = list(pattern) DCNL DCSP i = 0 DCNL DCSP while (i < (len(s) - 1)): DCNL DCSP  DCSP c = s[i] DCNL DCSP  DCSP if ((c == '$') and (s[(i + 1)] in '0123456789')): DCNL DCSP  DCSP  DCSP s[i] = '\\' DCNL DCSP  DCSP elif ((c == '\\') and (s[(i + 1)] == '$')): DCNL DCSP  DCSP  DCSP s[i] = '' DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP i += 1 DCNL DCSP return pattern[:0].join(s)
 DCSP recode = {'A': '1', 'C': '2', 'G': '3', 'T': '4', 'N': '0', '0': '0', '1': '1', '2': '2', '3': '3', '4': '4'} DCNL DCSP basename = os.path.split(inpedfilepath)[(-1)] DCNL DCSP inmap = ('%s.map' % inpedfilepath) DCNL DCSP inped = ('%s.ped' % inpedfilepath) DCNL DCSP outf = ('%s.ped' % basename) DCNL DCSP outfpath = os.path.join(outfilepath, outf) DCNL DCSP try: DCNL DCSP  DCSP mf = open(inmap, 'r') DCNL DCSP except: DCNL DCSP  DCSP sys.stderr.write(('%s DCSP cannot DCSP open DCSP inmap DCSP file DCSP %s DCSP - DCSP do DCSP you DCSP have DCSP permission?\n' % (prog, inmap))) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP try: DCNL DCSP  DCSP rsl = [x.split()[1] for x in mf] DCNL DCSP except: DCNL DCSP  DCSP sys.stderr.write(('## DCSP cannot DCSP parse DCSP %s' % inmap)) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP try: DCNL DCSP  DCSP os.makedirs(outfilepath) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP head = ' DCSP '.join(rsl) DCNL DCSP pedf = open(inped, 'r') DCNL DCSP o = open(outfpath, 'w', (2 ** 20)) DCNL DCSP o.write(head) DCNL DCSP o.write('\n') DCNL DCSP for (i, row) in enumerate(pedf): DCNL DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP lrow = row.split() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP [int(x) for x in lrow[10:50]] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP dorecode = 1 DCNL DCSP  DCSP if dorecode: DCNL DCSP  DCSP  DCSP lrow = row.strip().split() DCNL DCSP  DCSP  DCSP p = lrow[:6] DCNL DCSP  DCSP  DCSP g = lrow[6:] DCNL DCSP  DCSP  DCSP gc = [recode.get(z, '0') for z in g] DCNL DCSP  DCSP  DCSP lrow = (p + gc) DCNL DCSP  DCSP  DCSP row = ('%s\n' % ' DCSP '.join(lrow)) DCNL DCSP  DCSP o.write(row) DCNL DCSP o.close()
 DCSP result = '' DCNL DCSP if (header != ''): DCNL DCSP  DCSP result += (header + '\n') DCNL DCSP result += ('Correlation DCSP coefficient DCTB Parametric DCSP p-value DCTB ' + 'Nonparametric DCSP p-value DCTB CI DCSP (lower) DCTB CI DCSP (upper)\n') DCNL DCSP if (num_permutations > 0): DCNL DCSP  DCSP nonparam_p_val_str = format_p_value_for_num_iters(nonparam_p_val, num_permutations) DCNL DCSP else: DCNL DCSP  DCSP nonparam_p_val_str = 'N/A' DCNL DCSP if (conf_interval == (None, None)): DCNL DCSP  DCSP conf_interval_str = 'N/A DCTB N/A' DCNL DCSP else: DCNL DCSP  DCSP conf_interval_str = ('%.4f DCTB %.4f' % conf_interval) DCNL DCSP result += ('%.4f DCTB %.4f DCTB %s DCTB %s\n' % (corr_coeff, param_p_val, nonparam_p_val_str, conf_interval_str)) DCNL DCSP return result
 DCSP seg = make_segment(1, explicit=False) DCNL DCSP pg_xlog.touch(seg.name, '.ready') DCNL DCSP seg.mark_done()
 DCSP dicts = list(dicts) DCNL DCSP if (dicts and isinstance(dicts[0], OrderedDict)): DCNL DCSP  DCSP result = OrderedDict() DCNL DCSP else: DCNL DCSP  DCSP result = {} DCNL DCSP for d in (list(dicts) + [kwargs]): DCNL DCSP  DCSP duplicate_keys = (set(result.keys()) & set(d.keys())) DCNL DCSP  DCSP if duplicate_keys: DCNL DCSP  DCSP  DCSP raise ValueError('The DCSP following DCSP keys DCSP have DCSP duplicate DCSP entries: DCSP {}'.format(', DCSP '.join((str(key) for key in duplicate_keys)))) DCNL DCSP  DCSP result.update(d) DCNL DCSP return result
 DCSP return (not enabled(name, **kwargs))
 DCSP def path_searcher(target, extra_dirs=extra_paths): DCNL DCSP  DCSP matches = itertools.ifilter(target_predicate, path_generator(target, extra_dirs, **kwargs)) DCNL DCSP  DCSP paths = itertools.imap(target_normalizer, matches) DCNL DCSP  DCSP return next(paths, '') DCNL DCSP return path_searcher
 DCSP cmd = 'monit DCSP validate' DCNL DCSP return (not __salt__['cmd.retcode'](cmd, python_shell=False))
 DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP now = current.request.utcnow DCNL DCSP from dateutil.relativedelta import relativedelta DCNL DCSP TODAY = now.date() DCNL DCSP ONE_YEAR_AGO = (now - relativedelta(years=1)).date() DCNL DCSP ptable = s3db.pr_person DCNL DCSP ctable = s3db.dvr_case DCNL DCSP stable = s3db.dvr_case_status DCNL DCSP ftable = s3db.dvr_case_flag DCNL DCSP cftable = s3db.dvr_case_flag_case DCNL DCSP utable = s3db.cr_shelter_unit DCNL DCSP rtable = s3db.cr_shelter_registration DCNL DCSP ttable = s3db.dvr_case_appointment_type DCNL DCSP atable = s3db.dvr_case_appointment DCNL DCSP COMPLETED = 4 DCNL DCSP NOT_REQUIRED = 7 DCNL DCSP query = (ctable.deleted != True) DCNL DCSP db(query).update(transferable=False, household_transferable=False) DCNL DCSP query = (((ttable.name == 'Reported DCSP Transferable') | (ttable.name == 'Transfer')) & (ttable.deleted != True)) DCNL DCSP rows = db(query).select(ttable.id, limitby=(0, 2)) DCNL DCSP if rows: DCNL DCSP  DCSP transferability_complete = set((row.id for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP transferability_complete = None DCNL DCSP query = (((stable.is_closed == False) | (stable.is_closed == None)) & (stable.deleted != True)) DCNL DCSP rows = db(query).select(stable.id) DCNL DCSP if rows: DCNL DCSP  DCSP OPEN = set((row.id for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP OPEN = None DCNL DCSP query = ((ftable.is_not_transferable == True) & (ftable.deleted != True)) DCNL DCSP rows = db(query).select(ftable.id) DCNL DCSP if rows: DCNL DCSP  DCSP NOT_TRANSFERABLE = set((row.id for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP NOT_TRANSFERABLE = None DCNL DCSP age_groups = {'children': (None, 15, 'mandatory_children', None), 'adolescents': (15, 18, 'mandatory_adolescents', None), 'adults': (18, None, 'mandatory_adults', 4)} DCNL DCSP left = [stable.on((stable.id == ctable.status_id)), ptable.on((ptable.id == ctable.person_id)), rtable.on(((rtable.person_id == ptable.id) & (rtable.deleted != True))), utable.on((utable.id == rtable.shelter_unit_id))] DCNL DCSP if transferability_complete: DCNL DCSP  DCSP tctable = atable.with_alias('transferability_complete') DCNL DCSP  DCSP tcjoin = tctable.on((((((((tctable.person_id == ctable.person_id) & tctable.type_id.belongs(transferability_complete)) & (tctable.deleted != True)) & (tctable.date != None)) & (tctable.date >= ONE_YEAR_AGO)) & (tctable.date <= TODAY)) & (tctable.status == COMPLETED))) DCNL DCSP  DCSP left.append(tcjoin) DCNL DCSP if NOT_TRANSFERABLE: DCNL DCSP  DCSP cfjoin = cftable.on((((cftable.person_id == ctable.person_id) & cftable.flag_id.belongs(NOT_TRANSFERABLE)) & (cftable.deleted != True))) DCNL DCSP  DCSP left.append(cfjoin) DCNL DCSP result = 0 DCNL DCSP for age_group in age_groups: DCNL DCSP  DCSP (min_age, max_age, appointment_flag, maximum_absence) = age_groups[age_group] DCNL DCSP  DCSP dob_query = (ptable.date_of_birth != None) DCNL DCSP  DCSP if max_age: DCNL DCSP  DCSP  DCSP dob_min = (now - relativedelta(years=max_age)) DCNL DCSP  DCSP  DCSP dob_query &= (ptable.date_of_birth > dob_min) DCNL DCSP  DCSP if min_age: DCNL DCSP  DCSP  DCSP dob_max = (now - relativedelta(years=min_age)) DCNL DCSP  DCSP  DCSP dob_query &= (ptable.date_of_birth <= dob_max) DCNL DCSP  DCSP case_query = ((ctable.deleted != True) & ((ctable.archived == False) | (ctable.archived == None))) DCNL DCSP  DCSP if OPEN: DCNL DCSP  DCSP  DCSP case_query &= ctable.status_id.belongs(OPEN) DCNL DCSP  DCSP if site_id: DCNL DCSP  DCSP  DCSP case_query &= (ctable.site_id == site_id) DCNL DCSP  DCSP case_query &= ((stable.is_not_transferable == False) | (stable.is_not_transferable == None)) DCNL DCSP  DCSP if NOT_TRANSFERABLE: DCNL DCSP  DCSP  DCSP case_query &= (cftable.id == None) DCNL DCSP  DCSP case_query &= ((utable.id != None) & ((utable.transitory == False) | (utable.transitory == None))) DCNL DCSP  DCSP case_query &= dob_query DCNL DCSP  DCSP if transferability_complete: DCNL DCSP  DCSP  DCSP case_query &= (tctable.id == None) DCNL DCSP  DCSP if (maximum_absence is not None): DCNL DCSP  DCSP  DCSP if maximum_absence: DCNL DCSP  DCSP  DCSP  DCSP earliest_check_out_date = (now - relativedelta(days=maximum_absence)) DCNL DCSP  DCSP  DCSP  DCSP presence_query = ((rtable.registration_status == 2) | ((rtable.registration_status == 3) & (rtable.check_out_date > earliest_check_out_date))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP presence_query = rtable.registration_status.belongs(2, 3) DCNL DCSP  DCSP  DCSP case_query &= presence_query DCNL DCSP  DCSP cases = db(case_query).select(ctable.id, left=left) DCNL DCSP  DCSP case_ids = set((case.id for case in cases)) DCNL DCSP  DCSP if case_ids: DCNL DCSP  DCSP  DCSP query = ctable.id.belongs(case_ids) DCNL DCSP  DCSP  DCSP aleft = [] DCNL DCSP  DCSP  DCSP if appointment_flag: DCNL DCSP  DCSP  DCSP  DCSP tquery = ((ttable[appointment_flag] == True) & (ttable.deleted != True)) DCNL DCSP  DCSP  DCSP  DCSP rows = db(tquery).select(ttable.id) DCNL DCSP  DCSP  DCSP  DCSP mandatory_appointments = [row.id for row in rows] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP mandatory_appointments = None DCNL DCSP  DCSP  DCSP if mandatory_appointments: DCNL DCSP  DCSP  DCSP  DCSP for appointment_type_id in mandatory_appointments: DCNL DCSP  DCSP  DCSP  DCSP  DCSP alias = ('appointments_%s' % appointment_type_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable_ = atable.with_alias(alias) DCNL DCSP  DCSP  DCSP  DCSP  DCSP join = atable_.on(((((atable_.person_id == ctable.person_id) & (atable_.type_id == appointment_type_id)) & (atable_.deleted != True)) & (((((atable_.status == COMPLETED) & (atable_.date != None)) & (atable_.date >= ONE_YEAR_AGO)) & (atable_.date <= TODAY)) | (atable_.status == NOT_REQUIRED)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aleft.append(join) DCNL DCSP  DCSP  DCSP  DCSP  DCSP query &= (atable_.id != None) DCNL DCSP  DCSP  DCSP  DCSP cases = db(query).select(ctable.id, left=aleft) DCNL DCSP  DCSP  DCSP  DCSP case_ids = set((case.id for case in cases)) DCNL DCSP  DCSP  DCSP success = db(ctable.id.belongs(case_ids)).update(transferable=True) DCNL DCSP  DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP  DCSP result += success DCNL DCSP gtable = s3db.pr_group DCNL DCSP mtable = s3db.pr_group_membership DCNL DCSP query = (((gtable.group_type == 7) & (gtable.deleted != True)) & (ctable.id != None)) DCNL DCSP left = [mtable.on(((mtable.group_id == gtable.id) & (mtable.deleted != True))), ctable.on(((ctable.person_id == mtable.person_id) & (ctable.transferable == True)))] DCNL DCSP members = ctable.id.count() DCNL DCSP rows = db(query).select(gtable.id, groupby=gtable.id, having=(members == 0), left=left) DCNL DCSP group_ids = set((row.id for row in rows)) DCNL DCSP open_case = ((ctable.archived != True) & (ctable.deleted != True)) DCNL DCSP if OPEN: DCNL DCSP  DCSP open_case = (ctable.status_id.belongs(OPEN) & open_case) DCNL DCSP if group_ids: DCNL DCSP  DCSP query &= (~ gtable.id.belongs(group_ids)) DCNL DCSP left = [mtable.on(((mtable.group_id == gtable.id) & (mtable.deleted != True))), ctable.on((((ctable.person_id == mtable.person_id) & open_case) & ((ctable.transferable == False) | (ctable.transferable == None))))] DCNL DCSP if transferability_complete: DCNL DCSP  DCSP left.append(tcjoin) DCNL DCSP  DCSP query &= (tctable.id == None) DCNL DCSP rows = db(query).select(gtable.id, groupby=gtable.id, left=left) DCNL DCSP group_ids |= set((row.id for row in rows)) DCNL DCSP ftable = mtable.with_alias('family') DCNL DCSP left = [mtable.on((((mtable.person_id == ctable.person_id) & mtable.group_id.belongs(group_ids)) & (mtable.deleted != True))), gtable.on(((((ftable.person_id == ctable.person_id) & (ftable.deleted != True)) & (gtable.id == ftable.group_id)) & (gtable.group_type == 7)))] DCNL DCSP query = ((mtable.id == None) & (ctable.deleted != True)) DCNL DCSP families = gtable.id.count() DCNL DCSP required = ((families > 0) | (ctable.transferable == True)) DCNL DCSP rows = db(query).select(ctable.id, groupby=ctable.id, having=required, left=left) DCNL DCSP case_ids = set((row.id for row in rows)) DCNL DCSP if case_ids: DCNL DCSP  DCSP db(ctable.id.belongs(case_ids)).update(household_transferable=True) DCNL DCSP return result
 DCSP if ((r.representation == 'html') and (r.name == 'project')): DCNL DCSP  DCSP T = current.T DCNL DCSP  DCSP db = current.db DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP project_id = r.id DCNL DCSP  DCSP item = TABLE(_class='project_indicator_progress_report') DCNL DCSP  DCSP output = dict(item=item) DCNL DCSP  DCSP output['title'] = T('Monthly DCSP Progress DCSP by DCSP Indicator') DCNL DCSP  DCSP output['subtitle'] = ('%s: DCSP %s' % (T('Project'), r.record.name)) DCNL DCSP  DCSP if ('rheader' in attr): DCNL DCSP  DCSP  DCSP rheader = attr['rheader'](r) DCNL DCSP  DCSP  DCSP if rheader: DCNL DCSP  DCSP  DCSP  DCSP output['rheader'] = rheader DCNL DCSP  DCSP current.response.view = 'simple.html' DCNL DCSP  DCSP return output DCNL DCSP else: DCNL DCSP  DCSP raise HTTP(405, current.ERROR.BAD_METHOD)
 DCSP parts = module.split('.') DCNL DCSP while parts: DCNL DCSP  DCSP part = parts.pop(0) DCNL DCSP  DCSP (f, path, (suffix, mode, kind)) = info = imp.find_module(part, paths) DCNL DCSP  DCSP if (kind == PKG_DIRECTORY): DCNL DCSP  DCSP  DCSP parts = (parts or ['__init__']) DCNL DCSP  DCSP  DCSP paths = [path] DCNL DCSP  DCSP elif parts: DCNL DCSP  DCSP  DCSP raise ImportError(("Can't DCSP find DCSP %r DCSP in DCSP %s" % (parts, module))) DCNL DCSP return info
 DCSP (layout, page) = ([], []) DCNL DCSP layout.append(page) DCNL DCSP if format_data: DCNL DCSP  DCSP if (format_data[0].get(u'fieldname') == u'print_heading_template'): DCNL DCSP  DCSP  DCSP doc.print_heading_template = format_data[0].get(u'options') DCNL DCSP  DCSP  DCSP format_data = format_data[1:] DCNL DCSP def get_new_section(): DCNL DCSP  DCSP return {u'columns': [], u'has_data': False} DCNL DCSP def append_empty_field_dict_to_page_column(page): DCNL DCSP  DCSP u' DCSP append DCSP empty DCSP columns DCSP dict DCSP to DCSP page DCSP layout DCSP ' DCNL DCSP  DCSP if (not page[(-1)][u'columns']): DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'].append({u'fields': []}) DCNL DCSP for df in (format_data or meta.fields): DCNL DCSP  DCSP if format_data: DCNL DCSP  DCSP  DCSP df = frappe._dict(df) DCNL DCSP  DCSP  DCSP if df.fieldname: DCNL DCSP  DCSP  DCSP  DCSP original = meta.get_field(df.fieldname) DCNL DCSP  DCSP  DCSP  DCSP if original: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newdf = original.as_dict() DCNL DCSP  DCSP  DCSP  DCSP  DCSP newdf.update(df) DCNL DCSP  DCSP  DCSP  DCSP  DCSP df = newdf DCNL DCSP  DCSP  DCSP df.print_hide = 0 DCNL DCSP  DCSP if ((df.fieldtype == u'Section DCSP Break') or (page == [])): DCNL DCSP  DCSP  DCSP if (len(page) > 1): DCNL DCSP  DCSP  DCSP  DCSP if (page[(-1)][u'has_data'] == False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del page[(-1)] DCNL DCSP  DCSP  DCSP section = get_new_section() DCNL DCSP  DCSP  DCSP if ((df.fieldtype == u'Section DCSP Break') and df.label): DCNL DCSP  DCSP  DCSP  DCSP section[u'label'] = df.label DCNL DCSP  DCSP  DCSP page.append(section) DCNL DCSP  DCSP elif (df.fieldtype == u'Column DCSP Break'): DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'].append({u'fields': []}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP append_empty_field_dict_to_page_column(page) DCNL DCSP  DCSP if ((df.fieldtype == u'HTML') and df.options): DCNL DCSP  DCSP  DCSP doc.set(df.fieldname, True) DCNL DCSP  DCSP if (is_visible(df, doc) and has_value(df, doc)): DCNL DCSP  DCSP  DCSP append_empty_field_dict_to_page_column(page) DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'][(-1)][u'fields'].append(df) DCNL DCSP  DCSP  DCSP page[(-1)][u'has_data'] = True DCNL DCSP  DCSP  DCSP if (df.fieldtype == u'Table'): DCNL DCSP  DCSP  DCSP  DCSP df.rows = [] DCNL DCSP  DCSP  DCSP  DCSP df.start = 0 DCNL DCSP  DCSP  DCSP  DCSP df.end = None DCNL DCSP  DCSP  DCSP  DCSP for (i, row) in enumerate(doc.get(df.fieldname)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if row.get(u'page_break'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP df.end = i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page = [get_new_section()] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP layout.append(page) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP append_empty_field_dict_to_page_column(page) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP df = copy.copy(df) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP df.start = i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP df.end = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page[(-1)][u'columns'][(-1)][u'fields'].append(df) DCNL DCSP return layout
 DCSP if (deadline is None): DCNL DCSP  DCSP deadline = get_default_fetch_deadline() DCNL DCSP return apiproxy_stub_map.UserRPC('urlfetch', deadline, callback)
 DCSP access_key_id_script = AWS_ACCOUNTS['default'].ACCESS_KEY_ID_SCRIPT.get() DCNL DCSP return (access_key_id_script or get_s3a_access_key())
 DCSP rel = descriptor.related DCNL DCSP related_name = ('%s_cache' % rel.field.related_query_name()) DCNL DCSP @property DCNL DCSP def get(self): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP cached DCSP value DCSP of DCSP the DCSP related DCSP model DCSP if DCSP found\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP the DCSP cache. DCSP Otherwise DCSP gets DCSP and DCSP caches DCSP the DCSP related DCSP model.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(self, descriptor.cache_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(self, ('_%s_cache' % related_name)) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP instance = get_instance(rel.model, self.pk, timeout) DCNL DCSP  DCSP setattr(self, ('_%s_cache' % related_name), instance) DCNL DCSP  DCSP return instance DCNL DCSP setattr(rel.parent_model, related_name, get) DCNL DCSP def clear(self): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of DCSP self.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP delete_instance(rel.model, self) DCNL DCSP @classmethod DCNL DCSP def clear_pk(cls, *instances_or_pk): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP provided DCSP instances_or_pk.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP delete_instance(rel.model, *instances_or_pk) DCNL DCSP def clear_cache(sender, instance, *args, **kwargs): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP given DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP delete_instance(rel.model, instance) DCNL DCSP setattr(rel.parent_model, ('%s_clear' % related_name), clear) DCNL DCSP setattr(rel.parent_model, ('%s_clear_pk' % related_name), clear_pk) DCNL DCSP post_save.connect(clear_cache, sender=rel.model, weak=False) DCNL DCSP post_delete.connect(clear_cache, sender=rel.model, weak=False)
 DCSP if isinstance(seq, (list, tuple)): DCNL DCSP  DCSP return tuple((tuplize(i) for i in seq)) DCNL DCSP return seq
 DCSP sniff(prn=(lambda x: x.display()), *args, **kargs)
 DCSP rng = make_np_rng(rng, default_sparse_seed, which_method=['randn', 'randint']) DCNL DCSP W = np.zeros((input_space.num_channels, kernel_shape[0], kernel_shape[1], output_space.num_channels)) DCNL DCSP def random_coord(): DCNL DCSP  DCSP return [rng.randint(dim) for dim in W.shape[0:3]] DCNL DCSP for o in xrange(output_space.num_channels): DCNL DCSP  DCSP for i in xrange(num_nonzero): DCNL DCSP  DCSP  DCSP (ch, r, c) = random_coord() DCNL DCSP  DCSP  DCSP while (W[(ch, r, c, o)] != 0): DCNL DCSP  DCSP  DCSP  DCSP (ch, r, c) = random_coord() DCNL DCSP  DCSP  DCSP W[(ch, r, c, o)] = rng.randn() DCNL DCSP W = sharedX(W) DCNL DCSP return Conv2D(filters=W, input_axes=input_space.axes, output_axes=output_space.axes, kernel_stride=kernel_stride, pad=pad, message=message, partial_sum=partial_sum)
 DCSP ret = Forward() DCNL DCSP lastExpr = (baseExpr | ((lpar + ret) + rpar)) DCNL DCSP for (i, operDef) in enumerate(opList): DCNL DCSP  DCSP (opExpr, arity, rightLeftAssoc, pa) = (operDef + (None,))[:4] DCNL DCSP  DCSP if (arity == 3): DCNL DCSP  DCSP  DCSP if ((opExpr is None) or (len(opExpr) != 2)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('if DCSP numterms=3, DCSP opExpr DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP of DCSP two DCSP expressions') DCNL DCSP  DCSP  DCSP (opExpr1, opExpr2) = opExpr DCNL DCSP  DCSP thisExpr = Forward() DCNL DCSP  DCSP if (rightLeftAssoc == opAssoc.LEFT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + opExpr)) + Group((lastExpr + OneOrMore(opExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((lastExpr + opExpr) + lastExpr)) + Group((lastExpr + OneOrMore((opExpr + lastExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + lastExpr)) + Group((lastExpr + OneOrMore(lastExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr)) + Group(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP elif (rightLeftAssoc == opAssoc.RIGHT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(opExpr, Optional)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP opExpr = Optional(opExpr) DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((opExpr.expr + thisExpr)) + Group((opExpr + thisExpr))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((lastExpr + opExpr) + thisExpr)) + Group((lastExpr + OneOrMore((opExpr + thisExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy((lastExpr + thisExpr)) + Group((lastExpr + OneOrMore(thisExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FollowedBy(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr)) + Group(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP indicate DCSP right DCSP or DCSP left DCSP associativity') DCNL DCSP  DCSP if pa: DCNL DCSP  DCSP  DCSP matchExpr.setParseAction(pa) DCNL DCSP  DCSP thisExpr <<= (matchExpr | lastExpr) DCNL DCSP  DCSP lastExpr = thisExpr DCNL DCSP ret <<= lastExpr DCNL DCSP return ret
 DCSP ret = _get_account_policy_data_value(name, 'creationTime') DCNL DCSP unix_timestamp = salt.utils.mac_utils.parse_return(ret) DCNL DCSP date_text = _convert_to_datetime(unix_timestamp) DCNL DCSP return date_text
 DCSP if (not trigger.group(2)): DCNL DCSP  DCSP return bot.reply(u'No DCSP search DCSP term.') DCNL DCSP query = trigger.group(2) DCNL DCSP db_path = _find_geoip_db(bot) DCNL DCSP if (db_path is False): DCNL DCSP  DCSP LOGGER.error(u"Can't DCSP find DCSP (or DCSP download) DCSP usable DCSP GeoIP DCSP database") DCNL DCSP  DCSP bot.say(u"Sorry, DCSP I DCSP don't DCSP have DCSP a DCSP GeoIP DCSP database DCSP to DCSP use DCSP for DCSP this DCSP lookup") DCNL DCSP  DCSP return False DCNL DCSP geolite_city_filepath = os.path.join(_find_geoip_db(bot), u'GeoLiteCity.dat') DCNL DCSP geolite_ASN_filepath = os.path.join(_find_geoip_db(bot), u'GeoIPASNum.dat') DCNL DCSP gi_city = pygeoip.GeoIP(geolite_city_filepath) DCNL DCSP gi_org = pygeoip.GeoIP(geolite_ASN_filepath) DCNL DCSP host = socket.getfqdn(query) DCNL DCSP response = (u'[IP/Host DCSP Lookup] DCSP Hostname: DCSP %s' % host) DCNL DCSP try: DCNL DCSP  DCSP response += (u' DCSP | DCSP Location: DCSP %s' % gi_city.country_name_by_name(query)) DCNL DCSP except AttributeError: DCNL DCSP  DCSP response += u' DCSP | DCSP Location: DCSP Unknown' DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP return bot.say(u'[IP/Host DCSP Lookup] DCSP Unable DCSP to DCSP resolve DCSP IP/Hostname') DCNL DCSP region_data = gi_city.region_by_name(query) DCNL DCSP try: DCNL DCSP  DCSP region = region_data[u'region_code'] DCNL DCSP except KeyError: DCNL DCSP  DCSP region = region_data[u'region_name'] DCNL DCSP if region: DCNL DCSP  DCSP response += (u' DCSP | DCSP Region: DCSP %s' % region) DCNL DCSP isp = gi_org.org_by_name(query) DCNL DCSP response += (u' DCSP | DCSP ISP: DCSP %s' % isp) DCNL DCSP bot.say(response)
 DCSP tablename = ('%s_%s' % (module, resourcename)) DCNL DCSP s3db.table(tablename) DCNL DCSP type = 'GPX' DCNL DCSP LAYERS = T((TYPE_LAYERS_FMT % type)) DCNL DCSP ADD_NEW_LAYER = T((ADD_NEW_TYPE_LAYER_FMT % type)) DCNL DCSP EDIT_LAYER = T((EDIT_TYPE_LAYER_FMT % type)) DCNL DCSP LIST_LAYERS = T((LIST_TYPE_LAYERS_FMT % type)) DCNL DCSP NO_LAYERS = T((NO_TYPE_LAYERS_FMT % type)) DCNL DCSP s3.crud_strings[tablename] = Storage(label_create=ADD_LAYER, title_display=LAYER_DETAILS, title_list=LAYERS, title_update=EDIT_LAYER, label_list_button=LIST_LAYERS, label_delete_button=DELETE_LAYER, msg_record_created=LAYER_ADDED, msg_record_modified=LAYER_UPDATED, msg_record_deleted=LAYER_DELETED, msg_list_empty=NO_LAYERS) DCNL DCSP def prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (r.component_name == 'config'): DCNL DCSP  DCSP  DCSP  DCSP ltable = s3db.gis_layer_config DCNL DCSP  DCSP  DCSP  DCSP ltable.base.writable = ltable.base.readable = False DCNL DCSP  DCSP  DCSP  DCSP if (r.method != 'update'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = ((ltable.layer_id == table.layer_id) & (table.id == r.id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = db(query).select(ltable.config_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ltable.config_id.requires = IS_ONE_OF(db, 'gis_config.id', '%(name)s', not_filterby='config_id', not_filter_opts=[row.config_id for row in rows]) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if (r.interactive and (r.method != 'import')): DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP inject_enable(output) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3_rest_controller(rheader=s3db.gis_rheader) DCNL DCSP return output
 DCSP return False
 DCSP obj = RSAobj() DCNL DCSP obj.e = long(e) DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('p,q\n') DCNL DCSP p = q = 1L DCNL DCSP while (number.size((p * q)) < bits): DCNL DCSP  DCSP p = pubkey.getStrongPrime((bits >> 1), obj.e, 1e-12, randfunc) DCNL DCSP  DCSP q = pubkey.getStrongPrime((bits - (bits >> 1)), obj.e, 1e-12, randfunc) DCNL DCSP if (p > q): DCNL DCSP  DCSP (p, q) = (q, p) DCNL DCSP obj.p = p DCNL DCSP obj.q = q DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('u\n') DCNL DCSP obj.u = pubkey.inverse(obj.p, obj.q) DCNL DCSP obj.n = (obj.p * obj.q) DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('d\n') DCNL DCSP obj.d = pubkey.inverse(obj.e, ((obj.p - 1) * (obj.q - 1))) DCNL DCSP assert (bits <= (1 + obj.size())), 'Generated DCSP key DCSP is DCSP too DCSP small' DCNL DCSP return obj
 DCSP (_, rest) = token.contents.split(None, 1) DCNL DCSP filter_expr = parser.compile_filter((u'var|%s' % rest)) DCNL DCSP for (func, unused) in filter_expr.filters: DCNL DCSP  DCSP filter_name = getattr(func, u'_filter_name', None) DCNL DCSP  DCSP if (filter_name in (u'escape', u'safe')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"filter DCSP %s" DCSP is DCSP not DCSP permitted. DCSP  DCSP Use DCSP the DCSP "autoescape" DCSP tag DCSP instead.' % filter_name)) DCNL DCSP nodelist = parser.parse((u'endfilter',)) DCNL DCSP parser.delete_first_token() DCNL DCSP return FilterNode(filter_expr, nodelist)
 DCSP lines = buffer.text.splitlines(True) DCNL DCSP lines_before = lines[:from_row] DCNL DCSP lines_after = lines[(to_row + 1):] DCNL DCSP lines_to_reformat = lines[from_row:(to_row + 1)] DCNL DCSP if lines_to_reformat: DCNL DCSP  DCSP length = re.search(u'^\\s*', lines_to_reformat[0]).end() DCNL DCSP  DCSP indent = lines_to_reformat[0][:length].replace(u'\n', u'') DCNL DCSP  DCSP words = u''.join(lines_to_reformat).split() DCNL DCSP  DCSP width = ((buffer.text_width or 80) - len(indent)) DCNL DCSP  DCSP reshaped_text = [indent] DCNL DCSP  DCSP current_width = 0 DCNL DCSP  DCSP for w in words: DCNL DCSP  DCSP  DCSP if current_width: DCNL DCSP  DCSP  DCSP  DCSP if (((len(w) + current_width) + 1) > width): DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshaped_text.append(u'\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshaped_text.append(indent) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_width = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshaped_text.append(u' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_width += 1 DCNL DCSP  DCSP  DCSP reshaped_text.append(w) DCNL DCSP  DCSP  DCSP current_width += len(w) DCNL DCSP  DCSP if (reshaped_text[(-1)] != u'\n'): DCNL DCSP  DCSP  DCSP reshaped_text.append(u'\n') DCNL DCSP  DCSP buffer.document = Document(text=u''.join(((lines_before + reshaped_text) + lines_after)), cursor_position=len(u''.join((lines_before + reshaped_text))))
 DCSP x = np.asarray(x) DCNL DCSP if ((k % 2) != 1): DCNL DCSP  DCSP raise ValueError(('Odd DCSP degree DCSP for DCSP now DCSP only. DCSP Got DCSP %s.' % k)) DCNL DCSP m = ((k - 1) // 2) DCNL DCSP t = x[(m + 1):((- m) - 1)] DCNL DCSP t = np.r_[(((x[0],) * (k + 1)), t, ((x[(-1)],) * (k + 1)))] DCNL DCSP return t
 DCSP try: DCNL DCSP  DCSP r = urlfetch.fetch(url, method=urlfetch.GET) DCNL DCSP except urlfetch.Error as e: DCNL DCSP  DCSP log.warn((u'Error DCSP opening DCSP url=%r: DCSP %s' % (url, e)), error=IOError) DCNL DCSP else: DCNL DCSP  DCSP if (r.status_code == 200): DCNL DCSP  DCSP  DCSP mimetype = 'application/octet-stream' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (mimetype, params) = cgi.parse_header(r.headers['content-type']) DCNL DCSP  DCSP  DCSP  DCSP encoding = params['charset'] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP encoding = None DCNL DCSP  DCSP  DCSP if (mimetype != u'text/css'): DCNL DCSP  DCSP  DCSP  DCSP log.error((u'Expected DCSP "text/css" DCSP mime DCSP type DCSP for DCSP url DCSP %r DCSP but DCSP found: DCSP %r' % (url, mimetype)), error=ValueError) DCNL DCSP  DCSP  DCSP return (encoding, r.content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.warn((u'Error DCSP opening DCSP url=%r: DCSP HTTP DCSP status DCSP %s' % (url, r.status_code)), error=IOError)
 DCSP if (not os.path.exists(source)): DCNL DCSP  DCSP raise DistutilsFileError(("file DCSP '%s' DCSP does DCSP not DCSP exist" % os.path.abspath(source))) DCNL DCSP if (not os.path.exists(target)): DCNL DCSP  DCSP return 1 DCNL DCSP from stat import ST_MTIME DCNL DCSP mtime1 = os.stat(source)[ST_MTIME] DCNL DCSP mtime2 = os.stat(target)[ST_MTIME] DCNL DCSP return (mtime1 > mtime2)
 DCSP trash = contentstore('trashcan') DCNL DCSP store = contentstore() DCNL DCSP loc = StaticContent.get_location_from_path(location) DCNL DCSP content = trash.find(loc) DCNL DCSP store.save(content) DCNL DCSP if (content.thumbnail_location is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP thumbnail_content = trash.find(content.thumbnail_location) DCNL DCSP  DCSP  DCSP store.save(thumbnail_content) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP return json.dumps(dict, sort_keys=True, indent=indent)
 DCSP from werkzeug.wsgi import make_chunk_iter DCNL DCSP if return_iterator: DCNL DCSP  DCSP cls = (lambda x: x) DCNL DCSP elif (cls is None): DCNL DCSP  DCSP cls = MultiDict DCNL DCSP pair_iter = make_chunk_iter(stream, separator, limit) DCNL DCSP return cls(_url_decode_impl(pair_iter, charset, decode_keys, include_empty, errors))
 DCSP conn = _auth(profile) DCNL DCSP return conn.delete_subnet(subnet)
 DCSP try: DCNL DCSP  DCSP return int(info(name).get('PID')) DCNL DCSP except (TypeError, ValueError) as exc: DCNL DCSP  DCSP raise CommandExecutionError("Unable DCSP to DCSP get DCSP PID DCSP for DCSP container DCSP '{0}': DCSP {1}".format(name, exc))
 DCSP used_luns = _get_used_lun_ids_for_mappings(mapping) DCNL DCSP used_lun_id_counter = collections.Counter(used_luns) DCNL DCSP return used_lun_id_counter
 DCSP marker = object() DCNL DCSP if (getattr(original, 'mismatched', marker) is marker): DCNL DCSP  DCSP return mismatch(matchee, original.describe(), original.get_details()) DCNL DCSP return original
 DCSP if ('id' not in kwargs['opts']): DCNL DCSP  DCSP return {} DCNL DCSP cmd = '{0} DCSP {1}'.format(__opts__['master_tops']['ext_nodes'], kwargs['opts']['id']) DCNL DCSP ndata = yaml.safe_load(subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).communicate()[0]) DCNL DCSP if (not ndata): DCNL DCSP  DCSP log.info('master_tops DCSP ext_nodes DCSP call DCSP did DCSP not DCSP return DCSP any DCSP data') DCNL DCSP ret = {} DCNL DCSP if ('environment' in ndata): DCNL DCSP  DCSP env = ndata['environment'] DCNL DCSP else: DCNL DCSP  DCSP env = 'base' DCNL DCSP if ('classes' in ndata): DCNL DCSP  DCSP if isinstance(ndata['classes'], dict): DCNL DCSP  DCSP  DCSP ret[env] = list(ndata['classes']) DCNL DCSP  DCSP elif isinstance(ndata['classes'], list): DCNL DCSP  DCSP  DCSP ret[env] = ndata['classes'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP log.info('master_tops DCSP ext_nodes DCSP call DCSP did DCSP not DCSP have DCSP a DCSP dictionary DCSP with DCSP a DCSP "classes" DCSP key.') DCNL DCSP return ret
 DCSP m = mixin_cols['m'] DCNL DCSP m.info.name = 'a' DCNL DCSP assert (m.info.name == 'a') DCNL DCSP m.info.description = 'a' DCNL DCSP assert (m.info.description == 'a') DCNL DCSP if isinstance(m, (u.Quantity, coordinates.SkyCoord, time.Time)): DCNL DCSP  DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP  DCSP m.info.unit = u.m DCNL DCSP else: DCNL DCSP  DCSP m.info.unit = u.m DCNL DCSP  DCSP assert (m.info.unit is u.m) DCNL DCSP m.info.format = 'a' DCNL DCSP assert (m.info.format == 'a') DCNL DCSP m.info.meta = {'a': 1} DCNL DCSP assert (m.info.meta == {'a': 1}) DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP m.info.bad_attr = 1 DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP m.info.bad_attr
 DCSP cmd_obj = _DISTUTILS_REINIT(self, command, reinit_subcommands) DCNL DCSP options = self.command_options.get(command) DCNL DCSP if options: DCNL DCSP  DCSP self._set_command_options(cmd_obj, options) DCNL DCSP return cmd_obj
 DCSP z = atleast_1d(z) DCNL DCSP p = atleast_1d(p) DCNL DCSP degree = _relative_degree(z, p) DCNL DCSP fs2 = (2 * fs) DCNL DCSP z_z = ((fs2 + z) / (fs2 - z)) DCNL DCSP p_z = ((fs2 + p) / (fs2 - p)) DCNL DCSP z_z = append(z_z, (- ones(degree))) DCNL DCSP k_z = (k * real((prod((fs2 - z)) / prod((fs2 - p))))) DCNL DCSP return (z_z, p_z, k_z)
 DCSP if (config.getoption('gae_sdk') is not None): DCNL DCSP  DCSP set_up_gae_environment(config.getoption('gae_sdk'))
 DCSP try: DCNL DCSP  DCSP date = release['ReleaseDate'] DCNL DCSP except TypeError: DCNL DCSP  DCSP date = '' DCNL DCSP if (date is not None): DCNL DCSP  DCSP year = date[:4] DCNL DCSP else: DCNL DCSP  DCSP year = '' DCNL DCSP return (date, year)
 DCSP for i in xrange(startpos, len(line)): DCNL DCSP  DCSP if (line[i] == startchar): DCNL DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP elif (line[i] == endchar): DCNL DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP if (depth == 0): DCNL DCSP  DCSP  DCSP  DCSP return ((i + 1), 0) DCNL DCSP return ((-1), depth)
 DCSP if login_view.startswith(('https://', 'http://', '/')): DCNL DCSP  DCSP return login_view DCNL DCSP else: DCNL DCSP  DCSP return url_for(login_view)
 DCSP assert ((cxpb + mutpb) <= 1.0), 'The DCSP sum DCSP of DCSP the DCSP crossover DCSP and DCSP mutation DCSP probabilities DCSP must DCSP be DCSP smaller DCSP or DCSP equal DCSP to DCSP 1.0.' DCNL DCSP offspring = [] DCNL DCSP for _ in xrange(lambda_): DCNL DCSP  DCSP op_choice = random.random() DCNL DCSP  DCSP if (op_choice < cxpb): DCNL DCSP  DCSP  DCSP (ind1, ind2) = map(toolbox.clone, random.sample(population, 2)) DCNL DCSP  DCSP  DCSP (ind1, ind2) = toolbox.mate(ind1, ind2) DCNL DCSP  DCSP  DCSP del ind1.fitness.values DCNL DCSP  DCSP  DCSP offspring.append(ind1) DCNL DCSP  DCSP elif (op_choice < (cxpb + mutpb)): DCNL DCSP  DCSP  DCSP ind = toolbox.clone(random.choice(population)) DCNL DCSP  DCSP  DCSP (ind,) = toolbox.mutate(ind) DCNL DCSP  DCSP  DCSP del ind.fitness.values DCNL DCSP  DCSP  DCSP offspring.append(ind) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP offspring.append(random.choice(population)) DCNL DCSP return offspring
 DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP value = u','.join(value) DCNL DCSP elif isinstance(value, (date, datetime)): DCNL DCSP  DCSP value = value.isoformat() DCNL DCSP elif isinstance(value, bool): DCNL DCSP  DCSP value = str(value).lower() DCNL DCSP if isinstance(value, string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return value.encode(u'utf-8') DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return str(value)
 DCSP def wrap(response_function): DCNL DCSP  DCSP def _api_validate(*simple_vals, **param_vals): DCNL DCSP  DCSP  DCSP def val(fn): DCNL DCSP  DCSP  DCSP  DCSP @wraps(fn) DCNL DCSP  DCSP  DCSP  DCSP def newfn(self, *a, **env): DCNL DCSP  DCSP  DCSP  DCSP  DCSP renderstyle = request.params.get('renderstyle') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if renderstyle: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.render_style = api_type(renderstyle) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not c.extension): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.render_style = api_type(response_type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((response_type == 'html') and (not (request.params.get('api_type') == 'json'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responder = JQueryResponse() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responder = JsonResponse() DCNL DCSP  DCSP  DCSP  DCSP  DCSP response.content_type = responder.content_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kw = _make_validated_kw(fn, simple_vals, param_vals, env) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return response_function(self, fn, responder, simple_vals, param_vals, *a, **kw) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except UserRequiredException: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responder.send_failure(errors.USER_REQUIRED) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.api_wrapper(responder.make_response()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except VerifiedUserRequiredException: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responder.send_failure(errors.VERIFIED_USER_REQUIRED) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.api_wrapper(responder.make_response()) DCNL DCSP  DCSP  DCSP  DCSP extra_param_vals = {} DCNL DCSP  DCSP  DCSP  DCSP if add_api_type_doc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP extra_param_vals = {'api_type': 'the DCSP string DCSP `json`'} DCNL DCSP  DCSP  DCSP  DCSP set_api_docs(newfn, simple_vals, param_vals, extra_param_vals) DCNL DCSP  DCSP  DCSP  DCSP newfn.handles_csrf = _validators_handle_csrf(simple_vals, param_vals) DCNL DCSP  DCSP  DCSP  DCSP return newfn DCNL DCSP  DCSP  DCSP return val DCNL DCSP  DCSP return _api_validate DCNL DCSP return wrap
 DCSP if (compiler['platform'] == 'x64'): DCNL DCSP  DCSP return '' DCNL DCSP 'Build DCSP LCMS DCSP on DCSP VC2008. DCSP This DCSP version DCSP is DCSP only DCSP 32bit/Win32' DCNL DCSP return ('\nrem DCSP Build DCSP lcms2\nsetlocal\nrd DCSP /S DCSP /Q DCSP %%LCMS%%\\Lib\nrd DCSP /S DCSP /Q DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\Release\n%%MSBUILD%% DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\lcms2.sln DCSP  DCSP /t:Clean DCSP /p:Configuration="Release" DCSP /p:Platform=Win32 DCSP /m\n%%MSBUILD%% DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\lcms2.sln DCSP /t:lcms2_static DCSP /p:Configuration="Release" DCSP /p:Platform=Win32 DCSP /m\nxcopy DCSP /Y DCSP /E DCSP /Q DCSP %%LCMS%%\\include DCSP %%INCLIB%%\ncopy DCSP /Y DCSP /B DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\Release\\*.lib DCSP %%INCLIB%%\nendlocal\n' % compiler)
 DCSP try: DCNL DCSP  DCSP m = _rfc822_match(dt.lower()).groupdict(0) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None DCNL DCSP return _parse_date_group_rfc822(m)
 DCSP instances = find_instances(instance_id=instance_id, name=instance_name, tags=tags, region=region, key=key, keyid=keyid, profile=profile, return_objs=True, filters=filters) DCNL DCSP if (not instances): DCNL DCSP  DCSP log.error('Source DCSP instance DCSP not DCSP found') DCNL DCSP  DCSP return False DCNL DCSP if (len(instances) > 1): DCNL DCSP  DCSP log.error('Multiple DCSP instances DCSP found, DCSP must DCSP match DCSP exactly DCSP only DCSP one DCSP instance DCSP to DCSP create DCSP an DCSP image DCSP from') DCNL DCSP  DCSP return False DCNL DCSP instance = instances[0] DCNL DCSP try: DCNL DCSP  DCSP return instance.create_image(ami_name, description=description, no_reboot=no_reboot, dry_run=dry_run) DCNL DCSP except boto.exception.BotoServerError as exc: DCNL DCSP  DCSP log.error(exc) DCNL DCSP  DCSP return False
 DCSP return corpus_chrf([reference], [hypothesis], min_len, max_len, beta=beta)
 DCSP return (not ((os.name == 'nt') and version_check('5.3.0', operator.lt)))
 DCSP try: DCNL DCSP  DCSP f = open(scriptfile, mode='r') DCNL DCSP except Exception: DCNL DCSP  DCSP return DCNL DCSP mpstate.console.writeln(('Running DCSP script DCSP %s' % scriptfile)) DCNL DCSP for line in f: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') or line.startswith('#')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.startswith('@'): DCNL DCSP  DCSP  DCSP line = line[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mpstate.console.writeln(('-> DCSP %s' % line)) DCNL DCSP  DCSP process_stdin(line) DCNL DCSP f.close()
 DCSP log.debug('Adding DCSP cohort DCSP %s DCSP to DCSP %s', name, course_key) DCNL DCSP if is_cohort_exists(course_key, name): DCNL DCSP  DCSP raise ValueError(_('You DCSP cannot DCSP create DCSP two DCSP cohorts DCSP with DCSP the DCSP same DCSP name')) DCNL DCSP try: DCNL DCSP  DCSP course = courses.get_course_by_id(course_key) DCNL DCSP except Http404: DCNL DCSP  DCSP raise ValueError('Invalid DCSP course_key') DCNL DCSP cohort = CourseCohort.create(cohort_name=name, course_id=course.id, assignment_type=assignment_type).course_user_group DCNL DCSP tracker.emit('edx.cohort.creation_requested', {'cohort_name': cohort.name, 'cohort_id': cohort.id}) DCNL DCSP return cohort
 DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP delete_affinity_group DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('name' not in kwargs): DCNL DCSP  DCSP raise SaltCloudSystemExit('A DCSP name DCSP must DCSP be DCSP specified DCSP as DCSP "name"') DCNL DCSP if (not conn): DCNL DCSP  DCSP conn = get_conn() DCNL DCSP try: DCNL DCSP  DCSP conn.delete_affinity_group(kwargs['name']) DCNL DCSP  DCSP return {'Success': 'The DCSP affinity DCSP group DCSP was DCSP successfully DCSP deleted'} DCNL DCSP except AzureMissingResourceHttpError as exc: DCNL DCSP  DCSP raise SaltCloudSystemExit('{0}: DCSP {1}'.format(kwargs['name'], exc.message))
 DCSP from sympy.simplify.radsimp import radsimp, rad_rationalize, split_surds DCNL DCSP if (not expr.is_Pow): DCNL DCSP  DCSP return sqrtdenest(expr) DCNL DCSP if (expr.base < 0): DCNL DCSP  DCSP return (sqrt((-1)) * _sqrtdenest_rec(sqrt((- expr.base)))) DCNL DCSP (g, a, b) = split_surds(expr.base) DCNL DCSP a = (a * sqrt(g)) DCNL DCSP if (a < b): DCNL DCSP  DCSP (a, b) = (b, a) DCNL DCSP c2 = _mexpand(((a ** 2) - (b ** 2))) DCNL DCSP if (len(c2.args) > 2): DCNL DCSP  DCSP (g, a1, b1) = split_surds(c2) DCNL DCSP  DCSP a1 = (a1 * sqrt(g)) DCNL DCSP  DCSP if (a1 < b1): DCNL DCSP  DCSP  DCSP (a1, b1) = (b1, a1) DCNL DCSP  DCSP c2_1 = _mexpand(((a1 ** 2) - (b1 ** 2))) DCNL DCSP  DCSP c_1 = _sqrtdenest_rec(sqrt(c2_1)) DCNL DCSP  DCSP d_1 = _sqrtdenest_rec(sqrt((a1 + c_1))) DCNL DCSP  DCSP (num, den) = rad_rationalize(b1, d_1) DCNL DCSP  DCSP c = _mexpand(((d_1 / sqrt(2)) + (num / (den * sqrt(2))))) DCNL DCSP else: DCNL DCSP  DCSP c = _sqrtdenest1(sqrt(c2)) DCNL DCSP if (sqrt_depth(c) > 1): DCNL DCSP  DCSP raise SqrtdenestStopIteration DCNL DCSP ac = (a + c) DCNL DCSP if (len(ac.args) >= len(expr.args)): DCNL DCSP  DCSP if (count_ops(ac) >= count_ops(expr.base)): DCNL DCSP  DCSP  DCSP raise SqrtdenestStopIteration DCNL DCSP d = sqrtdenest(sqrt(ac)) DCNL DCSP if (sqrt_depth(d) > 1): DCNL DCSP  DCSP raise SqrtdenestStopIteration DCNL DCSP (num, den) = rad_rationalize(b, d) DCNL DCSP r = ((d / sqrt(2)) + (num / (den * sqrt(2)))) DCNL DCSP r = radsimp(r) DCNL DCSP return _mexpand(r)
 DCSP if instance.id: DCNL DCSP  DCSP user = User.objects.get(id=instance.id) DCNL DCSP  DCSP if (user.username != instance.username): DCNL DCSP  DCSP  DCSP questions = Question.objects.filter((Q(creator=instance) | Q(answers__creator=instance))).only('id').distinct() DCNL DCSP  DCSP  DCSP for q in questions: DCNL DCSP  DCSP  DCSP  DCSP q.index_later()
 DCSP thresh = np.where((mX[1:(-1)] > t), mX[1:(-1)], 0) DCNL DCSP next_minor = np.where((mX[1:(-1)] > mX[2:]), mX[1:(-1)], 0) DCNL DCSP prev_minor = np.where((mX[1:(-1)] > mX[:(-2)]), mX[1:(-1)], 0) DCNL DCSP ploc = ((thresh * next_minor) * prev_minor) DCNL DCSP ploc = (ploc.nonzero()[0] + 1) DCNL DCSP return ploc
 DCSP pos = fp.tell() DCNL DCSP fp.seek(0) DCNL DCSP try: DCNL DCSP  DCSP line1 = fp.readline() DCNL DCSP  DCSP has_bom = line1.startswith(codecs.BOM_UTF8) DCNL DCSP  DCSP if has_bom: DCNL DCSP  DCSP  DCSP line1 = line1[len(codecs.BOM_UTF8):] DCNL DCSP  DCSP m = PYTHON_MAGIC_COMMENT_re.match(line1) DCNL DCSP  DCSP if (not m): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP import parser DCNL DCSP  DCSP  DCSP  DCSP parser.suite(line1) DCNL DCSP  DCSP  DCSP except (ImportError, SyntaxError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP line2 = fp.readline() DCNL DCSP  DCSP  DCSP  DCSP m = PYTHON_MAGIC_COMMENT_re.match(line2) DCNL DCSP  DCSP if has_bom: DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP raise SyntaxError('python DCSP refuses DCSP to DCSP compile DCSP code DCSP with DCSP both DCSP a DCSP UTF8 DCSP byte-order-mark DCSP and DCSP a DCSP magic DCSP encoding DCSP comment') DCNL DCSP  DCSP  DCSP return 'utf_8' DCNL DCSP  DCSP elif m: DCNL DCSP  DCSP  DCSP return m.group(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP finally: DCNL DCSP  DCSP fp.seek(pos)
 DCSP signal.signal(signal.SIGINT, signal.default_int_handler)
 DCSP return tempfile.mkdtemp(suffix, prefix, parent)
 DCSP n = 1 DCNL DCSP extension = ext DCNL DCSP while os.path.exists((dir + extension)): DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP extension = (ext + str(n)) DCNL DCSP return (dir + extension)
 DCSP charset = config.Option.get('p_charset') DCNL DCSP if (not charset): DCNL DCSP  DCSP charset = cyclic_pattern_charset(charset) DCNL DCSP else: DCNL DCSP  DCSP charset = ''.join(set(charset)) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = 0 DCNL DCSP if (size is None): DCNL DCSP  DCSP size = 65536 DCNL DCSP size += start DCNL DCSP pattern = de_bruijn(charset, 3, size) DCNL DCSP return pattern[start:size].encode('utf-8')
 DCSP options = _UnderrideColor(options) DCNL DCSP options = _Underride(options, linewidth=0, alpha=0.6) DCNL DCSP pyplot.bar(xs, ys, **options)
 DCSP if ((not skipkeys) and ensure_ascii and check_circular and allow_nan and (cls is None) and (indent is None) and (separators is None) and (encoding == 'utf-8') and (default is None) and use_decimal and namedtuple_as_object and tuple_as_array and (not iterable_as_array) and (not bigint_as_string) and (not sort_keys) and (not item_sort_key) and (not for_json) and (not ignore_nan) and (int_as_string_bitcount is None) and (not kw)): DCNL DCSP  DCSP iterable = _default_encoder.iterencode(obj) DCNL DCSP else: DCNL DCSP  DCSP if (cls is None): DCNL DCSP  DCSP  DCSP cls = JSONEncoder DCNL DCSP  DCSP iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, use_decimal=use_decimal, namedtuple_as_object=namedtuple_as_object, tuple_as_array=tuple_as_array, iterable_as_array=iterable_as_array, bigint_as_string=bigint_as_string, sort_keys=sort_keys, item_sort_key=item_sort_key, for_json=for_json, ignore_nan=ignore_nan, int_as_string_bitcount=int_as_string_bitcount, **kw).iterencode(obj) DCNL DCSP for chunk in iterable: DCNL DCSP  DCSP fp.write(chunk)
 DCSP if (text is None): DCNL DCSP  DCSP return u'' DCNL DCSP tag_id = RE_TAGS.sub(u'', unicodedata.normalize(u'NFKD', text)).lower() DCNL DCSP tag_id = RE_WORD.sub(u'', tag_id).replace(u' DCSP ', sep) DCNL DCSP return quote(tag_id.encode(u'utf-8'))
 DCSP string = u(string).replace(u'\u2024', '.') DCNL DCSP matches = [] DCNL DCSP for m in RE_EMAIL.finditer(string): DCNL DCSP  DCSP s = m.group(0) DCNL DCSP  DCSP if ((not unique) or (s not in matches)): DCNL DCSP  DCSP  DCSP matches.append(s) DCNL DCSP return matches
 DCSP key = _make_ratelimit_cache_key(key_prefix, time_slice) DCNL DCSP try: DCNL DCSP  DCSP g.ratelimitcache.add(key, 0, time=time_slice.remaining) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return g.ratelimitcache.incr(key) DCNL DCSP  DCSP except pylibmc.NotFound: DCNL DCSP  DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP  DCSP if (now < time_slice.end): DCNL DCSP  DCSP  DCSP  DCSP g.ratelimitcache.add(key, 1, time=((time_slice.end - now) + 1)) DCNL DCSP  DCSP  DCSP  DCSP g.stats.simple_event('ratelimit.eviction') DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP except pylibmc.Error as e: DCNL DCSP  DCSP raise RatelimitError(e)
 DCSP try: DCNL DCSP  DCSP bbox_data = BboxData() DCNL DCSP  DCSP bbox_data.update() DCNL DCSP except requests.exceptions.HTTPError as error: DCNL DCSP  DCSP _LOGGER.error(error) DCNL DCSP  DCSP return False DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP sensors = [] DCNL DCSP for variable in config[CONF_MONITORED_VARIABLES]: DCNL DCSP  DCSP sensors.append(BboxSensor(bbox_data, variable, name)) DCNL DCSP add_devices(sensors)
 DCSP forum = get_object_or_404(Forum, slug=forum_slug) DCNL DCSP if (not forum.allows_viewing_by(request.user)): DCNL DCSP  DCSP raise Http404 DCNL DCSP if (request.POST.get('watch') == 'yes'): DCNL DCSP  DCSP NewThreadEvent.notify(request.user, forum) DCNL DCSP  DCSP statsd.incr('forums.watches.forum') DCNL DCSP else: DCNL DCSP  DCSP NewThreadEvent.stop_notifying(request.user, forum) DCNL DCSP return HttpResponseRedirect(reverse('forums.threads', args=[forum_slug]))
 DCSP return bool(_OVERRIDES_DISABLED.disabled)
 DCSP import ransac DCNL DCSP data = vstack((fp, tp)) DCNL DCSP (H, ransac_data) = ransac.ransac(data.T, model, 4, maxiter, match_theshold, 10, return_all=True) DCNL DCSP return (H, ransac_data['inliers'])
 DCSP string_len = len(string) DCNL DCSP if (string_len <= max_width): DCNL DCSP  DCSP return string DCNL DCSP visible = ((max_width - 16) - int(log10(string_len))) DCNL DCSP if (not isinstance(string, unistr)): DCNL DCSP  DCSP visstring = unistr(string[:visible], errors='ignore') DCNL DCSP else: DCNL DCSP  DCSP visstring = string[:visible] DCNL DCSP return u''.join((visstring, u'...(and DCSP ', unistr((string_len - visible)), u' DCSP more)'))
 DCSP me = MouseEvent('mouse_press') DCNL DCSP for fun in (me.pos, me.button, me.buttons, me.modifiers, me.delta, me.press_event, me.last_event, me.is_dragging): DCNL DCSP  DCSP fun DCNL DCSP me.drag_events() DCNL DCSP me._forget_last_event() DCNL DCSP me.trail() DCNL DCSP ke = KeyEvent('key_release') DCNL DCSP ke.key DCNL DCSP ke.text DCNL DCSP ke.modifiers
 DCSP init_subsystem(Native.Factory) DCNL DCSP return Native.Factory.global_instance().create()
 DCSP rsl = RSupervisedLearner(HALT_EXEC=HALT_EXEC) DCNL DCSP rsl.Parameters['-m'].on(response_fp) DCNL DCSP rsl.Parameters['-c'].on(response_name) DCNL DCSP rsl.Parameters['-n'].on(str(ntree)) DCNL DCSP rsl.Parameters['-o'].on(output_dir) DCNL DCSP rsl.Parameters['-e'].on(errortype) DCNL DCSP if verbose: DCNL DCSP  DCSP rsl.Parameters['-v'].on() DCNL DCSP app_result = rsl(predictor_fp) DCNL DCSP remove(join(output_dir, (splitext(split(predictor_fp)[1])[0] + '.txt'))) DCNL DCSP return app_result
 DCSP w = wcs.WCS(naxis=3) DCNL DCSP w.wcs.crval = [240.9303333333, 50, 212345678000.0] DCNL DCSP w.wcs.cdelt = [0.001, 0.001, 100000000.0] DCNL DCSP w.wcs.ctype = [u'RA---TAN', u'DEC--TAN', u'FREQ'] DCNL DCSP w.wcs.set() DCNL DCSP w2 = wcs.WCS(w.to_header()) DCNL DCSP w.wcs.compare(w2.wcs)
 DCSP cmd = browser.split()[0] DCNL DCSP if (not _iscommand(cmd)): DCNL DCSP  DCSP return [None, None] DCNL DCSP name = os.path.basename(cmd) DCNL DCSP try: DCNL DCSP  DCSP command = _browsers[name.lower()] DCNL DCSP except KeyError: DCNL DCSP  DCSP return [None, None] DCNL DCSP controller = command[1] DCNL DCSP if (controller and (name.lower() == controller.basename)): DCNL DCSP  DCSP import copy DCNL DCSP  DCSP controller = copy.copy(controller) DCNL DCSP  DCSP controller.name = browser DCNL DCSP  DCSP controller.basename = os.path.basename(browser) DCNL DCSP  DCSP register(browser, None, controller, update_tryorder) DCNL DCSP  DCSP return [None, controller] DCNL DCSP return [None, None]
 DCSP def _timeout(): DCNL DCSP  DCSP deferred.cancel() DCNL DCSP delayed_timeout = reactor.callLater(timeout_sec, _timeout) DCNL DCSP if (reason is not None): DCNL DCSP  DCSP def maybe_replace_reason(passthrough): DCNL DCSP  DCSP  DCSP if delayed_timeout.active(): DCNL DCSP  DCSP  DCSP  DCSP return passthrough DCNL DCSP  DCSP  DCSP return Failure(reason) DCNL DCSP  DCSP deferred.addErrback(maybe_replace_reason) DCNL DCSP def abort_timeout(passthrough): DCNL DCSP  DCSP if delayed_timeout.active(): DCNL DCSP  DCSP  DCSP delayed_timeout.cancel() DCNL DCSP  DCSP return passthrough DCNL DCSP deferred.addBoth(abort_timeout) DCNL DCSP return deferred
 DCSP row_data = [] DCNL DCSP for (field, cell) in zip(schema, row['f']): DCNL DCSP  DCSP converter = _CELLDATA_FROM_JSON[field.field_type] DCNL DCSP  DCSP if (field.mode == 'REPEATED'): DCNL DCSP  DCSP  DCSP row_data.append([converter(item['v'], field) for item in cell['v']]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP row_data.append(converter(cell['v'], field)) DCNL DCSP return tuple(row_data)
 DCSP if isinstance(cix, unicode): DCNL DCSP  DCSP cix = cix.encode('UTF-8', 'xmlcharrefreplace') DCNL DCSP tree = ET.XML(cix) DCNL DCSP version = tree.get('version') DCNL DCSP if (version == CIX_VERSION): DCNL DCSP  DCSP return tree DCNL DCSP elif (version == '0.1'): DCNL DCSP  DCSP return tree_2_0_from_tree_0_1(tree) DCNL DCSP else: DCNL DCSP  DCSP raise CodeIntelError(('unknown DCSP CIX DCSP version: DCSP %r' % version))
 DCSP if (status == BaseComment.OPEN): DCNL DCSP  DCSP return u'rb-icon-issue-open' DCNL DCSP elif (status == BaseComment.RESOLVED): DCNL DCSP  DCSP return u'rb-icon-issue-resolved' DCNL DCSP elif (status == BaseComment.DROPPED): DCNL DCSP  DCSP return u'rb-icon-issue-dropped' DCNL DCSP else: DCNL DCSP  DCSP raise ValueError((u'Unknown DCSP comment DCSP issue DCSP status DCSP "%s"' % status))
 DCSP floatX = theano.config.floatX DCNL DCSP rng = numpy.random.RandomState(1234) DCNL DCSP readout_dim = 5 DCNL DCSP feedback_dim = 3 DCNL DCSP dim = 20 DCNL DCSP batch_size = 30 DCNL DCSP n_steps = 10 DCNL DCSP transition = GatedRecurrent(dim=dim, activation=Tanh(), weights_init=Orthogonal()) DCNL DCSP generator = SequenceGenerator(Readout(readout_dim=readout_dim, source_names=['states'], emitter=SoftmaxEmitter(theano_seed=1234), feedback_brick=LookupFeedback(readout_dim, feedback_dim)), transition, weights_init=IsotropicGaussian(0.1), biases_init=Constant(0), seed=1234) DCNL DCSP generator.initialize() DCNL DCSP y = tensor.lmatrix('y') DCNL DCSP mask = tensor.matrix('mask') DCNL DCSP costs = generator.cost_matrix(y, mask) DCNL DCSP assert (costs.ndim == 2) DCNL DCSP costs_fun = theano.function([y, mask], [costs]) DCNL DCSP y_test = rng.randint(readout_dim, size=(n_steps, batch_size)) DCNL DCSP m_test = numpy.ones((n_steps, batch_size), dtype=floatX) DCNL DCSP costs_val = costs_fun(y_test, m_test)[0] DCNL DCSP assert (costs_val.shape == (n_steps, batch_size)) DCNL DCSP assert_allclose(costs_val.sum(), 482.827, rtol=1e-05) DCNL DCSP cost = generator.cost(y, mask) DCNL DCSP assert (cost.ndim == 0) DCNL DCSP cost_val = theano.function([y, mask], [cost])(y_test, m_test) DCNL DCSP assert_allclose(cost_val, 16.0942, rtol=1e-05) DCNL DCSP cg = ComputationGraph([cost]) DCNL DCSP var_filter = VariableFilter(roles=[AUXILIARY]) DCNL DCSP aux_var_name = '_'.join([generator.name, generator.cost.name, 'per_sequence_element']) DCNL DCSP cost_per_el = [el for el in var_filter(cg.variables) if (el.name == aux_var_name)][0] DCNL DCSP assert (cost_per_el.ndim == 0) DCNL DCSP cost_per_el_val = theano.function([y, mask], [cost_per_el])(y_test, m_test) DCNL DCSP assert_allclose(cost_per_el_val, 1.60942, rtol=1e-05) DCNL DCSP (states, outputs, costs) = generator.generate(iterate=True, batch_size=batch_size, n_steps=n_steps) DCNL DCSP cg = ComputationGraph(((states + outputs) + costs)) DCNL DCSP (states_val, outputs_val, costs_val) = theano.function([], [states, outputs, costs], updates=cg.updates)() DCNL DCSP assert (states_val.shape == (n_steps, batch_size, dim)) DCNL DCSP assert (outputs_val.shape == (n_steps, batch_size)) DCNL DCSP assert (outputs_val.dtype == 'int64') DCNL DCSP assert (costs_val.shape == (n_steps, batch_size)) DCNL DCSP assert_allclose(states_val.sum(), (-17.854), rtol=1e-05) DCNL DCSP assert_allclose(costs_val.sum(), 482.868, rtol=1e-05) DCNL DCSP assert (outputs_val.sum() == 629) DCNL DCSP cost1 = costs_fun([[1], [2]], [[1], [1]])[0] DCNL DCSP cost2 = costs_fun([[3, 1], [4, 2], [2, 0]], [[1, 1], [1, 1], [1, 0]])[0] DCNL DCSP assert_allclose(cost1.sum(), cost2[:, 1].sum(), rtol=1e-05)
 DCSP if (content.endswith(trailing) and (content != trailing)): DCNL DCSP  DCSP return content[:(- len(trailing))] DCNL DCSP return content
 DCSP state = twill.get_browser() DCNL DCSP form = state.get_form('1') DCNL DCSP if (not form): DCNL DCSP  DCSP print 'No DCSP messages; DCSP exiting.' DCNL DCSP  DCSP raise SystemExit
 DCSP return [o for o in gc.get_objects() if (name_filter == typename(o))]
 DCSP if (low < xmin): DCNL DCSP  DCSP low = xmin DCNL DCSP xs = np.linspace(low, high, n) DCNL DCSP ps = (1 - ((xs / xmin) ** (- alpha))) DCNL DCSP return (xs, ps)
 DCSP if (not HAS_APT): DCNL DCSP  DCSP raise CommandExecutionError("Error: DCSP 'python-apt' DCSP package DCSP not DCSP installed")
 DCSP non_local['loaders'] = [] DCNL DCSP for filename in z.namelist(): DCNL DCSP  DCSP if (not isinstance(filename, str_cls)): DCNL DCSP  DCSP  DCSP filename = filename.decode('utf-8') DCNL DCSP  DCSP non_local['loaders'].append(filename)
 DCSP return [id_to_word[i] for i in data]
 DCSP TINY = np.sqrt(np.finfo(float).eps) DCNL DCSP arrays = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP a = np.asarray(arg) DCNL DCSP  DCSP n = len(a) DCNL DCSP  DCSP mu = np.mean(a) DCNL DCSP  DCSP sq = ((a - mu) ** 2) DCNL DCSP  DCSP sumsq = sq.sum() DCNL DCSP  DCSP t = (((((n - 1.5) * n) * sq) - (0.5 * sumsq)) / ((n - 1) * (n - 2))) DCNL DCSP  DCSP var = (sumsq / (n - 1)) DCNL DCSP  DCSP if (abs((var - np.mean(t))) > TINY): DCNL DCSP  DCSP  DCSP raise ValueError('Lack DCSP of DCSP convergence DCSP in DCSP obrientransform.') DCNL DCSP  DCSP arrays.append(t) DCNL DCSP return np.array(arrays)
 DCSP target_dir = (script.scratch_path / 'target') DCNL DCSP result = script.pip_install_local('-t', target_dir, 'simple==1.0') DCNL DCSP assert (((Path('scratch') / 'target') / 'simple') in result.files_created), str(result) DCNL DCSP result = script.pip_install_local('-t', target_dir, 'simple==1.0', expect_stderr=True) DCNL DCSP assert (not (((Path('scratch') / 'target') / 'simple') in result.files_updated)) DCNL DCSP result = script.pip_install_local('--upgrade', '-t', target_dir, 'simple==2.0') DCNL DCSP assert (((Path('scratch') / 'target') / 'simple') in result.files_updated), str(result) DCNL DCSP egg_folder = (((Path('scratch') / 'target') / 'simple-2.0-py%s.egg-info') % pyversion) DCNL DCSP assert (egg_folder in result.files_created), str(result) DCNL DCSP result = script.pip_install_local('-t', target_dir, 'singlemodule==0.0.0') DCNL DCSP singlemodule_py = ((Path('scratch') / 'target') / 'singlemodule.py') DCNL DCSP assert (singlemodule_py in result.files_created), str(result) DCNL DCSP result = script.pip_install_local('-t', target_dir, 'singlemodule==0.0.1', '--upgrade') DCNL DCSP assert (singlemodule_py in result.files_updated), str(result)
 DCSP if (var == x): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(x, Compound): DCNL DCSP  DCSP return occur_check(var, x.args) DCNL DCSP elif is_args(x): DCNL DCSP  DCSP if any((occur_check(var, xi) for xi in x)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (source not in G): DCNL DCSP  DCSP raise nx.NodeNotFound('Source DCSP {} DCSP not DCSP in DCSP G'.format(source)) DCNL DCSP level = 0 DCNL DCSP nextlevel = [source] DCNL DCSP seen = {source: level} DCNL DCSP pred = {source: []} DCNL DCSP while nextlevel: DCNL DCSP  DCSP level = (level + 1) DCNL DCSP  DCSP thislevel = nextlevel DCNL DCSP  DCSP nextlevel = [] DCNL DCSP  DCSP for v in thislevel: DCNL DCSP  DCSP  DCSP for w in G[v]: DCNL DCSP  DCSP  DCSP  DCSP if (w not in seen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pred[w] = [v] DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen[w] = level DCNL DCSP  DCSP  DCSP  DCSP  DCSP nextlevel.append(w) DCNL DCSP  DCSP  DCSP  DCSP elif (seen[w] == level): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pred[w].append(v) DCNL DCSP  DCSP if (cutoff and (cutoff <= level)): DCNL DCSP  DCSP  DCSP break DCNL DCSP if (target is not None): DCNL DCSP  DCSP if return_seen: DCNL DCSP  DCSP  DCSP if (not (target in pred)): DCNL DCSP  DCSP  DCSP  DCSP return ([], (-1)) DCNL DCSP  DCSP  DCSP return (pred[target], seen[target]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not (target in pred)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP return pred[target] DCNL DCSP elif return_seen: DCNL DCSP  DCSP return (pred, seen) DCNL DCSP else: DCNL DCSP  DCSP return pred
 DCSP try: DCNL DCSP  DCSP if six.PY2: DCNL DCSP  DCSP  DCSP raw_key = public_key.decode('base64') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raw_key = base64.b64decode(public_key, validate=True) DCNL DCSP except binascii.Error: DCNL DCSP  DCSP return None DCNL DCSP ret = hashlib.md5(raw_key).hexdigest() DCNL DCSP chunks = [ret[i:(i + 2)] for i in range(0, len(ret), 2)] DCNL DCSP return ':'.join(chunks)
 DCSP if ('^' == response[0]): DCNL DCSP  DCSP body = [] DCNL DCSP elif ('running' in command): DCNL DCSP  DCSP body = response DCNL DCSP else: DCNL DCSP  DCSP if (command in response[0]): DCNL DCSP  DCSP  DCSP response = [response[0].split(command)[1]] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP body = [json.loads(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP module.fail_json(msg='Command DCSP does DCSP not DCSP support DCSP JSON DCSP output', command=command) DCNL DCSP return body
 DCSP return _osquery_cmd(table='hash', attrs=attrs, where=where)
 DCSP data = _get_data() DCNL DCSP return du.process_recarray(data, endog_idx=0, dtype=float)
 DCSP if isinstance(s, unicode): DCNL DCSP  DCSP s = s.encode(charset) DCNL DCSP return _decode_unicode(_unquote_plus(s), charset, errors)
 DCSP def perform(): DCNL DCSP  DCSP if (not worker._pending): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (worker._pending[0] is NoMoreWork): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP worker._pending.pop(0)() DCNL DCSP  DCSP return True DCNL DCSP worker = MemoryWorker() DCNL DCSP return (worker, perform)
 DCSP my_node_id = list(client.nodes.info('_local')['nodes'])[0] DCNL DCSP master_node_id = client.cluster.state(metric='master_node')['master_node'] DCNL DCSP return (my_node_id == master_node_id)
 DCSP global _config_vars DCNL DCSP if (_config_vars is None): DCNL DCSP  DCSP func = globals().get(('_init_' + os.name)) DCNL DCSP  DCSP if func: DCNL DCSP  DCSP  DCSP func() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _config_vars = {} DCNL DCSP  DCSP _config_vars['prefix'] = PREFIX DCNL DCSP  DCSP _config_vars['exec_prefix'] = EXEC_PREFIX DCNL DCSP  DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP  DCSP import _osx_support DCNL DCSP  DCSP  DCSP _osx_support.customize_config_vars(_config_vars) DCNL DCSP if args: DCNL DCSP  DCSP vals = [] DCNL DCSP  DCSP for name in args: DCNL DCSP  DCSP  DCSP vals.append(_config_vars.get(name)) DCNL DCSP  DCSP return vals DCNL DCSP else: DCNL DCSP  DCSP return _config_vars
 DCSP try: DCNL DCSP  DCSP todo = frappe.db.get_value(u'ToDo', {u'reference_type': doctype, u'reference_name': name, u'owner': assign_to, u'status': u'Open'}) DCNL DCSP  DCSP if todo: DCNL DCSP  DCSP  DCSP todo = frappe.get_doc(u'ToDo', todo) DCNL DCSP  DCSP  DCSP todo.status = u'Closed' DCNL DCSP  DCSP  DCSP todo.save(ignore_permissions=True) DCNL DCSP  DCSP  DCSP notify_assignment(todo.assigned_by, todo.owner, todo.reference_type, todo.reference_name) DCNL DCSP except frappe.DoesNotExistError: DCNL DCSP  DCSP pass DCNL DCSP if frappe.get_meta(doctype).get_field(u'assigned_to'): DCNL DCSP  DCSP frappe.db.set_value(doctype, name, u'assigned_to', None) DCNL DCSP return get({u'doctype': doctype, u'name': name})
 DCSP pscmd = [] DCNL DCSP current_apppools = list_apppools() DCNL DCSP apppool_path = 'IIS:\\AppPools\\{0}'.format(name) DCNL DCSP if (name in current_apppools): DCNL DCSP  DCSP _LOG.debug("Application DCSP pool DCSP '%s' DCSP already DCSP present.", name) DCNL DCSP  DCSP return True DCNL DCSP pscmd.append("New-Item DCSP -Path DCSP '{0}'".format(apppool_path)) DCNL DCSP cmd_ret = _srvmgr(str().join(pscmd)) DCNL DCSP if (cmd_ret['retcode'] == 0): DCNL DCSP  DCSP _LOG.debug('Application DCSP pool DCSP created DCSP successfully: DCSP %s', name) DCNL DCSP  DCSP return True DCNL DCSP _LOG.error('Unable DCSP to DCSP create DCSP application DCSP pool: DCSP %s', name) DCNL DCSP return False
 DCSP _emit_deprecation_warning('baremetal-node-list') DCNL DCSP nodes = cs.baremetal.list() DCNL DCSP _print_baremetal_nodes_list(nodes)
 DCSP options = {'xatol': xtol, 'maxiter': maxfun, 'disp': disp} DCNL DCSP res = _minimize_scalar_bounded(func, (x1, x2), args, **options) DCNL DCSP if full_output: DCNL DCSP  DCSP return (res['x'], res['fun'], res['status'], res['nfev']) DCNL DCSP else: DCNL DCSP  DCSP return res['x']
 DCSP result = getattr(instance, primary_key_for(instance)) DCNL DCSP if (not as_string): DCNL DCSP  DCSP return result DCNL DCSP try: DCNL DCSP  DCSP return str(result) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP return url_quote_plus(result.encode('utf-8'))
 DCSP expr = _literal_as_binds(expr) DCNL DCSP return expr.between(lower_bound, upper_bound)
 DCSP import ctypes DCNL DCSP from ctypes import wintypes, windll DCNL DCSP CSIDL_COMMON_APPDATA = 35 DCNL DCSP _SHGetFolderPath = windll.shell32.SHGetFolderPathW DCNL DCSP _SHGetFolderPath.argtypes = [wintypes.HWND, ctypes.c_int, wintypes.HANDLE, wintypes.DWORD, wintypes.LPCWSTR] DCNL DCSP path_buf = wintypes.create_unicode_buffer(wintypes.MAX_PATH) DCNL DCSP _SHGetFolderPath(0, CSIDL_COMMON_APPDATA, 0, 0, path_buf) DCNL DCSP return path_buf.value
 DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP return conn.get_all_launch_configurations() DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.error(e) DCNL DCSP  DCSP return []
 DCSP with tmpdir.as_cwd(): DCNL DCSP  DCSP tmpdir.join('config.yaml').write(mocked_aws_cf_simple) DCNL DCSP  DCSP assert (main(['create']) == 0) DCNL DCSP  DCSP assert (main(['create']) == 1)
 DCSP steps = StepDict() DCNL DCSP test_load = (lambda : steps.load('an DCSP invalid DCSP regex;)', (lambda : ''))) DCNL DCSP assert_raises(StepLoadingError, test_load)
 DCSP if (__grains__['os_family'] == 'RedHat'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/sysconfig/ip6tables' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/sysconfig/iptables' DCNL DCSP elif (__grains__['os_family'] == 'Arch'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/iptables/ip6tables.rules' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/iptables/iptables.rules' DCNL DCSP elif (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/iptables/rules.v6' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/iptables/rules.v4' DCNL DCSP elif (__grains__['os'] == 'Gentoo'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/var/lib/ip6tables/rules-save' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/var/lib/iptables/rules-save' DCNL DCSP elif (__grains__['os_family'] == 'SUSE'): DCNL DCSP  DCSP return '/etc/sysconfig/scripts/SuSEfirewall2-custom' DCNL DCSP else: DCNL DCSP  DCSP raise SaltException((('Saving DCSP iptables DCSP to DCSP file DCSP is DCSP not' + ' DCSP supported DCSP on DCSP {0}.'.format(__grains__['os'])) + ' DCSP Please DCSP file DCSP an DCSP issue DCSP with DCSP SaltStack'))
 DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP return ParametricRectifierLayer(layer, **kwargs)
 DCSP test_once = kwargs.get('test_once', False) DCNL DCSP for arg in args: DCNL DCSP  DCSP templates.update(arg) DCNL DCSP templates['inclusion.html'] = '{{ DCSP result DCSP }}' DCNL DCSP loaders = [('django.template.loaders.cached.Loader', [('django.template.loaders.locmem.Loader', templates)])] DCNL DCSP def decorator(func): DCNL DCSP  DCSP @override_settings(TEMPLATES=None) DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def inner(self): DCNL DCSP  DCSP  DCSP libraries = getattr(self, 'libraries', {}) DCNL DCSP  DCSP  DCSP self.engine = Engine(libraries=libraries, loaders=loaders) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP if test_once: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP self.engine = Engine(libraries=libraries, loaders=loaders, string_if_invalid='INVALID') DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP self.engine = Engine(debug=True, libraries=libraries, loaders=loaders) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP return inner DCNL DCSP return decorator
 DCSP if options['basedirlist']: DCNL DCSP  DCSP return options['basedirlist'] DCNL DCSP if os.environ.get('MPLBASEDIRLIST'): DCNL DCSP  DCSP return os.environ.get('MPLBASEDIRLIST').split(os.pathsep) DCNL DCSP win_bases = ['win32_static'] DCNL DCSP if os.getenv('CONDA_DEFAULT_ENV'): DCNL DCSP  DCSP win_bases.append(os.path.join(os.getenv('CONDA_DEFAULT_ENV'), 'Library')) DCNL DCSP basedir_map = {'win32': win_bases, 'darwin': ['/usr/local/', '/usr', '/usr/X11', '/opt/X11', '/opt/local'], 'sunos5': [(os.getenv('MPLIB_BASE') or '/usr/local')], 'gnu0': ['/usr'], 'aix5': ['/usr/local']} DCNL DCSP return basedir_map.get(sys.platform, ['/usr/local', '/usr'])
 DCSP p = ((50 - (which / 2)), (50 + (which / 2))) DCNL DCSP return percentiles(a, p, axis)
 DCSP valid_pairings = ['nearest', 'keep_odd'] DCNL DCSP if (pairing not in valid_pairings): DCNL DCSP  DCSP raise ValueError(('pairing DCSP must DCSP be DCSP one DCSP of DCSP %s, DCSP not DCSP %s' % (valid_pairings, pairing))) DCNL DCSP if (len(z) == len(p) == 0): DCNL DCSP  DCSP return array([[k, 0.0, 0.0, 1.0, 0.0, 0.0]]) DCNL DCSP p = np.concatenate((p, np.zeros(max((len(z) - len(p)), 0)))) DCNL DCSP z = np.concatenate((z, np.zeros(max((len(p) - len(z)), 0)))) DCNL DCSP n_sections = ((max(len(p), len(z)) + 1) // 2) DCNL DCSP sos = zeros((n_sections, 6)) DCNL DCSP if (((len(p) % 2) == 1) and (pairing == 'nearest')): DCNL DCSP  DCSP p = np.concatenate((p, [0.0])) DCNL DCSP  DCSP z = np.concatenate((z, [0.0])) DCNL DCSP assert (len(p) == len(z)) DCNL DCSP z = np.concatenate(_cplxreal(z)) DCNL DCSP p = np.concatenate(_cplxreal(p)) DCNL DCSP p_sos = np.zeros((n_sections, 2), np.complex128) DCNL DCSP z_sos = np.zeros_like(p_sos) DCNL DCSP for si in range(n_sections): DCNL DCSP  DCSP p1_idx = np.argmin(np.abs((1 - np.abs(p)))) DCNL DCSP  DCSP p1 = p[p1_idx] DCNL DCSP  DCSP p = np.delete(p, p1_idx) DCNL DCSP  DCSP if (np.isreal(p1) and (np.isreal(p).sum() == 0)): DCNL DCSP  DCSP  DCSP z1_idx = _nearest_real_complex_idx(z, p1, 'real') DCNL DCSP  DCSP  DCSP z1 = z[z1_idx] DCNL DCSP  DCSP  DCSP z = np.delete(z, z1_idx) DCNL DCSP  DCSP  DCSP p2 = z2 = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((not np.isreal(p1)) and (np.isreal(z).sum() == 1)): DCNL DCSP  DCSP  DCSP  DCSP z1_idx = _nearest_real_complex_idx(z, p1, 'complex') DCNL DCSP  DCSP  DCSP  DCSP assert (not np.isreal(z[z1_idx])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP z1_idx = np.argmin(np.abs((p1 - z))) DCNL DCSP  DCSP  DCSP z1 = z[z1_idx] DCNL DCSP  DCSP  DCSP z = np.delete(z, z1_idx) DCNL DCSP  DCSP  DCSP if (not np.isreal(p1)): DCNL DCSP  DCSP  DCSP  DCSP if (not np.isreal(z1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z1.conj() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2_idx = _nearest_real_complex_idx(z, p1, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z[z2_idx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(z2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z = np.delete(z, z2_idx) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (not np.isreal(z1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2_idx = _nearest_real_complex_idx(p, z1, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p[p2_idx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(p2) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP idx = np.where(np.isreal(p))[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (len(idx) > 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2_idx = idx[np.argmin(np.abs((np.abs(p[idx]) - 1)))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p[p2_idx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(p2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2_idx = _nearest_real_complex_idx(z, p2, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z[z2_idx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(z2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z = np.delete(z, z2_idx) DCNL DCSP  DCSP  DCSP  DCSP p = np.delete(p, p2_idx) DCNL DCSP  DCSP p_sos[si] = [p1, p2] DCNL DCSP  DCSP z_sos[si] = [z1, z2] DCNL DCSP assert (len(p) == len(z) == 0) DCNL DCSP del p, z DCNL DCSP p_sos = np.reshape(p_sos[::(-1)], (n_sections, 2)) DCNL DCSP z_sos = np.reshape(z_sos[::(-1)], (n_sections, 2)) DCNL DCSP gains = np.ones(n_sections) DCNL DCSP gains[0] = k DCNL DCSP for si in range(n_sections): DCNL DCSP  DCSP x = zpk2tf(z_sos[si], p_sos[si], gains[si]) DCNL DCSP  DCSP sos[si] = np.concatenate(x) DCNL DCSP return sos
 DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.to('/') DCNL DCSP assert ('302' in redirect.value.status)
 DCSP jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__['hash_type']) DCNL DCSP load_fn = os.path.join(jid_dir, LOAD_P) DCNL DCSP if ((not os.path.exists(jid_dir)) or (not os.path.exists(load_fn))): DCNL DCSP  DCSP return {} DCNL DCSP serial = salt.payload.Serial(__opts__) DCNL DCSP ret = serial.load(salt.utils.fopen(os.path.join(jid_dir, LOAD_P), 'rb')) DCNL DCSP minions_cache = [os.path.join(jid_dir, MINIONS_P)] DCNL DCSP minions_cache.extend(glob.glob(os.path.join(jid_dir, SYNDIC_MINIONS_P.format('*')))) DCNL DCSP all_minions = set() DCNL DCSP for minions_path in minions_cache: DCNL DCSP  DCSP log.debug('Reading DCSP minion DCSP list DCSP from DCSP %s', minions_path) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP all_minions.update(serial.load(salt.utils.fopen(minions_path, 'rb'))) DCNL DCSP  DCSP except IOError as exc: DCNL DCSP  DCSP  DCSP salt.utils.files.process_read_exception(exc, minions_path) DCNL DCSP if all_minions: DCNL DCSP  DCSP ret['Minions'] = sorted(all_minions) DCNL DCSP return ret
 DCSP scenario_collector = FeatureScenarioLocationCollector() DCNL DCSP features = [] DCNL DCSP for location in feature_files: DCNL DCSP  DCSP if (not isinstance(location, FileLocation)): DCNL DCSP  DCSP  DCSP assert isinstance(location, string_types) DCNL DCSP  DCSP  DCSP location = FileLocation(os.path.normpath(location)) DCNL DCSP  DCSP if (location.filename == scenario_collector.filename): DCNL DCSP  DCSP  DCSP scenario_collector.add_location(location) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif scenario_collector.feature: DCNL DCSP  DCSP  DCSP current_feature = scenario_collector.build_feature() DCNL DCSP  DCSP  DCSP features.append(current_feature) DCNL DCSP  DCSP  DCSP scenario_collector.clear() DCNL DCSP  DCSP assert isinstance(location, FileLocation) DCNL DCSP  DCSP filename = os.path.abspath(location.filename) DCNL DCSP  DCSP feature = parser.parse_file(filename, language=language) DCNL DCSP  DCSP if feature: DCNL DCSP  DCSP  DCSP scenario_collector.feature = feature DCNL DCSP  DCSP  DCSP scenario_collector.add_location(location) DCNL DCSP if scenario_collector.feature: DCNL DCSP  DCSP current_feature = scenario_collector.build_feature() DCNL DCSP  DCSP features.append(current_feature) DCNL DCSP return features
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
 DCSP course_key = CourseLocator.from_string(course_key) DCNL DCSP for ccx in CustomCourseForEdX.objects.filter(course_id=course_key): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ccx_key = CCXLocator.from_course_locator(course_key, unicode(ccx.id)) DCNL DCSP  DCSP except InvalidKeyError: DCNL DCSP  DCSP  DCSP log.info('Attempt DCSP to DCSP publish DCSP course DCSP with DCSP deprecated DCSP id. DCSP Course: DCSP %s. DCSP CCX: DCSP %s', course_key, ccx.id) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP responses = SignalHandler.course_published.send(sender=ccx, course_key=ccx_key) DCNL DCSP  DCSP for (rec, response) in responses: DCNL DCSP  DCSP  DCSP log.info('Signal DCSP fired DCSP when DCSP course DCSP is DCSP published. DCSP Receiver: DCSP %s. DCSP Response: DCSP %s', rec, response)
 DCSP return InverseHankelTransform(F, k, r, nu).doit(**hints)
 DCSP try: DCNL DCSP  DCSP iter(obj) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP a_sum = a.sum(axis) DCNL DCSP if (axis and (a.ndim > 1)): DCNL DCSP  DCSP a_sum[(a_sum == 0)] = 1 DCNL DCSP  DCSP shape = list(a.shape) DCNL DCSP  DCSP shape[axis] = 1 DCNL DCSP  DCSP a_sum.shape = shape DCNL DCSP a /= a_sum
 DCSP description = ['adjacencylist', 'Krackhardt DCSP Kite DCSP Social DCSP Network', 10, [[2, 3, 4, 6], [1, 4, 5, 7], [1, 4, 6], [1, 2, 3, 5, 6, 7], [2, 4, 7], [1, 3, 4, 7, 8], [2, 4, 5, 6, 8], [6, 7, 9], [8, 10], [9]]] DCNL DCSP G = make_small_undirected_graph(description, create_using) DCNL DCSP return G
 DCSP serv = _get_serv(ret=None) DCNL DCSP if ('influxdb08' in serv.__module__): DCNL DCSP  DCSP req = [{'name': 'jids', 'columns': ['jid', 'load'], 'points': [[jid, json.dumps(load)]]}] DCNL DCSP else: DCNL DCSP  DCSP req = [{'measurement': 'jids', 'tags': {'jid': jid}, 'fields': {'load': json.dumps(load)}}] DCNL DCSP try: DCNL DCSP  DCSP serv.write_points(req) DCNL DCSP except Exception as ex: DCNL DCSP  DCSP log.critical('Failed DCSP to DCSP store DCSP load DCSP with DCSP InfluxDB DCSP returner: DCSP {0}'.format(ex))
 DCSP euid = os.geteuid() DCNL DCSP if (str(user_id_or_name) == str(euid)): DCNL DCSP  DCSP return True DCNL DCSP effective_user_name = pwd.getpwuid(euid).pw_name DCNL DCSP return (user_id_or_name == effective_user_name)
 DCSP if (s in wordmap): DCNL DCSP  DCSP return s DCNL DCSP else: DCNL DCSP  DCSP possibilities = [word for word in wordmap.keys() if word.startswith(s)] DCNL DCSP  DCSP if (len(possibilities) == 1): DCNL DCSP  DCSP  DCSP return possibilities[0] DCNL DCSP  DCSP elif (not possibilities): DCNL DCSP  DCSP  DCSP raise BadOptionError(s) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP possibilities.sort() DCNL DCSP  DCSP  DCSP raise AmbiguousOptionError(s, possibilities)
 DCSP if (key_func is not None): DCNL DCSP  DCSP if callable(key_func): DCNL DCSP  DCSP  DCSP return key_func DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (key_func_module_path, key_func_name) = key_func.rsplit(u'.', 1) DCNL DCSP  DCSP  DCSP key_func_module = import_module(key_func_module_path) DCNL DCSP  DCSP  DCSP return getattr(key_func_module, key_func_name) DCNL DCSP return default_key_func
 DCSP default = {'weight': 0.0, 'count': 0} DCNL DCSP count_src = graph[src].get(n, default)['count'] DCNL DCSP count_dst = graph[dst].get(n, default)['count'] DCNL DCSP weight_src = graph[src].get(n, default)['weight'] DCNL DCSP weight_dst = graph[dst].get(n, default)['weight'] DCNL DCSP count = (count_src + count_dst) DCNL DCSP return {'count': count, 'weight': (((count_src * weight_src) + (count_dst * weight_dst)) / count)}
 DCSP if _use_unicode: DCNL DCSP  DCSP return unicode(*args) DCNL DCSP else: DCNL DCSP  DCSP return str(*args)
 DCSP ver = container.opf_version_parsed DCNL DCSP if move_to_start: DCNL DCSP  DCSP for (item, q, linear) in container.spine_iter: DCNL DCSP  DCSP  DCSP if (name == q): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not linear): DCNL DCSP  DCSP  DCSP item.set(u'linear', u'yes') DCNL DCSP  DCSP if (item.getparent().index(item) > 0): DCNL DCSP  DCSP  DCSP container.insert_into_xml(item.getparent(), item, 0) DCNL DCSP if (ver.major < 3): DCNL DCSP  DCSP for ref in container.opf_xpath(u'//opf:guide/opf:reference[@type="cover"]'): DCNL DCSP  DCSP  DCSP ref.getparent().remove(ref) DCNL DCSP  DCSP for guide in get_guides(container): DCNL DCSP  DCSP  DCSP container.insert_into_xml(guide, guide.makeelement(OPF(u'reference'), type=u'cover', href=container.name_to_href(name, container.opf_name))) DCNL DCSP else: DCNL DCSP  DCSP container.apply_unique_properties(name, u'calibre:title-page') DCNL DCSP container.dirty(container.opf_name)
 DCSP sys.settrace(Spew(trace_names, show_values))
 DCSP return BatchDet()(a)
 DCSP d = dict(user=request.user, **kwargs) DCNL DCSP d.update(csrf(request)) DCNL DCSP return RequestContext(request, d)
 DCSP start = (start or 0) DCNL DCSP end = ((end or total) - 1) DCNL DCSP return ('bytes DCSP %s-%s/%s' % (start, end, total))
 DCSP assert css_file.endswith('.css') DCNL DCSP new_css = css_file DCNL DCSP app_globals.main_css = str(new_css)
 DCSP for point in loop: DCNL DCSP  DCSP if (point in pointTable): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP for k in range((u['nterms'] - 1)): DCNL DCSP  DCSP k1 = (k + 1) DCNL DCSP  DCSP mu1n = np.power(mu[0], k1) DCNL DCSP  DCSP u['y'][k] = (u['w'][k] * (u['fn'][k1] - (mu1n * u['fn'][0]))) DCNL DCSP  DCSP for p in range((u['nfit'] - 1)): DCNL DCSP  DCSP  DCSP u['M'][k][p] = (u['w'][k] * (np.power(mu[(p + 1)], k1) - mu1n))
 DCSP tempdir = _TempDir() DCNL DCSP ave = read_evokeds(fname, 0) DCNL DCSP write_evokeds(op.join(tempdir, 'evoked-ave.fif'), ave) DCNL DCSP ave2 = read_evokeds(op.join(tempdir, 'evoked-ave.fif'))[0] DCNL DCSP assert_true(np.allclose(ave.data, ave2.data, atol=1e-16, rtol=0.001)) DCNL DCSP assert_array_almost_equal(ave.times, ave2.times) DCNL DCSP assert_equal(ave.nave, ave2.nave) DCNL DCSP assert_equal(ave._aspect_kind, ave2._aspect_kind) DCNL DCSP assert_equal(ave.kind, ave2.kind) DCNL DCSP assert_equal(ave.last, ave2.last) DCNL DCSP assert_equal(ave.first, ave2.first) DCNL DCSP assert_true(repr(ave)) DCNL DCSP ave2 = read_evokeds(fname_gz, 0) DCNL DCSP assert_true(np.allclose(ave.data, ave2.data, atol=1e-16, rtol=1e-08)) DCNL DCSP condition = 'Left DCSP Auditory' DCNL DCSP assert_raises(ValueError, read_evokeds, fname, condition, kind='stderr') DCNL DCSP assert_raises(ValueError, read_evokeds, fname, condition, kind='standard_error') DCNL DCSP ave3 = read_evokeds(fname, condition) DCNL DCSP assert_array_almost_equal(ave.data, ave3.data, 19) DCNL DCSP aves1 = read_evokeds(fname)[1::2] DCNL DCSP aves2 = read_evokeds(fname, [1, 3]) DCNL DCSP aves3 = read_evokeds(fname, ['Right DCSP Auditory', 'Right DCSP visual']) DCNL DCSP write_evokeds(op.join(tempdir, 'evoked-ave.fif'), aves1) DCNL DCSP aves4 = read_evokeds(op.join(tempdir, 'evoked-ave.fif')) DCNL DCSP for aves in [aves2, aves3, aves4]: DCNL DCSP  DCSP for [av1, av2] in zip(aves1, aves): DCNL DCSP  DCSP  DCSP assert_array_almost_equal(av1.data, av2.data) DCNL DCSP  DCSP  DCSP assert_array_almost_equal(av1.times, av2.times) DCNL DCSP  DCSP  DCSP assert_equal(av1.nave, av2.nave) DCNL DCSP  DCSP  DCSP assert_equal(av1.kind, av2.kind) DCNL DCSP  DCSP  DCSP assert_equal(av1._aspect_kind, av2._aspect_kind) DCNL DCSP  DCSP  DCSP assert_equal(av1.last, av2.last) DCNL DCSP  DCSP  DCSP assert_equal(av1.first, av2.first) DCNL DCSP  DCSP  DCSP assert_equal(av1.comment, av2.comment) DCNL DCSP fname2 = op.join(tempdir, 'test-bad-name.fif') DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP warnings.simplefilter('always') DCNL DCSP  DCSP write_evokeds(fname2, ave) DCNL DCSP  DCSP read_evokeds(fname2) DCNL DCSP assert_naming(w, 'test_evoked.py', 2) DCNL DCSP assert_raises(TypeError, Evoked, fname) DCNL DCSP fname_ms = op.join(tempdir, 'test-ave.fif') DCNL DCSP assert_true((ave.info['maxshield'] is False)) DCNL DCSP ave.info['maxshield'] = True DCNL DCSP ave.save(fname_ms) DCNL DCSP assert_raises(ValueError, read_evokeds, fname_ms) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP aves = read_evokeds(fname_ms, allow_maxshield=True) DCNL DCSP assert_true(all((('Elekta' in str(ww.message)) for ww in w))) DCNL DCSP assert_true(all(((ave.info['maxshield'] is True) for ave in aves))) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP aves = read_evokeds(fname_ms, allow_maxshield='yes') DCNL DCSP assert_equal(len(w), 0) DCNL DCSP assert_true(all(((ave.info['maxshield'] is True) for ave in aves)))
 DCSP beam = beam_area.to(si.sr).value DCNL DCSP nu = disp.to(si.GHz, spectral()) DCNL DCSP def convert_Jy_to_K(x_jybm): DCNL DCSP  DCSP factor = ((((2 * _si.k_B) * si.K) * (nu ** 2)) / (_si.c ** 2)).to(astrophys.Jy).value DCNL DCSP  DCSP return ((x_jybm / beam) / factor) DCNL DCSP def convert_K_to_Jy(x_K): DCNL DCSP  DCSP factor = (astrophys.Jy / (((2 * _si.k_B) * (nu ** 2)) / (_si.c ** 2))).to(si.K).value DCNL DCSP  DCSP return ((x_K * beam) / factor) DCNL DCSP return [(astrophys.Jy, si.K, convert_Jy_to_K, convert_K_to_Jy)]
 DCSP dt = connection.introspection.get_field_type(dbtype, description) DCNL DCSP if (type(dt) is tuple): DCNL DCSP  DCSP return dt[0] DCNL DCSP else: DCNL DCSP  DCSP return dt
 DCSP yaml_content = None DCNL DCSP assets_list = [] DCNL DCSP dir_path_array = dir_path.split('/') DCNL DCSP while (dir_path_array[(-1)] == ''): DCNL DCSP  DCSP dir_path_array = dir_path_array[:(-1)] DCNL DCSP dir_path_length = len(dir_path_array) DCNL DCSP for (root, dirs, files) in os.walk(dir_path): DCNL DCSP  DCSP for directory in dirs: DCNL DCSP  DCSP  DCSP if ((root == dir_path) and (directory != 'assets')): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('The DCSP only DCSP directory DCSP in DCSP %s DCSP should DCSP be DCSP assets/' % dir_path)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP filepath = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP if (root == dir_path): DCNL DCSP  DCSP  DCSP  DCSP if filepath.endswith('.DS_Store'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (yaml_content is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('More DCSP than DCSP one DCSP non-asset DCSP file DCSP specified DCSP for DCSP %s' % dir_path)) DCNL DCSP  DCSP  DCSP  DCSP elif (not filepath.endswith('.yaml')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('Found DCSP invalid DCSP non-asset DCSP file DCSP %s. DCSP There DCSP should DCSP only DCSP be DCSP a DCSP single DCSP non-asset DCSP file, DCSP and DCSP it DCSP should DCSP have DCSP a DCSP .yaml DCSP suffix.' % filepath)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP yaml_content = get_file_contents(filepath) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filepath_array = filepath.split('/') DCNL DCSP  DCSP  DCSP  DCSP filename = '/'.join(filepath_array[(dir_path_length + 1):]) DCNL DCSP  DCSP  DCSP  DCSP assets_list.append((filename, get_file_contents(filepath, raw_bytes=True))) DCNL DCSP if (yaml_content is None): DCNL DCSP  DCSP raise Exception(('No DCSP yaml DCSP file DCSP specifed DCSP for DCSP %s' % dir_path)) DCNL DCSP return (yaml_content, assets_list)
 DCSP from scipy.optimize import fmin_cobyla DCNL DCSP (parallel, p_fun, _) = parallel_func(fun, n_jobs) DCNL DCSP res = parallel((p_fun(min_dist_to_inner_skull, B, t, guess_rrs, guess_data, fwd_data, whitener, proj_op, fmin_cobyla, ori) for (B, t) in zip(data.T, times))) DCNL DCSP pos = np.array([r[0] for r in res]) DCNL DCSP amp = np.array([r[1] for r in res]) DCNL DCSP ori = np.array([r[2] for r in res]) DCNL DCSP gof = (np.array([r[3] for r in res]) * 100) DCNL DCSP residual = np.array([r[4] for r in res]).T DCNL DCSP return (pos, amp, ori, gof, residual)
 DCSP if (call != 'function'): DCNL DCSP  DCSP log.error('The DCSP copy_snapshot DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP  DCSP return False DCNL DCSP if ('source_region' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP source_region DCSP must DCSP be DCSP specified DCSP to DCSP copy DCSP a DCSP snapshot.') DCNL DCSP  DCSP return False DCNL DCSP if ('source_snapshot_id' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP source_snapshot_id DCSP must DCSP be DCSP specified DCSP to DCSP copy DCSP a DCSP snapshot.') DCNL DCSP  DCSP return False DCNL DCSP if ('description' not in kwargs): DCNL DCSP  DCSP kwargs['description'] = '' DCNL DCSP params = {'Action': 'CopySnapshot'} DCNL DCSP if ('source_region' in kwargs): DCNL DCSP  DCSP params['SourceRegion'] = kwargs['source_region'] DCNL DCSP if ('source_snapshot_id' in kwargs): DCNL DCSP  DCSP params['SourceSnapshotId'] = kwargs['source_snapshot_id'] DCNL DCSP if ('description' in kwargs): DCNL DCSP  DCSP params['Description'] = kwargs['description'] DCNL DCSP log.debug(params) DCNL DCSP data = aws.query(params, return_url=True, location=get_location(), provider=get_provider(), opts=__opts__, sigver='4') DCNL DCSP return data
 DCSP if (('tempest/scenario/' in filename) and ('/test_' in filename)): DCNL DCSP  DCSP if TEST_DEFINITION.match(physical_line): DCNL DCSP  DCSP  DCSP if (not SCENARIO_DECORATOR.match(previous_logical)): DCNL DCSP  DCSP  DCSP  DCSP return (physical_line.find('def'), 'T104: DCSP Scenario DCSP tests DCSP require DCSP a DCSP service DCSP decorator')
 DCSP return isinstance(object, (type, types.ClassType))
 DCSP if (settings.USER_LOG_MAX_RECORDS_PER_USER and kwargs['created']): DCNL DCSP  DCSP current_models = UserLog.objects.filter(user=kwargs['instance'].user, activity_type=kwargs['instance'].activity_type) DCNL DCSP  DCSP if (current_models.count() > settings.USER_LOG_MAX_RECORDS_PER_USER): DCNL DCSP  DCSP  DCSP to_discard = current_models.order_by('start_datetime')[0:(current_models.count() - settings.USER_LOG_MAX_RECORDS_PER_USER)] DCNL DCSP  DCSP  DCSP UserLog.objects.filter(pk__in=to_discard).delete()
 DCSP with zipfile.ZipFile(jar_path) as jar: DCNL DCSP  DCSP for name in jar.namelist(): DCNL DCSP  DCSP  DCSP (yield (name, jar.read(name)))
 DCSP if (palette is not None): DCNL DCSP  DCSP kwargs['palette'] = palette DCNL DCSP kwargs['columns'] = columns DCNL DCSP kwargs['bin'] = bin DCNL DCSP return ColorAttr(**kwargs)
 DCSP if (imp is None): DCNL DCSP  DCSP imp = importlib.import_module DCNL DCSP with cwd_in_path(): DCNL DCSP  DCSP return imp(module, package=package)
 DCSP profile = Profile.objects.get_or_create(user=request.user)[0] DCNL DCSP if (profile.extra_data is None): DCNL DCSP  DCSP profile.extra_data = {} DCNL DCSP  DCSP profile.save(update_fields=(u'extra_data',)) DCNL DCSP profile_data = profile.extra_data DCNL DCSP selected_primary_widgets = [] DCNL DCSP unselected_primary_widgets = [] DCNL DCSP primary_widget_selections = profile_data.get(u'primary_widget_selections') DCNL DCSP if primary_widget_selections: DCNL DCSP  DCSP for p in primary_widgets: DCNL DCSP  DCSP  DCSP if (primary_widget_selections[p.widget_id] == u'1'): DCNL DCSP  DCSP  DCSP  DCSP selected_primary_widgets.append(p) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unselected_primary_widgets.append(p) DCNL DCSP else: DCNL DCSP  DCSP selected_primary_widgets = primary_widgets DCNL DCSP  DCSP unselected_primary_widgets = None DCNL DCSP selected_secondary_widgets = [] DCNL DCSP unselected_secondary_widgets = [] DCNL DCSP secondary_widget_selections = profile_data.get(u'secondary_widget_selections') DCNL DCSP if secondary_widget_selections: DCNL DCSP  DCSP for s in secondary_widgets: DCNL DCSP  DCSP  DCSP if (secondary_widget_selections[s.widget_id] == u'1'): DCNL DCSP  DCSP  DCSP  DCSP selected_secondary_widgets.append(s) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unselected_secondary_widgets.append(s) DCNL DCSP else: DCNL DCSP  DCSP selected_secondary_widgets = secondary_widgets DCNL DCSP  DCSP unselected_secondary_widgets = None DCNL DCSP primary_widget_positions = profile_data.get(u'primary_widget_positions') DCNL DCSP if primary_widget_positions: DCNL DCSP  DCSP sorted_primary_widgets = sorted(selected_primary_widgets, key=(lambda y: (primary_widget_positions[y.widget_id] or len(primary_widget_positions)))) DCNL DCSP else: DCNL DCSP  DCSP sorted_primary_widgets = selected_primary_widgets DCNL DCSP secondary_widget_positions = profile_data.get(u'secondary_widget_positions') DCNL DCSP if secondary_widget_positions: DCNL DCSP  DCSP sorted_secondary_widgets = sorted(selected_secondary_widgets, key=(lambda y: (secondary_widget_positions[y.widget_id] or len(secondary_widget_positions)))) DCNL DCSP else: DCNL DCSP  DCSP sorted_secondary_widgets = selected_secondary_widgets DCNL DCSP return render_to_response(template_name, RequestContext(request, {u'primary_widgets': primary_widgets, u'root_path': (settings.SITE_ROOT + u'admin/db/'), u'secondary_widgets': secondary_widgets, u'selected_primary_widgets': sorted_primary_widgets, u'selected_secondary_widgets': sorted_secondary_widgets, u'support_data': serialize_support_data(request, True), u'title': _(u'Admin DCSP Dashboard'), u'unselected_primary_widgets': unselected_primary_widgets, u'unselected_secondary_widgets': unselected_secondary_widgets}))
 DCSP getvalue = None DCNL DCSP if (stream is None): DCNL DCSP  DCSP if (encoding is None): DCNL DCSP  DCSP  DCSP from StringIO import StringIO DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from cStringIO import StringIO DCNL DCSP  DCSP stream = StringIO() DCNL DCSP  DCSP getvalue = stream.getvalue DCNL DCSP dumper = Dumper(stream, default_style=default_style, default_flow_style=default_flow_style, canonical=canonical, indent=indent, width=width, allow_unicode=allow_unicode, line_break=line_break, encoding=encoding, version=version, tags=tags, explicit_start=explicit_start, explicit_end=explicit_end) DCNL DCSP dumper.open() DCNL DCSP for data in documents: DCNL DCSP  DCSP dumper.represent(data) DCNL DCSP dumper.close() DCNL DCSP if getvalue: DCNL DCSP  DCSP return getvalue()
 DCSP if (path1.source == path2.source): DCNL DCSP  DCSP if (path1.source_version_num > path2.source_version_num): DCNL DCSP  DCSP  DCSP return path1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return path2 DCNL DCSP return None
 DCSP return pygraphviz_layout(G, prog=prog, root=root, args=args)
 DCSP level_tags = constants.DEFAULT_TAGS.copy() DCNL DCSP level_tags.update(getattr(settings, 'MESSAGE_TAGS', {})) DCNL DCSP return level_tags
 DCSP bigquery_client = bigquery.Client(project=project) DCNL DCSP dataset = bigquery_client.dataset(dataset_name) DCNL DCSP table = dataset.table(table_name) DCNL DCSP if (not table.exists()): DCNL DCSP  DCSP print 'Table DCSP {}:{} DCSP does DCSP not DCSP exist.'.format(dataset_name, table_name) DCNL DCSP  DCSP return DCNL DCSP table.reload() DCNL DCSP rows = list(table.fetch_data(max_results=25)) DCNL DCSP format_string = ('{!s:<16} DCSP ' * len(table.schema)) DCNL DCSP field_names = [field.name for field in table.schema] DCNL DCSP print format_string.format(*field_names) DCNL DCSP for row in rows: DCNL DCSP  DCSP print format_string.format(*row)
 DCSP try: DCNL DCSP  DCSP return next(iter(seq)) DCNL DCSP except StopIteration: DCNL DCSP  DCSP return environment.undefined('No DCSP first DCSP item, DCSP sequence DCSP was DCSP empty.')
 DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())
 DCSP target = text.strip() DCNL DCSP if (not is_valid(target)): DCNL DCSP  DCSP return "I DCSP can't DCSP attack DCSP that." DCNL DCSP if is_self(conn, target): DCNL DCSP  DCSP target = nick DCNL DCSP message('{}, DCSP {}'.format(target, random.choice(flirts)))
 DCSP allow_fragments = bool(allow_fragments) DCNL DCSP key = (url, scheme, allow_fragments, type(url), type(scheme)) DCNL DCSP cached = _parse_cache.get(key, None) DCNL DCSP if cached: DCNL DCSP  DCSP return cached DCNL DCSP if (len(_parse_cache) >= MAX_CACHE_SIZE): DCNL DCSP  DCSP clear_cache() DCNL DCSP netloc = query = fragment = '' DCNL DCSP i = url.find(':') DCNL DCSP if (i > 0): DCNL DCSP  DCSP if (url[:i] == 'http'): DCNL DCSP  DCSP  DCSP scheme = url[:i].lower() DCNL DCSP  DCSP  DCSP url = url[(i + 1):] DCNL DCSP  DCSP  DCSP if (url[:2] == '//'): DCNL DCSP  DCSP  DCSP  DCSP (netloc, url) = _splitnetloc(url, 2) DCNL DCSP  DCSP  DCSP  DCSP if ((('[' in netloc) and (']' not in netloc)) or ((']' in netloc) and ('[' not in netloc))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Invalid DCSP IPv6 DCSP URL') DCNL DCSP  DCSP  DCSP if (allow_fragments and ('#' in url)): DCNL DCSP  DCSP  DCSP  DCSP (url, fragment) = url.split('#', 1) DCNL DCSP  DCSP  DCSP if ('?' in url): DCNL DCSP  DCSP  DCSP  DCSP (url, query) = url.split('?', 1) DCNL DCSP  DCSP  DCSP v = SplitResult(scheme, netloc, url, query, fragment) DCNL DCSP  DCSP  DCSP _parse_cache[key] = v DCNL DCSP  DCSP  DCSP return v DCNL DCSP  DCSP for c in url[:i]: DCNL DCSP  DCSP  DCSP if (c not in scheme_chars): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _testportnum = int(url[(i + 1):]) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP (scheme, url) = (url[:i].lower(), url[(i + 1):]) DCNL DCSP if (url[:2] == '//'): DCNL DCSP  DCSP (netloc, url) = _splitnetloc(url, 2) DCNL DCSP  DCSP if ((('[' in netloc) and (']' not in netloc)) or ((']' in netloc) and ('[' not in netloc))): DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP IPv6 DCSP URL') DCNL DCSP if (allow_fragments and (scheme in uses_fragment) and ('#' in url)): DCNL DCSP  DCSP (url, fragment) = url.split('#', 1) DCNL DCSP if ((scheme in uses_query) and ('?' in url)): DCNL DCSP  DCSP (url, query) = url.split('?', 1) DCNL DCSP v = SplitResult(scheme, netloc, url, query, fragment) DCNL DCSP _parse_cache[key] = v DCNL DCSP return v
 DCSP def callback(lexer, match, ctx=None): DCNL DCSP  DCSP for (i, action) in enumerate(args): DCNL DCSP  DCSP  DCSP if (action is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (type(action) is _TokenType): DCNL DCSP  DCSP  DCSP  DCSP data = match.group((i + 1)) DCNL DCSP  DCSP  DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (match.start((i + 1)), action, data)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if ctx: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ctx.pos = match.start((i + 1)) DCNL DCSP  DCSP  DCSP  DCSP for item in action(lexer, _PseudoMatch(match.start((i + 1)), match.group((i + 1))), ctx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if item: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield item) DCNL DCSP  DCSP if ctx: DCNL DCSP  DCSP  DCSP ctx.pos = match.end() DCNL DCSP return callback
 DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP policy = conn.get_policy(policyName=policyName) DCNL DCSP  DCSP if policy: DCNL DCSP  DCSP  DCSP keys = ('policyName', 'policyArn', 'policyDocument', 'defaultVersionId') DCNL DCSP  DCSP  DCSP return {'policy': dict([(k, policy.get(k)) for k in keys])} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'policy': None} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP err = salt.utils.boto3.get_error(e) DCNL DCSP  DCSP if (e.response.get('Error', {}).get('Code') == 'ResourceNotFoundException'): DCNL DCSP  DCSP  DCSP return {'policy': None} DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}
 DCSP asp_data = {} DCNL DCSP asp_data['maxNumReplicas'] = as_params['max_instances'] DCNL DCSP if ('min_instances' in as_params): DCNL DCSP  DCSP asp_data['minNumReplicas'] = as_params['min_instances'] DCNL DCSP if ('cool_down_period' in as_params): DCNL DCSP  DCSP asp_data['coolDownPeriodSec'] = as_params['cool_down_period'] DCNL DCSP if (('cpu_utilization' in as_params) and ('target' in as_params['cpu_utilization'])): DCNL DCSP  DCSP asp_data['cpuUtilization'] = {'utilizationTarget': as_params['cpu_utilization']['target']} DCNL DCSP if (('load_balancing_utilization' in as_params) and ('target' in as_params['load_balancing_utilization'])): DCNL DCSP  DCSP asp_data['loadBalancingUtilization'] = {'utilizationTarget': as_params['load_balancing_utilization']['target']} DCNL DCSP return asp_data
 DCSP token = tokens.current() DCNL DCSP result = [] DCNL DCSP if (token in '(['): DCNL DCSP  DCSP tokens.move() DCNL DCSP  DCSP (matching, pattern) = {'(': [')', Required], '[': [']', Optional]}[token] DCNL DCSP  DCSP result = pattern(*parse_expr(tokens, options)) DCNL DCSP  DCSP if (tokens.move() != matching): DCNL DCSP  DCSP  DCSP raise tokens.error(("unmatched DCSP '%s'" % token)) DCNL DCSP  DCSP return [result] DCNL DCSP elif (token == 'options'): DCNL DCSP  DCSP tokens.move() DCNL DCSP  DCSP return [OptionsShortcut()] DCNL DCSP elif (token.startswith('--') and (token != '--')): DCNL DCSP  DCSP return parse_long(tokens, options) DCNL DCSP elif (token.startswith('-') and (token not in ('-', '--'))): DCNL DCSP  DCSP return parse_shorts(tokens, options) DCNL DCSP elif ((token.startswith('<') and token.endswith('>')) or token.isupper()): DCNL DCSP  DCSP return [Argument(tokens.move())] DCNL DCSP else: DCNL DCSP  DCSP return [Command(tokens.move())]
 DCSP with open('test.rpt', 'r') as input_file: DCNL DCSP  DCSP data_text = input_file.read() DCNL DCSP data = yaml.safe_load(data_text) DCNL DCSP string_file = StringIO.StringIO() DCNL DCSP _generate_html(data, string_file) DCNL DCSP string_file.seek(0) DCNL DCSP result = string_file.read() DCNL DCSP with open('test.html', 'w') as output: DCNL DCSP  DCSP output.write(result)
 DCSP text = '' DCNL DCSP for character in value: DCNL DCSP  DCSP if (text != ''): DCNL DCSP  DCSP  DCSP text += ' DCSP ' DCNL DCSP  DCSP byte = ord(character) DCNL DCSP  DCSP text += byte2bin(byte, classic_mode) DCNL DCSP return text
 DCSP if form.textfile_use_local_files.data: DCNL DCSP  DCSP job.labels_file = form.textfile_local_labels_file.data.strip() DCNL DCSP else: DCNL DCSP  DCSP flask.request.files[form.textfile_labels_file.name].save(os.path.join(job.dir(), utils.constants.LABELS_FILE)) DCNL DCSP  DCSP job.labels_file = utils.constants.LABELS_FILE DCNL DCSP shuffle = bool(form.textfile_shuffle.data) DCNL DCSP backend = form.backend.data DCNL DCSP encoding = form.encoding.data DCNL DCSP compression = form.compression.data DCNL DCSP if form.textfile_use_local_files.data: DCNL DCSP  DCSP train_file = form.textfile_local_train_images.data.strip() DCNL DCSP else: DCNL DCSP  DCSP flask.request.files[form.textfile_train_images.name].save(os.path.join(job.dir(), utils.constants.TRAIN_FILE)) DCNL DCSP  DCSP train_file = utils.constants.TRAIN_FILE DCNL DCSP image_folder = form.textfile_train_folder.data.strip() DCNL DCSP if (not image_folder): DCNL DCSP  DCSP image_folder = None DCNL DCSP job.tasks.append(tasks.CreateDbTask(job_dir=job.dir(), input_file=train_file, db_name=utils.constants.TRAIN_DB, backend=backend, image_dims=job.image_dims, image_folder=image_folder, resize_mode=job.resize_mode, encoding=encoding, compression=compression, mean_file=utils.constants.MEAN_FILE_CAFFE, labels_file=job.labels_file, shuffle=shuffle)) DCNL DCSP if form.textfile_use_val.data: DCNL DCSP  DCSP if form.textfile_use_local_files.data: DCNL DCSP  DCSP  DCSP val_file = form.textfile_local_val_images.data.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flask.request.files[form.textfile_val_images.name].save(os.path.join(job.dir(), utils.constants.VAL_FILE)) DCNL DCSP  DCSP  DCSP val_file = utils.constants.VAL_FILE DCNL DCSP  DCSP image_folder = form.textfile_val_folder.data.strip() DCNL DCSP  DCSP if (not image_folder): DCNL DCSP  DCSP  DCSP image_folder = None DCNL DCSP  DCSP job.tasks.append(tasks.CreateDbTask(job_dir=job.dir(), input_file=val_file, db_name=utils.constants.VAL_DB, backend=backend, image_dims=job.image_dims, image_folder=image_folder, resize_mode=job.resize_mode, encoding=encoding, compression=compression, labels_file=job.labels_file, shuffle=shuffle)) DCNL DCSP if form.textfile_use_test.data: DCNL DCSP  DCSP if form.textfile_use_local_files.data: DCNL DCSP  DCSP  DCSP test_file = form.textfile_local_test_images.data.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flask.request.files[form.textfile_test_images.name].save(os.path.join(job.dir(), utils.constants.TEST_FILE)) DCNL DCSP  DCSP  DCSP test_file = utils.constants.TEST_FILE DCNL DCSP  DCSP image_folder = form.textfile_test_folder.data.strip() DCNL DCSP  DCSP if (not image_folder): DCNL DCSP  DCSP  DCSP image_folder = None DCNL DCSP  DCSP job.tasks.append(tasks.CreateDbTask(job_dir=job.dir(), input_file=test_file, db_name=utils.constants.TEST_DB, backend=backend, image_dims=job.image_dims, image_folder=image_folder, resize_mode=job.resize_mode, encoding=encoding, compression=compression, labels_file=job.labels_file, shuffle=shuffle))
 DCSP if (len(root.handlers) == 0): DCNL DCSP  DCSP basicConfig() DCNL DCSP root.debug(*((msg,) + args), **kwargs)
 DCSP return st.floats(min_value=0.0, allow_infinity=False).filter((lambda x: (x > 0.0)))
 DCSP return tf.train.FeatureList(feature=[_int64_feature(v) for v in values])
 DCSP return _sys_version()[0]
 DCSP assert part, 'part DCSP must DCSP be DCSP a DCSP field DCSP name DCSP and DCSP + DCSP or DCSP -' DCNL DCSP field = part[:(-1)] DCNL DCSP assert field, 'field DCSP is DCSP missing' DCNL DCSP direction = part[(-1)] DCNL DCSP assert (direction in ('+', '-')), 'part DCSP must DCSP end DCSP with DCSP + DCSP or DCSP -' DCNL DCSP is_ascending = (direction == '+') DCNL DCSP case_insensitive = beets.config['sort_case_insensitive'].get(bool) DCNL DCSP if (field in model_cls._sorts): DCNL DCSP  DCSP sort = model_cls._sorts[field](model_cls, is_ascending, case_insensitive) DCNL DCSP elif (field in model_cls._fields): DCNL DCSP  DCSP sort = query.FixedFieldSort(field, is_ascending, case_insensitive) DCNL DCSP else: DCNL DCSP  DCSP sort = query.SlowFieldSort(field, is_ascending, case_insensitive) DCNL DCSP return sort
 DCSP return _resource('add', zone, resource_type, None, **kwargs)
 DCSP return ''.join(bits(s, endian, zero, one))
 DCSP fd = CreateGRRTempFile(directory=directory, filename=filename, lifetime=lifetime, mode=mode, suffix=suffix) DCNL DCSP pathspec = rdf_paths.PathSpec(path=fd.name, pathtype=rdf_paths.PathSpec.PathType.TMPFILE) DCNL DCSP return (fd, pathspec)
 DCSP if backend.startswith('module://'): DCNL DCSP  DCSP backend_name = backend[9:] DCNL DCSP else: DCNL DCSP  DCSP backend_name = ('backend_' + backend) DCNL DCSP  DCSP backend_name = backend_name.lower() DCNL DCSP  DCSP backend_name = ('matplotlib.backends.%s' % backend_name.lower()) DCNL DCSP backend_mod = __import__(backend_name, globals(), locals(), [backend_name]) DCNL DCSP new_figure_manager = backend_mod.new_figure_manager DCNL DCSP def do_nothing_show(*args, **kwargs): DCNL DCSP  DCSP frame = inspect.currentframe() DCNL DCSP  DCSP fname = frame.f_back.f_code.co_filename DCNL DCSP  DCSP if (fname in ('<stdin>', '<ipython DCSP console>')): DCNL DCSP  DCSP  DCSP warnings.warn(("\nYour DCSP currently DCSP selected DCSP backend, DCSP '%s' DCSP does DCSP not DCSP support DCSP show().\nPlease DCSP select DCSP a DCSP GUI DCSP backend DCSP in DCSP your DCSP matplotlibrc DCSP file DCSP ('%s')\nor DCSP with DCSP matplotlib.use()" % (backend, matplotlib.matplotlib_fname()))) DCNL DCSP def do_nothing(*args, **kwargs): DCNL DCSP  DCSP pass DCNL DCSP backend_version = getattr(backend_mod, 'backend_version', 'unknown') DCNL DCSP show = getattr(backend_mod, 'show', do_nothing_show) DCNL DCSP draw_if_interactive = getattr(backend_mod, 'draw_if_interactive', do_nothing) DCNL DCSP if (backend.lower() in ['wx', 'wxagg']): DCNL DCSP  DCSP Toolbar = backend_mod.Toolbar DCNL DCSP  DCSP __all__.append('Toolbar') DCNL DCSP matplotlib.verbose.report(('backend DCSP %s DCSP version DCSP %s' % (backend, backend_version))) DCNL DCSP return (new_figure_manager, draw_if_interactive, show)
 DCSP course_key = SlashSeparatedCourseKey.from_deprecated_string(course_id) DCNL DCSP if hasattr(course_key, 'ccx'): DCNL DCSP  DCSP return redirect(reverse('dashboard')) DCNL DCSP with modulestore().bulk_operations(course_key): DCNL DCSP  DCSP permission = get_permission_for_course_about() DCNL DCSP  DCSP course = get_course_with_access(request.user, permission, course_key) DCNL DCSP  DCSP course_details = CourseDetails.populate(course) DCNL DCSP  DCSP modes = CourseMode.modes_for_course_dict(course_key) DCNL DCSP  DCSP if configuration_helpers.get_value('ENABLE_MKTG_SITE', settings.FEATURES.get('ENABLE_MKTG_SITE', False)): DCNL DCSP  DCSP  DCSP return redirect(reverse('info', args=[course.id.to_deprecated_string()])) DCNL DCSP  DCSP registered = registered_for_course(course, request.user) DCNL DCSP  DCSP staff_access = bool(has_access(request.user, 'staff', course)) DCNL DCSP  DCSP studio_url = get_studio_url(course, 'settings/details') DCNL DCSP  DCSP if has_access(request.user, 'load', course): DCNL DCSP  DCSP  DCSP course_target = reverse('info', args=[course.id.to_deprecated_string()]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP course_target = reverse('about_course', args=[course.id.to_deprecated_string()]) DCNL DCSP  DCSP show_courseware_link = bool(((has_access(request.user, 'load', course) and has_access(request.user, 'view_courseware_with_prerequisites', course)) or settings.FEATURES.get('ENABLE_LMS_MIGRATION'))) DCNL DCSP  DCSP in_cart = False DCNL DCSP  DCSP reg_then_add_to_cart_link = '' DCNL DCSP  DCSP _is_shopping_cart_enabled = is_shopping_cart_enabled() DCNL DCSP  DCSP if _is_shopping_cart_enabled: DCNL DCSP  DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP  DCSP cart = shoppingcart.models.Order.get_cart_for_user(request.user) DCNL DCSP  DCSP  DCSP  DCSP in_cart = (shoppingcart.models.PaidCourseRegistration.contained_in_order(cart, course_key) or shoppingcart.models.CourseRegCodeItem.contained_in_order(cart, course_key)) DCNL DCSP  DCSP  DCSP reg_then_add_to_cart_link = '{reg_url}?course_id={course_id}&enrollment_action=add_to_cart'.format(reg_url=reverse('register_user'), course_id=urllib.quote(str(course_id))) DCNL DCSP  DCSP ecomm_service = EcommerceService() DCNL DCSP  DCSP ecommerce_checkout = ecomm_service.is_enabled(request.user) DCNL DCSP  DCSP ecommerce_checkout_link = '' DCNL DCSP  DCSP ecommerce_bulk_checkout_link = '' DCNL DCSP  DCSP professional_mode = None DCNL DCSP  DCSP is_professional_mode = ((CourseMode.PROFESSIONAL in modes) or (CourseMode.NO_ID_PROFESSIONAL_MODE in modes)) DCNL DCSP  DCSP if (ecommerce_checkout and is_professional_mode): DCNL DCSP  DCSP  DCSP professional_mode = (modes.get(CourseMode.PROFESSIONAL, '') or modes.get(CourseMode.NO_ID_PROFESSIONAL_MODE, '')) DCNL DCSP  DCSP  DCSP if professional_mode.sku: DCNL DCSP  DCSP  DCSP  DCSP ecommerce_checkout_link = ecomm_service.checkout_page_url(professional_mode.sku) DCNL DCSP  DCSP  DCSP if professional_mode.bulk_sku: DCNL DCSP  DCSP  DCSP  DCSP ecommerce_bulk_checkout_link = ecomm_service.checkout_page_url(professional_mode.bulk_sku) DCNL DCSP  DCSP registration_price = CourseMode.min_course_price_for_currency(course_key, settings.PAID_COURSE_REGISTRATION_CURRENCY[0]) DCNL DCSP  DCSP course_price = get_cosmetic_display_price(course, registration_price) DCNL DCSP  DCSP can_add_course_to_cart = (_is_shopping_cart_enabled and registration_price and (not ecommerce_checkout_link)) DCNL DCSP  DCSP can_enroll = bool(has_access(request.user, 'enroll', course)) DCNL DCSP  DCSP invitation_only = course.invitation_only DCNL DCSP  DCSP is_course_full = CourseEnrollment.objects.is_course_full(course) DCNL DCSP  DCSP active_reg_button = (not (registered or is_course_full or (not can_enroll))) DCNL DCSP  DCSP is_shib_course = uses_shib(course) DCNL DCSP  DCSP pre_requisite_courses = get_prerequisite_courses_display(course) DCNL DCSP  DCSP overview = CourseOverview.get_from_id(course.id) DCNL DCSP  DCSP context = {'course': course, 'course_details': course_details, 'staff_access': staff_access, 'studio_url': studio_url, 'registered': registered, 'course_target': course_target, 'is_cosmetic_price_enabled': settings.FEATURES.get('ENABLE_COSMETIC_DISPLAY_PRICE'), 'course_price': course_price, 'in_cart': in_cart, 'ecommerce_checkout': ecommerce_checkout, 'ecommerce_checkout_link': ecommerce_checkout_link, 'ecommerce_bulk_checkout_link': ecommerce_bulk_checkout_link, 'professional_mode': professional_mode, 'reg_then_add_to_cart_link': reg_then_add_to_cart_link, 'show_courseware_link': show_courseware_link, 'is_course_full': is_course_full, 'can_enroll': can_enroll, 'invitation_only': invitation_only, 'active_reg_button': active_reg_button, 'is_shib_course': is_shib_course, 'disable_courseware_header': True, 'can_add_course_to_cart': can_add_course_to_cart, 'cart_link': reverse('shoppingcart.views.show_cart'), 'pre_requisite_courses': pre_requisite_courses, 'course_image_urls': overview.image_urls} DCNL DCSP  DCSP inject_coursetalk_keys_into_context(context, course_key) DCNL DCSP  DCSP return render_to_response('courseware/course_about.html', context)
 DCSP return ipaddress.ip_address(ip_addr).is_private
 DCSP a1 = _asarray_validated(a, check_finite=check_finite) DCNL DCSP if ((len(a1.shape) != 2) or (a1.shape[0] != a1.shape[1])): DCNL DCSP  DCSP raise ValueError('expected DCSP square DCSP matrix') DCNL DCSP overwrite_a = (overwrite_a or _datacopied(a1, a)) DCNL DCSP if (a1.shape[0] <= 2): DCNL DCSP  DCSP if calc_q: DCNL DCSP  DCSP  DCSP return (a1, numpy.eye(a1.shape[0])) DCNL DCSP  DCSP return a1 DCNL DCSP (gehrd, gebal, gehrd_lwork) = get_lapack_funcs(('gehrd', 'gebal', 'gehrd_lwork'), (a1,)) DCNL DCSP (ba, lo, hi, pivscale, info) = gebal(a1, permute=0, overwrite_a=overwrite_a) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %d-th DCSP argument DCSP of DCSP internal DCSP gebal DCSP (hessenberg)' % (- info))) DCNL DCSP n = len(a1) DCNL DCSP lwork = _compute_lwork(gehrd_lwork, ba.shape[0], lo=lo, hi=hi) DCNL DCSP (hq, tau, info) = gehrd(ba, lo=lo, hi=hi, lwork=lwork, overwrite_a=1) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %d-th DCSP argument DCSP of DCSP internal DCSP gehrd DCSP (hessenberg)' % (- info))) DCNL DCSP h = numpy.triu(hq, (-1)) DCNL DCSP if (not calc_q): DCNL DCSP  DCSP return h DCNL DCSP (orghr, orghr_lwork) = get_lapack_funcs(('orghr', 'orghr_lwork'), (a1,)) DCNL DCSP lwork = _compute_lwork(orghr_lwork, n, lo=lo, hi=hi) DCNL DCSP (q, info) = orghr(a=hq, tau=tau, lo=lo, hi=hi, lwork=lwork, overwrite_a=1) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %d-th DCSP argument DCSP of DCSP internal DCSP orghr DCSP (hessenberg)' % (- info))) DCNL DCSP return (h, q)
 DCSP if (not is_cuda_ndarray(obj)): DCNL DCSP  DCSP raise ValueError('require DCSP an DCSP cuda DCSP ndarray DCSP object')
 DCSP if ((len(path) < 2) or (not derivation.track)): DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP point = point.dropAxis() DCNL DCSP begin = path[(((pointIndex + len(path)) - 1) % len(path))].dropAxis() DCNL DCSP end = path[((pointIndex + 1) % len(path))].dropAxis() DCNL DCSP pointMinusBegin = (point - begin) DCNL DCSP pointMinusBeginLength = abs(pointMinusBegin) DCNL DCSP endMinusPoint = (end - point) DCNL DCSP endMinusPointLength = abs(endMinusPoint) DCNL DCSP if (not derivation.closed): DCNL DCSP  DCSP if ((pointIndex == 0) and (endMinusPointLength > 0.0)): DCNL DCSP  DCSP  DCSP return getRotationMatrixByPolar(arrayDictionary, endMinusPoint, endMinusPointLength) DCNL DCSP  DCSP elif ((pointIndex == (len(path) - 1)) and (pointMinusBeginLength > 0.0)): DCNL DCSP  DCSP  DCSP return getRotationMatrixByPolar(arrayDictionary, pointMinusBegin, pointMinusBeginLength) DCNL DCSP if (pointMinusBeginLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP point DCSP equals DCSP previous DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointIndex DCNL DCSP  DCSP print derivation.elementNode DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP pointMinusBegin /= pointMinusBeginLength DCNL DCSP if (endMinusPointLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP point DCSP equals DCSP next DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointIndex DCNL DCSP  DCSP print derivation.elementNode DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP endMinusPoint /= endMinusPointLength DCNL DCSP averagePolar = (pointMinusBegin + endMinusPoint) DCNL DCSP averagePolarLength = abs(averagePolar) DCNL DCSP if (averagePolarLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP averagePolarLength DCSP is DCSP zero DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointIndex DCNL DCSP  DCSP print derivation.elementNode DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP return getRotationMatrixByPolar(arrayDictionary, averagePolar, averagePolarLength)
 DCSP dim0 = (np.prod(dim[:(-1)]) + pad) DCNL DCSP return (dim0, dim[(-1)])
 DCSP if (predicate is None): DCNL DCSP  DCSP predicate = (lambda line: line.strip()) DCNL DCSP def prefixed_lines(): DCNL DCSP  DCSP for line in text.splitlines(True): DCNL DCSP  DCSP  DCSP (yield ((prefix + line) if predicate(line) else line)) DCNL DCSP return ''.join(prefixed_lines())
 DCSP return six.next(six.itervalues(obj))
 DCSP return (urllib_parse(url)[0] in ssh_uri_schemes)
 DCSP o = object.__new__(cls) DCNL DCSP o._as_parameter_ = ctype DCNL DCSP return o
 DCSP if platescale.unit.is_equivalent((si.arcsec / si.m)): DCNL DCSP  DCSP platescale_val = platescale.to((si.radian / si.m)).value DCNL DCSP elif platescale.unit.is_equivalent((si.m / si.arcsec)): DCNL DCSP  DCSP platescale_val = (1 / platescale).to((si.radian / si.m)).value DCNL DCSP else: DCNL DCSP  DCSP raise UnitsError(u'The DCSP pixel DCSP scale DCSP must DCSP be DCSP in DCSP angle/distance DCSP or DCSP distance/angle') DCNL DCSP return [(si.m, si.radian, (lambda d: (d * platescale_val)), (lambda rad: (rad / platescale_val)))]
 DCSP assert ((uidb36 is not None) and (token is not None)) DCNL DCSP if (post_reset_redirect is None): DCNL DCSP  DCSP post_reset_redirect = reverse('django.contrib.auth.views.password_reset_complete') DCNL DCSP try: DCNL DCSP  DCSP uid_int = base36_to_int(uidb36) DCNL DCSP  DCSP user = User.objects.get(id=uid_int) DCNL DCSP except (ValueError, User.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) and token_generator.check_token(user, token)): DCNL DCSP  DCSP validlink = True DCNL DCSP  DCSP if (request.method == 'POST'): DCNL DCSP  DCSP  DCSP form = set_password_form(user, request.POST) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(post_reset_redirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_password_form(None) DCNL DCSP else: DCNL DCSP  DCSP validlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'validlink': validlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.update(extra_context) DCNL DCSP return TemplateResponse(request, template_name, context, current_app=current_app)
 DCSP (memlen, itemsize, _, _, _, _) = t DCNL DCSP return gen_items((memlen // itemsize), ('#' + fmt), 'numpy')
 DCSP if isinstance(track, TlTrack): DCNL DCSP  DCSP (tlid, track) = track DCNL DCSP else: DCNL DCSP  DCSP (tlid, track) = (None, track) DCNL DCSP if (not track.uri): DCNL DCSP  DCSP logger.warning(u'Ignoring DCSP track DCSP without DCSP uri') DCNL DCSP  DCSP return [] DCNL DCSP result = [(u'file', track.uri), (u'Time', ((track.length and (track.length // 1000)) or 0)), (u'Artist', concat_multi_values(track.artists, u'name')), (u'Album', ((track.album and track.album.name) or u''))] DCNL DCSP if (stream_title is not None): DCNL DCSP  DCSP result.append((u'Title', stream_title)) DCNL DCSP  DCSP if track.name: DCNL DCSP  DCSP  DCSP result.append((u'Name', track.name)) DCNL DCSP else: DCNL DCSP  DCSP result.append((u'Title', (track.name or u''))) DCNL DCSP if track.date: DCNL DCSP  DCSP result.append((u'Date', track.date)) DCNL DCSP if ((track.album is not None) and (track.album.num_tracks is not None)): DCNL DCSP  DCSP result.append((u'Track', (u'%d/%d' % ((track.track_no or 0), track.album.num_tracks)))) DCNL DCSP else: DCNL DCSP  DCSP result.append((u'Track', (track.track_no or 0))) DCNL DCSP if ((position is not None) and (tlid is not None)): DCNL DCSP  DCSP result.append((u'Pos', position)) DCNL DCSP  DCSP result.append((u'Id', tlid)) DCNL DCSP if ((track.album is not None) and (track.album.musicbrainz_id is not None)): DCNL DCSP  DCSP result.append((u'MUSICBRAINZ_ALBUMID', track.album.musicbrainz_id)) DCNL DCSP if ((track.album is not None) and track.album.artists): DCNL DCSP  DCSP result.append((u'AlbumArtist', concat_multi_values(track.album.artists, u'name'))) DCNL DCSP  DCSP musicbrainz_ids = concat_multi_values(track.album.artists, u'musicbrainz_id') DCNL DCSP  DCSP if musicbrainz_ids: DCNL DCSP  DCSP  DCSP result.append((u'MUSICBRAINZ_ALBUMARTISTID', musicbrainz_ids)) DCNL DCSP if track.artists: DCNL DCSP  DCSP musicbrainz_ids = concat_multi_values(track.artists, u'musicbrainz_id') DCNL DCSP  DCSP if musicbrainz_ids: DCNL DCSP  DCSP  DCSP result.append((u'MUSICBRAINZ_ARTISTID', musicbrainz_ids)) DCNL DCSP if track.composers: DCNL DCSP  DCSP result.append((u'Composer', concat_multi_values(track.composers, u'name'))) DCNL DCSP if track.performers: DCNL DCSP  DCSP result.append((u'Performer', concat_multi_values(track.performers, u'name'))) DCNL DCSP if track.genre: DCNL DCSP  DCSP result.append((u'Genre', track.genre)) DCNL DCSP if track.disc_no: DCNL DCSP  DCSP result.append((u'Disc', track.disc_no)) DCNL DCSP if track.last_modified: DCNL DCSP  DCSP datestring = datetime.datetime.utcfromtimestamp((track.last_modified // 1000)).isoformat() DCNL DCSP  DCSP result.append((u'Last-Modified', (datestring + u'Z'))) DCNL DCSP if (track.musicbrainz_id is not None): DCNL DCSP  DCSP result.append((u'MUSICBRAINZ_TRACKID', track.musicbrainz_id)) DCNL DCSP if (track.album and track.album.uri): DCNL DCSP  DCSP result.append((u'X-AlbumUri', track.album.uri)) DCNL DCSP if (track.album and track.album.images): DCNL DCSP  DCSP images = u';'.join((i for i in track.album.images if (i is not u''))) DCNL DCSP  DCSP result.append((u'X-AlbumImage', images)) DCNL DCSP result = [element for element in result if _has_value(*element)] DCNL DCSP return result
 DCSP text = archive.getFileText(archive.getProfilesPath(getProfileBaseName(repository)), False) DCNL DCSP if (text == ''): DCNL DCSP  DCSP if (repository.baseNameSynonym != None): DCNL DCSP  DCSP  DCSP text = archive.getFileText(archive.getProfilesPath(getProfileBaseNameSynonym(repository)), False) DCNL DCSP if (text == ''): DCNL DCSP  DCSP print ('The DCSP default DCSP %s DCSP will DCSP be DCSP written DCSP in DCSP the DCSP .skeinforge DCSP folder DCSP in DCSP the DCSP home DCSP directory.' % repository.title.lower()) DCNL DCSP  DCSP text = archive.getFileText(getProfilesDirectoryInAboveDirectory(getProfileBaseName(repository)), False) DCNL DCSP  DCSP if (text != ''): DCNL DCSP  DCSP  DCSP readSettingsFromText(repository, text) DCNL DCSP  DCSP writeSettings(repository) DCNL DCSP  DCSP temporaryApplyOverrides(repository) DCNL DCSP  DCSP return repository DCNL DCSP readSettingsFromText(repository, text) DCNL DCSP temporaryApplyOverrides(repository) DCNL DCSP return repository
 DCSP p = element DCNL DCSP while True: DCNL DCSP  DCSP p = p.getparent() DCNL DCSP  DCSP if (p.tag == tag): DCNL DCSP  DCSP  DCSP return p DCNL DCSP return None
 DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP walker = r.get_walker(max_entries=max_entries, paths=paths, reverse=reverse) DCNL DCSP  DCSP for entry in walker: DCNL DCSP  DCSP  DCSP decode = (lambda x: commit_decode(entry.commit, x)) DCNL DCSP  DCSP  DCSP print_commit(entry.commit, decode, outstream) DCNL DCSP  DCSP  DCSP if name_status: DCNL DCSP  DCSP  DCSP  DCSP outstream.writelines([(l + '\n') for l in print_name_status(entry.changes())])
 DCSP if (not chain): DCNL DCSP  DCSP return 'Error: DCSP Chain DCSP needs DCSP to DCSP be DCSP specified' DCNL DCSP if (not rule): DCNL DCSP  DCSP return 'Error: DCSP Rule DCSP needs DCSP to DCSP be DCSP specified' DCNL DCSP if (not check_table(table, family=family)): DCNL DCSP  DCSP return 'Error: DCSP table DCSP {0} DCSP in DCSP family DCSP {1} DCSP does DCSP not DCSP exist'.format(table, family) DCNL DCSP if (not check_chain(table, chain, family=family)): DCNL DCSP  DCSP return 'Error: DCSP chain DCSP {0} DCSP in DCSP table DCSP {1} DCSP in DCSP family DCSP {2} DCSP does DCSP not DCSP exist'.format(chain, table, family) DCNL DCSP if (not check(table, chain, rule, family=family)): DCNL DCSP  DCSP return 'Error: DCSP rule DCSP {0} DCSP chain DCSP {1} DCSP in DCSP table DCSP {2} DCSP in DCSP family DCSP {3} DCSP does DCSP not DCSP exist'.format(rule, chain, table, family) DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmd = '{0} DCSP --numeric DCSP --numeric DCSP --numeric DCSP --handle DCSP list DCSP chain DCSP {1} DCSP {2} DCSP {3}'.format(_nftables_cmd(), nft_family, table, chain) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP rules = re.split('\n+', out) DCNL DCSP pat = re.compile('{0} DCSP # DCSP handle DCSP (?P<handle>\\d+)'.format(rule)) DCNL DCSP for r in rules: DCNL DCSP  DCSP match = pat.search(r) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP return match.group('handle') DCNL DCSP return 'Error: DCSP could DCSP not DCSP find DCSP rule DCSP {0}'.format(rule)
 DCSP objs = [] DCNL DCSP for obj in domain_obj_list: DCNL DCSP  DCSP objs.append((obj.name if obj else None)) DCNL DCSP return objs
 DCSP data = {} DCNL DCSP if os.path.exists(filename): DCNL DCSP  DCSP lock.acquire() DCNL DCSP  DCSP with open(filename, 'r') as f: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP data = _json.load(f) DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(data, dict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = {} DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP data = {} DCNL DCSP  DCSP lock.release() DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP return {key: data[key] for key in args if (key in data)} DCNL DCSP return data
 DCSP tmp = copy.deepcopy(__salt__['config.option'](alarms_from_pillar, {})) DCNL DCSP if alarms: DCNL DCSP  DCSP tmp = dictupdate.update(tmp, alarms) DCNL DCSP merged_return_value = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP for (_, info) in six.iteritems(tmp): DCNL DCSP  DCSP info['name'] = ((name + ' DCSP ') + info['name']) DCNL DCSP  DCSP info['attributes']['description'] = ((name + ' DCSP ') + info['attributes']['description']) DCNL DCSP  DCSP if ('dimensions' not in info['attributes']): DCNL DCSP  DCSP  DCSP info['attributes']['dimensions'] = {'AutoScalingGroupName': [name]} DCNL DCSP  DCSP scaling_policy_actions_only = True DCNL DCSP  DCSP for action_type in ['alarm_actions', 'insufficient_data_actions', 'ok_actions']: DCNL DCSP  DCSP  DCSP if (action_type in info['attributes']): DCNL DCSP  DCSP  DCSP  DCSP new_actions = [] DCNL DCSP  DCSP  DCSP  DCSP for action in info['attributes'][action_type]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('scaling_policy' not in action): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scaling_policy_actions_only = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (':self:' in action): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP action = action.replace(':self:', ':{0}:'.format(name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_actions.append(action) DCNL DCSP  DCSP  DCSP  DCSP info['attributes'][action_type] = new_actions DCNL DCSP  DCSP if (scaling_policy_actions_only and min_size_equals_max_size): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP kwargs = {'name': info['name'], 'attributes': info['attributes'], 'region': region, 'key': key, 'keyid': keyid, 'profile': profile} DCNL DCSP  DCSP results = __states__['boto_cloudwatch_alarm.present'](**kwargs) DCNL DCSP  DCSP if (not results['result']): DCNL DCSP  DCSP  DCSP merged_return_value['result'] = False DCNL DCSP  DCSP if (results.get('changes', {}) != {}): DCNL DCSP  DCSP  DCSP merged_return_value['changes'][info['name']] = results['changes'] DCNL DCSP  DCSP if ('comment' in results): DCNL DCSP  DCSP  DCSP merged_return_value['comment'] += results['comment'] DCNL DCSP return merged_return_value
 DCSP response = get_dict('url', 'args', 'headers', 'origin') DCNL DCSP n = min(n, 100) DCNL DCSP def generate_stream(): DCNL DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP response['id'] = i DCNL DCSP  DCSP  DCSP (yield (json.dumps(response) + '\n')) DCNL DCSP return Response(generate_stream(), headers={'Content-Type': 'application/json'})
 DCSP if (not iterable(vel_vecs)): DCNL DCSP  DCSP raise TypeError('Velocity DCSP vectors DCSP must DCSP be DCSP contained DCSP in DCSP an DCSP iterable.') DCNL DCSP if (not iterable(gen_speeds)): DCNL DCSP  DCSP raise TypeError('Generalized DCSP speeds DCSP must DCSP be DCSP contained DCSP in DCSP an DCSP iterable') DCNL DCSP vec_partials = [] DCNL DCSP for vec in vel_vecs: DCNL DCSP  DCSP partials = [] DCNL DCSP  DCSP for speed in gen_speeds: DCNL DCSP  DCSP  DCSP partials.append(vec.diff(speed, frame, var_in_dcm=False)) DCNL DCSP  DCSP vec_partials.append(partials) DCNL DCSP return vec_partials
 DCSP return all(((ord(c) < 128) for c in string))
 DCSP if (global_dict is None): DCNL DCSP  DCSP global_dict = {} DCNL DCSP if ('__file__' not in global_dict): DCNL DCSP  DCSP global_dict['__file__'] = filename DCNL DCSP if ('__doc__' not in global_dict): DCNL DCSP  DCSP global_dict['__doc__'] = None DCNL DCSP try: DCNL DCSP  DCSP with open(filename) as f: DCNL DCSP  DCSP  DCSP code = compile(f.read(), filename, 'exec') DCNL DCSP  DCSP  DCSP exec code in global_dict DCNL DCSP except SystemExit: DCNL DCSP  DCSP pass DCNL DCSP except SkipTest: DCNL DCSP  DCSP raise AssertionError((("Couldn't DCSP verify DCSP format DCSP of DCSP " + filename) + 'due DCSP to DCSP SkipTest')) DCNL DCSP all_errors = [] DCNL DCSP for (key, val) in six.iteritems(global_dict): DCNL DCSP  DCSP if (not key.startswith('_')): DCNL DCSP  DCSP  DCSP module_name = '' DCNL DCSP  DCSP  DCSP if hasattr(inspect.getmodule(val), '__name__'): DCNL DCSP  DCSP  DCSP  DCSP module_name = inspect.getmodule(val).__name__ DCNL DCSP  DCSP  DCSP if ((inspect.isfunction(val) or inspect.isclass(val)) and ((inspect.getmodule(val) is None) or (module_name == '__builtin__'))): DCNL DCSP  DCSP  DCSP  DCSP if inspect.isfunction(val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP all_errors.extend(handle_function(val, key)) DCNL DCSP  DCSP  DCSP  DCSP elif inspect.isclass(val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP all_errors.extend(handle_class(val, key)) DCNL DCSP  DCSP elif (key == '__doc__'): DCNL DCSP  DCSP  DCSP all_errors.extend(handle_module(val, key)) DCNL DCSP if all_errors: DCNL DCSP  DCSP all_errors.insert(0, (('%s:' % filename),)) DCNL DCSP return all_errors
 DCSP import doctest DCNL DCSP default_kwargs = {'optionflags': doctest.ELLIPSIS} DCNL DCSP kwargs.update(default_kwargs) DCNL DCSP cur_dir = os.path.abspath(os.curdir) DCNL DCSP print('Running DCSP doctests...') DCNL DCSP try: DCNL DCSP  DCSP os.chdir(find_test_dir(target_dir)) DCNL DCSP  DCSP doctest.testmod(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP os.chdir(cur_dir) DCNL DCSP print('Done')
 DCSP ico = _get_ico_surface(grade) DCNL DCSP if (not return_surf): DCNL DCSP  DCSP return ico['tris'] DCNL DCSP else: DCNL DCSP  DCSP return ico
 DCSP files = list(files) DCNL DCSP if files: DCNL DCSP  DCSP return max((datetime.datetime.fromtimestamp(os.path.getmtime(f)) for f in files)) DCNL DCSP return datetime.datetime(1970, 1, 1)
 DCSP ' DCSP According DCSP to DCSP JEP-0030:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query DCSP MAY DCSP have DCSP node DCSP attribute\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP identity: DCSP MUST DCSP HAVE DCSP category DCSP and DCSP name DCSP attributes DCSP and DCSP MAY DCSP HAVE DCSP type DCSP attribute.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feature: DCSP MUST DCSP HAVE DCSP var DCSP attribute' DCNL DCSP (identities, features) = ([], []) DCNL DCSP for i in _discover(disp, NS_DISCO_INFO, jid, node): DCNL DCSP  DCSP if (i.getName() == 'identity'): DCNL DCSP  DCSP  DCSP identities.append(i.attrs) DCNL DCSP  DCSP elif (i.getName() == 'feature'): DCNL DCSP  DCSP  DCSP features.append(i.getAttr('var')) DCNL DCSP  DCSP elif (i.getName() == 'agent'): DCNL DCSP  DCSP  DCSP if i.getTag('name'): DCNL DCSP  DCSP  DCSP  DCSP i.setAttr('name', i.getTagData('name')) DCNL DCSP  DCSP  DCSP if i.getTag('description'): DCNL DCSP  DCSP  DCSP  DCSP i.setAttr('name', i.getTagData('description')) DCNL DCSP  DCSP  DCSP identities.append(i.attrs) DCNL DCSP  DCSP  DCSP if i.getTag('groupchat'): DCNL DCSP  DCSP  DCSP  DCSP features.append(NS_GROUPCHAT) DCNL DCSP  DCSP  DCSP if i.getTag('register'): DCNL DCSP  DCSP  DCSP  DCSP features.append(NS_REGISTER) DCNL DCSP  DCSP  DCSP if i.getTag('search'): DCNL DCSP  DCSP  DCSP  DCSP features.append(NS_SEARCH) DCNL DCSP return (identities, features)
 DCSP entity_id = (entity_id or ENTITY_ID) DCNL DCSP return hass.states.is_state(entity_id, STATE_ABOVE_HORIZON)
 DCSP pass
 DCSP return _availables_plugins(resources.PLUGINS_WEB)
 DCSP if (hasattr(field, '_south_introspects') and field._south_introspects): DCNL DCSP  DCSP return True DCNL DCSP full_name = ('%s.%s' % (field.__class__.__module__, field.__class__.__name__)) DCNL DCSP for regex in allowed_fields: DCNL DCSP  DCSP if re.match(regex, full_name): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP def _dec(view_func): DCNL DCSP  DCSP def _checklogin(request, *args, **kwargs): DCNL DCSP  DCSP  DCSP if test_func(request.user): DCNL DCSP  DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(('%s?%s=%s' % (login_url, REDIRECT_FIELD_NAME, quote(request.get_full_path())))) DCNL DCSP  DCSP _checklogin.__doc__ = view_func.__doc__ DCNL DCSP  DCSP _checklogin.__dict__ = view_func.__dict__ DCNL DCSP  DCSP return _checklogin DCNL DCSP return _dec
 DCSP task = get_object_or_404(Task, pk=task_id) DCNL DCSP if (not request.user.profile.has_permission(task)): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Task") DCNL DCSP if request.user.profile.has_permission(task, mode='x'): DCNL DCSP  DCSP if request.POST: DCNL DCSP  DCSP  DCSP if ('add-work' in request.POST): DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('projects_task_time_slot_add', args=[task.id])) DCNL DCSP  DCSP  DCSP elif ('start-work' in request.POST): DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('projects_task_view', args=[task.id])) DCNL DCSP  DCSP  DCSP record = UpdateRecord() DCNL DCSP  DCSP  DCSP record.record_type = 'manual' DCNL DCSP  DCSP  DCSP form = TaskRecordForm(request.user.profile, request.POST, instance=record) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP record = form.save() DCNL DCSP  DCSP  DCSP  DCSP record.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP record.save() DCNL DCSP  DCSP  DCSP  DCSP record.about.add(task) DCNL DCSP  DCSP  DCSP  DCSP task.set_last_updated() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('projects_task_view', args=[task.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = TaskRecordForm(request.user.profile) DCNL DCSP else: DCNL DCSP  DCSP form = None DCNL DCSP subtasks = Object.filter_by_request(request, Task.objects.filter(parent=task)) DCNL DCSP time_slots = Object.filter_by_request(request, TaskTimeSlot.objects.filter(task=task)) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'task': task, 'subtasks': subtasks, 'record_form': form, 'time_slots': time_slots}) DCNL DCSP if (('massform' in context) and ('project' in context['massform'].fields)): DCNL DCSP  DCSP del context['massform'].fields['project'] DCNL DCSP return render_to_response('projects/task_view', context, context_instance=RequestContext(request), response_format=response_format)
 DCSP decodedString = string DCNL DCSP octalNumbers = re.findall('\\\\([0-7]{1-3})', decodedString, re.DOTALL) DCNL DCSP for octal in octalNumbers: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP decodedString = decodedString.replace(('\\\\' + octal), chr(int(octal, 8))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return ((-1), 'Error DCSP decoding DCSP string') DCNL DCSP return (0, decodedString)
 DCSP warnings = 0 DCNL DCSP for sourcePath in iterSourceCode(paths): DCNL DCSP  DCSP warnings += checkPath(sourcePath, reporter) DCNL DCSP return warnings
 DCSP add_devices([VlcDevice(config.get(CONF_NAME), config.get(CONF_ARGUMENTS))])
 DCSP assert (hsl_to_rgb(180, 20, 50) == (102, 153, 153)) DCNL DCSP assert (hsl_to_rgb(180, 60, 50) == (51, 204, 204)) DCNL DCSP assert (hsl_to_rgb(180, 100, 50) == (0, 255, 255))
 DCSP md = event.mimeData() DCNL DCSP if (md.hasFormat(u'text/uri-list') and (not md.hasFormat(u'application/calibre+from_library'))): DCNL DCSP  DCSP urls = [unicode(u.toLocalFile()) for u in md.urls()] DCNL DCSP  DCSP return [u for u in urls if (os.path.splitext(u)[1] and os.path.exists(u))]
 DCSP s1 = np.cos(((2 * np.pi) * t)) DCNL DCSP e1 = np.exp((- t)) DCNL DCSP return (s1 * e1)
 DCSP return np.exp(((2.1 * a) + (3.2 * b)))
 DCSP if start_position: DCNL DCSP  DCSP document_file.seek(start_position) DCNL DCSP else: DCNL DCSP  DCSP start_position = document_file.tell() DCNL DCSP if section_end_keywords: DCNL DCSP  DCSP first_keyword = None DCNL DCSP  DCSP line_match = KEYWORD_LINE.match(stem.util.str_tools._to_unicode(document_file.readline())) DCNL DCSP  DCSP if line_match: DCNL DCSP  DCSP  DCSP first_keyword = line_match.groups()[0] DCNL DCSP  DCSP document_file.seek(start_position) DCNL DCSP  DCSP if (first_keyword in section_end_keywords): DCNL DCSP  DCSP  DCSP return DCNL DCSP while ((end_position is None) or (document_file.tell() < end_position)): DCNL DCSP  DCSP (desc_lines, ending_keyword) = _read_until_keywords(((entry_keyword,) + section_end_keywords), document_file, ignore_first=True, end_position=end_position, include_ending_keyword=True) DCNL DCSP  DCSP desc_content = bytes.join('', desc_lines) DCNL DCSP  DCSP if desc_content: DCNL DCSP  DCSP  DCSP (yield entry_class(desc_content, validate, *extra_args)) DCNL DCSP  DCSP  DCSP if (ending_keyword in section_end_keywords): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
 DCSP return novaclient(request).flavors.list()
 DCSP if isinstance(policy_or_index, BaseStoragePolicy): DCNL DCSP  DCSP policy = policy_or_index DCNL DCSP else: DCNL DCSP  DCSP policy = POLICIES.get_by_index(policy_or_index) DCNL DCSP  DCSP if (policy is None): DCNL DCSP  DCSP  DCSP raise PolicyError('Unknown DCSP policy', index=policy_or_index) DCNL DCSP return _get_policy_string(base, int(policy))
 DCSP ret = {'changes': {}, 'result': True, 'comment': ''} DCNL DCSP old = list_pkgs() DCNL DCSP if salt.utils.is_true(refresh): DCNL DCSP  DCSP refresh_db() DCNL DCSP result = _call_brew('brew DCSP upgrade', failhard=False) DCNL DCSP __context__.pop('pkg.list_pkgs', None) DCNL DCSP new = list_pkgs() DCNL DCSP ret = salt.utils.compare_dicts(old, new) DCNL DCSP if (result['retcode'] != 0): DCNL DCSP  DCSP raise CommandExecutionError('Problem DCSP encountered DCSP upgrading DCSP packages', info={'changes': ret, 'result': result}) DCNL DCSP return ret
 DCSP filename = '/'.join(request.args) DCNL DCSP path = apath(filename, r=request) DCNL DCSP a = safe_read(path).split('\n') DCNL DCSP try: DCNL DCSP  DCSP b = safe_read((path + '.1')).split('\n') DCNL DCSP except IOError: DCNL DCSP  DCSP session.flash = 'Other DCSP file, DCSP no DCSP longer DCSP there' DCNL DCSP  DCSP redirect(URL('edit', args=request.args)) DCNL DCSP d = difflib.ndiff(a, b) DCNL DCSP def leading(line): DCNL DCSP  DCSP ' DCSP  DCSP ' DCNL DCSP  DCSP z = '' DCNL DCSP  DCSP for (k, c) in enumerate(line): DCNL DCSP  DCSP  DCSP if (c == ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP z += '&nbsp;' DCNL DCSP  DCSP  DCSP elif (c == ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP  DCSP z += '&nbsp;' DCNL DCSP  DCSP  DCSP elif ((k == 0) and (c == '?')): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return XML(z) DCNL DCSP def getclass(item): DCNL DCSP  DCSP ' DCSP Determine DCSP item DCSP class DCSP ' DCNL DCSP  DCSP operators = {' DCSP ': 'normal', '+': 'plus', '-': 'minus'} DCNL DCSP  DCSP return operators[item[0]] DCNL DCSP if request.vars: DCNL DCSP  DCSP c = '\n'.join([item[2:].rstrip() for (i, item) in enumerate(d) if ((item[0] == ' DCSP ') or (('line%i' % i) in request.vars))]) DCNL DCSP  DCSP safe_write(path, c) DCNL DCSP  DCSP session.flash = 'files DCSP merged' DCNL DCSP  DCSP redirect(URL('edit', args=request.args)) DCNL DCSP else: DCNL DCSP  DCSP gen_data = (lambda index, item: (((not (item[:1] in ['+', '-'])) and '') or INPUT(_type='checkbox', _name=('line%i' % index), value=(item[0] == '+')))) DCNL DCSP  DCSP diff = TABLE(*[TR(TD(gen_data(i, item)), TD(item[0]), TD(leading(item[2:]), TT(item[2:].rstrip())), _class=getclass(item)) for (i, item) in enumerate(d) if (item[0] != '?')]) DCNL DCSP return dict(diff=diff, filename=filename)
 DCSP global _modes DCNL DCSP if (not _modes): DCNL DCSP  DCSP from . import Image DCNL DCSP  DCSP modes = {} DCNL DCSP  DCSP for (m, (basemode, basetype, bands)) in Image._MODEINFO.items(): DCNL DCSP  DCSP  DCSP modes[m] = ModeDescriptor(m, bands, basemode, basetype) DCNL DCSP  DCSP modes['RGBa'] = ModeDescriptor('RGBa', ('R', 'G', 'B', 'a'), 'RGB', 'L') DCNL DCSP  DCSP modes['LA'] = ModeDescriptor('LA', ('L', 'A'), 'L', 'L') DCNL DCSP  DCSP modes['La'] = ModeDescriptor('La', ('L', 'a'), 'L', 'L') DCNL DCSP  DCSP modes['PA'] = ModeDescriptor('PA', ('P', 'A'), 'RGB', 'L') DCNL DCSP  DCSP modes['I;16'] = ModeDescriptor('I;16', 'I', 'L', 'L') DCNL DCSP  DCSP modes['I;16L'] = ModeDescriptor('I;16L', 'I', 'L', 'L') DCNL DCSP  DCSP modes['I;16B'] = ModeDescriptor('I;16B', 'I', 'L', 'L') DCNL DCSP  DCSP _modes = modes DCNL DCSP return _modes[mode]
 DCSP try: DCNL DCSP  DCSP plugin.save(title) DCNL DCSP  DCSP plugin.restart() DCNL DCSP  DCSP return True DCNL DCSP except le_errors.Error as error: DCNL DCSP  DCSP logger.error('Plugin DCSP failed DCSP to DCSP save DCSP and DCSP restart DCSP server:') DCNL DCSP  DCSP logger.exception(error) DCNL DCSP  DCSP return False
 DCSP args = [] DCNL DCSP s = True DCNL DCSP n = M.rows DCNL DCSP try: DCNL DCSP  DCSP list = M._mat DCNL DCSP except AttributeError: DCNL DCSP  DCSP list = flatten(M.tolist()) DCNL DCSP for perm in generate_bell(n): DCNL DCSP  DCSP fac = [] DCNL DCSP  DCSP idx = 0 DCNL DCSP  DCSP for j in perm: DCNL DCSP  DCSP  DCSP fac.append(list[(idx + j)]) DCNL DCSP  DCSP  DCSP idx += n DCNL DCSP  DCSP term = Mul(*fac) DCNL DCSP  DCSP args.append((term if s else (- term))) DCNL DCSP  DCSP s = (not s) DCNL DCSP return Add(*args)
 DCSP from hadoop import job_tracker DCNL DCSP from hadoop.fs import webhdfs DCNL DCSP res = [] DCNL DCSP submit_to = [] DCNL DCSP has_default = False DCNL DCSP for name in HDFS_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = HDFS_CLUSTERS[name] DCNL DCSP  DCSP res.extend(webhdfs.test_fs_configuration(cluster)) DCNL DCSP  DCSP if (name == 'default'): DCNL DCSP  DCSP  DCSP has_default = True DCNL DCSP if (not has_default): DCNL DCSP  DCSP res.append(('hadoop.hdfs_clusters', "You DCSP should DCSP have DCSP an DCSP HDFS DCSP called DCSP 'default'.")) DCNL DCSP mr_down = [] DCNL DCSP for name in MR_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = MR_CLUSTERS[name] DCNL DCSP  DCSP if cluster.SUBMIT_TO.get(): DCNL DCSP  DCSP  DCSP mr_down.extend(job_tracker.test_jt_configuration(cluster)) DCNL DCSP  DCSP  DCSP submit_to.append(('mapred_clusters.' + name)) DCNL DCSP if (mr_down and (len(mr_down) == len(MR_CLUSTERS.keys()))): DCNL DCSP  DCSP res.extend(mr_down) DCNL DCSP if YARN_CLUSTERS.keys(): DCNL DCSP  DCSP res.extend(test_yarn_configurations(user)) DCNL DCSP for name in YARN_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = YARN_CLUSTERS[name] DCNL DCSP  DCSP if cluster.SUBMIT_TO.get(): DCNL DCSP  DCSP  DCSP submit_to.append(('yarn_clusters.' + name)) DCNL DCSP if (not submit_to): DCNL DCSP  DCSP res.append(('hadoop', "Please DCSP designate DCSP one DCSP of DCSP the DCSP MapReduce DCSP or DCSP Yarn DCSP clusters DCSP with DCSP `submit_to=true' DCSP in DCSP order DCSP to DCSP run DCSP jobs.")) DCNL DCSP return res
 DCSP try: DCNL DCSP  DCSP obj = match_obj.group(name) DCNL DCSP except: DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP if (obj is not None): DCNL DCSP  DCSP  DCSP return obj DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ''
 DCSP if (secret is None): DCNL DCSP  DCSP secret = settings.SECRET_KEY DCNL DCSP key_salt = force_bytes(key_salt) DCNL DCSP secret = force_bytes(secret) DCNL DCSP key = hashlib.sha1((key_salt + secret)).digest() DCNL DCSP return hmac.new(key, msg=force_bytes(value), digestmod=hashlib.sha1)
 DCSP return _osquery_cmd(table='etc_hosts', attrs=attrs, where=where)
 DCSP def decorator(f): DCNL DCSP  DCSP group = args[0] DCNL DCSP  DCSP name = args[1] DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def wrapper(self, *func_args, **func_kwargs): DCNL DCSP  DCSP  DCSP if hasattr(CONF, group): DCNL DCSP  DCSP  DCSP  DCSP conf_group = getattr(CONF, group) DCNL DCSP  DCSP  DCSP  DCSP if hasattr(conf_group, name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = getattr(conf_group, name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(args) == 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = args[2] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = ('Config DCSP option DCSP %s.%s DCSP is DCSP false' % (group, name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise testtools.TestCase.skipException(msg) DCNL DCSP  DCSP  DCSP return f(self, *func_args, **func_kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
 DCSP return enet_path(X, y, l1_ratio=1.0, eps=eps, n_alphas=n_alphas, alphas=alphas, precompute=precompute, Xy=Xy, copy_X=copy_X, coef_init=coef_init, verbose=verbose, positive=positive, return_n_iter=return_n_iter, **params)
 DCSP extra_service_versions = set([]) DCNL DCSP _tempest_modules = set(tempest_modules()) DCNL DCSP plugin_services = ClientsRegistry().get_service_clients() DCNL DCSP for plugin_name in plugin_services: DCNL DCSP  DCSP plug_service_versions = set([x['service_version'] for x in plugin_services[plugin_name]]) DCNL DCSP  DCSP if plug_service_versions: DCNL DCSP  DCSP  DCSP if (not plug_service_versions.isdisjoint(extra_service_versions)): DCNL DCSP  DCSP  DCSP  DCSP detailed_error = ('Plugin DCSP %s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP %s DCSP already DCSP claimed DCSP by DCSP another DCSP one' % (plugin_name, (extra_service_versions & plug_service_versions))) DCNL DCSP  DCSP  DCSP  DCSP raise exceptions.PluginRegistrationException(name=plugin_name, detailed_error=detailed_error) DCNL DCSP  DCSP  DCSP if (not plug_service_versions.isdisjoint(_tempest_internal_modules())): DCNL DCSP  DCSP  DCSP  DCSP detailed_error = ('Plugin DCSP %s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP %s DCSP already DCSP claimed DCSP by DCSP a DCSP Tempest DCSP one' % (plugin_name, (_tempest_internal_modules() & plug_service_versions))) DCNL DCSP  DCSP  DCSP  DCSP raise exceptions.PluginRegistrationException(name=plugin_name, detailed_error=detailed_error) DCNL DCSP  DCSP extra_service_versions |= plug_service_versions DCNL DCSP return (_tempest_modules | extra_service_versions)
 DCSP if (file is None): DCNL DCSP  DCSP file = sys.stderr DCNL DCSP try: DCNL DCSP  DCSP (etype, value, tb) = sys.exc_info() DCNL DCSP  DCSP print_exception(etype, value, tb, limit, file) DCNL DCSP finally: DCNL DCSP  DCSP etype = value = tb = None
 DCSP if ((nterms == 0) and (not fit_mean)): DCNL DCSP  DCSP raise ValueError('Cannot DCSP have DCSP nterms DCSP = DCSP 0 DCSP without DCSP fitting DCSP bias') DCNL DCSP if (dy is None): DCNL DCSP  DCSP dy = 1 DCNL DCSP (t, y, dy) = np.broadcast_arrays(t, y, dy) DCNL DCSP if (t.ndim != 1): DCNL DCSP  DCSP raise ValueError('t, DCSP y, DCSP dy DCSP should DCSP be DCSP one DCSP dimensional') DCNL DCSP if (f0 < 0): DCNL DCSP  DCSP raise ValueError('Frequencies DCSP must DCSP be DCSP positive') DCNL DCSP if (df <= 0): DCNL DCSP  DCSP raise ValueError('Frequency DCSP steps DCSP must DCSP be DCSP positive') DCNL DCSP if (Nf <= 0): DCNL DCSP  DCSP raise ValueError('Number DCSP of DCSP frequencies DCSP must DCSP be DCSP positive') DCNL DCSP w = (dy ** (-2.0)) DCNL DCSP ws = np.sum(w) DCNL DCSP if (center_data or fit_mean): DCNL DCSP  DCSP y = (y - (np.dot(w, y) / ws)) DCNL DCSP yw = (y / dy) DCNL DCSP chi2_ref = np.dot(yw, yw) DCNL DCSP kwargs = dict.copy((trig_sum_kwds or {})) DCNL DCSP kwargs.update(f0=f0, df=df, use_fft=use_fft, N=Nf) DCNL DCSP yws = np.sum((y * w)) DCNL DCSP SCw = [(np.zeros(Nf), (ws * np.ones(Nf)))] DCNL DCSP SCw.extend([trig_sum(t, w, freq_factor=i, **kwargs) for i in range(1, ((2 * nterms) + 1))]) DCNL DCSP (Sw, Cw) = zip(*SCw) DCNL DCSP SCyw = [(np.zeros(Nf), (yws * np.ones(Nf)))] DCNL DCSP SCyw.extend([trig_sum(t, (w * y), freq_factor=i, **kwargs) for i in range(1, (nterms + 1))]) DCNL DCSP (Syw, Cyw) = zip(*SCyw) DCNL DCSP order = ([('C', 0)] if fit_mean else []) DCNL DCSP order.extend(sum([[('S', i), ('C', i)] for i in range(1, (nterms + 1))], [])) DCNL DCSP funcs = dict(S=(lambda m, i: Syw[m][i]), C=(lambda m, i: Cyw[m][i]), SS=(lambda m, n, i: (0.5 * (Cw[abs((m - n))][i] - Cw[(m + n)][i]))), CC=(lambda m, n, i: (0.5 * (Cw[abs((m - n))][i] + Cw[(m + n)][i]))), SC=(lambda m, n, i: (0.5 * ((np.sign((m - n)) * Sw[abs((m - n))][i]) + Sw[(m + n)][i]))), CS=(lambda m, n, i: (0.5 * ((np.sign((n - m)) * Sw[abs((n - m))][i]) + Sw[(n + m)][i])))) DCNL DCSP def compute_power(i): DCNL DCSP  DCSP XTX = np.array([[funcs[(A[0] + B[0])](A[1], B[1], i) for A in order] for B in order]) DCNL DCSP  DCSP XTy = np.array([funcs[A[0]](A[1], i) for A in order]) DCNL DCSP  DCSP return np.dot(XTy.T, np.linalg.solve(XTX, XTy)) DCNL DCSP p = np.array([compute_power(i) for i in range(Nf)]) DCNL DCSP if (normalization == 'psd'): DCNL DCSP  DCSP p *= 0.5 DCNL DCSP elif (normalization == 'standard'): DCNL DCSP  DCSP p /= chi2_ref DCNL DCSP elif (normalization == 'log'): DCNL DCSP  DCSP p = (- np.log((1 - (p / chi2_ref)))) DCNL DCSP elif (normalization == 'model'): DCNL DCSP  DCSP p /= (chi2_ref - p) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("normalization='{0}' DCSP not DCSP recognized".format(normalization)) DCNL DCSP return p
 DCSP boundaries = [0, 1.1, 2.2] DCNL DCSP vals = [(-1), 0, 1, 2, 2.2, 4] DCNL DCSP expected = [(-1), 0, 0, 1, 2, 2] DCNL DCSP ncolors = (len(boundaries) - 1) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, ncolors) DCNL DCSP assert_array_equal(bn(vals), expected) DCNL DCSP expected = [(-1), 0, 0, 2, 3, 3] DCNL DCSP ncolors = len(boundaries) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, ncolors) DCNL DCSP assert_array_equal(bn(vals), expected) DCNL DCSP boundaries = [0, 1, 2, 3] DCNL DCSP vals = [(-1), 0.1, 1.1, 2.2, 4] DCNL DCSP ncolors = 5 DCNL DCSP expected = [(-1), 0, 2, 4, 5] DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, ncolors) DCNL DCSP assert_array_equal(bn(vals), expected) DCNL DCSP boundaries = [0, 1, 2] DCNL DCSP vals = [(-1), 0.1, 1.1, 2.2] DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, 2) DCNL DCSP expected = [(-1), 0, 1, 2] DCNL DCSP for (v, ex) in zip(vals, expected): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_equal(ret, ex) DCNL DCSP  DCSP assert_array_equal(bn([v]), ex) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, 3) DCNL DCSP expected = [(-1), 0, 2, 3] DCNL DCSP for (v, ex) in zip(vals, expected): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_equal(ret, ex) DCNL DCSP  DCSP assert_array_equal(bn([v]), ex) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, 3, clip=True) DCNL DCSP expected = [0, 0, 2, 2] DCNL DCSP for (v, ex) in zip(vals, expected): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_equal(ret, ex) DCNL DCSP  DCSP assert_array_equal(bn([v]), ex) DCNL DCSP boundaries = [0, 1.1, 2.2] DCNL DCSP vals = np.ma.masked_invalid([(-1.0), np.NaN, 0, 1.4, 9]) DCNL DCSP ncolors = (len(boundaries) - 1) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, ncolors) DCNL DCSP expected = np.ma.masked_array([(-1), (-99), 0, 1, 2], mask=[0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(bn(vals), expected) DCNL DCSP bn = mcolors.BoundaryNorm(boundaries, len(boundaries)) DCNL DCSP expected = np.ma.masked_array([(-1), (-99), 0, 2, 3], mask=[0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(bn(vals), expected) DCNL DCSP vals = np.ma.masked_invalid([np.Inf, np.NaN]) DCNL DCSP assert np.all(bn(vals).mask) DCNL DCSP vals = np.ma.masked_invalid([np.Inf]) DCNL DCSP assert np.all(bn(vals).mask)
 DCSP values = values.copy() DCNL DCSP values['metadata'] = _metadata_refs(values.get('metadata'), models.InstanceMetadata) DCNL DCSP values['system_metadata'] = _metadata_refs(values.get('system_metadata'), models.InstanceSystemMetadata) DCNL DCSP instance_ref = models.Instance() DCNL DCSP if (not values.get('uuid')): DCNL DCSP  DCSP values['uuid'] = str(uuid.uuid4()) DCNL DCSP instance_ref['info_cache'] = models.InstanceInfoCache() DCNL DCSP info_cache = values.pop('info_cache', None) DCNL DCSP if (info_cache is not None): DCNL DCSP  DCSP instance_ref['info_cache'].update(info_cache) DCNL DCSP security_groups = values.pop('security_groups', []) DCNL DCSP instance_ref.update(values) DCNL DCSP def _get_sec_group_models(session, security_groups): DCNL DCSP  DCSP models = [] DCNL DCSP  DCSP (_existed, default_group) = security_group_ensure_default(context, session=session) DCNL DCSP  DCSP if ('default' in security_groups): DCNL DCSP  DCSP  DCSP models.append(default_group) DCNL DCSP  DCSP  DCSP security_groups = [x for x in security_groups if (x != 'default')] DCNL DCSP  DCSP if security_groups: DCNL DCSP  DCSP  DCSP models.extend(_security_group_get_by_names(context, session, context.project_id, security_groups)) DCNL DCSP  DCSP return models DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP if ('hostname' in values): DCNL DCSP  DCSP  DCSP _validate_unique_server_name(context, session, values['hostname']) DCNL DCSP  DCSP instance_ref.security_groups = _get_sec_group_models(session, security_groups) DCNL DCSP  DCSP instance_ref.save(session=session) DCNL DCSP ec2_instance_create(context, instance_ref['uuid']) DCNL DCSP return instance_ref
 DCSP validate_is_mapping('update', update) DCNL DCSP if (not update): DCNL DCSP  DCSP raise ValueError('update DCSP only DCSP works DCSP with DCSP $ DCSP operators') DCNL DCSP first = next(iter(update)) DCNL DCSP if (not first.startswith('$')): DCNL DCSP  DCSP raise ValueError('update DCSP only DCSP works DCSP with DCSP $ DCSP operators')
 DCSP for ch in chunked: DCNL DCSP  DCSP ch.append(u'O') DCNL DCSP for (i, chunk) in enumerate(chunked): DCNL DCSP  DCSP if (chunk[2].endswith(u'PP') and (chunk[(-1)] == u'O')): DCNL DCSP  DCSP  DCSP if ((i < (len(chunked) - 1)) and (chunked[(i + 1)][2].endswith((u'NP', u'PP')) or (chunked[(i + 1)][1] in (u'VBG', u'VBN')))): DCNL DCSP  DCSP  DCSP  DCSP chunk[(-1)] = u'B-PNP' DCNL DCSP  DCSP  DCSP  DCSP pp = True DCNL DCSP  DCSP  DCSP  DCSP for ch in chunked[(i + 1):]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ch[2].endswith((u'NP', u'PP')) or (ch[1] in (u'VBG', u'VBN')))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ch[2].endswith(u'PP') and pp): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ch[(-1)] = u'I-PNP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not ch[2].endswith(u'PP')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ch[(-1)] = u'I-PNP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pp = False DCNL DCSP return chunked
 DCSP args = ops.copy() DCNL DCSP args.update(_dict) DCNL DCSP args.update(kw) DCNL DCSP for (k, v) in list(args.items()): DCNL DCSP  DCSP if hasattr(v, 'im'): DCNL DCSP  DCSP  DCSP args[k] = _Operand(v) DCNL DCSP out = builtins.eval(expression, args) DCNL DCSP try: DCNL DCSP  DCSP return out.im DCNL DCSP except AttributeError: DCNL DCSP  DCSP return out
 DCSP use_numexpr = (use_numexpr and _bool_arith_check(op_str, a, b)) DCNL DCSP if use_numexpr: DCNL DCSP  DCSP return _evaluate(op, op_str, a, b, raise_on_error=raise_on_error, **eval_kwargs) DCNL DCSP return _evaluate_standard(op, op_str, a, b, raise_on_error=raise_on_error)
 DCSP with gzip_open(archive_path, 'wb') as archive: DCNL DCSP  DCSP if os.path.isfile(source_path): DCNL DCSP  DCSP  DCSP with open(source_path, 'rb') as source: DCNL DCSP  DCSP  DCSP  DCSP copyfileobj(source, archive)
 DCSP if ((value_to_mask == 'NaN') or np.isnan(value_to_mask)): DCNL DCSP  DCSP return np.isnan(X) DCNL DCSP else: DCNL DCSP  DCSP return (X == value_to_mask)
 DCSP x = T.ftensor4('inputs') DCNL DCSP ops = [relu_(x).sum(), relu(x).sum(), relu__(x).sum(), T.grad(relu_(x).sum(), x), T.grad(relu(x).sum(), x), T.grad(relu__(x).sum(), x)] DCNL DCSP names = ['fprop_old', 'fprop_alter', 'fprop_alter2', 'grad_old', 'grad_alter', 'grad_alter2'] DCNL DCSP value = numpy.random.uniform(size=(512, 32, 32, 100)).astype(floatX) DCNL DCSP times = [] DCNL DCSP for (op, name) in zip(ops, names): DCNL DCSP  DCSP f = theano.function(inputs=[x], outputs=op, name=name) DCNL DCSP  DCSP n_loops = 10 DCNL DCSP  DCSP t0 = time.time() DCNL DCSP  DCSP for i in range(n_loops): DCNL DCSP  DCSP  DCSP f(value) DCNL DCSP  DCSP t1 = time.time() DCNL DCSP  DCSP benchmark = (t1 - t0) DCNL DCSP  DCSP times.append(benchmark) DCNL DCSP  DCSP print(name) DCNL DCSP  DCSP theano.printing.debugprint(f, print_type=True) DCNL DCSP print(names) DCNL DCSP print(times)
 DCSP open_flag = ((open_for_write and 'c') or 'r') DCNL DCSP sto_filepath = path.join(package_dirpath, PARSER_RESULT_STORE) DCNL DCSP return shelve_open(sto_filepath, flag=open_flag)
 DCSP alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DCNL DCSP if (colx <= 25): DCNL DCSP  DCSP return alphabet[colx] DCNL DCSP else: DCNL DCSP  DCSP (xdiv26, xmod26) = divmod(colx, 26) DCNL DCSP  DCSP return (alphabet[(xdiv26 - 1)] + alphabet[xmod26])
 DCSP if isinstance(b, six.string_types): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if ((b is None) or (b == u'none')): DCNL DCSP  DCSP return None DCNL DCSP if (b in (u't', u'y', u'yes', u'on', u'true', u'1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in (u'f', u'n', u'no', u'off', u'false', u'0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError((u'Could DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
 DCSP if (not hasattr(response, 'seek')): DCNL DCSP  DCSP wrapper_class = get_seek_wrapper_class(response) DCNL DCSP  DCSP response = wrapper_class(response) DCNL DCSP assert hasattr(response, 'get_data') DCNL DCSP return response
 DCSP (suffix, mode, type_) = details DCNL DCSP if (mode and ((not mode.startswith(('r', 'U'))) or ('+' in mode))): DCNL DCSP  DCSP raise ValueError('invalid DCSP file DCSP open DCSP mode DCSP {!r}'.format(mode)) DCNL DCSP elif ((file is None) and (type_ in {PY_SOURCE, PY_COMPILED})): DCNL DCSP  DCSP msg = 'file DCSP object DCSP required DCSP for DCSP import DCSP (type DCSP code DCSP {})'.format(type_) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP elif (type_ == PY_SOURCE): DCNL DCSP  DCSP return load_source(name, filename, file) DCNL DCSP elif (type_ == PY_COMPILED): DCNL DCSP  DCSP return load_compiled(name, filename, file) DCNL DCSP elif ((type_ == C_EXTENSION) and (load_dynamic is not None)): DCNL DCSP  DCSP if (file is None): DCNL DCSP  DCSP  DCSP with open(filename, 'rb') as opened_file: DCNL DCSP  DCSP  DCSP  DCSP return load_dynamic(name, filename, opened_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return load_dynamic(name, filename, file) DCNL DCSP elif (type_ == PKG_DIRECTORY): DCNL DCSP  DCSP return load_package(name, filename) DCNL DCSP elif (type_ == C_BUILTIN): DCNL DCSP  DCSP return init_builtin(name) DCNL DCSP elif (type_ == PY_FROZEN): DCNL DCSP  DCSP return init_frozen(name) DCNL DCSP else: DCNL DCSP  DCSP msg = "Don't DCSP know DCSP how DCSP to DCSP import DCSP {} DCSP (type DCSP code DCSP {})".format(name, type_) DCNL DCSP  DCSP raise ImportError(msg, name=name)
 DCSP def _iterate(test_suite_or_case): DCNL DCSP  DCSP 'Iterate DCSP through DCSP all DCSP the DCSP test DCSP cases DCSP in DCSP `test_suite_or_case`.' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP suite = iter(test_suite_or_case) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP (yield test_suite_or_case) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for test in suite: DCNL DCSP  DCSP  DCSP  DCSP for subtest in _iterate(test): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield subtest) DCNL DCSP feconf.PLATFORM = 'gae' DCNL DCSP for directory in DIRS_TO_ADD_TO_SYS_PATH: DCNL DCSP  DCSP if (not os.path.exists(os.path.dirname(directory))): DCNL DCSP  DCSP  DCSP raise Exception(('Directory DCSP %s DCSP does DCSP not DCSP exist.' % directory)) DCNL DCSP  DCSP sys.path.insert(0, directory) DCNL DCSP import dev_appserver DCNL DCSP dev_appserver.fix_sys_path() DCNL DCSP parsed_args = _PARSER.parse_args() DCNL DCSP suites = create_test_suites(parsed_args.test_target) DCNL DCSP results = [unittest.TextTestRunner(verbosity=2).run(suite) for suite in suites] DCNL DCSP tests_run = 0 DCNL DCSP for result in results: DCNL DCSP  DCSP tests_run += result.testsRun DCNL DCSP  DCSP if (result.errors or result.failures): DCNL DCSP  DCSP  DCSP raise Exception(('Test DCSP suite DCSP failed: DCSP %s DCSP tests DCSP run, DCSP %s DCSP errors, DCSP %s DCSP failures.' % (result.testsRun, len(result.errors), len(result.failures)))) DCNL DCSP if (tests_run == 0): DCNL DCSP  DCSP raise Exception('No DCSP tests DCSP were DCSP run.')
 DCSP if (not ccx): DCNL DCSP  DCSP raise Http404 DCNL DCSP action = request.POST.get('enrollment-button') DCNL DCSP identifiers_raw = request.POST.get('student-ids') DCNL DCSP identifiers = _split_input_list(identifiers_raw) DCNL DCSP email_students = ('email-students' in request.POST) DCNL DCSP course_key = CCXLocator.from_course_locator(course.id, unicode(ccx.id)) DCNL DCSP email_params = get_email_params(course, auto_enroll=True, course_key=course_key, display_name=ccx.display_name) DCNL DCSP ccx_students_enrolling_center(action, identifiers, email_students, course_key, email_params, ccx.coach) DCNL DCSP url = reverse('ccx_coach_dashboard', kwargs={'course_id': course_key}) DCNL DCSP return redirect(url)
 DCSP if (enum is None): DCNL DCSP  DCSP return num DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return socket.AddressType(num) DCNL DCSP  DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP  DCSP return num
 DCSP return (token[:3] == PKI_ASN1_PREFIX)
 DCSP records = [] DCNL DCSP if (python_dict or idict): DCNL DCSP  DCSP variables = {} DCNL DCSP else: DCNL DCSP  DCSP variables = AttrDict() DCNL DCSP f = open(file_name, 'rb') DCNL DCSP signature = _read_bytes(f, 2) DCNL DCSP if (signature != 'SR'): DCNL DCSP  DCSP raise Exception(('Invalid DCSP SIGNATURE: DCSP %s' % signature)) DCNL DCSP recfmt = _read_bytes(f, 2) DCNL DCSP if (recfmt == '\x00\x04'): DCNL DCSP  DCSP pass DCNL DCSP elif (recfmt == '\x00\x06'): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print('IDL DCSP Save DCSP file DCSP is DCSP compressed') DCNL DCSP  DCSP if uncompressed_file_name: DCNL DCSP  DCSP  DCSP fout = open(uncompressed_file_name, 'w+b') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fout = tempfile.NamedTemporaryFile(suffix='.sav') DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print((' DCSP -> DCSP expanding DCSP to DCSP %s' % fout.name)) DCNL DCSP  DCSP fout.write('SR\x00\x04') DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP rectype = _read_long(f) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>l', int(rectype))) DCNL DCSP  DCSP  DCSP nextrec = _read_uint32(f) DCNL DCSP  DCSP  DCSP nextrec += (_read_uint32(f) * (2 ** 32)) DCNL DCSP  DCSP  DCSP unknown = f.read(4) DCNL DCSP  DCSP  DCSP if (RECTYPE_DICT[rectype] == 'END_MARKER'): DCNL DCSP  DCSP  DCSP  DCSP fout.write(struct.pack('>I', (int(nextrec) % (2 ** 32)))) DCNL DCSP  DCSP  DCSP  DCSP fout.write(struct.pack('>I', int(((nextrec - (nextrec % (2 ** 32))) / (2 ** 32))))) DCNL DCSP  DCSP  DCSP  DCSP fout.write(unknown) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP pos = f.tell() DCNL DCSP  DCSP  DCSP rec_string = zlib.decompress(f.read((nextrec - pos))) DCNL DCSP  DCSP  DCSP nextrec = ((fout.tell() + len(rec_string)) + 12) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>I', int((nextrec % (2 ** 32))))) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>I', int(((nextrec - (nextrec % (2 ** 32))) / (2 ** 32))))) DCNL DCSP  DCSP  DCSP fout.write(unknown) DCNL DCSP  DCSP  DCSP fout.write(rec_string) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP f = fout DCNL DCSP  DCSP f.seek(4) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invalid DCSP RECFMT: DCSP %s' % recfmt)) DCNL DCSP while True: DCNL DCSP  DCSP r = _read_record(f) DCNL DCSP  DCSP records.append(r) DCNL DCSP  DCSP if ('end' in r): DCNL DCSP  DCSP  DCSP if r['end']: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP f.close() DCNL DCSP heap = {} DCNL DCSP for r in records: DCNL DCSP  DCSP if (r['rectype'] == 'HEAP_DATA'): DCNL DCSP  DCSP  DCSP heap[r['heap_index']] = r['data'] DCNL DCSP for r in records: DCNL DCSP  DCSP if (r['rectype'] == 'VARIABLE'): DCNL DCSP  DCSP  DCSP (replace, new) = _replace_heap(r['data'], heap) DCNL DCSP  DCSP  DCSP if replace: DCNL DCSP  DCSP  DCSP  DCSP r['data'] = new DCNL DCSP  DCSP  DCSP variables[r['varname'].lower()] = r['data'] DCNL DCSP if verbose: DCNL DCSP  DCSP for record in records: DCNL DCSP  DCSP  DCSP if (record['rectype'] == 'TIMESTAMP'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Date: DCSP %s' % record['date'])) DCNL DCSP  DCSP  DCSP  DCSP print(('User: DCSP %s' % record['user'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Host: DCSP %s' % record['host'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for record in records: DCNL DCSP  DCSP  DCSP if (record['rectype'] == 'VERSION'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Format: DCSP %s' % record['format'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Architecture: DCSP %s' % record['arch'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Operating DCSP System: DCSP %s' % record['os'])) DCNL DCSP  DCSP  DCSP  DCSP print(('IDL DCSP Version: DCSP %s' % record['release'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for record in records: DCNL DCSP  DCSP  DCSP if (record['rectype'] == 'IDENTIFICATON'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Author: DCSP %s' % record['author'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Title: DCSP %s' % record['title'])) DCNL DCSP  DCSP  DCSP  DCSP print(('ID DCSP Code: DCSP %s' % record['idcode'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for record in records: DCNL DCSP  DCSP  DCSP if (record['rectype'] == 'DESCRIPTION'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Description: DCSP %s' % record['description'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP print(('Successfully DCSP read DCSP %i DCSP records DCSP of DCSP which:' % len(records))) DCNL DCSP  DCSP rectypes = [r['rectype'] for r in records] DCNL DCSP  DCSP for rt in set(rectypes): DCNL DCSP  DCSP  DCSP if (rt != 'END_MARKER'): DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP - DCSP %i DCSP are DCSP of DCSP type DCSP %s' % (rectypes.count(rt), rt))) DCNL DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP if ('VARIABLE' in rectypes): DCNL DCSP  DCSP  DCSP print('Available DCSP variables:') DCNL DCSP  DCSP  DCSP for var in variables: DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP - DCSP %s DCSP [%s]' % (var, type(variables[var])))) DCNL DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP if idict: DCNL DCSP  DCSP for var in variables: DCNL DCSP  DCSP  DCSP idict[var] = variables[var] DCNL DCSP  DCSP return idict DCNL DCSP else: DCNL DCSP  DCSP return variables
 DCSP if (in_bash() and string): DCNL DCSP  DCSP return '"{0}"'.format(string) DCNL DCSP return string
 DCSP if engine.policies: DCNL DCSP  DCSP redaction_filter = RedactionFilter(engine) DCNL DCSP  DCSP for handler in logger.handlers: DCNL DCSP  DCSP  DCSP handler.addFilter(redaction_filter)
 DCSP return ('%s.%s:%d' % (model._meta.app_label, model._meta.model_name, getattr(instance_or_pk, 'pk', instance_or_pk)))
 DCSP if (boundary is None): DCNL DCSP  DCSP boundary = ('---------------WerkzeugFormPart_%s%s' % (time(), random())) DCNL DCSP _closure = [BytesIO(), 0, False] DCNL DCSP if use_tempfile: DCNL DCSP  DCSP def write_binary(string): DCNL DCSP  DCSP  DCSP (stream, total_length, on_disk) = _closure DCNL DCSP  DCSP  DCSP if on_disk: DCNL DCSP  DCSP  DCSP  DCSP stream.write(string) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP length = len(string) DCNL DCSP  DCSP  DCSP  DCSP if ((length + _closure[1]) <= threshold): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stream.write(string) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream = TemporaryFile('wb+') DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream.write(stream.getvalue()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream.write(string) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _closure[0] = new_stream DCNL DCSP  DCSP  DCSP  DCSP  DCSP _closure[2] = True DCNL DCSP  DCSP  DCSP  DCSP _closure[1] = (total_length + length) DCNL DCSP else: DCNL DCSP  DCSP write_binary = _closure[0].write DCNL DCSP def write(string): DCNL DCSP  DCSP write_binary(string.encode(charset)) DCNL DCSP if (not isinstance(values, MultiDict)): DCNL DCSP  DCSP values = MultiDict(values) DCNL DCSP for (key, values) in iterlists(values): DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP write(('--%s\r\nContent-Disposition: DCSP form-data; DCSP name="%s"' % (boundary, key))) DCNL DCSP  DCSP  DCSP reader = getattr(value, 'read', None) DCNL DCSP  DCSP  DCSP if (reader is not None): DCNL DCSP  DCSP  DCSP  DCSP filename = getattr(value, 'filename', getattr(value, 'name', None)) DCNL DCSP  DCSP  DCSP  DCSP content_type = getattr(value, 'content_type', None) DCNL DCSP  DCSP  DCSP  DCSP if (content_type is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP content_type = ((filename and mimetypes.guess_type(filename)[0]) or 'application/octet-stream') DCNL DCSP  DCSP  DCSP  DCSP if (filename is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write(('; DCSP filename="%s"\r\n' % filename)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write('\r\n') DCNL DCSP  DCSP  DCSP  DCSP write(('Content-Type: DCSP %s\r\n\r\n' % content_type)) DCNL DCSP  DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chunk = reader(16384) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not chunk): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_binary(chunk) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, string_types)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = str(value) DCNL DCSP  DCSP  DCSP  DCSP value = to_bytes(value, charset) DCNL DCSP  DCSP  DCSP  DCSP write('\r\n\r\n') DCNL DCSP  DCSP  DCSP  DCSP write_binary(value) DCNL DCSP  DCSP  DCSP write('\r\n') DCNL DCSP write(('--%s--\r\n' % boundary)) DCNL DCSP length = int(_closure[0].tell()) DCNL DCSP _closure[0].seek(0) DCNL DCSP return (_closure[0], length, boundary)
 DCSP cuda_dict = dict(use_cuda=False, fft_plan=None, ifft_plan=None, x_fft=None, x=None, y_fft=None, y=None) DCNL DCSP (n_fft_x, n_fft_y) = (len(W), new_len) DCNL DCSP cuda_fft_len_x = int((((n_fft_x - (n_fft_x % 2)) // 2) + 1)) DCNL DCSP cuda_fft_len_y = int((((n_fft_y - (n_fft_y % 2)) // 2) + 1)) DCNL DCSP if (n_jobs == 'cuda'): DCNL DCSP  DCSP n_jobs = 1 DCNL DCSP  DCSP init_cuda() DCNL DCSP  DCSP if _cuda_capable: DCNL DCSP  DCSP  DCSP from pycuda import gpuarray DCNL DCSP  DCSP  DCSP cudafft = _get_cudafft() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP W = gpuarray.to_gpu((W[:cuda_fft_len_x].astype('complex_') / n_fft_y)) DCNL DCSP  DCSP  DCSP  DCSP cuda_dict.update(use_cuda=True, fft_plan=cudafft.Plan(n_fft_x, np.float64, np.complex128), ifft_plan=cudafft.Plan(n_fft_y, np.complex128, np.float64), x_fft=gpuarray.zeros(max(cuda_fft_len_x, cuda_fft_len_y), np.complex128), x=gpuarray.empty(max(int(n_fft_x), int(n_fft_y)), np.float64)) DCNL DCSP  DCSP  DCSP  DCSP logger.info('Using DCSP CUDA DCSP for DCSP FFT DCSP resampling') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP logger.info('CUDA DCSP not DCSP used, DCSP could DCSP not DCSP instantiate DCSP memory DCSP (arrays DCSP may DCSP be DCSP too DCSP large), DCSP falling DCSP back DCSP to DCSP n_jobs=1') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('CUDA DCSP not DCSP used, DCSP CUDA DCSP could DCSP not DCSP be DCSP initialized, DCSP falling DCSP back DCSP to DCSP n_jobs=1') DCNL DCSP return (n_jobs, cuda_dict, W)
 DCSP if (not batch_size): DCNL DCSP  DCSP batch_size = FLAGS.batch_size DCNL DCSP with tf.device('/cpu:0'): DCNL DCSP  DCSP (images, labels) = batch_inputs(dataset, batch_size, train=True, num_preprocess_threads=num_preprocess_threads, num_readers=FLAGS.num_readers) DCNL DCSP return (images, labels)
 DCSP target = (target or 'gl2') DCNL DCSP target = target.replace('+', 'plus') DCNL DCSP (target, _, options) = target.partition(' DCSP ') DCNL DCSP debug = (config['gl_debug'] or ('debug' in options)) DCNL DCSP try: DCNL DCSP  DCSP mod = __import__(target, globals(), level=1) DCNL DCSP except ImportError as err: DCNL DCSP  DCSP msg = ('Could DCSP not DCSP import DCSP gl DCSP target DCSP "%s":\n%s' % (target, str(err))) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP global current_backend DCNL DCSP current_backend = mod DCNL DCSP _clear_namespace() DCNL DCSP if ('plus' in target): DCNL DCSP  DCSP _copy_gl_functions(mod._pyopengl2, globals()) DCNL DCSP  DCSP _copy_gl_functions(mod, globals(), True) DCNL DCSP elif debug: DCNL DCSP  DCSP _copy_gl_functions(_debug_proxy, globals()) DCNL DCSP else: DCNL DCSP  DCSP _copy_gl_functions(mod, globals())
 DCSP mod = fn.module DCNL DCSP fnty = fn.type.pointee DCNL DCSP consts = [lc.MetaDataString.get(mod, str(a)) for a in fnty.args] DCNL DCSP name = lc.MetaDataString.get(mod, 'kernel_arg_base_type') DCNL DCSP return lc.MetaData.get(mod, ([name] + consts))
 DCSP request_url = base_url.format(token, method_name) DCNL DCSP logger.debug('Request: DCSP method={0} DCSP url={1} DCSP params={2} DCSP files={3}'.format(method, request_url, params, files)) DCNL DCSP read_timeout = READ_TIMEOUT DCNL DCSP connect_timeout = CONNECT_TIMEOUT DCNL DCSP if params: DCNL DCSP  DCSP if ('timeout' in params): DCNL DCSP  DCSP  DCSP read_timeout = (params['timeout'] + 10) DCNL DCSP  DCSP if ('connect-timeout' in params): DCNL DCSP  DCSP  DCSP connect_timeout = (params['connect-timeout'] + 10) DCNL DCSP result = req_session.request(method, request_url, params=params, files=files, timeout=(connect_timeout, read_timeout)) DCNL DCSP logger.debug("The DCSP server DCSP returned: DCSP '{0}'".format(result.text.encode('utf8'))) DCNL DCSP return _check_result(method_name, result)['result']
 DCSP return UnspacedList(RawNginxParser(source).as_list())
 DCSP if ((size is None) and (footprint is None) and (structure is None)): DCNL DCSP  DCSP raise ValueError('size, DCSP footprint DCSP or DCSP structure DCSP must DCSP be DCSP specified') DCNL DCSP if (structure is not None): DCNL DCSP  DCSP structure = numpy.asarray(structure) DCNL DCSP  DCSP structure = structure[tuple(([slice(None, None, (-1))] * structure.ndim))] DCNL DCSP if (footprint is not None): DCNL DCSP  DCSP footprint = numpy.asarray(footprint) DCNL DCSP  DCSP footprint = footprint[tuple(([slice(None, None, (-1))] * footprint.ndim))] DCNL DCSP input = numpy.asarray(input) DCNL DCSP origin = _ni_support._normalize_sequence(origin, input.ndim) DCNL DCSP for ii in range(len(origin)): DCNL DCSP  DCSP origin[ii] = (- origin[ii]) DCNL DCSP  DCSP if (footprint is not None): DCNL DCSP  DCSP  DCSP sz = footprint.shape[ii] DCNL DCSP  DCSP elif (structure is not None): DCNL DCSP  DCSP  DCSP sz = structure.shape[ii] DCNL DCSP  DCSP elif numpy.isscalar(size): DCNL DCSP  DCSP  DCSP sz = size DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sz = size[ii] DCNL DCSP  DCSP if (not (sz & 1)): DCNL DCSP  DCSP  DCSP origin[ii] -= 1 DCNL DCSP return filters._min_or_max_filter(input, size, footprint, structure, output, mode, cval, origin, 0)
 DCSP countCols = 0 DCNL DCSP attrs = {} DCNL DCSP for col in cls._imdbpySchema.cols: DCNL DCSP  DCSP countCols += 1 DCNL DCSP  DCSP if (col.name == 'id'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not col.foreignKey): DCNL DCSP  DCSP  DCSP attrs[col.name] = MAP_COLS[col.kind](**col.params) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP thisColName = col.name DCNL DCSP  DCSP if thisColName.endswith('ID'): DCNL DCSP  DCSP  DCSP thisColName = thisColName[:(-2)] DCNL DCSP  DCSP fks = col.foreignKey.split('.', 1) DCNL DCSP  DCSP foreignTableName = fks[0] DCNL DCSP  DCSP if (len(fks) == 2): DCNL DCSP  DCSP  DCSP foreignColName = fks[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP foreignColName = 'id' DCNL DCSP  DCSP fk = ForeignKey(foreignTableName, name=thisColName, default=None) DCNL DCSP  DCSP attrs[thisColName] = fk DCNL DCSP newcls = type(fakeTableName, (SQLObject,), attrs) DCNL DCSP return newcls
 DCSP try: DCNL DCSP  DCSP port = context.session.query(models_v2.Port).enable_eagerloads(False).filter_by(id=port_id).with_lockmode('update').one() DCNL DCSP  DCSP binding = context.session.query(models.PortBinding).enable_eagerloads(False).filter_by(port_id=port_id).with_lockmode('update').one() DCNL DCSP  DCSP return (port, binding) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return (None, None)
 DCSP parens = 0 DCNL DCSP need_space = False DCNL DCSP prev_type = tokenize.OP DCNL DCSP prev_text = prev_end = None DCNL DCSP for (token_type, text, start, end, line) in tokens: DCNL DCSP  DCSP if (token_type in (tokenize.NL, tokenize.NEWLINE, tokenize.ERRORTOKEN)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (text in ('(', 'lambda')): DCNL DCSP  DCSP  DCSP parens += 1 DCNL DCSP  DCSP elif (text == ')'): DCNL DCSP  DCSP  DCSP parens -= 1 DCNL DCSP  DCSP if need_space: DCNL DCSP  DCSP  DCSP if (start != prev_end): DCNL DCSP  DCSP  DCSP  DCSP if ((need_space is not True) and (not need_space[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (need_space[0], 'E225 DCSP missing DCSP whitespace DCSP around DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP need_space = False DCNL DCSP  DCSP  DCSP elif ((text == '>') and (prev_text in ('<', '-'))): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if ((need_space is True) or need_space[1]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (prev_end, 'E225 DCSP missing DCSP whitespace DCSP around DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (code, optype) = ('E226', 'arithmetic') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (prev_text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (code, optype) = ('E228', 'modulo') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (prev_text not in ARITHMETIC_OP): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (code, optype) = ('E227', 'bitwise DCSP or DCSP shift') DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (need_space[0], ('%s DCSP missing DCSP whitespace DCSP around DCSP %s DCSP operator' % (code, optype)))) DCNL DCSP  DCSP  DCSP  DCSP need_space = False DCNL DCSP  DCSP elif ((token_type == tokenize.OP) and (prev_end is not None)): DCNL DCSP  DCSP  DCSP if ((text == '=') and parens): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (text in WS_NEEDED_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP need_space = True DCNL DCSP  DCSP  DCSP elif (text in UNARY_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP if (prev_type == tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_text in '}])') DCNL DCSP  DCSP  DCSP  DCSP elif (prev_type == tokenize.NAME): DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_text not in KEYWORDS) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_type not in SKIP_TOKENS) DCNL DCSP  DCSP  DCSP  DCSP if binary_usage: DCNL DCSP  DCSP  DCSP  DCSP  DCSP need_space = None DCNL DCSP  DCSP  DCSP elif (text in WS_OPTIONAL_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP need_space = None DCNL DCSP  DCSP  DCSP if (need_space is None): DCNL DCSP  DCSP  DCSP  DCSP need_space = (prev_end, (start != prev_end)) DCNL DCSP  DCSP  DCSP elif (need_space and (start == prev_end)): DCNL DCSP  DCSP  DCSP  DCSP (yield (prev_end, 'E225 DCSP missing DCSP whitespace DCSP around DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP need_space = False DCNL DCSP  DCSP prev_type = token_type DCNL DCSP  DCSP prev_text = text DCNL DCSP  DCSP prev_end = end
 DCSP return None
 DCSP mlp = MLP(layers=[Linear(layer_name='h', dim=5, irange=0.01, max_col_norm=0.01)]) DCNL DCSP conditional = DiagonalGaussian(mlp=mlp, name='conditional') DCNL DCSP vae = DummyVAE() DCNL DCSP conditional.set_vae(vae) DCNL DCSP input_space = VectorSpace(dim=5) DCNL DCSP conditional.initialize_parameters(input_space=input_space, ndim=5) DCNL DCSP conditional.sample_from_epsilon((2, 10, 5))
 DCSP return _from_text(text, _edns_by_text)
 DCSP if (not isinstance(value, datetime.date)): DCNL DCSP  DCSP raise TypeError(('Cannot DCSP convert DCSP to DCSP datetime DCSP expected DCSP date DCSP value; DCSP received DCSP %s' % value)) DCNL DCSP return datetime.datetime(value.year, value.month, value.day)
 DCSP registrations = models.Node.find(Q('is_registration', 'eq', True)) DCNL DCSP for registration in registrations: DCNL DCSP  DCSP meta = (registration.registered_meta or {}) DCNL DCSP  DCSP keys = meta.keys() DCNL DCSP  DCSP if (len(keys) != 1): DCNL DCSP  DCSP  DCSP print 'Inconsistency: DCSP Number DCSP of DCSP keys DCSP on DCSP project DCSP {} DCSP ({}) DCSP != DCSP 1'.format(registration.title, registration._primary_key) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (keys[0] not in known_schemas): DCNL DCSP  DCSP  DCSP print 'Inconsistency: DCSP Registration DCSP schema DCSP {} DCSP on DCSP project DCSP {} DCSP ({}) DCSP not DCSP in DCSP known DCSP schemas'.format(keys[0], registration.title, registration._primary_key)
 DCSP xml = to_xml(output) DCNL DCSP n = int(n) DCNL DCSP num_elements = len(xml.findall(path)) DCNL DCSP if (num_elements != n): DCNL DCSP  DCSP errmsg = ('Expected DCSP to DCSP find DCSP %d DCSP elements DCSP with DCSP path DCSP %s, DCSP but DCSP %d DCSP were DCSP found.' % (n, path, num_elements)) DCNL DCSP  DCSP raise AssertionError(errmsg)
 DCSP with patch.object(_LOGGER, 'warning') as mock_warn: DCNL DCSP  DCSP Config(None, {'type': 'google_home', 'host_ip': '123.123.123.123', 'listen_port': 8300}) DCNL DCSP  DCSP assert mock_warn.called DCNL DCSP  DCSP assert (mock_warn.mock_calls[0][1][0] == 'When DCSP targetting DCSP Google DCSP Home, DCSP listening DCSP port DCSP has DCSP to DCSP be DCSP port DCSP 80')
 DCSP r = tied_rank(posterior) DCNL DCSP num_positive = len([0 for x in actual if (x == 1)]) DCNL DCSP num_negative = (len(actual) - num_positive) DCNL DCSP sum_positive = sum([r[i] for i in range(len(r)) if (actual[i] == 1)]) DCNL DCSP auc = ((sum_positive - ((num_positive * (num_positive + 1)) / 2.0)) / (num_negative * num_positive)) DCNL DCSP return auc
 DCSP if (derivation.topBevel <= 0.0): DCNL DCSP  DCSP return DCNL DCSP bottom = (derivation.height - derivation.topBevel) DCNL DCSP top = derivation.height DCNL DCSP groove = [complex(x, bottom), complex((x - derivation.topBevel), top), complex((x + derivation.topBevel), top)] DCNL DCSP triangle_mesh.addSymmetricYPath(negatives, groove, (1.0001 * derivation.topRight.imag))
 DCSP return apiproxy_stub_map.apiproxy.GetStub('channel')
 DCSP assert context.table, 'REQUIRE: DCSP context.table' DCNL DCSP context.table.require_columns(['name', 'tags']) DCNL DCSP model_element_names = set() DCNL DCSP model_elements = [] DCNL DCSP for row in context.table.rows: DCNL DCSP  DCSP name = row['name'].strip() DCNL DCSP  DCSP tags = convert_model_element_tags(row['tags']) DCNL DCSP  DCSP assert (name not in model_element_names), ('DUPLICATED: DCSP name=%s' % name) DCNL DCSP  DCSP model_elements.append(ModelElement(name, tags=tags)) DCNL DCSP  DCSP model_element_names.add(name) DCNL DCSP context.model_elements = model_elements
 DCSP if (barcode_type == 'variable_length'): DCNL DCSP  DCSP var_len_barcodes = True DCNL DCSP else: DCNL DCSP  DCSP var_len_barcodes = False DCNL DCSP if (barcode_type == '0'): DCNL DCSP  DCSP has_barcodes = False DCNL DCSP (hds, mapping_data, run_description, errors, warnings) = process_id_map(infile, has_barcodes=has_barcodes, disable_primer_check=disable_primer_check, added_demultiplex_field=added_demultiplex_field, variable_len_barcodes=var_len_barcodes) DCNL DCSP if errors: DCNL DCSP  DCSP raise ValueError((('Errors DCSP were DCSP found DCSP with DCSP mapping DCSP file, DCSP ' + 'please DCSP run DCSP validate_mapping_file.py DCSP to DCSP ') + 'identify DCSP problems.')) DCNL DCSP id_map = {} DCNL DCSP for curr_data in mapping_data: DCNL DCSP  DCSP id_map[curr_data[0]] = {} DCNL DCSP for header in range(len(hds)): DCNL DCSP  DCSP for curr_data in mapping_data: DCNL DCSP  DCSP  DCSP id_map[curr_data[0]][hds[header]] = curr_data[header] DCNL DCSP barcode_to_sample_id = {} DCNL DCSP primer_seqs_lens = {} DCNL DCSP all_primers = {} DCNL DCSP for (sample_id, sample) in id_map.items(): DCNL DCSP  DCSP if added_demultiplex_field: DCNL DCSP  DCSP  DCSP barcode_to_sample_id[((sample['BarcodeSequence'].upper() + ',') + sample[added_demultiplex_field])] = sample_id DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP barcode_to_sample_id[sample['BarcodeSequence'].upper()] = sample_id DCNL DCSP  DCSP if (not disable_primer_check): DCNL DCSP  DCSP  DCSP raw_primers = sample['LinkerPrimerSequence'].upper().split(',') DCNL DCSP  DCSP  DCSP if (len(raw_primers[0].strip()) == 0): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP primers DCSP detected, DCSP please DCSP use DCSP the DCSP ' + '-p DCSP parameter DCSP to DCSP disable DCSP primer DCSP detection.')) DCNL DCSP  DCSP  DCSP expanded_primers = expand_degeneracies(raw_primers) DCNL DCSP  DCSP  DCSP curr_bc_primers = {} DCNL DCSP  DCSP  DCSP for primer in expanded_primers: DCNL DCSP  DCSP  DCSP  DCSP curr_bc_primers[primer] = len(primer) DCNL DCSP  DCSP  DCSP  DCSP all_primers[primer] = len(primer) DCNL DCSP  DCSP  DCSP primer_seqs_lens[sample['BarcodeSequence']] = curr_bc_primers DCNL DCSP return (hds, id_map, barcode_to_sample_id, warnings, errors, primer_seqs_lens, all_primers)
 DCSP template = get_templates()[name] DCNL DCSP local_path = template[u'local_path'] DCNL DCSP if (not os.path.exists(local_path)): DCNL DCSP  DCSP project_root = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP  DCSP local_path = os.path.join(project_root, local_path) DCNL DCSP remote_path = template[u'remote_path'] DCNL DCSP reload_command = template.get(u'reload_command') DCNL DCSP owner = template.get(u'owner') DCNL DCSP mode = template.get(u'mode') DCNL DCSP remote_data = u'' DCNL DCSP if exists(remote_path): DCNL DCSP  DCSP with hide(u'stdout'): DCNL DCSP  DCSP  DCSP remote_data = sudo((u'cat DCSP %s' % remote_path), show=False) DCNL DCSP with open(local_path, u'r') as f: DCNL DCSP  DCSP local_data = f.read() DCNL DCSP  DCSP local_data = re.sub(u'%(?!\\(\\w+\\)s)', u'%%', local_data) DCNL DCSP  DCSP if (u'%(db_pass)s' in local_data): DCNL DCSP  DCSP  DCSP env.db_pass = db_pass() DCNL DCSP  DCSP local_data %= env DCNL DCSP clean = (lambda s: s.replace(u'\n', u'').replace(u'\r', u'').strip()) DCNL DCSP if (clean(remote_data) == clean(local_data)): DCNL DCSP  DCSP return DCNL DCSP upload_template(local_path, remote_path, env, use_sudo=True, backup=False) DCNL DCSP if owner: DCNL DCSP  DCSP sudo((u'chown DCSP %s DCSP %s' % (owner, remote_path))) DCNL DCSP if mode: DCNL DCSP  DCSP sudo((u'chmod DCSP %s DCSP %s' % (mode, remote_path))) DCNL DCSP if reload_command: DCNL DCSP  DCSP sudo(reload_command)
 DCSP root = testdir.tmpdir DCNL DCSP src = root.join('src').ensure(dir=1) DCNL DCSP src.join('pytest.ini').write('[pytest]') DCNL DCSP src.join('conftest.py').write(_pytest._code.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP pytest\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @pytest.fixture\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP fix1(): DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP src.join('test_foo.py').write(_pytest._code.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP test_1(fix1):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP test_2(out_of_reach):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP root.join('conftest.py').write(_pytest._code.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP pytest\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @pytest.fixture\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP out_of_reach(): DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP args = [str(src)] DCNL DCSP if confcutdir: DCNL DCSP  DCSP args = [('--confcutdir=%s' % root.join(confcutdir))] DCNL DCSP result = testdir.runpytest(*args) DCNL DCSP match = '' DCNL DCSP if passed: DCNL DCSP  DCSP match += ('*%d DCSP passed*' % passed) DCNL DCSP if error: DCNL DCSP  DCSP match += ('*%d DCSP error*' % error) DCNL DCSP result.stdout.fnmatch_lines(match)
 DCSP country_code = numobj.country_code DCNL DCSP if (region_code is None): DCNL DCSP  DCSP return False DCNL DCSP metadata = PhoneMetadata.metadata_for_region_or_calling_code(country_code, region_code.upper()) DCNL DCSP if ((metadata is None) or ((region_code != REGION_CODE_FOR_NON_GEO_ENTITY) and (country_code != country_code_for_valid_region(region_code)))): DCNL DCSP  DCSP return False DCNL DCSP nsn = national_significant_number(numobj) DCNL DCSP return (_number_type_helper(nsn, metadata) != PhoneNumberType.UNKNOWN)
 DCSP shape = (4, 5, 9) DCNL DCSP a = cuda_ndarray.CudaNdarray(theano._asarray(numpy.random.rand(*shape), dtype='float32')) DCNL DCSP a = theano._asarray(numpy.random.rand(*shape), dtype='float32') DCNL DCSP a2 = tcn.shared_constructor(a, 'a') DCNL DCSP a3 = a2.dimshuffle(0, 'x', 1, 2) DCNL DCSP b = tcn.CudaNdarrayType((False, False, False, False))() DCNL DCSP c = (a3 + b) DCNL DCSP f = pfunc([b], [c], mode=mode_with_gpu) DCNL DCSP v = theano._asarray(numpy.random.rand(shape[0], 5, *shape[1:]), dtype='float32') DCNL DCSP v = cuda_ndarray.CudaNdarray(v) DCNL DCSP out = f(v)[0] DCNL DCSP assert numpy.allclose(out, (a.reshape(shape[0], 1, *shape[1:]) + v))
 DCSP if (not text): DCNL DCSP  DCSP return False DCNL DCSP badTriggersOcc = [] DCNL DCSP nbLines = text.count('\n') DCNL DCSP if (nbLines <= 1): DCNL DCSP  DCSP log.debug(u"Ignoring DCSP too DCSP short DCSP lyrics DCSP '{0}'".format(text)) DCNL DCSP  DCSP return False DCNL DCSP elif (nbLines < 5): DCNL DCSP  DCSP badTriggersOcc.append('too_short') DCNL DCSP else: DCNL DCSP  DCSP text = remove_credits(text) DCNL DCSP badTriggers = ['lyrics', 'copyright', 'property', 'links'] DCNL DCSP if artist: DCNL DCSP  DCSP badTriggersOcc += [artist] DCNL DCSP for item in badTriggers: DCNL DCSP  DCSP badTriggersOcc += ([item] * len(re.findall(('\\W%s\\W' % item), text, re.I))) DCNL DCSP if badTriggersOcc: DCNL DCSP  DCSP log.debug(u'Bad DCSP triggers DCSP detected: DCSP {0}'.format(badTriggersOcc)) DCNL DCSP return (len(badTriggersOcc) < 2)
 DCSP evoked = evoked.copy() DCNL DCSP if (ch_type not in ['mag', 'grad']): DCNL DCSP  DCSP raise ValueError(('to_type DCSP must DCSP be DCSP "mag" DCSP or DCSP "grad", DCSP not DCSP "%s"' % ch_type)) DCNL DCSP pick_from = pick_types(evoked.info, meg=True, eeg=False, ref_meg=False) DCNL DCSP pick_to = pick_types(evoked.info, meg=ch_type, eeg=False, ref_meg=False) DCNL DCSP if (len(pick_to) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP channels DCSP matching DCSP the DCSP destination DCSP channel DCSP type DCSP found DCSP in DCSP info. DCSP Please DCSP pass DCSP an DCSP evoked DCSP containingboth DCSP the DCSP original DCSP and DCSP destination DCSP channels. DCSP Only DCSP the DCSP locations DCSP of DCSP the DCSP destination DCSP channels DCSP will DCSP be DCSP used DCSP for DCSP interpolation.') DCNL DCSP info_from = pick_info(evoked.info, pick_from) DCNL DCSP info_to = pick_info(evoked.info, pick_to) DCNL DCSP mapping = _map_meg_channels(info_from, info_to, mode=mode) DCNL DCSP data = np.dot(mapping, evoked.data[pick_from]) DCNL DCSP evoked.pick_types(meg=ch_type, eeg=False, ref_meg=False) DCNL DCSP evoked.data = data DCNL DCSP for ch in evoked.info['chs']: DCNL DCSP  DCSP ch['ch_name'] += '_virtual' DCNL DCSP evoked.info._update_redundant() DCNL DCSP evoked.info._check_consistency() DCNL DCSP return evoked
 DCSP functions = [] DCNL DCSP for fileName in fileNames: DCNL DCSP  DCSP functions += getFunctionsWithStringByFileName(fileName, searchString) DCNL DCSP functions.sort() DCNL DCSP return functions
 DCSP f = (_Cfunctions.get('libvlc_video_get_title_description', None) or _Cfunction('libvlc_video_get_title_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP return pattern.match(value)
 DCSP course_key = CourseKey.from_string(course_key_string) DCNL DCSP with modulestore().bulk_operations(course_key): DCNL DCSP  DCSP course_module = get_course_and_check_access(course_key, request.user) DCNL DCSP  DCSP if (('text/html' in request.META.get('HTTP_ACCEPT', '')) and (request.method == 'GET')): DCNL DCSP  DCSP  DCSP return render_to_response('settings_advanced.html', {'context_course': course_module, 'advanced_dict': CourseMetadata.fetch(course_module), 'advanced_settings_url': reverse_course_url('advanced_settings_handler', course_key)}) DCNL DCSP  DCSP elif ('application/json' in request.META.get('HTTP_ACCEPT', '')): DCNL DCSP  DCSP  DCSP if (request.method == 'GET'): DCNL DCSP  DCSP  DCSP  DCSP return JsonResponse(CourseMetadata.fetch(course_module)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (is_valid, errors, updated_data) = CourseMetadata.validate_and_update_from_json(course_module, request.json, user=request.user) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_valid: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _refresh_course_tabs(request, course_module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except InvalidTabsException as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP log.exception(err.message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_message = [{'message': _('An DCSP error DCSP occurred DCSP while DCSP trying DCSP to DCSP save DCSP your DCSP tabs'), 'model': {'display_name': _('Tabs DCSP Exception')}}] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponseBadRequest(response_message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP modulestore().update_item(course_module, request.user.id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponse(updated_data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponseBadRequest(errors) DCNL DCSP  DCSP  DCSP  DCSP except (TypeError, ValueError, InvalidTabsException) as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseBadRequest(django.utils.html.escape(err.message), content_type='text/plain')
 DCSP return ((sys.platform == 'darwin') and ((2, 6, 0) <= sys.version_info < (2, 6, 4)))
 DCSP return str(uuid.uuid4())
 DCSP def decorator(func): DCNL DCSP  DCSP add_event_handler(name, func, priority) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP ha_conn = _get_conn(socket) DCNL DCSP ha_cmd = haproxy.cmds.showFrontends() DCNL DCSP return ha_conn.sendCmd(ha_cmd)
 DCSP src = File.pathname(src) DCNL DCSP dst = File.pathname(dst) DCNL DCSP if createpath: DCNL DCSP  DCSP mkdirs(os.path.split(dst)[0]) DCNL DCSP ifp = open(src, 'rb') DCNL DCSP ofp = open(dst, 'wb') DCNL DCSP d = ifp.read(BUFSIZ) DCNL DCSP while d: DCNL DCSP  DCSP ofp.write(d) DCNL DCSP  DCSP d = ifp.read(BUFSIZ) DCNL DCSP ifp.close() DCNL DCSP ofp.close() DCNL DCSP ifp = openrf(src, '*rb') DCNL DCSP ofp = openrf(dst, '*wb') DCNL DCSP d = ifp.read(BUFSIZ) DCNL DCSP while d: DCNL DCSP  DCSP ofp.write(d) DCNL DCSP  DCSP d = ifp.read(BUFSIZ) DCNL DCSP ifp.close() DCNL DCSP ofp.close() DCNL DCSP srcfss = File.FSSpec(src) DCNL DCSP dstfss = File.FSSpec(dst) DCNL DCSP sf = srcfss.FSpGetFInfo() DCNL DCSP df = dstfss.FSpGetFInfo() DCNL DCSP (df.Creator, df.Type) = (sf.Creator, sf.Type) DCNL DCSP if (forcetype is not None): DCNL DCSP  DCSP df.Type = forcetype DCNL DCSP df.Flags = (sf.Flags & COPY_FLAGS) DCNL DCSP dstfss.FSpSetFInfo(df) DCNL DCSP if copydates: DCNL DCSP  DCSP srcfsr = File.FSRef(src) DCNL DCSP  DCSP dstfsr = File.FSRef(dst) DCNL DCSP  DCSP (catinfo, _, _, _) = srcfsr.FSGetCatalogInfo(Files.kFSCatInfoAllDates) DCNL DCSP  DCSP dstfsr.FSSetCatalogInfo(Files.kFSCatInfoAllDates, catinfo)
 DCSP from nose.tools import assert_true DCNL DCSP snr = (linalg.norm(desired, ord='fro') / linalg.norm((desired - actual), ord='fro')) DCNL DCSP assert_true((snr >= tol), msg=('%f DCSP < DCSP %f' % (snr, tol)))
 DCSP widgets = {} DCNL DCSP widgets.update(WIDGETS) DCNL DCSP try: DCNL DCSP  DCSP agent = request.user.profile.serviceagent_set.all()[0] DCNL DCSP except Exception: DCNL DCSP  DCSP agent = None DCNL DCSP if (not agent): DCNL DCSP  DCSP del widgets['widget_index_assigned'] DCNL DCSP return widgets
 DCSP train_path = get_wmt_enfr_train_set(data_dir) DCNL DCSP dev_path = get_wmt_enfr_dev_set(data_dir) DCNL DCSP from_train_path = (train_path + '.en') DCNL DCSP to_train_path = (train_path + '.fr') DCNL DCSP from_dev_path = (dev_path + '.en') DCNL DCSP to_dev_path = (dev_path + '.fr') DCNL DCSP return prepare_data(data_dir, from_train_path, to_train_path, from_dev_path, to_dev_path, en_vocabulary_size, fr_vocabulary_size, tokenizer)
 DCSP ret = {} DCNL DCSP imgadm = _check_imgadm() DCNL DCSP cmd = '{0} DCSP vacuum DCSP -f'.format(imgadm) DCNL DCSP res = __salt__['cmd.run_all'](cmd) DCNL DCSP retcode = res['retcode'] DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP ret['Error'] = _exit_status(retcode) DCNL DCSP  DCSP return ret DCNL DCSP result = {} DCNL DCSP for image in res['stdout'].splitlines(): DCNL DCSP  DCSP image = [var for var in image.split(' DCSP ') if var] DCNL DCSP  DCSP result[image[2]] = {'name': image[3][1:image[3].index('@')], 'version': image[3][(image[3].index('@') + 1):(-1)]} DCNL DCSP if verbose: DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP return list(result.keys())
 DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP write_tree_diff(outstream, r.object_store, old_tree, new_tree)
 DCSP Q = np.zeros((6, 6)) DCNL DCSP (Q[(0, 1)], Q[(1, 0)]) = (1, 1) DCNL DCSP Q[(2, [0, 3])] = (1 / 2) DCNL DCSP (Q[(3, 4)], Q[(4, 5)], Q[(5, 3)]) = (1, 1, 1) DCNL DCSP Q_stationary_dists = np.array([[(1 / 2), (1 / 2), 0, 0, 0, 0], [0, 0, 0, (1 / 3), (1 / 3), (1 / 3)]]) DCNL DCSP testset = [{'P': np.array([[0.4, 0.6], [0.2, 0.8]]), 'stationary_dists': np.array([[0.25, 0.75]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreducible': True, 'period': 1, 'is_aperiodic': True, 'cyclic_classes': [np.arange(2)]}, {'P': sparse.csr_matrix([[0.4, 0.6], [0.2, 0.8]]), 'stationary_dists': np.array([[0.25, 0.75]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreducible': True, 'period': 1, 'is_aperiodic': True, 'cyclic_classes': [np.arange(2)]}, {'P': np.array([[0, 1], [1, 0]]), 'stationary_dists': np.array([[0.5, 0.5]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreducible': True, 'period': 2, 'is_aperiodic': False, 'cyclic_classes': [np.array([0]), np.array([1])]}, {'P': np.eye(2), 'stationary_dists': np.array([[1, 0], [0, 1]]), 'comm_classes': [np.array([0]), np.array([1])], 'rec_classes': [np.array([0]), np.array([1])], 'is_irreducible': False, 'period': 1, 'is_aperiodic': True}, {'P': np.array([[1, 0], [1, 0]]), 'stationary_dists': np.array([[1, 0]]), 'comm_classes': [np.array([0]), np.array([1])], 'rec_classes': [np.array([0])], 'is_irreducible': False, 'period': 1, 'is_aperiodic': True}, {'P': Q, 'stationary_dists': Q_stationary_dists, 'comm_classes': [np.array([0, 1]), np.array([2]), np.array([3, 4, 5])], 'rec_classes': [np.array([0, 1]), np.array([3, 4, 5])], 'is_irreducible': False, 'period': 6, 'is_aperiodic': False}, {'P': sparse.csr_matrix(Q), 'stationary_dists': Q_stationary_dists, 'comm_classes': [np.array([0, 1]), np.array([2]), np.array([3, 4, 5])], 'rec_classes': [np.array([0, 1]), np.array([3, 4, 5])], 'is_irreducible': False, 'period': 6, 'is_aperiodic': False}] DCNL DCSP for test_dict in testset: DCNL DCSP  DCSP mc = MarkovChain(test_dict['P']) DCNL DCSP  DCSP computed = mc.stationary_distributions DCNL DCSP  DCSP assert_allclose(computed, test_dict['stationary_dists']) DCNL DCSP  DCSP assert (mc.num_communication_classes == len(test_dict['comm_classes'])) DCNL DCSP  DCSP assert (mc.is_irreducible == test_dict['is_irreducible']) DCNL DCSP  DCSP assert (mc.num_recurrent_classes == len(test_dict['rec_classes'])) DCNL DCSP  DCSP list_of_array_equal(sorted(mc.communication_classes, key=(lambda x: x[0])), sorted(test_dict['comm_classes'], key=(lambda x: x[0]))) DCNL DCSP  DCSP list_of_array_equal(sorted(mc.recurrent_classes, key=(lambda x: x[0])), sorted(test_dict['rec_classes'], key=(lambda x: x[0]))) DCNL DCSP  DCSP assert (mc.period == test_dict['period']) DCNL DCSP  DCSP assert (mc.is_aperiodic == test_dict['is_aperiodic']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP list_of_array_equal(sorted(mc.cyclic_classes, key=(lambda x: x[0])), sorted(test_dict['cyclic_classes'], key=(lambda x: x[0]))) DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP assert (mc.is_irreducible is False) DCNL DCSP  DCSP computed = mc_compute_stationary(test_dict['P']) DCNL DCSP  DCSP assert_allclose(computed, test_dict['stationary_dists'])
 DCSP string = decode_utf8(string) DCNL DCSP string = re.sub("([a-z|A-Z])'(m|s|ve|re|ll|d)", u'\\1 DCSP <QUOTE/>\\2', string) DCNL DCSP string = re.sub("(c|d|gl|j|l|m|n|s|t|un)'([a-z|A-Z])", u'\\1<QUOTE/> DCSP \\2', string) DCNL DCSP words = (w.strip(punctuation).replace(u'<QUOTE/>', "'", 1) for w in string.split()) DCNL DCSP words = (w for w in words if ((filter is None) or (filter(w) is not False))) DCNL DCSP words = [w for w in words if w] DCNL DCSP return words
 DCSP return render(request, template_name, {'error_message': error_message})
 DCSP return Type.GetTypeFromProgID(prog_id)
 DCSP res = socket.getaddrinfo(hostname, None)[0] DCNL DCSP (family, socktype, proto, canonname, sockaddr) = res DCNL DCSP return sockaddr[0]
 DCSP course = modulestore().get_course(course_id, depth=4) DCNL DCSP problem_set = [] DCNL DCSP problem_info = {} DCNL DCSP c_subsection = 0 DCNL DCSP for subsection in course.get_children()[section].get_children(): DCNL DCSP  DCSP c_subsection += 1 DCNL DCSP  DCSP c_unit = 0 DCNL DCSP  DCSP for unit in subsection.get_children(): DCNL DCSP  DCSP  DCSP c_unit += 1 DCNL DCSP  DCSP  DCSP c_problem = 0 DCNL DCSP  DCSP  DCSP for child in unit.get_children(): DCNL DCSP  DCSP  DCSP  DCSP if (child.location.category == 'problem'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP c_problem += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP problem_set.append(child.location) DCNL DCSP  DCSP  DCSP  DCSP  DCSP problem_info[child.location] = {'id': child.location.to_deprecated_string(), 'x_value': 'P{0}.{1}.{2}'.format(c_subsection, c_unit, c_problem), 'display_name': own_metadata(child).get('display_name', '')} DCNL DCSP grade_distrib = get_problem_set_grade_distrib(course_id, problem_set) DCNL DCSP d3_data = [] DCNL DCSP for problem in problem_set: DCNL DCSP  DCSP stack_data = [] DCNL DCSP  DCSP if (problem in grade_distrib): DCNL DCSP  DCSP  DCSP max_grade = float(grade_distrib[problem]['max_grade']) DCNL DCSP  DCSP  DCSP for (grade, count_grade) in grade_distrib[problem]['grade_distrib']: DCNL DCSP  DCSP  DCSP  DCSP percent = 0.0 DCNL DCSP  DCSP  DCSP  DCSP if (max_grade > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP percent = round(((grade * 100.0) / max_grade), 1) DCNL DCSP  DCSP  DCSP  DCSP tooltip = {'type': 'problem', 'problem_info_x': problem_info[problem]['x_value'], 'count_grade': count_grade, 'percent': percent, 'problem_info_n': problem_info[problem]['display_name'], 'grade': grade, 'max_grade': max_grade} DCNL DCSP  DCSP  DCSP  DCSP stack_data.append({'color': percent, 'value': count_grade, 'tooltip': tooltip}) DCNL DCSP  DCSP d3_data.append({'xValue': problem_info[problem]['x_value'], 'stackData': stack_data}) DCNL DCSP return d3_data
 DCSP _check_unknown_options(unknown_options) DCNL DCSP tol = xtol DCNL DCSP if (brack is None): DCNL DCSP  DCSP (xa, xb, xc, fa, fb, fc, funcalls) = bracket(func, args=args) DCNL DCSP elif (len(brack) == 2): DCNL DCSP  DCSP (xa, xb, xc, fa, fb, fc, funcalls) = bracket(func, xa=brack[0], xb=brack[1], args=args) DCNL DCSP elif (len(brack) == 3): DCNL DCSP  DCSP (xa, xb, xc) = brack DCNL DCSP  DCSP if (xa > xc): DCNL DCSP  DCSP  DCSP (xc, xa) = (xa, xc) DCNL DCSP  DCSP if (not ((xa < xb) and (xb < xc))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP a DCSP bracketing DCSP interval.') DCNL DCSP  DCSP fa = func(*((xa,) + args)) DCNL DCSP  DCSP fb = func(*((xb,) + args)) DCNL DCSP  DCSP fc = func(*((xc,) + args)) DCNL DCSP  DCSP if (not ((fb < fa) and (fb < fc))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP a DCSP bracketing DCSP interval.') DCNL DCSP  DCSP funcalls = 3 DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Bracketing DCSP interval DCSP must DCSP be DCSP length DCSP 2 DCSP or DCSP 3 DCSP sequence.') DCNL DCSP _gR = 0.61803399 DCNL DCSP _gC = (1.0 - _gR) DCNL DCSP x3 = xc DCNL DCSP x0 = xa DCNL DCSP if (numpy.abs((xc - xb)) > numpy.abs((xb - xa))): DCNL DCSP  DCSP x1 = xb DCNL DCSP  DCSP x2 = (xb + (_gC * (xc - xb))) DCNL DCSP else: DCNL DCSP  DCSP x2 = xb DCNL DCSP  DCSP x1 = (xb - (_gC * (xb - xa))) DCNL DCSP f1 = func(*((x1,) + args)) DCNL DCSP f2 = func(*((x2,) + args)) DCNL DCSP funcalls += 2 DCNL DCSP nit = 0 DCNL DCSP for i in xrange(maxiter): DCNL DCSP  DCSP if (numpy.abs((x3 - x0)) <= (tol * (numpy.abs(x1) + numpy.abs(x2)))): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (f2 < f1): DCNL DCSP  DCSP  DCSP x0 = x1 DCNL DCSP  DCSP  DCSP x1 = x2 DCNL DCSP  DCSP  DCSP x2 = ((_gR * x1) + (_gC * x3)) DCNL DCSP  DCSP  DCSP f1 = f2 DCNL DCSP  DCSP  DCSP f2 = func(*((x2,) + args)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP x3 = x2 DCNL DCSP  DCSP  DCSP x2 = x1 DCNL DCSP  DCSP  DCSP x1 = ((_gR * x2) + (_gC * x0)) DCNL DCSP  DCSP  DCSP f2 = f1 DCNL DCSP  DCSP  DCSP f1 = func(*((x1,) + args)) DCNL DCSP  DCSP funcalls += 1 DCNL DCSP  DCSP nit += 1 DCNL DCSP if (f1 < f2): DCNL DCSP  DCSP xmin = x1 DCNL DCSP  DCSP fval = f1 DCNL DCSP else: DCNL DCSP  DCSP xmin = x2 DCNL DCSP  DCSP fval = f2 DCNL DCSP return OptimizeResult(fun=fval, nfev=funcalls, x=xmin, nit=nit, success=(nit < maxiter))
 DCSP badge = get_or_create_badge(badge_template, year) DCNL DCSP if badge.is_awarded_to(user): DCNL DCSP  DCSP return DCNL DCSP qs = Reply.objects.filter(user=user, created__gte=date(year, 1, 1), created__lt=date((year + 1), 1, 1)) DCNL DCSP if (qs.count() >= 50): DCNL DCSP  DCSP badge.award_to(user) DCNL DCSP  DCSP return True
 DCSP return remove(name=name, pkgs=pkgs)
 DCSP frames = buildRequestFrames(headers, data, frameFactory, streamID) DCNL DCSP return ''.join((f.serialize() for f in frames))
 DCSP if include_headers: DCNL DCSP  DCSP include_headers = tuple([h.lower() for h in sorted(include_headers)]) DCNL DCSP cache = _fingerprint_cache.setdefault(request, {}) DCNL DCSP if (include_headers not in cache): DCNL DCSP  DCSP fp = hashlib.sha1() DCNL DCSP  DCSP fp.update(request.method) DCNL DCSP  DCSP fp.update(canonicalize_url(request.url)) DCNL DCSP  DCSP fp.update((request.body or '')) DCNL DCSP  DCSP if include_headers: DCNL DCSP  DCSP  DCSP for hdr in include_headers: DCNL DCSP  DCSP  DCSP  DCSP if (hdr in request.headers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fp.update(hdr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for v in request.headers.getlist(hdr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.update(v) DCNL DCSP  DCSP cache[include_headers] = fp.hexdigest() DCNL DCSP return cache[include_headers]
 DCSP warn('Test') DCNL DCSP eq_('\nWarning: DCSP Test\n\n', sys.stderr.getvalue())
 DCSP mode = tcgetattr(fd) DCNL DCSP mode[IFLAG] = (mode[IFLAG] & (~ ((((BRKINT | ICRNL) | INPCK) | ISTRIP) | IXON))) DCNL DCSP mode[OFLAG] = (mode[OFLAG] & (~ OPOST)) DCNL DCSP mode[CFLAG] = (mode[CFLAG] & (~ (CSIZE | PARENB))) DCNL DCSP mode[CFLAG] = (mode[CFLAG] | CS8) DCNL DCSP mode[LFLAG] = (mode[LFLAG] & (~ (((ECHO | ICANON) | IEXTEN) | ISIG))) DCNL DCSP mode[CC][VMIN] = 1 DCNL DCSP mode[CC][VTIME] = 0 DCNL DCSP tcsetattr(fd, when, mode)
 DCSP models.get_apps() DCNL DCSP opts = model._meta DCNL DCSP validate_base(cls, model) DCNL DCSP if hasattr(cls, 'list_display'): DCNL DCSP  DCSP check_isseq(cls, 'list_display', cls.list_display) DCNL DCSP  DCSP for (idx, field) in enumerate(cls.list_display): DCNL DCSP  DCSP  DCSP if (not callable(field)): DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(cls, field)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not hasattr(model, field)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opts.get_field(field) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except models.FieldDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(('%s.list_display[%d], DCSP %r DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP an DCSP attribute DCSP of DCSP %r DCSP or DCSP found DCSP in DCSP the DCSP model DCSP %r.' % (cls.__name__, idx, field, cls.__name__, model._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = fetch_attr(cls, model, opts, ('list_display[%d]' % idx), field) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(f, models.ManyToManyField): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_display[%d]', DCSP '%s' DCSP is DCSP a DCSP ManyToManyField DCSP which DCSP is DCSP not DCSP supported." % (cls.__name__, idx, field))) DCNL DCSP if hasattr(cls, 'list_display_links'): DCNL DCSP  DCSP check_isseq(cls, 'list_display_links', cls.list_display_links) DCNL DCSP  DCSP for (idx, field) in enumerate(cls.list_display_links): DCNL DCSP  DCSP  DCSP if (field not in cls.list_display): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_display_links[%d]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP defined DCSP in DCSP 'list_display'." % (cls.__name__, idx, field))) DCNL DCSP if hasattr(cls, 'list_filter'): DCNL DCSP  DCSP check_isseq(cls, 'list_filter', cls.list_filter) DCNL DCSP  DCSP for (idx, fpath) in enumerate(cls.list_filter): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP get_fields_from_path(model, fpath) DCNL DCSP  DCSP  DCSP except (NotRelationField, FieldDoesNotExist) as e: DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_filter[%d]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP does DCSP not DCSP refer DCSP to DCSP a DCSP Field." % (cls.__name__, idx, fpath))) DCNL DCSP if (hasattr(cls, 'list_per_page') and (not isinstance(cls.list_per_page, int))): DCNL DCSP  DCSP raise ImproperlyConfigured(("'%s.list_per_page' DCSP should DCSP be DCSP a DCSP integer." % cls.__name__)) DCNL DCSP if (hasattr(cls, 'list_editable') and cls.list_editable): DCNL DCSP  DCSP check_isseq(cls, 'list_editable', cls.list_editable) DCNL DCSP  DCSP for (idx, field_name) in enumerate(cls.list_editable): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP field = opts.get_field_by_name(field_name)[0] DCNL DCSP  DCSP  DCSP except models.FieldDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_editable[%d]' DCSP refers DCSP to DCSP a DCSP field, DCSP '%s', DCSP not DCSP defined DCSP on DCSP %s." % (cls.__name__, idx, field_name, model.__name__))) DCNL DCSP  DCSP  DCSP if (field_name not in cls.list_display): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_editable[%d]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP defined DCSP in DCSP 'list_display'." % (cls.__name__, idx, field_name))) DCNL DCSP  DCSP  DCSP if (field_name in cls.list_display_links): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s' DCSP cannot DCSP be DCSP in DCSP both DCSP '%s.list_editable' DCSP and DCSP '%s.list_display_links'" % (field_name, cls.__name__, cls.__name__))) DCNL DCSP  DCSP  DCSP if ((not cls.list_display_links) and (cls.list_display[0] in cls.list_editable)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_editable[%d]' DCSP refers DCSP to DCSP the DCSP first DCSP field DCSP in DCSP list_display, DCSP '%s', DCSP which DCSP can't DCSP be DCSP used DCSP unless DCSP list_display_links DCSP is DCSP set." % (cls.__name__, idx, cls.list_display[0]))) DCNL DCSP  DCSP  DCSP if (not field.editable): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.list_editable[%d]' DCSP refers DCSP to DCSP a DCSP field, DCSP '%s', DCSP which DCSP isn't DCSP editable DCSP through DCSP the DCSP admin." % (cls.__name__, idx, field_name))) DCNL DCSP if hasattr(cls, 'search_fields'): DCNL DCSP  DCSP check_isseq(cls, 'search_fields', cls.search_fields) DCNL DCSP if cls.date_hierarchy: DCNL DCSP  DCSP f = get_field(cls, model, opts, 'date_hierarchy', cls.date_hierarchy) DCNL DCSP  DCSP if (not isinstance(f, (models.DateField, models.DateTimeField))): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.date_hierarchy DCSP is DCSP neither DCSP an DCSP instance DCSP of DCSP DateField DCSP nor DCSP DateTimeField." % cls.__name__)) DCNL DCSP if cls.ordering: DCNL DCSP  DCSP check_isseq(cls, 'ordering', cls.ordering) DCNL DCSP  DCSP for (idx, field) in enumerate(cls.ordering): DCNL DCSP  DCSP  DCSP if ((field == '?') and (len(cls.ordering) != 1)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.ordering' DCSP has DCSP the DCSP random DCSP ordering DCSP marker DCSP '?', DCSP but DCSP contains DCSP other DCSP fields DCSP as DCSP well. DCSP Please DCSP either DCSP remove DCSP '?' DCSP or DCSP the DCSP other DCSP fields." % cls.__name__)) DCNL DCSP  DCSP  DCSP if (field == '?'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if field.startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP field = field[1:] DCNL DCSP  DCSP  DCSP if ('__' in field): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP get_field(cls, model, opts, ('ordering[%d]' % idx), field) DCNL DCSP if hasattr(cls, 'readonly_fields'): DCNL DCSP  DCSP check_readonly_fields(cls, model, opts) DCNL DCSP for attr in ('list_select_related', 'save_as', 'save_on_top'): DCNL DCSP  DCSP if (not isinstance(getattr(cls, attr), bool)): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.%s' DCSP should DCSP be DCSP a DCSP boolean." % (cls.__name__, attr))) DCNL DCSP if hasattr(cls, 'inlines'): DCNL DCSP  DCSP check_isseq(cls, 'inlines', cls.inlines) DCNL DCSP  DCSP for (idx, inline) in enumerate(cls.inlines): DCNL DCSP  DCSP  DCSP if (not issubclass(inline, BaseModelAdmin)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.inlines[%d]' DCSP does DCSP not DCSP inherit DCSP from DCSP BaseModelAdmin." % (cls.__name__, idx))) DCNL DCSP  DCSP  DCSP if (not inline.model): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'model' DCSP is DCSP a DCSP required DCSP attribute DCSP of DCSP '%s.inlines[%d]'." % (cls.__name__, idx))) DCNL DCSP  DCSP  DCSP if (not issubclass(inline.model, models.Model)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigured(("'%s.inlines[%d].model' DCSP does DCSP not DCSP inherit DCSP from DCSP models.Model." % (cls.__name__, idx))) DCNL DCSP  DCSP  DCSP validate_base(inline, inline.model) DCNL DCSP  DCSP  DCSP validate_inline(inline, cls, model)
 DCSP pass
 DCSP return filepath.replace('/', '\\')
 DCSP values = [] DCNL DCSP ascii = [] DCNL DCSP offset = 0 DCNL DCSP for (h, a) in sixteen(data): DCNL DCSP  DCSP if (h is None): DCNL DCSP  DCSP  DCSP (yield (offset, ' DCSP '.join([''.join(values), ''.join(ascii)]))) DCNL DCSP  DCSP  DCSP del values[:] DCNL DCSP  DCSP  DCSP del ascii[:] DCNL DCSP  DCSP  DCSP offset += 16 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP values.append(h) DCNL DCSP  DCSP  DCSP ascii.append(a)
 DCSP dssp = {} DCNL DCSP start = 0 DCNL DCSP keys = [] DCNL DCSP for l in handle.readlines(): DCNL DCSP  DCSP sl = l.split() DCNL DCSP  DCSP if (len(sl) < 2): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (sl[1] == 'RESIDUE'): DCNL DCSP  DCSP  DCSP start = 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not start): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (l[9] == ' DCSP '): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP dssp_index = int(l[:5]) DCNL DCSP  DCSP resseq = int(l[5:10]) DCNL DCSP  DCSP icode = l[10] DCNL DCSP  DCSP chainid = l[11] DCNL DCSP  DCSP aa = l[13] DCNL DCSP  DCSP ss = l[16] DCNL DCSP  DCSP if (ss == ' DCSP '): DCNL DCSP  DCSP  DCSP ss = '-' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP NH_O_1_relidx = int(l[38:45]) DCNL DCSP  DCSP  DCSP NH_O_1_energy = float(l[46:50]) DCNL DCSP  DCSP  DCSP O_NH_1_relidx = int(l[50:56]) DCNL DCSP  DCSP  DCSP O_NH_1_energy = float(l[57:61]) DCNL DCSP  DCSP  DCSP NH_O_2_relidx = int(l[61:67]) DCNL DCSP  DCSP  DCSP NH_O_2_energy = float(l[68:72]) DCNL DCSP  DCSP  DCSP O_NH_2_relidx = int(l[72:78]) DCNL DCSP  DCSP  DCSP O_NH_2_energy = float(l[79:83]) DCNL DCSP  DCSP  DCSP acc = int(l[34:38]) DCNL DCSP  DCSP  DCSP phi = float(l[103:109]) DCNL DCSP  DCSP  DCSP psi = float(l[109:115]) DCNL DCSP  DCSP except ValueError as exc: DCNL DCSP  DCSP  DCSP if (l[34] != ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP shift = l[34:].find(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP NH_O_1_relidx = int(l[(38 + shift):(45 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_1_energy = float(l[(46 + shift):(50 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_1_relidx = int(l[(50 + shift):(56 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_1_energy = float(l[(57 + shift):(61 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_2_relidx = int(l[(61 + shift):(67 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_2_energy = float(l[(68 + shift):(72 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_2_relidx = int(l[(72 + shift):(78 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_2_energy = float(l[(79 + shift):(83 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP acc = int(l[(34 + shift):(38 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP phi = float(l[(103 + shift):(109 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP psi = float(l[(109 + shift):(115 + shift)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(exc) DCNL DCSP  DCSP res_id = (' DCSP ', resseq, icode) DCNL DCSP  DCSP dssp[(chainid, res_id)] = (aa, ss, acc, phi, psi, dssp_index, NH_O_1_relidx, NH_O_1_energy, O_NH_1_relidx, O_NH_1_energy, NH_O_2_relidx, NH_O_2_energy, O_NH_2_relidx, O_NH_2_energy) DCNL DCSP  DCSP keys.append((chainid, res_id)) DCNL DCSP return (dssp, keys)
 DCSP def null_safe_rl(expr): DCNL DCSP  DCSP result = rule(expr) DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP return expr DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return result DCNL DCSP return null_safe_rl
 DCSP message = escape(kwd.get('message', '')) DCNL DCSP status = kwd.get('status', 'done') DCNL DCSP full_url = ('%s/find?%s' % (search_url, urllib.urlencode({'kwd': search_term}))) DCNL DCSP response = urllib2.urlopen(full_url) DCNL DCSP ldda_ids = loads(response.read())['ids'] DCNL DCSP response.close() DCNL DCSP lddas = [trans.sa_session.query(trans.app.model.LibraryDatasetDatasetAssociation).get(ldda_id) for ldda_id in ldda_ids] DCNL DCSP return (status, message, get_sorted_accessible_library_items(trans, cntrller, lddas, 'name'))
 DCSP with gzip.open(ATLAS_FILE, 'rb') as f: DCNL DCSP  DCSP line = f.readline() DCNL DCSP  DCSP while (line and line.startswith('GRAPH')): DCNL DCSP  DCSP  DCSP graph_index = int(line[6:].rstrip()) DCNL DCSP  DCSP  DCSP line = f.readline() DCNL DCSP  DCSP  DCSP num_nodes = int(line[6:].rstrip()) DCNL DCSP  DCSP  DCSP edgelist = [] DCNL DCSP  DCSP  DCSP line = f.readline() DCNL DCSP  DCSP  DCSP while (line and (not line.startswith('GRAPH'))): DCNL DCSP  DCSP  DCSP  DCSP edgelist.append(line.rstrip()) DCNL DCSP  DCSP  DCSP  DCSP line = f.readline() DCNL DCSP  DCSP  DCSP G = nx.Graph() DCNL DCSP  DCSP  DCSP G.name = 'G{}'.format(graph_index) DCNL DCSP  DCSP  DCSP G.add_nodes_from(range(num_nodes)) DCNL DCSP  DCSP  DCSP G.add_edges_from((tuple(map(int, e.split())) for e in edgelist)) DCNL DCSP  DCSP  DCSP (yield G)
 DCSP if (n is None): DCNL DCSP  DCSP return '' DCNL DCSP return format_decimal(n, locale=_babel_locale(_contextual_locale(context)))
 DCSP expr_part = [] DCNL DCSP qexpr_part = [] DCNL DCSP for arg in e.args: DCNL DCSP  DCSP if (not isinstance(arg, QExpr)): DCNL DCSP  DCSP  DCSP expr_part.append(arg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qexpr_part.append(arg) DCNL DCSP return (expr_part, qexpr_part)
 DCSP assert_equals(strings.column_width(u'\u3042\u3044\u3046\u3048\u304a'), 10)
 DCSP def real_decorator(function): DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP ts = time.time() DCNL DCSP  DCSP  DCSP for i in range(num_tries): DCNL DCSP  DCSP  DCSP  DCSP result = function(*args, **kwargs) DCNL DCSP  DCSP  DCSP te = time.time() DCNL DCSP  DCSP  DCSP tt = ((te - ts) / num_tries) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP log.info(u'{0} DCSP took DCSP {1} DCSP s DCSP on DCSP AVERAGE DCSP for DCSP {2} DCSP call(s).'.format(function.__name__, tt, num_tries)) DCNL DCSP  DCSP  DCSP return (tt, result) DCNL DCSP  DCSP return wrapper DCNL DCSP return real_decorator
 DCSP input_factory = factory DCNL DCSP class TheMap(CheckedPMap, ): DCNL DCSP  DCSP __key_type__ = key_type DCNL DCSP  DCSP __value_type__ = value_type DCNL DCSP TheMap.__name__ = ((key_type.__name__.capitalize() + value_type.__name__.capitalize()) + 'PMap') DCNL DCSP if optional: DCNL DCSP  DCSP def mapping_factory(argument): DCNL DCSP  DCSP  DCSP if (argument is None): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return TheMap(argument) DCNL DCSP else: DCNL DCSP  DCSP mapping_factory = TheMap DCNL DCSP if input_factory: DCNL DCSP  DCSP factory = (lambda x: mapping_factory(input_factory(x))) DCNL DCSP else: DCNL DCSP  DCSP factory = mapping_factory DCNL DCSP if (initial is _UNDEFINED): DCNL DCSP  DCSP initial = TheMap() DCNL DCSP else: DCNL DCSP  DCSP initial = factory(initial) DCNL DCSP return field(mandatory=True, initial=initial, type=(optional_type(TheMap) if optional else TheMap), factory=factory, invariant=invariant)
 DCSP return (path and ('/' not in path) and (path not in ('.', '..')))
 DCSP os.system('cd DCSP build/html; DCSP rsync DCSP -avz DCSP . DCSP pandas@pandas.pydata.org:/usr/share/nginx/pandas/pandas-docs/vbench/ DCSP -essh')
 DCSP from_addr = (from_addr or settings.FROM_EMAIL) DCNL DCSP mailer = (mailer or tasks.send_email) DCNL DCSP subject = mail.subject(**context) DCNL DCSP message = (mail.text(**context) if (mimetype in ('plain', 'txt')) else mail.html(**context)) DCNL DCSP ttls = login = (not settings.DEBUG_MODE) DCNL DCSP logger.debug('Sending DCSP email...') DCNL DCSP logger.debug(u'To: DCSP {to_addr}\nFrom: DCSP {from_addr}\nSubject: DCSP {subject}\nMessage: DCSP {message}'.format(**locals())) DCNL DCSP kwargs = dict(from_addr=from_addr, to_addr=to_addr, subject=subject, message=message, mimetype=mimetype, ttls=ttls, login=login, username=username, password=password, categories=mail.categories) DCNL DCSP if settings.USE_EMAIL: DCNL DCSP  DCSP if settings.USE_CELERY: DCNL DCSP  DCSP  DCSP return mailer.apply_async(kwargs=kwargs, link=callback) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = mailer(**kwargs) DCNL DCSP  DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP  DCSP callback() DCNL DCSP  DCSP  DCSP return ret
 DCSP from django.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK DCNL DCSP out = StringIO() DCNL DCSP intrans = False DCNL DCSP inplural = False DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP for t in Lexer(src, None).tokenize(): DCNL DCSP  DCSP if intrans: DCNL DCSP  DCSP  DCSP if (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP endbmatch = endblock_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP pluralmatch = plural_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP if endbmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP ngettext(%r,%r,count) DCSP ' % (''.join(singular), ''.join(plural)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in plural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'P')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP gettext(%r) DCSP ' % ''.join(singular))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP intrans = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP  DCSP elif pluralmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SyntaxError, ('Translation DCSP blocks DCSP must DCSP not DCSP include DCSP other DCSP block DCSP tags: DCSP %s' % t.contents) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.append(('%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.append(('%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_TEXT): DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.append(t.contents) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.append(t.contents) DCNL DCSP  DCSP elif (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP imatch = inline_re.match(t.contents) DCNL DCSP  DCSP  DCSP bmatch = block_re.match(t.contents) DCNL DCSP  DCSP  DCSP cmatches = constant_re.findall(t.contents) DCNL DCSP  DCSP  DCSP if imatch: DCNL DCSP  DCSP  DCSP  DCSP g = imatch.group(1) DCNL DCSP  DCSP  DCSP  DCSP if (g[0] == '"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip('"') DCNL DCSP  DCSP  DCSP  DCSP elif (g[0] == "'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip("'") DCNL DCSP  DCSP  DCSP  DCSP out.write((' DCSP gettext(%r) DCSP ' % g)) DCNL DCSP  DCSP  DCSP elif bmatch: DCNL DCSP  DCSP  DCSP  DCSP intrans = True DCNL DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP elif cmatches: DCNL DCSP  DCSP  DCSP  DCSP for cmatch in cmatches: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP _(%s) DCSP ' % cmatch)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out.write(blankout(t.contents, 'B')) DCNL DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP parts = t.contents.split('|') DCNL DCSP  DCSP  DCSP cmatch = constant_re.match(parts[0]) DCNL DCSP  DCSP  DCSP if cmatch: DCNL DCSP  DCSP  DCSP  DCSP out.write((' DCSP _(%s) DCSP ' % cmatch.group(1))) DCNL DCSP  DCSP  DCSP for p in parts[1:]: DCNL DCSP  DCSP  DCSP  DCSP if (p.find(':_(') >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP %s DCSP ' % p.split(':', 1)[1])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(p, 'F')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.write(blankout(t.contents, 'X')) DCNL DCSP return out.getvalue()
 DCSP if ('d' not in xmlElement.attributeDictionary): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP processSVGElementpath DCSP in DCSP svgReader DCSP can DCSP not DCSP get DCSP a DCSP value DCSP for DCSP d DCSP in:' DCNL DCSP  DCSP print xmlElement.attributeDictionary DCNL DCSP  DCSP return DCNL DCSP rotatedLoopLayer = svgReader.getRotatedLoopLayer() DCNL DCSP PathReader(rotatedLoopLayer.loops, xmlElement, svgReader.yAxisPointingUpward)
 DCSP keys = [_make_ratelimit_cache_key(k, t) for (k, t) in prefix_slices] DCNL DCSP try: DCNL DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP for (key, (_, time_slice)) in zip(keys, prefix_slices): DCNL DCSP  DCSP  DCSP g.ratelimitcache.add(key, 0, time=((time_slice.end - now) + 1)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP recent_usage = g.ratelimitcache.incr_multi(keys) DCNL DCSP  DCSP except pylibmc.NotFound: DCNL DCSP  DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP  DCSP if (now < time_slice.end): DCNL DCSP  DCSP  DCSP  DCSP recent_usage = [] DCNL DCSP  DCSP  DCSP  DCSP for (key, (_, time_slice)) in zip(keys, prefix_slices): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if g.ratelimitcache.add(key, 1, time=((time_slice.end - now) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP recent_usage.append(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP g.stats.simple_event('ratelimit.eviction') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP recent_usage.append(g.ratelimitcache.get(key)) DCNL DCSP  DCSP return recent_usage DCNL DCSP except pylibmc.Error as e: DCNL DCSP  DCSP raise RatelimitError(e)
 DCSP import lixian_hash DCNL DCSP import lixian_cli_parser DCNL DCSP lixian_hash.main(lixian_cli_parser.expand_command_line(args))
 DCSP keys = environ.keys() DCNL DCSP keys.sort() DCNL DCSP print DCNL DCSP print '<H3>Shell DCSP Environment:</H3>' DCNL DCSP print '<DL>' DCNL DCSP for key in keys: DCNL DCSP  DCSP print '<DT>', escape(key), '<DD>', escape(environ[key]) DCNL DCSP print '</DL>' DCNL DCSP print
 DCSP return for_dtypes_combination(_signed_dtypes, names=names, full=full)
 DCSP if (query and (not (set(query) <= urlencoded))): DCNL DCSP  DCSP raise ValueError('Invalid DCSP characters DCSP in DCSP query DCSP string.') DCNL DCSP invalid_hex = u'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]' DCNL DCSP if len(re.findall(invalid_hex, query)): DCNL DCSP  DCSP raise ValueError('Invalid DCSP hex DCSP encoding DCSP in DCSP query DCSP string.') DCNL DCSP query = (query.decode('utf-8') if isinstance(query, str) else query) DCNL DCSP params = urlparse.parse_qsl(query, keep_blank_values=True) DCNL DCSP return decode_params_utf8(params)
 DCSP (result, cli) = _feed_cli_with_input(u'hello\x01X\n') DCNL DCSP assert (result.text == u'Xhello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x01X\x05Y\n') DCNL DCSP assert (result.text == u'XhelloY') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x08X\n') DCNL DCSP assert (result.text == u'hellX') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x1b[D\x1b[D\x1b[3~\n') DCNL DCSP assert (result.text == u'helo') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x1b[DX\n') DCNL DCSP assert (result.text == u'hellXo') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x01\x1b[CX\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x01\x1b[CX\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x02X\n') DCNL DCSP assert (result.text == u'hellXo') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x01\x06X\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP with pytest.raises(KeyboardInterrupt): DCNL DCSP  DCSP (result, cli) = _feed_cli_with_input(u'hello\x03\n') DCNL DCSP  DCSP assert (result.text == u'hello') DCNL DCSP with pytest.raises(EOFError): DCNL DCSP  DCSP (result, cli) = _feed_cli_with_input(u'\x04\n') DCNL DCSP  DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x01\x04\n') DCNL DCSP assert (result.text == u'ello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x04\n') DCNL DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x1b[D\x1b[D\x0b\n') DCNL DCSP assert (result.text == u'hel') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x1b[D\x1b[D\x1b-\x0b\n') DCNL DCSP assert (result.text == u'lo') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello\x0c\n') DCNL DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x01X\x1b[1;5CY\n') DCNL DCSP assert (result.text == u'XhelloY DCSP world') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x1b[1;5DY\n') DCNL DCSP assert (result.text == u'hello DCSP Yworld') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world DCSP abc DCSP def\x01\x1b3\x1bfX\n') DCNL DCSP assert (result.text == u'hello DCSP world DCSP abcX DCSP def') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world DCSP abc DCSP def\x1b-\x1b3\x1bfX\n') DCNL DCSP assert (result.text == u'hello DCSP Xworld DCSP abc DCSP def') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world DCSP abc DCSP def\x1b3\x1bbX\n') DCNL DCSP assert (result.text == u'hello DCSP Xworld DCSP abc DCSP def') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world DCSP abc DCSP def\x01\x1b-\x1b3\x1bbX\n') DCNL DCSP assert (result.text == u'hello DCSP world DCSP abc DCSP Xdef') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x17\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboard.get_data().text == u'world') DCNL DCSP (result, cli) = _feed_cli_with_input(u'test DCSP hello DCSP world\x1b2\x17\n') DCNL DCSP assert (result.text == u'test DCSP ') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x1b\x7f\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboard.get_data().text == u'world') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x1b\x08\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboard.get_data().text == u'world') DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x7f\n') DCNL DCSP assert (result.text == u'hello DCSP worl') DCNL DCSP assert (result.cursor_position == len(u'hello DCSP worl')) DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x08\n') DCNL DCSP assert (result.text == u'hello DCSP worl') DCNL DCSP assert (result.cursor_position == len(u'hello DCSP worl')) DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP world\x01\x1b[3~\n') DCNL DCSP assert (result.text == u'ello DCSP world') DCNL DCSP assert (result.cursor_position == 0) DCNL DCSP (result, cli) = _feed_cli_with_input(u'hello DCSP  DCSP  DCSP  DCSP  DCSP world\x1b8\x02\x1b\\\n') DCNL DCSP assert (result.text == u'helloworld') DCNL DCSP assert (result.cursor_position == len(u'hello'))
 DCSP if _IsSudsIterable(obj): DCNL DCSP  DCSP copy_of_obj = tuple(obj) DCNL DCSP  DCSP for item in copy_of_obj: DCNL DCSP  DCSP  DCSP if _IsSudsIterable(item): DCNL DCSP  DCSP  DCSP  DCSP if ('xsi_type' in item): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(obj, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent[obj[0]] = _PackForSuds(obj[1], factory) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj.remove(item) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj.append(_PackForSuds(item, factory)) DCNL DCSP  DCSP  DCSP  DCSP _RecurseOverObject(item, factory, obj)
 DCSP byte = primitives.byte(value, endian, format, signed, full_range, fuzzable, name) DCNL DCSP blocks.CURRENT.push(byte)
 DCSP _publish_activity(committer_id, collection_id, feconf.ACTIVITY_TYPE_COLLECTION)
 DCSP import os, re DCNL DCSP dirs = ['', 'c:\\windows\\system32', 'c:\\winnt\\system32'] DCNL DCSP try: DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP buffer = ctypes.create_string_buffer(300) DCNL DCSP  DCSP ctypes.windll.kernel32.GetSystemDirectoryA(buffer, 300) DCNL DCSP  DCSP dirs.insert(0, buffer.value.decode('mbcs')) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP for dir in dirs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pipe = os.popen((os.path.join(dir, 'ipconfig') + ' DCSP /all')) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for line in pipe: DCNL DCSP  DCSP  DCSP value = line.split(':')[(-1)].strip().lower() DCNL DCSP  DCSP  DCSP if re.match('([0-9a-f][0-9a-f]-){5}[0-9a-f][0-9a-f]', value): DCNL DCSP  DCSP  DCSP  DCSP return int(value.replace('-', ''), 16)
 DCSP projects = [] DCNL DCSP for filePath in baseDirectory.walk(): DCNL DCSP  DCSP if (filePath.basename() == 'topfiles'): DCNL DCSP  DCSP  DCSP projectDirectory = filePath.parent() DCNL DCSP  DCSP  DCSP projects.append(Project(projectDirectory)) DCNL DCSP return projects
 DCSP rounds = ((len(expanded_key) // BLOCK_SIZE_BYTES) - 1) DCNL DCSP data = xor(data, expanded_key[:BLOCK_SIZE_BYTES]) DCNL DCSP for i in range(1, (rounds + 1)): DCNL DCSP  DCSP data = sub_bytes(data) DCNL DCSP  DCSP data = shift_rows(data) DCNL DCSP  DCSP if (i != rounds): DCNL DCSP  DCSP  DCSP data = mix_columns(data) DCNL DCSP  DCSP data = xor(data, expanded_key[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)]) DCNL DCSP return data
 DCSP if (not hasattr(seq, 'next')): DCNL DCSP  DCSP seq = iter(seq) DCNL DCSP while True: DCNL DCSP  DCSP (yield [seq.next() for i in xrange(size)])
 DCSP def foo(a, b, c=1, d=2, e=3, **kwargs): DCNL DCSP  DCSP u'A DCSP test DCSP function.' DCNL DCSP  DCSP return (a, b, c, d, e, kwargs) DCNL DCSP @wraps(foo) DCNL DCSP def bar(*args, **kwargs): DCNL DCSP  DCSP return ((u'test',) + foo(*args, **kwargs)) DCNL DCSP expected = (u'test', 1, 2, 3, 4, 5, {u'f': 6, u'g': 7}) DCNL DCSP assert (bar(1, 2, 3, 4, 5, f=6, g=7) == expected) DCNL DCSP assert (bar.__name__ == u'foo') DCNL DCSP if (foo.__doc__ is not None): DCNL DCSP  DCSP assert (bar.__doc__ == u'A DCSP test DCSP function.') DCNL DCSP if hasattr(foo, u'__qualname__'): DCNL DCSP  DCSP assert (bar.__qualname__ == foo.__qualname__) DCNL DCSP if six.PY2: DCNL DCSP  DCSP argspec = inspect.getargspec(bar) DCNL DCSP  DCSP assert (argspec.keywords == u'kwargs') DCNL DCSP else: DCNL DCSP  DCSP argspec = inspect.getfullargspec(bar) DCNL DCSP  DCSP assert (argspec.varkw == u'kwargs') DCNL DCSP assert (argspec.args == [u'a', u'b', u'c', u'd', u'e']) DCNL DCSP assert (argspec.defaults == (1, 2, 3))
 DCSP ret = {'name': name, 'changes': {}, 'comment': str(), 'result': None} DCNL DCSP ret_settings = {'changes': dict(), 'failures': dict()} DCNL DCSP if (not services): DCNL DCSP  DCSP services = ['None'] DCNL DCSP services = sorted(set(services)) DCNL DCSP settings = {'contact': contact, 'location': location, 'services': services} DCNL DCSP current_settings = __salt__['win_snmp.get_agent_settings']() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (str(settings[setting]) != str(current_settings[setting])): DCNL DCSP  DCSP  DCSP ret_settings['changes'][setting] = {'old': current_settings[setting], 'new': settings[setting]} DCNL DCSP if (not ret_settings['changes']): DCNL DCSP  DCSP ret['comment'] = 'Agent DCSP settings DCSP already DCSP contain DCSP the DCSP provided DCSP values.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Agent DCSP settings DCSP will DCSP be DCSP changed.' DCNL DCSP  DCSP ret['changes'] = ret_settings DCNL DCSP  DCSP return ret DCNL DCSP __salt__['win_snmp.set_agent_settings'](**settings) DCNL DCSP new_settings = __salt__['win_snmp.get_agent_settings']() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (settings[setting] != new_settings[setting]): DCNL DCSP  DCSP  DCSP ret_settings['failures'][setting] = {'old': current_settings[setting], 'new': new_settings[setting]} DCNL DCSP  DCSP  DCSP ret_settings['changes'].pop(setting, None) DCNL DCSP if ret_settings['failures']: DCNL DCSP  DCSP ret['comment'] = 'Some DCSP agent DCSP settings DCSP failed DCSP to DCSP change.' DCNL DCSP  DCSP ret['changes'] = ret_settings DCNL DCSP  DCSP ret['result'] = False DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Set DCSP agent DCSP settings DCSP to DCSP contain DCSP the DCSP provided DCSP values.' DCNL DCSP  DCSP ret['changes'] = ret_settings['changes'] DCNL DCSP  DCSP ret['result'] = True DCNL DCSP return ret
 DCSP print (('File DCSP ' + filename) + ' DCSP is DCSP being DCSP displayed.') DCNL DCSP fileText = archive.getFileText(filename) DCNL DCSP gcodec.writeFileMessageSuffix(filename, displayText(fileText), 'The DCSP gcode DCSP log DCSP file DCSP is DCSP saved DCSP as DCSP ', '_log')
 DCSP for a in np.arange(2.51, 3.49, 0.1): DCNL DCSP  DCSP assert np.all((extract_array(np.arange(5), 3, a) == np.array([2, 3, 4])))
 DCSP n = len(x) DCNL DCSP for i in reversed(range((n // 2))): DCNL DCSP  DCSP _siftup_max(x, i)
 DCSP (x1, y1) = p1 DCNL DCSP (x2, y2) = p2 DCNL DCSP (x3, y3) = p3 DCNL DCSP (x4, y4) = p4 DCNL DCSP points = [] DCNL DCSP _curve4_recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4) DCNL DCSP (dx, dy) = ((points[0][0] - x1), (points[0][1] - y1)) DCNL DCSP if (((dx * dx) + (dy * dy)) > 1e-10): DCNL DCSP  DCSP points.insert(0, (x1, y1)) DCNL DCSP (dx, dy) = ((points[(-1)][0] - x4), (points[(-1)][1] - y4)) DCNL DCSP if (((dx * dx) + (dy * dy)) > 1e-10): DCNL DCSP  DCSP points.append((x4, y4)) DCNL DCSP return np.array(points).reshape(len(points), 2)
 DCSP return ((N - M) + 1)
 DCSP return IMPL.instance_type_access_remove(context, flavor_id, project_id)
 DCSP if (len(text) > maxlen): DCNL DCSP  DCSP pre = max(0, ((maxlen - 3) // 2)) DCNL DCSP  DCSP post = max(0, ((maxlen - 3) - pre)) DCNL DCSP  DCSP return ((text[:pre] + '...') + text[(len(text) - post):]) DCNL DCSP return text
 DCSP return IMPL.quota_usage_update(context, project_id, resource, **kwargs)
 DCSP location_dict = {'system': system, 'type': lun_type, 'id': six.text_type(lun_id), 'base_lun_name': six.text_type(base_lun_name), 'version': version} DCNL DCSP return dump_provider_location(location_dict)
 DCSP if ((r.representation == 'html') and (r.name == 'shelter') and r.id and (not r.component)): DCNL DCSP  DCSP T = current.T DCNL DCSP  DCSP msg = current.msg DCNL DCSP  DCSP s3db = current.s3db DCNL DCSP  DCSP record = r.record DCNL DCSP  DCSP ctable = s3db.pr_contact DCNL DCSP  DCSP stable = s3db.cr_shelter DCNL DCSP  DCSP message = '' DCNL DCSP  DCSP text = '' DCNL DCSP  DCSP s_id = record.id DCNL DCSP  DCSP s_name = record.name DCNL DCSP  DCSP s_phone = record.phone DCNL DCSP  DCSP s_email = record.email DCNL DCSP  DCSP s_status = record.status DCNL DCSP  DCSP if (s_phone in ('', None)): DCNL DCSP  DCSP  DCSP s_phone = T('Not DCSP Defined') DCNL DCSP  DCSP if (s_email in ('', None)): DCNL DCSP  DCSP  DCSP s_phone = T('Not DCSP Defined') DCNL DCSP  DCSP if (s_status in ('', None)): DCNL DCSP  DCSP  DCSP s_status = T('Not DCSP Defined') DCNL DCSP  DCSP elif (s_status == 1): DCNL DCSP  DCSP  DCSP s_status = 'Open' DCNL DCSP  DCSP elif (s_status == 2): DCNL DCSP  DCSP  DCSP s_status = 'Close' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s_status = 'Unassigned DCSP Shelter DCSP Status' DCNL DCSP  DCSP text += '************************************************' DCNL DCSP  DCSP text += ('\n%s DCSP ' % T('Automatic DCSP Message')) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Shelter DCSP ID'), s_id)) DCNL DCSP  DCSP text += (' DCSP %s: DCSP %s' % (T('Shelter DCSP name'), s_name)) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Email'), s_email)) DCNL DCSP  DCSP text += (' DCSP %s: DCSP %s' % (T('Phone'), s_phone)) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Working DCSP Status'), s_status)) DCNL DCSP  DCSP text += '\n************************************************\n' DCNL DCSP  DCSP url = URL(c='cr', f='shelter', args=r.id) DCNL DCSP  DCSP opts = dict(type='SMS', subject=T('Deployment DCSP Request'), message=(message + text), url=url) DCNL DCSP  DCSP output = msg.compose(**opts) DCNL DCSP  DCSP if attr.get('rheader'): DCNL DCSP  DCSP  DCSP rheader = attr['rheader'](r) DCNL DCSP  DCSP  DCSP if rheader: DCNL DCSP  DCSP  DCSP  DCSP output['rheader'] = rheader DCNL DCSP  DCSP output['title'] = T('Send DCSP Notification') DCNL DCSP  DCSP current.response.view = 'msg/compose.html' DCNL DCSP  DCSP return output DCNL DCSP else: DCNL DCSP  DCSP raise HTTP(501, current.messages.BADMETHOD)
 DCSP return {'id': member_ref['id'], 'image_id': member_ref['image_id'], 'member': member_ref['member'], 'can_share': member_ref['can_share'], 'status': member_ref['status'], 'created_at': member_ref['created_at'], 'updated_at': member_ref['updated_at'], 'deleted': member_ref['deleted']}
 DCSP while True: DCNL DCSP  DCSP v = np.random.rand(1) DCNL DCSP  DCSP if (v > p): DCNL DCSP  DCSP  DCSP (yield 0.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield np.random.rand(1))
 DCSP if (not policy_data): DCNL DCSP  DCSP policy_data = '' DCNL DCSP specialValueRegex = '(\\*\\*Del\\.|\\*\\*DelVals\\.){0,1}' DCNL DCSP item_key = None DCNL DCSP item_value_name = None DCNL DCSP data_to_replace = None DCNL DCSP if (not append_only): DCNL DCSP  DCSP item_key = this_string.split('{0};'.format(chr(0)))[0].lstrip('[') DCNL DCSP  DCSP item_value_name = re.sub(specialValueRegex, '', this_string.split('{0};'.format(chr(0)))[1], flags=re.IGNORECASE) DCNL DCSP  DCSP log.debug('item DCSP value DCSP name DCSP is DCSP {0}'.format(item_value_name)) DCNL DCSP  DCSP data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name) DCNL DCSP if data_to_replace: DCNL DCSP  DCSP log.debug('replacing DCSP {0} DCSP with DCSP {1}'.format([data_to_replace], [this_string])) DCNL DCSP  DCSP policy_data = policy_data.replace(data_to_replace, this_string) DCNL DCSP else: DCNL DCSP  DCSP log.debug('appending DCSP {0}'.format([this_string])) DCNL DCSP  DCSP policy_data = ''.join([policy_data, this_string]) DCNL DCSP return policy_data
 DCSP spec = db_spec(db) DCNL DCSP @decorator DCNL DCSP def decorate(fn, *args, **kw): DCNL DCSP  DCSP if isinstance(db, util.string_types): DCNL DCSP  DCSP  DCSP if (not spec(config._current)): DCNL DCSP  DCSP  DCSP  DCSP return fn(*args, **kw) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP wrapped = emits_warning(*warnings)(fn) DCNL DCSP  DCSP  DCSP  DCSP return wrapped(*args, **kw) DCNL DCSP  DCSP elif (not _is_excluded(*db)): DCNL DCSP  DCSP  DCSP return fn(*args, **kw) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wrapped = emits_warning(*warnings)(fn) DCNL DCSP  DCSP  DCSP return wrapped(*args, **kw) DCNL DCSP return decorate
 DCSP def construct(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/ldap.secret', 'r') DCNL DCSP  DCSP  DCSP bind_dn = 'cn=admin,{}'.format(base_dn()) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/machine.secret', 'r') DCNL DCSP  DCSP  DCSP bind_dn = config_registry()['ldap/hostdn'] DCNL DCSP  DCSP pwd_line = secret_file.readline() DCNL DCSP  DCSP pwd = re.sub('\n', '', pwd_line) DCNL DCSP  DCSP import univention.admin.uldap DCNL DCSP  DCSP return univention.admin.uldap.access(host=config_registry()['ldap/master'], base=base_dn(), binddn=bind_dn, bindpw=pwd, start_tls=1) DCNL DCSP return _singleton('uldap', construct)
 DCSP lres = [] DCNL DCSP bi = s.find(cont) DCNL DCSP if (bi != (-1)): DCNL DCSP  DCSP btag = s[:bi].rfind('<') DCNL DCSP  DCSP if (btag != (-1)): DCNL DCSP  DCSP  DCSP if (not toClosure): DCNL DCSP  DCSP  DCSP  DCSP etag = s[(bi + 1):].find('>') DCNL DCSP  DCSP  DCSP  DCSP if (etag != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP endidx = ((bi + 2) + etag) DCNL DCSP  DCSP  DCSP  DCSP  DCSP lres.append(s[btag:endidx]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((maxRes is not None) and (len(lres) >= maxRes)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return lres DCNL DCSP  DCSP  DCSP  DCSP  DCSP lres += _getTagsWith(s[endidx:], cont, toClosure=toClosure) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP spaceidx = s[btag:].find(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (spaceidx != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ctag = ('</%s>' % s[(btag + 1):(btag + spaceidx)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP closeidx = s[bi:].find(ctag) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (closeidx != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP endidx = ((bi + closeidx) + len(ctag)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lres.append(s[btag:endidx]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((maxRes is not None) and (len(lres) >= maxRes)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return lres DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lres += _getTagsWith(s[endidx:], cont, toClosure=toClosure) DCNL DCSP return lres
 DCSP request = cherrypy.serving.request DCNL DCSP auth_header = request.headers.get('authorization') DCNL DCSP nonce_is_stale = False DCNL DCSP if (auth_header is not None): DCNL DCSP  DCSP with cherrypy.HTTPError.handle(ValueError, 400, 'The DCSP Authorization DCSP header DCSP could DCSP not DCSP be DCSP parsed.'): DCNL DCSP  DCSP  DCSP auth = HttpDigestAuthorization(auth_header, request.method, debug=debug) DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP TRACE(str(auth)) DCNL DCSP  DCSP if auth.validate_nonce(realm, key): DCNL DCSP  DCSP  DCSP ha1 = get_ha1(realm, auth.username) DCNL DCSP  DCSP  DCSP if (ha1 is not None): DCNL DCSP  DCSP  DCSP  DCSP digest = auth.request_digest(ha1, entity_body=request.body) DCNL DCSP  DCSP  DCSP  DCSP if (digest == auth.response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE('digest DCSP matches DCSP auth.response') DCNL DCSP  DCSP  DCSP  DCSP  DCSP nonce_is_stale = auth.is_nonce_stale(max_age_seconds=600) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not nonce_is_stale): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP request.login = auth.username DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE(('authentication DCSP of DCSP %s DCSP successful' % auth.username)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP header = www_authenticate(realm, key, stale=nonce_is_stale) DCNL DCSP if debug: DCNL DCSP  DCSP TRACE(header) DCNL DCSP cherrypy.serving.response.headers['WWW-Authenticate'] = header DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP that DCSP resource')
 DCSP compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'} DCNL DCSP compress_flags = {'gzip': ['-f9'], 'compress': ['-f'], 'bzip2': ['-f9']} DCNL DCSP if ((compress is not None) and (compress not in compress_ext.keys())): DCNL DCSP  DCSP raise ValueError, "bad DCSP value DCSP for DCSP 'compress': DCSP must DCSP be DCSP None, DCSP 'gzip', DCSP or DCSP 'compress'" DCNL DCSP archive_name = (base_name + '.tar') DCNL DCSP mkpath(os.path.dirname(archive_name), dry_run=dry_run) DCNL DCSP cmd = ['tar', '-cf', archive_name, base_dir] DCNL DCSP spawn(cmd, dry_run=dry_run) DCNL DCSP if compress: DCNL DCSP  DCSP spawn((([compress] + compress_flags[compress]) + [archive_name]), dry_run=dry_run) DCNL DCSP  DCSP return (archive_name + compress_ext[compress]) DCNL DCSP else: DCNL DCSP  DCSP return archive_name
 DCSP return call_talib_with_ds(ds, count, talib.TRIX, timeperiod)
 DCSP lockdir = os.path.join(_get_download_cache_locs()[0], u'lock') DCNL DCSP for i in range(conf.download_cache_lock_attempts): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.mkdir(lockdir) DCNL DCSP  DCSP  DCSP with open(os.path.join(lockdir, u'pid'), u'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(str(os.getpid())) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP msg = u"Unable DCSP to DCSP acquire DCSP lock DCSP for DCSP cache DCSP directory DCSP ({0} DCSP exists). DCSP You DCSP may DCSP need DCSP to DCSP delete DCSP the DCSP lock DCSP if DCSP the DCSP python DCSP interpreter DCSP wasn't DCSP shut DCSP down DCSP properly." DCNL DCSP raise RuntimeError(msg.format(lockdir))
 DCSP return Select(select_browser_query.first.results[0]).options
 DCSP paragraph_re = re.compile('\\n(\\s*\\n)+', re.MULTILINE) DCNL DCSP text = dedent(text).strip() DCNL DCSP paragraphs = paragraph_re.split(text)[::2] DCNL DCSP out_ps = [] DCNL DCSP indent_re = re.compile('\\n\\s+', re.MULTILINE) DCNL DCSP for p in paragraphs: DCNL DCSP  DCSP if (indent_re.search(p) is None): DCNL DCSP  DCSP  DCSP p = textwrap.fill(p, ncols) DCNL DCSP  DCSP out_ps.append(p) DCNL DCSP return out_ps
 DCSP if os.path.isfile(path): DCNL DCSP  DCSP os.remove(path)
 DCSP try: DCNL DCSP  DCSP to_index = PyQuery(content).text() DCNL DCSP except ValueError: DCNL DCSP  DCSP return '' DCNL DCSP return to_index
 DCSP bits = token.split_contents() DCNL DCSP options = {} DCNL DCSP remaining_bits = bits[1:] DCNL DCSP while remaining_bits: DCNL DCSP  DCSP option = remaining_bits.pop(0) DCNL DCSP  DCSP if (option in options): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('The DCSP %r DCSP option DCSP was DCSP specified DCSP more DCSP than DCSP once.' % option)) DCNL DCSP  DCSP if (option == 'with'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"with" DCSP in DCSP %r DCSP tag DCSP needs DCSP at DCSP least DCSP one DCSP keyword DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == 'count'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (len(value) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"count" DCSP in DCSP %r DCSP tag DCSP expected DCSP exactly DCSP one DCSP keyword DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == 'context'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = remaining_bits.pop(0) DCNL DCSP  DCSP  DCSP  DCSP value = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"context" DCSP in DCSP %r DCSP tag DCSP expected DCSP exactly DCSP one DCSP argument.' % bits[0])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('Unknown DCSP argument DCSP for DCSP %r DCSP tag: DCSP %r.' % (bits[0], option))) DCNL DCSP  DCSP options[option] = value DCNL DCSP if ('count' in options): DCNL DCSP  DCSP (countervar, counter) = options['count'].items()[0] DCNL DCSP else: DCNL DCSP  DCSP (countervar, counter) = (None, None) DCNL DCSP if ('context' in options): DCNL DCSP  DCSP message_context = options['context'] DCNL DCSP else: DCNL DCSP  DCSP message_context = None DCNL DCSP extra_context = options.get('with', {}) DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP while parser.tokens: DCNL DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP singular.append(token) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (countervar and counter): DCNL DCSP  DCSP if (token.contents.strip() != 'plural'): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError("'blocktrans' DCSP doesn't DCSP allow DCSP other DCSP block DCSP tags DCSP inside DCSP it") DCNL DCSP  DCSP while parser.tokens: DCNL DCSP  DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP  DCSP plural.append(token) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (token.contents.strip() != 'endblocktrans'): DCNL DCSP  DCSP raise TemplateSyntaxError(("'blocktrans' DCSP doesn't DCSP allow DCSP other DCSP block DCSP tags DCSP (seen DCSP %r) DCSP inside DCSP it" % token.contents)) DCNL DCSP return BlockTranslateNode(extra_context, singular, plural, countervar, counter, message_context)
 DCSP if (entry == None): DCNL DCSP  DCSP return DCNL DCSP entry.delete(0, Tkinter.END) DCNL DCSP entry.insert(0, str(value))
 DCSP center = 'median' DCNL DCSP proportiontocut = 0.05 DCNL DCSP for (kw, value) in kwds.items(): DCNL DCSP  DCSP if (kw not in ['center', 'proportiontocut']): DCNL DCSP  DCSP  DCSP raise TypeError(("levene() DCSP got DCSP an DCSP unexpected DCSP keyword DCSP argument DCSP '%s'" % kw)) DCNL DCSP  DCSP if (kw == 'center'): DCNL DCSP  DCSP  DCSP center = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP proportiontocut = value DCNL DCSP k = len(args) DCNL DCSP if (k < 2): DCNL DCSP  DCSP raise ValueError('Must DCSP enter DCSP at DCSP least DCSP two DCSP input DCSP sample DCSP vectors.') DCNL DCSP Ni = zeros(k) DCNL DCSP Yci = zeros(k, 'd') DCNL DCSP if (center not in ['mean', 'median', 'trimmed']): DCNL DCSP  DCSP raise ValueError("Keyword DCSP argument DCSP <center> DCSP must DCSP be DCSP 'mean', DCSP 'median' DCSP or DCSP 'trimmed'.") DCNL DCSP if (center == 'median'): DCNL DCSP  DCSP func = (lambda x: np.median(x, axis=0)) DCNL DCSP elif (center == 'mean'): DCNL DCSP  DCSP func = (lambda x: np.mean(x, axis=0)) DCNL DCSP else: DCNL DCSP  DCSP args = tuple((stats.trimboth(np.sort(arg), proportiontocut) for arg in args)) DCNL DCSP  DCSP func = (lambda x: np.mean(x, axis=0)) DCNL DCSP for j in range(k): DCNL DCSP  DCSP Ni[j] = len(args[j]) DCNL DCSP  DCSP Yci[j] = func(args[j]) DCNL DCSP Ntot = np.sum(Ni, axis=0) DCNL DCSP Zij = ([None] * k) DCNL DCSP for i in range(k): DCNL DCSP  DCSP Zij[i] = abs((asarray(args[i]) - Yci[i])) DCNL DCSP Zbari = zeros(k, 'd') DCNL DCSP Zbar = 0.0 DCNL DCSP for i in range(k): DCNL DCSP  DCSP Zbari[i] = np.mean(Zij[i], axis=0) DCNL DCSP  DCSP Zbar += (Zbari[i] * Ni[i]) DCNL DCSP Zbar /= Ntot DCNL DCSP numer = ((Ntot - k) * np.sum((Ni * ((Zbari - Zbar) ** 2)), axis=0)) DCNL DCSP dvar = 0.0 DCNL DCSP for i in range(k): DCNL DCSP  DCSP dvar += np.sum(((Zij[i] - Zbari[i]) ** 2), axis=0) DCNL DCSP denom = ((k - 1.0) * dvar) DCNL DCSP W = (numer / denom) DCNL DCSP pval = distributions.f.sf(W, (k - 1), (Ntot - k)) DCNL DCSP return LeveneResult(W, pval)
 DCSP for innerNestedRing in nestedRing.innerNestedRings: DCNL DCSP  DCSP createFillForSurroundings(innerNestedRing.innerNestedRings, radius, radiusAround, shouldExtraLoopsBeAdded) DCNL DCSP allFillLoops = intercircle.getInsetSeparateLoopsFromAroundLoops(nestedRing.getLoopsToBeFilled(), radius, max((1.4 * radius), radiusAround)) DCNL DCSP if (len(allFillLoops) < 1): DCNL DCSP  DCSP return DCNL DCSP if shouldExtraLoopsBeAdded: DCNL DCSP  DCSP nestedRing.extraLoops += allFillLoops DCNL DCSP  DCSP nestedRing.penultimateFillLoops = nestedRing.lastFillLoops DCNL DCSP nestedRing.lastFillLoops = allFillLoops
 DCSP letters = re.compile('[A-PR-Y]', re.I) DCNL DCSP char2number = (lambda m: {'a': '2', 'c': '2', 'b': '2', 'e': '3', 'd': '3', 'g': '4', 'f': '3', 'i': '4', 'h': '4', 'k': '5', 'j': '5', 'm': '6', 'l': '5', 'o': '6', 'n': '6', 'p': '7', 's': '7', 'r': '7', 'u': '8', 't': '8', 'w': '9', 'v': '8', 'y': '9', 'x': '9'}.get(m.group(0).lower())) DCNL DCSP return letters.sub(char2number, phone)
 DCSP pass
 DCSP (dirname, _) = os.path.split(filename) DCNL DCSP if (dirname and (not os.path.exists(dirname))): DCNL DCSP  DCSP os.makedirs(dirname)
 DCSP (featuresNorm, MEAN, STD) = normalizeFeatures([features]) DCNL DCSP featuresNorm = featuresNorm[0] DCNL DCSP nSamples = labels.shape[0] DCNL DCSP partTrain = 0.9 DCNL DCSP ErrorsAll = [] DCNL DCSP ErrorsTrainAll = [] DCNL DCSP ErrorsBaselineAll = [] DCNL DCSP for (Ci, C) in enumerate(Params): DCNL DCSP  DCSP Errors = [] DCNL DCSP  DCSP ErrorsTrain = [] DCNL DCSP  DCSP ErrorsBaseline = [] DCNL DCSP  DCSP for e in range(nExp): DCNL DCSP  DCSP  DCSP randperm = numpy.random.permutation(range(nSamples)) DCNL DCSP  DCSP  DCSP nTrain = int(round((partTrain * nSamples))) DCNL DCSP  DCSP  DCSP featuresTrain = [featuresNorm[randperm[i]] for i in range(nTrain)] DCNL DCSP  DCSP  DCSP featuresTest = [featuresNorm[randperm[(i + nTrain)]] for i in range((nSamples - nTrain))] DCNL DCSP  DCSP  DCSP labelsTrain = [labels[randperm[i]] for i in range(nTrain)] DCNL DCSP  DCSP  DCSP labelsTest = [labels[randperm[(i + nTrain)]] for i in range((nSamples - nTrain))] DCNL DCSP  DCSP  DCSP featuresTrain = numpy.matrix(featuresTrain) DCNL DCSP  DCSP  DCSP if (MethodName == 'svm'): DCNL DCSP  DCSP  DCSP  DCSP [Classifier, trainError] = trainSVMregression(featuresTrain, labelsTrain, C) DCNL DCSP  DCSP  DCSP ErrorTest = [] DCNL DCSP  DCSP  DCSP ErrorTestBaseline = [] DCNL DCSP  DCSP  DCSP for (itest, fTest) in enumerate(featuresTest): DCNL DCSP  DCSP  DCSP  DCSP R = regressionWrapper(Classifier, MethodName, fTest) DCNL DCSP  DCSP  DCSP  DCSP Rbaseline = numpy.mean(labelsTrain) DCNL DCSP  DCSP  DCSP  DCSP ErrorTest.append(((R - labelsTest[itest]) * (R - labelsTest[itest]))) DCNL DCSP  DCSP  DCSP  DCSP ErrorTestBaseline.append(((Rbaseline - labelsTest[itest]) * (Rbaseline - labelsTest[itest]))) DCNL DCSP  DCSP  DCSP Error = numpy.array(ErrorTest).mean() DCNL DCSP  DCSP  DCSP ErrorBaseline = numpy.array(ErrorTestBaseline).mean() DCNL DCSP  DCSP  DCSP Errors.append(Error) DCNL DCSP  DCSP  DCSP ErrorsTrain.append(trainError) DCNL DCSP  DCSP  DCSP ErrorsBaseline.append(ErrorBaseline) DCNL DCSP  DCSP ErrorsAll.append(numpy.array(Errors).mean()) DCNL DCSP  DCSP ErrorsTrainAll.append(numpy.array(ErrorsTrain).mean()) DCNL DCSP  DCSP ErrorsBaselineAll.append(numpy.array(ErrorsBaseline).mean()) DCNL DCSP bestInd = numpy.argmin(ErrorsAll) DCNL DCSP print '{0:s} DCTB  DCTB {1:s} DCTB  DCTB {2:s} DCTB  DCTB {3:s}'.format('Param', 'MSE', 'T-MSE', 'R-MSE') DCNL DCSP for i in range(len(ErrorsAll)): DCNL DCSP  DCSP print '{0:.4f} DCTB  DCTB {1:.2f} DCTB  DCTB {2:.2f} DCTB  DCTB {3:.2f}'.format(Params[i], ErrorsAll[i], ErrorsTrainAll[i], ErrorsBaselineAll[i]), DCNL DCSP  DCSP if (i == bestInd): DCNL DCSP  DCSP  DCSP print ' DCTB  DCTB  DCSP best', DCNL DCSP  DCSP print DCNL DCSP return Params[bestInd]
 DCSP conn = _get_driver(profile=profile) DCNL DCSP return conn.get_record(zone_id, record_id)
 DCSP ret = salt.utils.mac_utils.execute_return_result('systemsetup DCSP -getrestartpowerfailure') DCNL DCSP return (salt.utils.mac_utils.validate_enabled(salt.utils.mac_utils.parse_return(ret)) == 'on')
 DCSP for (x_i, y_i, (low, high)) in zip(x, central_data, ci.T): DCNL DCSP  DCSP ax.plot([x_i, x_i], [low, high], color=color, solid_capstyle='round', **err_kws)
 DCSP query = models.HostQueueEntry.query_objects(filter_data) DCNL DCSP complete_count = query.filter(complete=True).count() DCNL DCSP total_count = query.count() DCNL DCSP if (total_count == 0): DCNL DCSP  DCSP return 1 DCNL DCSP return (float(complete_count) / total_count)
 DCSP encrypter = Encrypter(mode, padding=padding) DCNL DCSP _feed_stream(encrypter, in_stream, out_stream, block_size)
 DCSP return divider.join([el[0] for el in query])
 DCSP return os.path.abspath(os.path.join(path, os.pardir))
 DCSP meta_sources = {} DCNL DCSP for (module_path, class_name) in SOURCES.items(): DCNL DCSP  DCSP module = import_module(((METASYNC_MODULE + '.') + module_path)) DCNL DCSP  DCSP meta_sources[class_name.lower()] = getattr(module, class_name) DCNL DCSP return meta_sources
 DCSP alias_sql = sqlalchemy.text(u'SELECT DCSP alias_of DCSP FROM DCSP "_table_metadata"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP name DCSP = DCSP :alias DCSP AND DCSP alias_of DCSP IS DCSP NOT DCSP NULL') DCNL DCSP results = context['connection'].execute(alias_sql, alias=alias).fetchall() DCNL DCSP return [x[0] for x in results]
 DCSP from simplewiki import database DCNL DCSP wiki = make_wiki() DCNL DCSP wiki.bind_to_context() DCNL DCSP return {'wiki': wiki, 'db': database}
 DCSP if (not os.path.exists(work_directory)): DCNL DCSP  DCSP os.mkdir(work_directory) DCNL DCSP filepath = os.path.join(work_directory, filename) DCNL DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP print('Downloading DCSP MNIST...') DCNL DCSP  DCSP (filepath, _) = urllib.request.urlretrieve((SOURCE_URL + filename), filepath) DCNL DCSP  DCSP statinfo = os.stat(filepath) DCNL DCSP  DCSP print('Succesfully DCSP downloaded', filename, statinfo.st_size, 'bytes.') DCNL DCSP return filepath
 DCSP range_operands = [Constant.int(load.type, lower_bound), Constant.int(load.type, upper_bound)] DCNL DCSP md = builder.module.add_metadata(range_operands) DCNL DCSP load.set_metadata('range', md)
 DCSP found_pid = False DCNL DCSP pid_str = (' DCSP PID: DCSP %s DCSP ' % pid) DCNL DCSP for line in fileinput.input(glob.glob((static.DEBUG_FILE + '*'))): DCNL DCSP  DCSP if (pid_str in line): DCNL DCSP  DCSP  DCSP (yield line) DCNL DCSP  DCSP  DCSP found_pid = True DCNL DCSP  DCSP elif (found_pid and (' DCSP PID: DCSP ' not in line)): DCNL DCSP  DCSP  DCSP (yield line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP found_pid = False
 DCSP size = (params['fig'].get_size_inches() * params['fig'].dpi) DCNL DCSP scroll_width = 25 DCNL DCSP hscroll_dist = 25 DCNL DCSP vscroll_dist = 10 DCNL DCSP l_border = 100 DCNL DCSP r_border = 10 DCNL DCSP t_border = 35 DCNL DCSP b_border = 40 DCNL DCSP if ((size[0] < (2 * scroll_width)) or (size[1] < ((2 * scroll_width) + hscroll_dist))): DCNL DCSP  DCSP return DCNL DCSP scroll_width_x = (scroll_width / size[0]) DCNL DCSP scroll_width_y = (scroll_width / size[1]) DCNL DCSP vscroll_dist /= size[0] DCNL DCSP hscroll_dist /= size[1] DCNL DCSP l_border /= size[0] DCNL DCSP r_border /= size[0] DCNL DCSP t_border /= size[1] DCNL DCSP b_border /= size[1] DCNL DCSP ax_width = ((((1.0 - scroll_width_x) - l_border) - r_border) - vscroll_dist) DCNL DCSP ax_y = ((hscroll_dist + scroll_width_y) + b_border) DCNL DCSP ax_height = ((1.0 - ax_y) - t_border) DCNL DCSP pos = [l_border, ax_y, ax_width, ax_height] DCNL DCSP params['ax'].set_position(pos) DCNL DCSP if ('ax2' in params): DCNL DCSP  DCSP params['ax2'].set_position(pos) DCNL DCSP params['ax'].set_position(pos) DCNL DCSP pos = [((ax_width + l_border) + vscroll_dist), ax_y, scroll_width_x, ax_height] DCNL DCSP params['ax_vscroll'].set_position(pos) DCNL DCSP pos = [l_border, b_border, ax_width, scroll_width_y] DCNL DCSP params['ax_hscroll'].set_position(pos) DCNL DCSP if ('ax_button' in params): DCNL DCSP  DCSP pos = [((l_border + ax_width) + vscroll_dist), b_border, scroll_width_x, scroll_width_y] DCNL DCSP  DCSP params['ax_button'].set_position(pos) DCNL DCSP if ('ax_help_button' in params): DCNL DCSP  DCSP pos = [((l_border - vscroll_dist) - (scroll_width_x * 2)), b_border, (scroll_width_x * 2), scroll_width_y] DCNL DCSP  DCSP params['ax_help_button'].set_position(pos) DCNL DCSP params['fig'].canvas.draw()
 DCSP _test_fetch('http://google.com')
 DCSP if (mock_hadoop_uses_yarn(environ) and args and (args[0] == '-R')): DCNL DCSP  DCSP path_args = args[1:] DCNL DCSP  DCSP recursive = True DCNL DCSP else: DCNL DCSP  DCSP path_args = args DCNL DCSP  DCSP recursive = False DCNL DCSP return _hadoop_fs_ls('ls', stdout, stderr, environ, path_args=path_args, recursive=recursive)
 DCSP return re.sub('(?m)^(?!$)', (indent * ' DCSP '), s)
 DCSP model_n = 7 DCNL DCSP if binocular: DCNL DCSP  DCSP model_n = 13 DCNL DCSP cal_pt_cloud = np.array(cal_pt_cloud) DCNL DCSP (cx, cy, err_x, err_y) = fit_poly_surface(cal_pt_cloud, model_n) DCNL DCSP (err_dist, err_mean, err_rms) = fit_error_screen(err_x, err_y, screen_size) DCNL DCSP if cal_pt_cloud[(err_dist <= threshold)].shape[0]: DCNL DCSP  DCSP (cx, cy, new_err_x, new_err_y) = fit_poly_surface(cal_pt_cloud[(err_dist <= threshold)], model_n) DCNL DCSP  DCSP map_fn = make_map_function(cx, cy, model_n) DCNL DCSP  DCSP (new_err_dist, new_err_mean, new_err_rms) = fit_error_screen(new_err_x, new_err_y, screen_size) DCNL DCSP  DCSP logger.info('first DCSP iteration. DCSP root-mean-square DCSP residuals: DCSP {}, DCSP in DCSP pixel'.format(err_rms)) DCNL DCSP  DCSP logger.info('second DCSP iteration: DCSP ignoring DCSP outliers. DCSP root-mean-square DCSP residuals: DCSP {} DCSP in DCSP pixel'.format(new_err_rms)) DCNL DCSP  DCSP logger.info('used DCSP {} DCSP data DCSP points DCSP out DCSP of DCSP the DCSP full DCSP dataset DCSP {}: DCSP subset DCSP is DCSP {} DCSP percent'.format((cal_pt_cloud[(err_dist <= threshold)].shape[0], cal_pt_cloud.shape[0], ((100 * float(cal_pt_cloud[(err_dist <= threshold)].shape[0])) / cal_pt_cloud.shape[0])))) DCNL DCSP  DCSP return (map_fn, (err_dist <= threshold), (cx, cy, model_n)) DCNL DCSP else: DCNL DCSP  DCSP map_fn = make_map_function(cx, cy, model_n) DCNL DCSP  DCSP logger.error('First DCSP iteration. DCSP root-mean-square DCSP residuals: DCSP {} DCSP in DCSP pixel, DCSP this DCSP is DCSP bad!'.format(err_rms)) DCNL DCSP  DCSP logger.error('The DCSP data DCSP cannot DCSP be DCSP represented DCSP by DCSP the DCSP model DCSP in DCSP a DCSP meaningfull DCSP way.') DCNL DCSP  DCSP return (map_fn, (err_dist <= threshold), (cx, cy, model_n))
 DCSP sig = np.empty(1000) DCNL DCSP sfreq = 1000 DCNL DCSP assert_raises(RuntimeError, filter_data, sig, sfreq, 0.6, None, method='iir', iir_params=dict(ftype='butter', order=8, output='ba')) DCNL DCSP filter_data(sig, sfreq, 0.6, None, method='iir', iir_params=dict(ftype='butter', order=8, output='sos')) DCNL DCSP assert_raises(ValueError, filter_data, sig, sfreq, 0.6, None, method='iir', iir_params=dict(ftype='butter', order=8, output='foo')) DCNL DCSP assert_raises(RuntimeError, filter_data, sig, sfreq, 0.6, None, method='iir', iir_params=dict(order=8, output='sos')) DCNL DCSP assert_raises(RuntimeError, filter_data, sig, sfreq, 0.6, None, method='iir', iir_params=dict(order=8, ftype='foo', output='sos')) DCNL DCSP assert_raises(RuntimeError, filter_data, sig, sfreq, 0.6, None, method='iir', iir_params=dict(gpass=0.5, output='sos')) DCNL DCSP assert_raises(ValueError, filter_data, sig, sfreq, 0.1, None, method='fft', iir_params=dict(ftype='butter', order=2, output='sos')) DCNL DCSP assert_raises(TypeError, filter_data, sig, sfreq, 0.1, None, method=1) DCNL DCSP assert_raises(ValueError, filter_data, sig, sfreq, 0.1, None, method='blah') DCNL DCSP assert_raises(TypeError, filter_data, sig, sfreq, 0.1, None, method='iir', iir_params='blah') DCNL DCSP assert_raises(ValueError, filter_data, sig, sfreq, 0.1, None, method='fft', iir_params=dict()) DCNL DCSP iir_params = dict(ftype='butter', order=2, output='sos') DCNL DCSP x_sos = filter_data(sig, 250, 0.5, None, method='iir', iir_params=iir_params) DCNL DCSP iir_params_sos = construct_iir_filter(iir_params, f_pass=0.5, sfreq=250, btype='highpass') DCNL DCSP x_sos_2 = filter_data(sig, 250, 0.5, None, method='iir', iir_params=iir_params_sos) DCNL DCSP assert_allclose(x_sos[100:(-100)], x_sos_2[100:(-100)]) DCNL DCSP x_ba = filter_data(sig, 250, 0.5, None, method='iir', iir_params=dict(ftype='butter', order=2, output='ba')) DCNL DCSP assert_allclose(x_sos[100:(-100)], x_ba[100:(-100)])
 DCSP return re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()
 DCSP lines = archive.getTextLines(text) DCNL DCSP shortDictionary = {} DCNL DCSP for setting in repository.preferences: DCNL DCSP  DCSP shortDictionary[getShortestUniqueSettingName(setting.name, repository.preferences)] = setting DCNL DCSP for lineIndex in xrange(len(lines)): DCNL DCSP  DCSP setRepositoryToLine(lineIndex, lines, shortDictionary)
 DCSP return '\n'.join(salt.version.versions_report())
 DCSP import subprocess, time DCNL DCSP result = pEyeGaze.EgExit(byref(eyegaze_control)) DCNL DCSP eyegaze_control = None DCNL DCSP p = subprocess.Popen(('calibrate.exe', '')) DCNL DCSP while (p.poll() is None): DCNL DCSP  DCSP time.sleep(0.05) DCNL DCSP return initEyeGaze()
 DCSP if (len(fps) != len(distmats)): DCNL DCSP  DCSP raise ValueError('Must DCSP provide DCSP the DCSP same DCSP number DCSP of DCSP filepaths DCSP as DCSP there DCSP are DCSP distance DCSP matrices.') DCNL DCSP if (comment is None): DCNL DCSP  DCSP comment = '' DCNL DCSP result = ((((comment + 'DM1 DCTB DM2 DCTB Number DCSP of DCSP entries DCTB ') + 'Number DCSP of DCSP permutations DCTB Class DCSP index DCTB ') + 'Number DCSP of DCSP distances DCTB Mantel DCSP r DCSP statistic DCTB ') + 'p-value DCTB p-value DCSP (Bonferroni DCSP corrected) DCTB Tail DCSP type\n') DCNL DCSP correlogram_fps = [] DCNL DCSP correlograms = [] DCNL DCSP for (i, (fp1, (dm1_labels, dm1_data))) in enumerate(zip(fps, distmats)): DCNL DCSP  DCSP for (fp2, (dm2_labels, dm2_data)) in zip(fps, distmats)[(i + 1):]: DCNL DCSP  DCSP  DCSP ((dm1_labels, dm1_data), (dm2_labels, dm2_data)) = make_compatible_distance_matrices((dm1_labels, dm1_data), (dm2_labels, dm2_data), lookup=sample_id_map) DCNL DCSP  DCSP  DCSP if (len(dm1_labels) < 3): DCNL DCSP  DCSP  DCSP  DCSP result += ('%s DCTB %s DCTB %d DCTB Too DCSP few DCSP samples\n' % (fp1, fp2, len(dm1_labels))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP dm1 = DistanceMatrix(dm1_data, dm1_labels) DCNL DCSP  DCSP  DCSP dm2 = DistanceMatrix(dm2_data, dm2_labels) DCNL DCSP  DCSP  DCSP mc = MantelCorrelogram(dm1, dm2, alpha=alpha, variable_size_distance_classes=variable_size_distance_classes) DCNL DCSP  DCSP  DCSP results = mc(num_perms) DCNL DCSP  DCSP  DCSP dm1_name = path.basename(fp1) DCNL DCSP  DCSP  DCSP dm2_name = path.basename(fp2) DCNL DCSP  DCSP  DCSP correlogram_fps.append(('_'.join((dm1_name, 'AND', dm2_name, 'mantel_correlogram')) + '.')) DCNL DCSP  DCSP  DCSP correlograms.append(results['correlogram_plot']) DCNL DCSP  DCSP  DCSP first_time = True DCNL DCSP  DCSP  DCSP for (class_idx, num_dist, r, p, p_corr) in zip(results['class_index'], results['num_dist'], results['mantel_r'], results['mantel_p'], results['mantel_p_corr']): DCNL DCSP  DCSP  DCSP  DCSP p_str = None DCNL DCSP  DCSP  DCSP  DCSP if (p is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_str = p_value_to_str(p, num_perms) DCNL DCSP  DCSP  DCSP  DCSP p_corr_str = None DCNL DCSP  DCSP  DCSP  DCSP if (p_corr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_corr_str = p_value_to_str(p_corr, num_perms) DCNL DCSP  DCSP  DCSP  DCSP if (r is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = None DCNL DCSP  DCSP  DCSP  DCSP elif (r < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = 'less' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = 'greater' DCNL DCSP  DCSP  DCSP  DCSP if first_time: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result += ('%s DCTB %s DCTB %d DCTB %d DCTB %s DCTB %d DCTB %s DCTB %s DCTB %s DCTB %s\n' % (fp1, fp2, len(dm1_labels), num_perms, class_idx, num_dist, r, p_str, p_corr_str, tail_type)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_time = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result += (' DCTB  DCTB  DCTB  DCTB %s DCTB %d DCTB %s DCTB %s DCTB %s DCTB %s\n' % (class_idx, num_dist, r, p_str, p_corr_str, tail_type)) DCNL DCSP return (result, correlogram_fps, correlograms)
 DCSP if (port_eth in (True, None)): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP port_eth = EthAddr(port_eth) DCNL DCSP dpid = str_to_dpid(dpid) DCNL DCSP try: DCNL DCSP  DCSP port = int(port) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP def dhcpclient_init(): DCNL DCSP  DCSP n = name DCNL DCSP  DCSP if (n is None): DCNL DCSP  DCSP  DCSP s = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP if (not core.hasComponent(('DHCPClient' + s))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP n = ('DHCPClient' + s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP s = str((int(('0' + s)) + 1)) DCNL DCSP  DCSP elif core.hasComponent(n): DCNL DCSP  DCSP  DCSP self.log.error('Already DCSP have DCSP component DCSP %s', n) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP client = DHCPClient(port=port, dpid=dpid, name=n, port_eth=port_eth) DCNL DCSP  DCSP core.register(n, client) DCNL DCSP core.call_when_ready(dhcpclient_init, ['openflow'])
 DCSP if (not isinstance(config, dict)): DCNL DCSP  DCSP return (False, 'Configuration DCSP for DCSP btmp DCSP beacon DCSP must DCSP be DCSP a DCSP list DCSP of DCSP dictionaries.') DCNL DCSP return (True, 'Valid DCSP beacon DCSP configuration')
 DCSP plotter = _HeatMapper(data, vmin, vmax, cmap, center, robust, annot, fmt, annot_kws, cbar, cbar_kws, xticklabels, yticklabels, mask) DCNL DCSP kwargs['linewidths'] = linewidths DCNL DCSP kwargs['edgecolor'] = linecolor DCNL DCSP if (ax is None): DCNL DCSP  DCSP ax = plt.gca() DCNL DCSP if square: DCNL DCSP  DCSP ax.set_aspect('equal') DCNL DCSP plotter.plot(ax, cbar_ax, kwargs) DCNL DCSP return ax
 DCSP @wraps(fun) DCNL DCSP def get(self): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return self._cache[fun] DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP self._cache = {} DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP ret = self._cache[fun] = fun(self) DCNL DCSP  DCSP return ret DCNL DCSP return property(get)
 DCSP @wraps(function) DCNL DCSP def dec(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP except np.linalg.LinAlgError as exp: DCNL DCSP  DCSP  DCSP if ('SVD DCSP did DCSP not DCSP converge' in str(exp)): DCNL DCSP  DCSP  DCSP  DCSP from nose.plugins.skip import SkipTest DCNL DCSP  DCSP  DCSP  DCSP msg = 'Intel DCSP MKL DCSP SVD DCSP convergence DCSP error DCSP detected, DCSP skipping DCSP test' DCNL DCSP  DCSP  DCSP  DCSP warn(msg) DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP  DCSP raise DCNL DCSP return dec
 DCSP running_tasks_data = [] DCNL DCSP for task in tasks: DCNL DCSP  DCSP if task.isAlive(): DCNL DCSP  DCSP  DCSP running_tasks_data.append((' DCSP  DCSP %s DCSP (started DCSP %s)' % (task.name, time.strftime('%H:%M:%S', time.localtime(task.start_time))))) DCNL DCSP  DCSP if task.exception: DCNL DCSP  DCSP  DCSP ALL_ERRORS.append(task.exception) DCNL DCSP if running_tasks_data: DCNL DCSP  DCSP log('----------------------------------------') DCNL DCSP  DCSP log('Tasks DCSP still DCSP running:') DCNL DCSP  DCSP for task_details in running_tasks_data: DCNL DCSP  DCSP  DCSP log(task_details)
 DCSP if (value in __opts__): DCNL DCSP  DCSP return __opts__[value] DCNL DCSP master_opts = __pillar__.get('master', {}) DCNL DCSP if (value in master_opts): DCNL DCSP  DCSP return master_opts[value] DCNL DCSP if (value in __pillar__): DCNL DCSP  DCSP return __pillar__[value]
 DCSP port = socket() DCNL DCSP port.bind(('', 0)) DCNL DCSP port.listen(1) DCNL DCSP client = socket() DCNL DCSP client.setblocking(False) DCNL DCSP client.connect_ex(('127.0.0.1', port.getsockname()[1])) DCNL DCSP client.setblocking(True) DCNL DCSP server = port.accept()[0] DCNL DCSP server.send(b('x')) DCNL DCSP assert (client.recv(1024) == b('x')) DCNL DCSP client.send(b('y')) DCNL DCSP assert (server.recv(1024) == b('y')) DCNL DCSP server.setblocking(False) DCNL DCSP client.setblocking(False) DCNL DCSP return (server, client)
 DCSP from flask_migrate import upgrade DCNL DCSP from app.models import Role, User DCNL DCSP upgrade() DCNL DCSP Role.insert_roles() DCNL DCSP User.add_self_follows()
 DCSP statements = [] DCNL DCSP current = '' DCNL DCSP prev = '' DCNL DCSP between_quotes = None DCNL DCSP is_comment = None DCNL DCSP start_row = 0 DCNL DCSP start_col = 0 DCNL DCSP end_row = 0 DCNL DCSP end_col = (len(hql) - 1) DCNL DCSP if (hql.find(';') in ((-1), (len(hql) - 1))): DCNL DCSP  DCSP return [((start_row, start_col), (end_row, end_col), hql)] DCNL DCSP lines = hql.splitlines() DCNL DCSP for (row, line) in enumerate(lines): DCNL DCSP  DCSP end_col = 0 DCNL DCSP  DCSP end_row = row DCNL DCSP  DCSP if ((start_row == row) and (line.strip() == '')): DCNL DCSP  DCSP  DCSP start_row += 1 DCNL DCSP  DCSP elif (current.strip() == ''): DCNL DCSP  DCSP  DCSP start_row = row DCNL DCSP  DCSP  DCSP start_col = 0 DCNL DCSP  DCSP for (col, c) in enumerate(line): DCNL DCSP  DCSP  DCSP current += c DCNL DCSP  DCSP  DCSP if ((c in ('"', "'")) and (prev != '\\') and (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP if (between_quotes == c): DCNL DCSP  DCSP  DCSP  DCSP  DCSP between_quotes = None DCNL DCSP  DCSP  DCSP  DCSP elif (between_quotes is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP between_quotes = c DCNL DCSP  DCSP  DCSP elif ((c == '-') and (prev == '-') and (between_quotes is None) and (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP is_comment = True DCNL DCSP  DCSP  DCSP elif (c == ';'): DCNL DCSP  DCSP  DCSP  DCSP if ((between_quotes is None) and (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = current.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = current[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(current) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP statements.append(((start_row, start_col), (row, (col + 1)), current)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start_col = (col + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = '' DCNL DCSP  DCSP  DCSP if ((prev == '\\') and (between_quotes is not None)): DCNL DCSP  DCSP  DCSP  DCSP c = '' DCNL DCSP  DCSP  DCSP prev = c DCNL DCSP  DCSP  DCSP end_col = col DCNL DCSP  DCSP is_comment = None DCNL DCSP  DCSP prev = os.linesep DCNL DCSP  DCSP if (current != ''): DCNL DCSP  DCSP  DCSP current += os.linesep DCNL DCSP if (current and (current != ';')): DCNL DCSP  DCSP current = current.strip() DCNL DCSP  DCSP statements.append(((start_row, start_col), (end_row, (end_col + 1)), current)) DCNL DCSP return statements
 DCSP if ((len(data) >= 4) and (data[:2] == _l2bytes([254, 255])) and (data[2:4] != _l2bytes([0, 0]))): DCNL DCSP  DCSP encoding = 'utf-16be' DCNL DCSP  DCSP data = data[2:] DCNL DCSP elif ((len(data) >= 4) and (data[:2] == _l2bytes([255, 254])) and (data[2:4] != _l2bytes([0, 0]))): DCNL DCSP  DCSP encoding = 'utf-16le' DCNL DCSP  DCSP data = data[2:] DCNL DCSP elif (data[:3] == _l2bytes([239, 187, 191])): DCNL DCSP  DCSP encoding = 'utf-8' DCNL DCSP  DCSP data = data[3:] DCNL DCSP elif (data[:4] == _l2bytes([0, 0, 254, 255])): DCNL DCSP  DCSP encoding = 'utf-32be' DCNL DCSP  DCSP data = data[4:] DCNL DCSP elif (data[:4] == _l2bytes([255, 254, 0, 0])): DCNL DCSP  DCSP encoding = 'utf-32le' DCNL DCSP  DCSP data = data[4:] DCNL DCSP newdata = unicode(data, encoding) DCNL DCSP declmatch = re.compile('^<\\?xml[^>]*?>') DCNL DCSP newdecl = "<?xml DCSP version='1.0' DCSP encoding='utf-8'?>" DCNL DCSP if declmatch.search(newdata): DCNL DCSP  DCSP newdata = declmatch.sub(newdecl, newdata) DCNL DCSP else: DCNL DCSP  DCSP newdata = ((newdecl + u'\n') + newdata) DCNL DCSP return newdata.encode('utf-8')
 DCSP tp = TrivialPrompter() DCNL DCSP stdio.StandardIO(tp) DCNL DCSP proto.prompt = tp.prompt DCNL DCSP proto.display = tp.display DCNL DCSP return proto.authenticate(password).addCallback(cbAuthentication, proto).addErrback(ebAuthentication, proto, username, password)
 DCSP res = Q(filter_, thing) DCNL DCSP if isinstance(filter_, type({})): DCNL DCSP  DCSP for k in res: DCNL DCSP  DCSP  DCSP res[k] = list(res[k]) DCNL DCSP  DCSP return res DCNL DCSP else: DCNL DCSP  DCSP return list(res)
 DCSP return _levelNames.get(level, ('Level DCSP %s' % level))
 DCSP return __salt__['probes.delete_probes'](_ordered_dict_to_dict(probes), commit=False)
 DCSP redirect_to = request.REQUEST.get(redirect_field_name, '') DCNL DCSP if ((not redirect_to) or ('//' in redirect_to) or (' DCSP ' in redirect_to)): DCNL DCSP  DCSP redirect_to = default_redirect DCNL DCSP rels = UserAssociation.objects.filter(user__id=request.user.id) DCNL DCSP associated_openids = [rel.openid_url for rel in rels] DCNL DCSP if ((len(associated_openids) == 1) and (not request.user.has_usable_password())): DCNL DCSP  DCSP msg = _("You DCSP can't DCSP remove DCSP this DCSP openid. DCSP You DCSP should DCSP set DCSP a DCSP password DCSP first.") DCNL DCSP  DCSP return HttpResponseRedirect(('%s?%s' % (redirect_to, urllib.urlencode({'msg': msg})))) DCNL DCSP if request.POST: DCNL DCSP  DCSP form = dissociate_form(request.POST) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP openid_url = form.cleaned_data['openid_url'] DCNL DCSP  DCSP  DCSP msg = '' DCNL DCSP  DCSP  DCSP if (openid_url not in associated_openids): DCNL DCSP  DCSP  DCSP  DCSP msg = (_('%s DCSP is DCSP not DCSP associated DCSP to DCSP your DCSP account') % openid_url) DCNL DCSP  DCSP  DCSP if (not msg): DCNL DCSP  DCSP  DCSP  DCSP UserAssociation.objects.get(openid_url__exact=openid_url).delete() DCNL DCSP  DCSP  DCSP  DCSP if (openid_url == request.session.get('openid_url')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del request.session['openid_url'] DCNL DCSP  DCSP  DCSP  DCSP msg = _('openid DCSP removed.') DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(('%s?%s' % (redirect_to, urllib.urlencode({'msg': msg})))) DCNL DCSP else: DCNL DCSP  DCSP openid_url = request.GET.get('openid_url', '') DCNL DCSP  DCSP if (not openid_url): DCNL DCSP  DCSP  DCSP msg = _('Invalid DCSP OpenID DCSP url.') DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(('%s?%s' % (redirect_to, urllib.urlencode({'msg': msg})))) DCNL DCSP  DCSP form = dissociate_form(initial={'openid_url': openid_url}) DCNL DCSP return render(template_name, {'form': form, 'openid_url': openid_url}, context_instance=_build_context(request, extra_context=extra_context))
 DCSP logger.debug('Checking DCSP if DCSP %s DCSP is DCSP complete', task) DCNL DCSP try: DCNL DCSP  DCSP is_complete = task.complete() DCNL DCSP except Exception: DCNL DCSP  DCSP is_complete = TracebackWrapper(traceback.format_exc()) DCNL DCSP out_queue.put((task, is_complete))
 DCSP pkg2rm = '' DCNL DCSP if pkgs: DCNL DCSP  DCSP for pkg in pkgs: DCNL DCSP  DCSP  DCSP pkg2rm += '{0} DCSP '.format(pkg) DCNL DCSP  DCSP log.debug('Installing DCSP these DCSP packages DCSP instead DCSP of DCSP {0}: DCSP {1}'.format(name, pkg2rm)) DCNL DCSP else: DCNL DCSP  DCSP pkg2rm = '{0}'.format(name) DCNL DCSP old = list_pkgs() DCNL DCSP cmd = '/bin/pkg DCSP uninstall DCSP -v DCSP {0}'.format(pkg2rm) DCNL DCSP out = __salt__['cmd.run_all'](cmd, output_loglevel='trace') DCNL DCSP __context__.pop('pkg.list_pkgs', None) DCNL DCSP new = list_pkgs() DCNL DCSP ret = salt.utils.compare_dicts(old, new) DCNL DCSP if (out['retcode'] != 0): DCNL DCSP  DCSP raise CommandExecutionError('Error DCSP occurred DCSP removing DCSP package(s)', info={'changes': ret, 'retcode': ips_pkg_return_values[out['retcode']], 'errors': [out['stderr']]}) DCNL DCSP return ret
 DCSP from inbox.config import config DCNL DCSP database_hosts = config.get_required('DATABASE_HOSTS') DCNL DCSP schemas = [(shard['SCHEMA_NAME'], host['HOSTNAME']) for host in database_hosts for shard in host['SHARDS']] DCNL DCSP assert all([('test' in s) for (s, h) in schemas]) DCNL DCSP for (name, host) in schemas: DCNL DCSP  DCSP cmd = 'DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP {name}; DCSP CREATE DCSP DATABASE DCSP IF DCSP NOT DCSP EXISTS DCSP {name} DCSP DEFAULT DCSP CHARACTER DCSP SET DCSP utf8mb4 DCSP DEFAULT DCSP COLLATE DCSP utf8mb4_general_ci'.format(name=name) DCNL DCSP  DCSP subprocess.check_call('mysql DCSP -h DCSP {} DCSP -uinboxtest DCSP -pinboxtest DCSP -e DCSP "{}"'.format(host, cmd), shell=True)
 DCSP if (key is None): DCNL DCSP  DCSP return {} DCNL DCSP key = _to_bytes(key) DCNL DCSP key_hash = hashlib.sha256(key).digest() DCNL DCSP key_hash = base64.b64encode(key_hash).rstrip() DCNL DCSP key = base64.b64encode(key).rstrip() DCNL DCSP if source: DCNL DCSP  DCSP prefix = 'X-Goog-Copy-Source-Encryption-' DCNL DCSP else: DCNL DCSP  DCSP prefix = 'X-Goog-Encryption-' DCNL DCSP return {(prefix + 'Algorithm'): 'AES256', (prefix + 'Key'): _bytes_to_unicode(key), (prefix + 'Key-Sha256'): _bytes_to_unicode(key_hash)}
 DCSP return get_current_app()._rgetattr(reverse_name)(*args)
 DCSP return (auth.user_has_role(user, CourseBetaTesterRole(descriptor.id)) or _has_staff_access_to_descriptor(user, descriptor, descriptor.id) or _is_descriptor_mobile_available(descriptor))
 DCSP if (not kargs.has_key('timeout')): DCNL DCSP  DCSP kargs['timeout'] = (-1) DCNL DCSP s = conf.L3socket(promisc=promisc, filter=filter, nofilter=nofilter, iface=iface) DCNL DCSP (a, b) = sndrcv(s, x, *args, **kargs) DCNL DCSP s.close() DCNL DCSP if (len(a) > 0): DCNL DCSP  DCSP return a[0][1] DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP global FS_CACHE, MR_CACHE DCNL DCSP old = (FS_CACHE, MR_CACHE) DCNL DCSP (FS_CACHE, MR_CACHE) = (None, None) DCNL DCSP return old
 DCSP return (len(value) == int(arg))
 DCSP return LazyLoader(_module_dirs(opts, 'search', 'search'), opts, tag='search', whitelist=whitelist, pack={'__ret__': returners})
 DCSP if six.PY3: DCNL DCSP  DCSP b = salt.utils.to_bytes(instr) DCNL DCSP  DCSP b64 = base64.b64encode(b) DCNL DCSP  DCSP return salt.utils.to_str(b64) DCNL DCSP return base64.b64encode(instr)
 DCSP return getattr(d, _iteritems)()
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP if isinstance(storage, LazyObject): DCNL DCSP  DCSP if (storage._wrapped is None): DCNL DCSP  DCSP  DCSP storage._setup() DCNL DCSP  DCSP storage = storage._wrapped DCNL DCSP if (not isinstance(storage, six.string_types)): DCNL DCSP  DCSP storage_cls = storage.__class__ DCNL DCSP  DCSP storage = ('%s.%s' % (storage_cls.__module__, storage_cls.__name__)) DCNL DCSP return hashlib.md5(storage.encode('utf8')).hexdigest()
 DCSP prev_value = config.compute_test_value DCNL DCSP try: DCNL DCSP  DCSP config.compute_test_value = 'off' DCNL DCSP  DCSP x = T.vector() DCNL DCSP  DCSP for x_val in op.get_debug_values(x): DCNL DCSP  DCSP  DCSP assert False DCNL DCSP finally: DCNL DCSP  DCSP config.compute_test_value = prev_value
 DCSP return ((option in helpful_parser.defaults) and (helpful_parser.defaults[option] == value))
 DCSP def rate_element(driver): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inner_wrapper = find_id_with_wait(context, id_, wait_time=2) DCNL DCSP  DCSP  DCSP els = inner_wrapper.find_elements_by_class_name(STAR_RATING_OPTION_CLASS) DCNL DCSP  DCSP  DCSP rating_el = [el for el in filter((lambda x: (int(x.get_attribute('data-val')) == val)), els)][0] DCNL DCSP  DCSP  DCSP rating_el.click() DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except (NoSuchElementException, StaleElementReferenceException, TimeoutException, IndexError): DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, 30).until(rate_element) DCNL DCSP except TimeoutException: DCNL DCSP  DCSP raise Exception("Unable DCSP to DCSP enter DCSP rating DCSP for DCSP container DCSP with DCSP id DCSP '{id:s}'".format(id=id_))
 DCSP if ('docker.client' not in __context__): DCNL DCSP  DCSP client_kwargs = {} DCNL DCSP  DCSP for (key, val) in (('base_url', 'docker.url'), ('version', 'docker.version')): DCNL DCSP  DCSP  DCSP param = __salt__['config.get'](val, NOTSET) DCNL DCSP  DCSP  DCSP if (param is not NOTSET): DCNL DCSP  DCSP  DCSP  DCSP client_kwargs[key] = param DCNL DCSP  DCSP if (('base_url' not in client_kwargs) and ('DOCKER_HOST' in os.environ)): DCNL DCSP  DCSP  DCSP client_kwargs['base_url'] = os.environ.get('DOCKER_HOST') DCNL DCSP  DCSP if ('version' not in client_kwargs): DCNL DCSP  DCSP  DCSP client_kwargs['version'] = 'auto' DCNL DCSP  DCSP docker_machine = __salt__['config.get']('docker.machine', NOTSET) DCNL DCSP  DCSP if (docker_machine is not NOTSET): DCNL DCSP  DCSP  DCSP docker_machine_json = __salt__['cmd.run'](('docker-machine DCSP inspect DCSP ' + docker_machine)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP docker_machine_json = json.loads(docker_machine_json) DCNL DCSP  DCSP  DCSP  DCSP docker_machine_tls = docker_machine_json['HostOptions']['AuthOptions'] DCNL DCSP  DCSP  DCSP  DCSP docker_machine_ip = docker_machine_json['Driver']['IPAddress'] DCNL DCSP  DCSP  DCSP  DCSP client_kwargs['base_url'] = (('https://' + docker_machine_ip) + ':2376') DCNL DCSP  DCSP  DCSP  DCSP client_kwargs['tls'] = docker.tls.TLSConfig(client_cert=(docker_machine_tls['ClientCertPath'], docker_machine_tls['ClientKeyPath']), ca_cert=docker_machine_tls['CaCertPath'], assert_hostname=False, verify=True) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError('Docker DCSP machine DCSP {0} DCSP failed: DCSP {1}'.format(docker_machine, exc)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __context__['docker.client'] = docker.Client(**client_kwargs) DCNL DCSP  DCSP except docker.errors.DockerException: DCNL DCSP  DCSP  DCSP log.error('Could DCSP not DCSP initialize DCSP Docker DCSP client') DCNL DCSP  DCSP  DCSP return False DCNL DCSP if ((timeout is not None) and (__context__['docker.client'].timeout != timeout)): DCNL DCSP  DCSP __context__['docker.client'].timeout = timeout
 DCSP rgb_components = [] DCNL DCSP for component in colors: DCNL DCSP  DCSP rounded_num = decimal.Decimal(str((component * 255.0))).quantize(decimal.Decimal('1'), rounding=decimal.ROUND_HALF_EVEN) DCNL DCSP  DCSP rounded_num = int(rounded_num) DCNL DCSP  DCSP rgb_components.append(rounded_num) DCNL DCSP return (rgb_components[0], rgb_components[1], rgb_components[2])
 DCSP pass
 DCSP pass
 DCSP context = context.copy() DCNL DCSP results = {} DCNL DCSP for (k, v) in context.iteritems(): DCNL DCSP  DCSP if (not hasattr(v, '__call__')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (prefix and (not k.startswith(prefix))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP print (k + ':'), DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP r = v() DCNL DCSP  DCSP  DCSP dictincr(results, r) DCNL DCSP  DCSP  DCSP print r DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP print 'ERROR' DCNL DCSP  DCSP  DCSP dictincr(results, 'ERROR') DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP ' + '\n DCSP  DCSP  DCSP '.join(traceback.format_exc().split('\n'))) DCNL DCSP print ('-' * 40) DCNL DCSP print 'results:' DCNL DCSP for (k, v) in results.iteritems(): DCNL DCSP  DCSP print (' DCSP ' * 2), (str(k) + ':'), v
 DCSP craftTypeName = getCraftTypeName() DCNL DCSP return os.path.join(craftTypeName, getProfileName(craftTypeName))
 DCSP if ((not isscalar(nt)) or (floor(nt) != nt) or (nt <= 0)): DCNL DCSP  DCSP raise ValueError('nt DCSP must DCSP be DCSP positive DCSP integer DCSP scalar.') DCNL DCSP return specfun.klvnzo(nt, 5)
 DCSP return ('%s DCSP %s' % (_article(word, article, gender, role), word))
 DCSP data = open(results_file).read().strip() DCNL DCSP pieces = data.split('|') DCNL DCSP if (not (len(pieces) == 4)): DCNL DCSP  DCSP state = 'UNKNOWN' DCNL DCSP  DCSP ret = 3 DCNL DCSP  DCSP data = 'Results DCSP file DCSP malformed' DCNL DCSP else: DCNL DCSP  DCSP timestamp = int(pieces[0]) DCNL DCSP  DCSP time_diff = (time.time() - timestamp) DCNL DCSP  DCSP if (time_diff > (60 * 2)): DCNL DCSP  DCSP  DCSP ret = 3 DCNL DCSP  DCSP  DCSP state = 'UNKNOWN' DCNL DCSP  DCSP  DCSP data = 'Results DCSP file DCSP is DCSP stale' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = int(pieces[1]) DCNL DCSP  DCSP  DCSP state = pieces[2] DCNL DCSP  DCSP  DCSP data = pieces[3] DCNL DCSP return (ret, ('%s: DCSP %s' % (state, data)))
 DCSP store0.sync() DCNL DCSP store0.update(store0.file.store) DCNL DCSP initial_max_revision = Unit.max_revision() DCNL DCSP initial_revision = Revision.get() DCNL DCSP assert (initial_max_revision == initial_revision) DCNL DCSP for i in range(10): DCNL DCSP  DCSP _update_translation(store0, 0, {'target': str(i)}, sync=False) DCNL DCSP end_max_revision = Unit.max_revision() DCNL DCSP end_revision = Revision.get() DCNL DCSP assert (end_max_revision == end_revision) DCNL DCSP assert (end_max_revision != initial_max_revision) DCNL DCSP assert (end_revision != initial_revision) DCNL DCSP assert (end_revision == (10 + initial_revision))
 DCSP return JsonResponse(data)
 DCSP def fun(x): DCNL DCSP  DCSP return func(x) DCNL DCSP rvs = dist.rvs(size=size) DCNL DCSP return fun(rvs).mean(0)
 DCSP from Tkinter import Menu, Text, Text DCNL DCSP from idlelib.EditorWindow import prepstr, get_accelerator DCNL DCSP from idlelib import Bindings DCNL DCSP from idlelib import WindowList DCNL DCSP from idlelib.MultiCall import MultiCallCreator DCNL DCSP closeItem = Bindings.menudefs[0][1][(-2)] DCNL DCSP del Bindings.menudefs[0][1][(-3):] DCNL DCSP Bindings.menudefs[0][1].insert(6, closeItem) DCNL DCSP del Bindings.menudefs[(-1)][1][0:2] DCNL DCSP del Bindings.menudefs[(-2)][1][0:2] DCNL DCSP menubar = Menu(root) DCNL DCSP root.configure(menu=menubar) DCNL DCSP menudict = {} DCNL DCSP menudict['windows'] = menu = Menu(menubar, name='windows') DCNL DCSP menubar.add_cascade(label='Window', menu=menu, underline=0) DCNL DCSP def postwindowsmenu(menu=menu): DCNL DCSP  DCSP end = menu.index('end') DCNL DCSP  DCSP if (end is None): DCNL DCSP  DCSP  DCSP end = (-1) DCNL DCSP  DCSP if (end > 0): DCNL DCSP  DCSP  DCSP menu.delete(0, end) DCNL DCSP  DCSP WindowList.add_windows_to_menu(menu) DCNL DCSP WindowList.register_callback(postwindowsmenu) DCNL DCSP def about_dialog(event=None): DCNL DCSP  DCSP from idlelib import aboutDialog DCNL DCSP  DCSP aboutDialog.AboutDialog(root, 'About DCSP IDLE') DCNL DCSP def config_dialog(event=None): DCNL DCSP  DCSP from idlelib import configDialog DCNL DCSP  DCSP root.instance_dict = flist.inversedict DCNL DCSP  DCSP configDialog.ConfigDialog(root, 'Settings') DCNL DCSP def help_dialog(event=None): DCNL DCSP  DCSP from idlelib import textView DCNL DCSP  DCSP fn = path.join(path.abspath(path.dirname(__file__)), 'help.txt') DCNL DCSP  DCSP textView.view_file(root, 'Help', fn) DCNL DCSP root.bind('<<about-idle>>', about_dialog) DCNL DCSP root.bind('<<open-config-dialog>>', config_dialog) DCNL DCSP root.createcommand('::tk::mac::ShowPreferences', config_dialog) DCNL DCSP if flist: DCNL DCSP  DCSP root.bind('<<close-all-windows>>', flist.close_all_callback) DCNL DCSP  DCSP root.createcommand('exit', flist.close_all_callback) DCNL DCSP if isCarbonTk(): DCNL DCSP  DCSP menudict['application'] = menu = Menu(menubar, name='apple') DCNL DCSP  DCSP menubar.add_cascade(label='IDLE', menu=menu) DCNL DCSP  DCSP Bindings.menudefs.insert(0, ('application', [('About DCSP IDLE', '<<about-idle>>'), None])) DCNL DCSP  DCSP tkversion = root.tk.eval('info DCSP patchlevel') DCNL DCSP  DCSP if (tuple(map(int, tkversion.split('.'))) < (8, 4, 14)): DCNL DCSP  DCSP  DCSP Bindings.menudefs[0][1].append(('_Preferences....', '<<open-config-dialog>>')) DCNL DCSP if isCocoaTk(): DCNL DCSP  DCSP root.createcommand('tkAboutDialog', about_dialog) DCNL DCSP  DCSP root.createcommand('::tk::mac::ShowHelp', help_dialog) DCNL DCSP  DCSP del Bindings.menudefs[(-1)][1][0]
 DCSP return func(*args, **kw)
 DCSP assert (cell_type is not None) DCNL DCSP rnn_func = None DCNL DCSP if (cell_type == 'lstm'): DCNL DCSP  DCSP rnn_func = lstm_layer DCNL DCSP assert (rnn_func is not None) DCNL DCSP assert (direction in ['forward', 'backward', 'bidirectional']) DCNL DCSP with tf.variable_scope(name): DCNL DCSP  DCSP if (direction in ['forward', 'bidirectional']): DCNL DCSP  DCSP  DCSP forward = rnn_func(inp=inp, length=length, backward=False, name='forward', *args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(forward, tuple): DCNL DCSP  DCSP  DCSP  DCSP forward = forward[0] DCNL DCSP  DCSP if (direction in ['backward', 'bidirectional']): DCNL DCSP  DCSP  DCSP backward = rnn_func(inp=inp, length=length, backward=True, name='backward', *args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(backward, tuple): DCNL DCSP  DCSP  DCSP  DCSP backward = backward[0] DCNL DCSP  DCSP if (direction == 'forward'): DCNL DCSP  DCSP  DCSP out = forward DCNL DCSP  DCSP elif (direction == 'backward'): DCNL DCSP  DCSP  DCSP out = backward DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out = tf.concat(2, [forward, backward]) DCNL DCSP return out
 DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))
 DCSP try: DCNL DCSP  DCSP widget_desc = registry.widget(node_el.get('qualified_name')) DCNL DCSP except KeyError as ex: DCNL DCSP  DCSP raise UnknownWidgetDefinition(*ex.args) DCNL DCSP title = node_el.get('title') DCNL DCSP pos = node_el.get('position') DCNL DCSP if (pos is not None): DCNL DCSP  DCSP pos = tuple_eval(pos) DCNL DCSP return SchemeNode(widget_desc, title=title, position=pos)
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP c = OrderedDict() DCNL DCSP for elem in iterable: DCNL DCSP  DCSP c[elem] = (c.get(elem, 0) + 1) DCNL DCSP return c
 DCSP return _pull_image('dkr', url, name, index=index)
 DCSP return config.get_cloud_config_value('managedcloud', vm_, __opts__, default='False', search_global=False)
 DCSP __tracebackhide__ = True DCNL DCSP nose = import_nose() DCNL DCSP if (sys.version_info.major >= 3): DCNL DCSP  DCSP funcname = nose.tools.assert_raises_regex DCNL DCSP else: DCNL DCSP  DCSP funcname = nose.tools.assert_raises_regexp DCNL DCSP return funcname(exception_class, expected_regexp, callable_obj, *args, **kwargs)
 DCSP if ((not result.result) and force): DCNL DCSP  DCSP result.output += logHelper(u'Forcing DCSP deletion DCSP of DCSP files, DCSP even DCSP though DCSP last DCSP result DCSP was DCSP not DCSP success', sickrage.srCore.srLogger.DEBUG) DCNL DCSP elif (not result.result): DCNL DCSP  DCSP return DCNL DCSP for cur_file in notwantedFiles: DCNL DCSP  DCSP cur_file_path = os.path.join(processPath, cur_file) DCNL DCSP  DCSP if (not os.path.isfile(cur_file_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.output += logHelper((u'Deleting DCSP file DCSP %s' % cur_file), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP file_attribute = os.stat(cur_file_path)[0] DCNL DCSP  DCSP if (not (file_attribute & stat.S_IWRITE)): DCNL DCSP  DCSP  DCSP result.output += logHelper((u'Changing DCSP ReadOnly DCSP Flag DCSP for DCSP file DCSP %s' % cur_file), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.chmod(cur_file_path, stat.S_IWRITE) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP result.output += logHelper((u'Cannot DCSP change DCSP permissions DCSP of DCSP %s: DCSP %s' % (cur_file, str(e.strerror).decode(sickrage.SYS_ENCODING))), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(cur_file_path) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP result.output += logHelper((u'Unable DCSP to DCSP delete DCSP file DCSP %s: DCSP %s' % (cur_file, str(e.strerror).decode(sickrage.SYS_ENCODING))), sickrage.srCore.srLogger.DEBUG)
 DCSP def decorator(f): DCNL DCSP  DCSP def callback(ctx, param, value): DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP ctx.abort() DCNL DCSP  DCSP attrs.setdefault('is_flag', True) DCNL DCSP  DCSP attrs.setdefault('callback', callback) DCNL DCSP  DCSP attrs.setdefault('expose_value', False) DCNL DCSP  DCSP attrs.setdefault('prompt', 'Do DCSP you DCSP want DCSP to DCSP continue?') DCNL DCSP  DCSP attrs.setdefault('help', 'Confirm DCSP the DCSP action DCSP without DCSP prompting.') DCNL DCSP  DCSP return option(*(param_decls or ('--yes',)), **attrs)(f) DCNL DCSP return decorator
 DCSP return list(_iter_schedule_requests(state.consumer.timer))
 DCSP if (input_data is None): DCNL DCSP  DCSP assert input_shape DCNL DCSP  DCSP if (not input_dtype): DCNL DCSP  DCSP  DCSP input_dtype = K.floatx() DCNL DCSP  DCSP input_data_shape = list(input_shape) DCNL DCSP  DCSP for (i, e) in enumerate(input_data_shape): DCNL DCSP  DCSP  DCSP if (e is None): DCNL DCSP  DCSP  DCSP  DCSP input_data_shape[i] = np.random.randint(1, 4) DCNL DCSP  DCSP input_data = (10 * np.random.random(input_data_shape)) DCNL DCSP  DCSP input_data = input_data.astype(input_dtype) DCNL DCSP elif (input_shape is None): DCNL DCSP  DCSP input_shape = input_data.shape DCNL DCSP if (expected_output_dtype is None): DCNL DCSP  DCSP expected_output_dtype = input_dtype DCNL DCSP layer = layer_cls(**kwargs) DCNL DCSP weights = layer.get_weights() DCNL DCSP layer.set_weights(weights) DCNL DCSP if ('weights' in inspect.getargspec(layer_cls.__init__)): DCNL DCSP  DCSP kwargs['weights'] = weights DCNL DCSP  DCSP layer = layer_cls(**kwargs) DCNL DCSP if fixed_batch_size: DCNL DCSP  DCSP x = Input(batch_shape=input_shape, dtype=input_dtype) DCNL DCSP else: DCNL DCSP  DCSP x = Input(shape=input_shape[1:], dtype=input_dtype) DCNL DCSP y = layer(x) DCNL DCSP assert (K.dtype(y) == expected_output_dtype) DCNL DCSP model = Model(input=x, output=y) DCNL DCSP model.compile('rmsprop', 'mse') DCNL DCSP expected_output_shape = layer.get_output_shape_for(input_shape) DCNL DCSP actual_output = model.predict(input_data) DCNL DCSP actual_output_shape = actual_output.shape DCNL DCSP for (expected_dim, actual_dim) in zip(expected_output_shape, actual_output_shape): DCNL DCSP  DCSP if (expected_dim is not None): DCNL DCSP  DCSP  DCSP assert (expected_dim == actual_dim) DCNL DCSP if (expected_output is not None): DCNL DCSP  DCSP assert_allclose(actual_output, expected_output, rtol=0.001) DCNL DCSP model_config = model.get_config() DCNL DCSP model = Model.from_config(model_config) DCNL DCSP model.compile('rmsprop', 'mse') DCNL DCSP layer_config = layer.get_config() DCNL DCSP layer_config['batch_input_shape'] = input_shape DCNL DCSP layer = layer.__class__.from_config(layer_config) DCNL DCSP model = Sequential() DCNL DCSP model.add(layer) DCNL DCSP model.compile('rmsprop', 'mse') DCNL DCSP actual_output = model.predict(input_data) DCNL DCSP actual_output_shape = actual_output.shape DCNL DCSP for (expected_dim, actual_dim) in zip(expected_output_shape, actual_output_shape): DCNL DCSP  DCSP if (expected_dim is not None): DCNL DCSP  DCSP  DCSP assert (expected_dim == actual_dim) DCNL DCSP if (expected_output is not None): DCNL DCSP  DCSP assert_allclose(actual_output, expected_output, rtol=0.001) DCNL DCSP json_model = model.to_json() DCNL DCSP model = model_from_json(json_model) DCNL DCSP return actual_output
 DCSP Raven.tags_context({'project': event.project_id}) DCNL DCSP plugin = plugins.get(plugin_slug) DCNL DCSP safe_execute(plugin.post_process, event=event, group=event.group, **kwargs)
 DCSP return (isinstance(asn, numbers.Integral) and (0 <= asn <= 4294967295))
 DCSP tmp = [BIN_HEX_DICT[hstr] for hstr in hex(number)[2:]] DCNL DCSP return BIN_ZSTRIP.sub('0b', ''.join(tmp))
 DCSP if (not conf.direct): DCNL DCSP  DCSP return DCNL DCSP details = None DCNL DCSP remote = False DCNL DCSP for dbms in SUPPORTED_DBMS: DCNL DCSP  DCSP details = re.search(('^(?P<dbms>%s)://(?P<credentials>(?P<user>.+?)\\:(?P<pass>.*)\\@)?(?P<remote>(?P<hostname>.+?)\\:(?P<port>[\\d]+)\\/)?(?P<db>[\\w\\d\\ DCSP \\:\\.\\_\\-\\/\\\\]+?)$' % dbms), conf.direct, re.I) DCNL DCSP  DCSP if details: DCNL DCSP  DCSP  DCSP conf.dbms = details.group('dbms') DCNL DCSP  DCSP  DCSP if details.group('credentials'): DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsUser = details.group('user') DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = details.group('pass') DCNL DCSP  DCSP  DCSP elif conf.dbmsCred: DCNL DCSP  DCSP  DCSP  DCSP (conf.dbmsUser, conf.dbmsPass) = conf.dbmsCred.split(':') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsUser = unicode() DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = unicode() DCNL DCSP  DCSP  DCSP if (not conf.dbmsPass): DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = None DCNL DCSP  DCSP  DCSP if details.group('remote'): DCNL DCSP  DCSP  DCSP  DCSP remote = True DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = details.group('hostname').strip() DCNL DCSP  DCSP  DCSP  DCSP conf.port = int(details.group('port')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP conf.dbmsDb = details.group('db') DCNL DCSP  DCSP  DCSP conf.parameters[None] = 'direct DCSP connection' DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not details): DCNL DCSP  DCSP errMsg = 'invalid DCSP target DCSP details, DCSP valid DCSP syntax DCSP is DCSP for DCSP instance DCSP ' DCNL DCSP  DCSP errMsg += "'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP " DCNL DCSP  DCSP errMsg += "or DCSP 'access://DATABASE_FILEPATH'" DCNL DCSP  DCSP raise SqlmapSyntaxException(errMsg) DCNL DCSP for (dbmsName, data) in DBMS_DICT.items(): DCNL DCSP  DCSP if ((dbmsName == conf.dbms) or (conf.dbms.lower() in data[0])): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (dbmsName in (DBMS.ACCESS, DBMS.SQLITE, DBMS.FIREBIRD)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if remote: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg = 'direct DCSP connection DCSP over DCSP the DCSP network DCSP for DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg += ('%s DCSP DBMS DCSP is DCSP not DCSP supported' % dbmsName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warn(warnMsg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP  DCSP elif (not remote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = 'missing DCSP remote DCSP connection DCSP details DCSP (e.g. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += "'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP " DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += "or DCSP 'access://DATABASE_FILEPATH')" DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapSyntaxException(errMsg) DCNL DCSP  DCSP  DCSP  DCSP if (dbmsName in (DBMS.MSSQL, DBMS.SYBASE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import _mssql DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymssql DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not hasattr(pymssql, '__version__')) or (pymssql.__version__ < '1.0.2')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg = ("'%s' DCSP third-party DCSP library DCSP must DCSP be DCSP " % data[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'version DCSP >= DCSP 1.0.2 DCSP to DCSP work DCSP properly. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("Download DCSP from DCSP '%s'" % data[2]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapMissingDependence(errMsg) DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.MYSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymysql DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.PGSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import psycopg2 DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.ORACLE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import cx_Oracle DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.SQLITE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import sqlite3 DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.ACCESS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pyodbc DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.FIREBIRD): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import kinterbasdb DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP if (_sqlalchemy and (data[3] in _sqlalchemy.dialects.__all__)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = ("sqlmap DCSP requires DCSP '%s' DCSP third-party DCSP library DCSP " % data[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'in DCSP order DCSP to DCSP directly DCSP connect DCSP to DCSP the DCSP DBMS DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("%s. DCSP You DCSP can DCSP download DCSP it DCSP from DCSP '%s'" % (dbmsName, data[2])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ". DCSP Alternative DCSP is DCSP to DCSP use DCSP a DCSP package DCSP 'python-sqlalchemy' DCSP " DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("with DCSP support DCSP for DCSP dialect DCSP '%s' DCSP installed" % data[3]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapMissingDependence(errMsg)
 DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP return conn.create_access_key(user_name) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP log.error('Failed DCSP to DCSP create DCSP access DCSP key.') DCNL DCSP  DCSP return str(e)
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args) DCNL DCSP  DCSP except (OSError, select.error) as e: DCNL DCSP  DCSP  DCSP if (e.args[0] != errno.EINTR): DCNL DCSP  DCSP  DCSP  DCSP raise
 DCSP if (s.lower() == 'none'): DCNL DCSP  DCSP return 'None' DCNL DCSP if is_color_like(s): DCNL DCSP  DCSP return s DCNL DCSP stmp = ('#' + s) DCNL DCSP if is_color_like(stmp): DCNL DCSP  DCSP return stmp DCNL DCSP colorarg = s DCNL DCSP msg = '' DCNL DCSP if (s.find(',') >= 0): DCNL DCSP  DCSP stmp = ''.join([c for c in s if (c.isdigit() or (c == '.') or (c == ','))]) DCNL DCSP  DCSP vals = stmp.split(',') DCNL DCSP  DCSP if (len(vals) != 3): DCNL DCSP  DCSP  DCSP msg = '\nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP colorarg = [float(val) for val in vals] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP msg = '\nCould DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats' DCNL DCSP if ((not msg) and is_color_like(colorarg)): DCNL DCSP  DCSP return colorarg DCNL DCSP raise ValueError(('%s DCSP does DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg%s' % (s, msg)))
 DCSP tests = [] DCNL DCSP for name in os.listdir(testdir): DCNL DCSP  DCSP if ((not suffix) or name.endswith(suffix)): DCNL DCSP  DCSP  DCSP for prefix in prefixes: DCNL DCSP  DCSP  DCSP  DCSP if name.startswith(prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (remove_suffix and name.endswith(suffix)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = name[:(- len(suffix))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in excludes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tests.append(name) DCNL DCSP tests.sort() DCNL DCSP return tests
 DCSP d = {} DCNL DCSP id_path = os.path.join(storage_path, 'compute_nodes') DCNL DCSP if os.path.exists(id_path): DCNL DCSP  DCSP with open(id_path) as f: DCNL DCSP  DCSP  DCSP d = json.loads(f.read()) DCNL DCSP recent_users = [] DCNL DCSP for node in d: DCNL DCSP  DCSP if ((time.time() - d[node]) < TWENTY_FOUR_HOURS): DCNL DCSP  DCSP  DCSP recent_users.append(node) DCNL DCSP return recent_users
 DCSP return (data.encode(enc) if isinstance(data, unicode) else bytes(data))
 DCSP bind = op.get_bind() DCNL DCSP insp = sa.engine.reflection.Inspector.from_engine(bind) DCNL DCSP return (table_name in insp.get_table_names())
 DCSP for parser_type in PARSER_TYPES: DCNL DCSP  DCSP parsers[parser_type] = {} DCNL DCSP  DCSP for p in plugin.get_plugins(interface=(parser_type + u'_parser')): DCNL DCSP  DCSP  DCSP parsers[parser_type][p.name.replace(u'parser_', u'')] = p.instance DCNL DCSP  DCSP func_name = (u'parse_' + parser_type) DCNL DCSP  DCSP default_parsers[parser_type] = max(iter(parsers[parser_type].items()), key=(lambda p: getattr(getattr(p[1], func_name), u'priority', 0)))[0] DCNL DCSP  DCSP log.debug((u'setting DCSP default DCSP %s DCSP parser DCSP to DCSP %s. DCSP (options: DCSP %s)' % (parser_type, default_parsers[parser_type], parsers[parser_type])))
 DCSP fields = [] DCNL DCSP (i, n) = (0, len(line)) DCNL DCSP while (i < n): DCNL DCSP  DCSP (field, i) = parsefield(line, i, n) DCNL DCSP  DCSP fields.append(field) DCNL DCSP  DCSP i = (i + 1) DCNL DCSP if (len(fields) < 2): DCNL DCSP  DCSP return (None, None) DCNL DCSP (key, view, rest) = (fields[0], fields[1], fields[2:]) DCNL DCSP fields = {'view': view} DCNL DCSP for field in rest: DCNL DCSP  DCSP i = field.find('=') DCNL DCSP  DCSP if (i < 0): DCNL DCSP  DCSP  DCSP fkey = field DCNL DCSP  DCSP  DCSP fvalue = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fkey = field[:i].strip() DCNL DCSP  DCSP  DCSP fvalue = field[(i + 1):].strip() DCNL DCSP  DCSP if (fkey in fields): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fields[fkey] = fvalue DCNL DCSP return (key, fields)
 DCSP global A, p_keys, v_keys DCNL DCSP if ((p < 0.1) or (p > 0.999)): DCNL DCSP  DCSP raise ValueError('p DCSP must DCSP be DCSP between DCSP .1 DCSP and DCSP .999') DCNL DCSP if (p < 0.9): DCNL DCSP  DCSP if (v < 2): DCNL DCSP  DCSP  DCSP raise ValueError('v DCSP must DCSP be DCSP > DCSP 2 DCSP when DCSP p DCSP < DCSP .9') DCNL DCSP elif (v < 1): DCNL DCSP  DCSP raise ValueError('v DCSP must DCSP be DCSP > DCSP 1 DCSP when DCSP p DCSP >= DCSP .9') DCNL DCSP p = float(p) DCNL DCSP if isinstance(v, np.ndarray): DCNL DCSP  DCSP v = v.item() DCNL DCSP if ((p, v) in A): DCNL DCSP  DCSP y = (_func(A[(p, v)], p, r, v) + 1.0) DCNL DCSP elif ((p not in p_keys) and (v not in (v_keys + ([], [1])[(p >= 0.9)]))): DCNL DCSP  DCSP (v0, v1, v2) = _select_vs(v, p) DCNL DCSP  DCSP (p0, p1, p2) = _select_ps(p) DCNL DCSP  DCSP r0_sq = (_interpolate_p(p, r, v0) ** 2) DCNL DCSP  DCSP r1_sq = (_interpolate_p(p, r, v1) ** 2) DCNL DCSP  DCSP r2_sq = (_interpolate_p(p, r, v2) ** 2) DCNL DCSP  DCSP (v_, v0_, v1_, v2_) = ((1.0 / v), (1.0 / v0), (1.0 / v1), (1.0 / v2)) DCNL DCSP  DCSP d2 = ((2.0 * (((r2_sq - r1_sq) / (v2_ - v1_)) - ((r0_sq - r1_sq) / (v0_ - v1_)))) / (v2_ - v0_)) DCNL DCSP  DCSP if ((v2_ + v0_) >= (v1_ + v1_)): DCNL DCSP  DCSP  DCSP d1 = (((r2_sq - r1_sq) / (v2_ - v1_)) - ((0.5 * d2) * (v2_ - v1_))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP d1 = (((r1_sq - r0_sq) / (v1_ - v0_)) + ((0.5 * d2) * (v1_ - v0_))) DCNL DCSP  DCSP d0 = r1_sq DCNL DCSP  DCSP y = math.sqrt(((((d2 / 2.0) * ((v_ - v1_) ** 2.0)) + (d1 * (v_ - v1_))) + d0)) DCNL DCSP elif (v not in (v_keys + ([], [1])[(p >= 0.9)])): DCNL DCSP  DCSP y = _interpolate_v(p, r, v) DCNL DCSP elif (p not in p_keys): DCNL DCSP  DCSP y = _interpolate_p(p, r, v) DCNL DCSP return ((math.sqrt(2) * (- y)) * scipy.stats.t.isf(((1.0 + p) / 2.0), (v, 1e+38)[(v > 1e+38)]))
 DCSP fut = delete_async(blob_key, **options) DCNL DCSP return fut.get_result()
 DCSP return call_talib_with_hlc(barDs, count, talib.TRANGE)
 DCSP return (1920 <= year < 2030)
 DCSP if ((pillar is not None) and (not isinstance(pillar, dict))): DCNL DCSP  DCSP raise SaltInvocationError('Pillar DCSP data DCSP must DCSP be DCSP formatted DCSP as DCSP a DCSP dictionary') DCNL DCSP __opts__['file_client'] = 'local' DCNL DCSP minion = salt.minion.MasterMinion(__opts__) DCNL DCSP running = minion.functions['state.high'](data, test=None, queue=False, pillar=pillar, **kwargs) DCNL DCSP ret = {minion.opts['id']: running} DCNL DCSP __jid_event__.fire_event({'data': ret, 'outputter': 'highstate'}, 'progress') DCNL DCSP return ret
 DCSP if isinstance(a, (tuple, list, set)): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for item in a: DCNL DCSP  DCSP  DCSP l.extend(flatten(item)) DCNL DCSP  DCSP return l DCNL DCSP else: DCNL DCSP  DCSP return [a]
 DCSP all_cats = Category.objects.filter(type=amo.ADDON_WEBAPP) DCNL DCSP try: DCNL DCSP  DCSP entertainment = all_cats.filter(slug='entertainment-sports')[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP print 'Could DCSP not DCSP find DCSP Category DCSP with DCSP slug="entertainment-sports"' DCNL DCSP else: DCNL DCSP  DCSP entertainment.name = 'Entertainment' DCNL DCSP  DCSP entertainment.slug = 'entertainment' DCNL DCSP  DCSP entertainment.save() DCNL DCSP  DCSP print 'Renamed DCSP "Entertainment DCSP & DCSP Sports" DCSP to DCSP "Entertainment"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='sports', name='Sports') DCNL DCSP print 'Created DCSP "Sports"' DCNL DCSP try: DCNL DCSP  DCSP music = all_cats.filter(slug='music')[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP print 'Could DCSP not DCSP find DCSP Category DCSP with DCSP slug="music"' DCNL DCSP else: DCNL DCSP  DCSP music.name = 'Music' DCNL DCSP  DCSP music.save() DCNL DCSP  DCSP print 'Renamed DCSP "Music DCSP & DCSP Audio" DCSP to DCSP "Music"' DCNL DCSP try: DCNL DCSP  DCSP social = all_cats.filter(slug='social')[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP print 'Could DCSP not DCSP find DCSP Category DCSP with DCSP slug="social"' DCNL DCSP else: DCNL DCSP  DCSP social.name = 'Social' DCNL DCSP  DCSP social.save() DCNL DCSP  DCSP print 'Renamed DCSP "Social DCSP & DCSP Communication" DCSP to DCSP "Social"' DCNL DCSP try: DCNL DCSP  DCSP books = all_cats.filter(slug='books-reference')[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP print 'Could DCSP not DCSP find DCSP Category DCSP with DCSP slug="books-reference"' DCNL DCSP else: DCNL DCSP  DCSP books.name = 'Books' DCNL DCSP  DCSP books.slug = 'books' DCNL DCSP  DCSP books.save() DCNL DCSP  DCSP print 'Renamed DCSP "Books DCSP & DCSP Reference" DCSP to DCSP "Books"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='reference', name='Reference') DCNL DCSP print 'Created DCSP "Reference"' DCNL DCSP try: DCNL DCSP  DCSP photos = all_cats.filter(slug='photos-media')[0] DCNL DCSP except IndexError: DCNL DCSP  DCSP print 'Could DCSP not DCSP find DCSP Category DCSP with DCSP slug="photos-media"' DCNL DCSP else: DCNL DCSP  DCSP photos.name = 'Photo DCSP & DCSP Video' DCNL DCSP  DCSP photos.slug = 'photo-video' DCNL DCSP  DCSP photos.save() DCNL DCSP  DCSP print 'Renamed DCSP "Photos DCSP & DCSP Media" DCSP to DCSP "Photo DCSP & DCSP Video"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='maps-navigation', name='Maps DCSP & DCSP Navigation') DCNL DCSP print 'Created DCSP "Maps DCSP & DCSP Navigation"'
 DCSP dotted_path_split = dotted_path.split('.') DCNL DCSP if (len(dotted_path_split) > 1): DCNL DCSP  DCSP klass_name = dotted_path_split[(-1)] DCNL DCSP  DCSP module_name = '.'.join(dotted_path_split[:(-1)]) DCNL DCSP  DCSP module = load_module(module_name) DCNL DCSP  DCSP if has_attribute(module, klass_name): DCNL DCSP  DCSP  DCSP klass = getattr(module, klass_name) DCNL DCSP  DCSP  DCSP return klass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise AttributeError(('Module DCSP %s DCSP does DCSP not DCSP have DCSP class DCSP attribute DCSP %s' % (module_name, klass_name))) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Dotted DCSP module DCSP path DCSP %s DCSP must DCSP contain DCSP a DCSP module DCSP name DCSP and DCSP a DCSP classname' % dotted_path))
 DCSP return stats
 DCSP img = gpu_contiguous(X) DCNL DCSP kerns = gpu_contiguous(w) DCNL DCSP desc = GpuDnnConvDesc(border_mode=border_mode, subsample=subsample, conv_mode=conv_mode)(gpu_alloc_empty(img.shape[0], kerns.shape[1], (img.shape[2] * subsample[0]), (img.shape[3] * subsample[1])).shape, kerns.shape) DCNL DCSP out = gpu_alloc_empty(img.shape[0], kerns.shape[1], (img.shape[2] * subsample[0]), (img.shape[3] * subsample[1])) DCNL DCSP d_img = GpuDnnConvGradI()(kerns, img, out, desc) DCNL DCSP return d_img
 DCSP if (not cwd): DCNL DCSP  DCSP cwd = os.getcwd() DCNL DCSP if (not env): DCNL DCSP  DCSP env = common_environment() DCNL DCSP cmd = list(cmd) DCNL DCSP escaped_cmd = ' DCSP '.join((pipes.quote(c) for c in cmd)) DCNL DCSP display.info(('Run DCSP command: DCSP %s' % escaped_cmd), verbosity=1) DCNL DCSP display.info(('Working DCSP directory: DCSP %s' % cwd), verbosity=2) DCNL DCSP program = find_executable(cmd[0], cwd=cwd, path=env['PATH'], required='warning') DCNL DCSP if program: DCNL DCSP  DCSP display.info(('Program DCSP found: DCSP %s' % program), verbosity=2) DCNL DCSP for key in sorted(env.keys()): DCNL DCSP  DCSP display.info(('%s=%s' % (key, env[key])), verbosity=2) DCNL DCSP if explain: DCNL DCSP  DCSP return (None, None) DCNL DCSP communicate = False DCNL DCSP if (stdin is not None): DCNL DCSP  DCSP data = None DCNL DCSP  DCSP communicate = True DCNL DCSP elif (data is not None): DCNL DCSP  DCSP stdin = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP if stdout: DCNL DCSP  DCSP communicate = True DCNL DCSP if capture: DCNL DCSP  DCSP stdout = (stdout or subprocess.PIPE) DCNL DCSP  DCSP stderr = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP else: DCNL DCSP  DCSP stderr = None DCNL DCSP start = time.time() DCNL DCSP try: DCNL DCSP  DCSP process = subprocess.Popen(cmd, env=env, stdin=stdin, stdout=stdout, stderr=stderr, cwd=cwd) DCNL DCSP except OSError as ex: DCNL DCSP  DCSP if (ex.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP raise ApplicationError(('Required DCSP program DCSP "%s" DCSP not DCSP found.' % cmd[0])) DCNL DCSP  DCSP raise DCNL DCSP if communicate: DCNL DCSP  DCSP (stdout, stderr) = process.communicate(data) DCNL DCSP else: DCNL DCSP  DCSP process.wait() DCNL DCSP  DCSP (stdout, stderr) = (None, None) DCNL DCSP status = process.returncode DCNL DCSP runtime = (time.time() - start) DCNL DCSP display.info(('Command DCSP exited DCSP with DCSP status DCSP %s DCSP after DCSP %s DCSP seconds.' % (status, runtime)), verbosity=4) DCNL DCSP if (status == 0): DCNL DCSP  DCSP return (stdout, stderr) DCNL DCSP raise SubprocessError(cmd, status, stdout, stderr, runtime)
 DCSP return archive.getTextLines(getAlterationFile(fileName))
 DCSP checkfile = ek(os.path.abspath, checkfile) DCNL DCSP if (not ek(os.path.exists, checkfile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP f = ek(io.open, checkfile, u'rb') DCNL DCSP  DCSP f.close() DCNL DCSP except IOError: DCNL DCSP  DCSP return True DCNL DCSP if writeLockCheck: DCNL DCSP  DCSP lockFile = (checkfile + u'.lckchk') DCNL DCSP  DCSP if ek(os.path.exists, lockFile): DCNL DCSP  DCSP  DCSP ek(os.remove, lockFile) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ek(os.rename, checkfile, lockFile) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP ek(os.rename, lockFile, checkfile) DCNL DCSP  DCSP except (OSError, IOError): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP return UUID(hex=_BOOT_ID.getContent().strip())
 DCSP os.chdir(os.path.join(gitdname, 'statsmodels', 'docs')) DCNL DCSP sphinx_dir = os.path.join(virtual_dir, 'bin') DCNL DCSP retcode = subprocess.call(' DCSP '.join(['make', 'latexpdf', (('SPHINXBUILD=' + sphinx_dir) + '/sphinx-build')]), shell=True) DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP msg = ('Could DCSP not DCSP build DCSP the DCSP pdf DCSP docs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP os.chdir(dname)
 DCSP ordered_steps = order_workflow_steps(steps) DCNL DCSP workflow.has_cycles = (not bool(ordered_steps)) DCNL DCSP for (i, step) in enumerate((ordered_steps or steps)): DCNL DCSP  DCSP step.order_index = i DCNL DCSP  DCSP workflow.steps.append(step)
 DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP if set(str(exc_value).split(' DCSP ')).issuperset(set(keywords)): DCNL DCSP  DCSP exc_value._safe_message = message DCNL DCSP  DCSP raise
 DCSP html = re.sub('id="\\d+"', 'id="###"', html) DCNL DCSP global_id = 1 DCNL DCSP while (len(re.findall('id="###"', html)) > 0): DCNL DCSP  DCSP html = re.sub('id="###"', ('id="%s"' % global_id), html, count=1) DCNL DCSP  DCSP global_id += 1 DCNL DCSP return html
 DCSP scenario = Scenario.from_string(SCENARIO1) DCNL DCSP assert isinstance(scenario, Scenario) DCNL DCSP assert_equals(scenario.name, 'Adding DCSP some DCSP students DCSP to DCSP my DCSP university DCSP database')
 DCSP _volume_register.append(cls) DCNL DCSP return cls
 DCSP if isinstance(constantString, bytes): DCNL DCSP  DCSP otherType = constantString.decode('ascii') DCNL DCSP else: DCNL DCSP  DCSP otherType = constantString.encode('ascii') DCNL DCSP if (type(constantString) == type(inputString)): DCNL DCSP  DCSP return constantString DCNL DCSP else: DCNL DCSP  DCSP return otherType
 DCSP tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: '', 'compress': ''} DCNL DCSP compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'} DCNL DCSP if ((compress is not None) and (compress not in compress_ext.keys())): DCNL DCSP  DCSP raise ValueError, "bad DCSP value DCSP for DCSP 'compress': DCSP must DCSP be DCSP None, DCSP 'gzip', DCSP 'bzip2' DCSP or DCSP 'compress'" DCNL DCSP archive_name = (base_name + '.tar') DCNL DCSP if (compress != 'compress'): DCNL DCSP  DCSP archive_name += compress_ext.get(compress, '') DCNL DCSP mkpath(os.path.dirname(archive_name), dry_run=dry_run) DCNL DCSP import tarfile DCNL DCSP log.info('Creating DCSP tar DCSP archive') DCNL DCSP uid = _get_uid(owner) DCNL DCSP gid = _get_gid(group) DCNL DCSP def _set_uid_gid(tarinfo): DCNL DCSP  DCSP if (gid is not None): DCNL DCSP  DCSP  DCSP tarinfo.gid = gid DCNL DCSP  DCSP  DCSP tarinfo.gname = group DCNL DCSP  DCSP if (uid is not None): DCNL DCSP  DCSP  DCSP tarinfo.uid = uid DCNL DCSP  DCSP  DCSP tarinfo.uname = owner DCNL DCSP  DCSP return tarinfo DCNL DCSP if (not dry_run): DCNL DCSP  DCSP tar = tarfile.open(archive_name, ('w|%s' % tar_compression[compress])) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tar.add(base_dir, filter=_set_uid_gid) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP tar.close() DCNL DCSP if (compress == 'compress'): DCNL DCSP  DCSP warn("'compress' DCSP will DCSP be DCSP deprecated.", PendingDeprecationWarning) DCNL DCSP  DCSP compressed_name = (archive_name + compress_ext[compress]) DCNL DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP cmd = [compress, archive_name, compressed_name] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = [compress, '-f', archive_name] DCNL DCSP  DCSP spawn(cmd, dry_run=dry_run) DCNL DCSP  DCSP return compressed_name DCNL DCSP return archive_name
 DCSP allevents = [] DCNL DCSP timeout = Timeout.start_new(timeout) DCNL DCSP result = SelectResult() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for readfd in rlist: DCNL DCSP  DCSP  DCSP  DCSP allevents.append(core.read_event(get_fileno(readfd), result.update, arg=readfd)) DCNL DCSP  DCSP  DCSP for writefd in wlist: DCNL DCSP  DCSP  DCSP  DCSP allevents.append(core.write_event(get_fileno(writefd), result.update, arg=writefd)) DCNL DCSP  DCSP except IOError as ex: DCNL DCSP  DCSP  DCSP raise error(*ex.args) DCNL DCSP  DCSP result.event.wait(timeout=timeout) DCNL DCSP  DCSP return (result.read, result.write, []) DCNL DCSP finally: DCNL DCSP  DCSP for evt in allevents: DCNL DCSP  DCSP  DCSP evt.cancel() DCNL DCSP  DCSP timeout.cancel()
 DCSP if isinstance(url, six.text_type): DCNL DCSP  DCSP return quote_chinese(url.encode(encodeing)) DCNL DCSP if six.PY3: DCNL DCSP  DCSP res = [(six.int2byte(b).decode('latin-1') if (b < 128) else ('%%%02X' % b)) for b in url] DCNL DCSP else: DCNL DCSP  DCSP res = [(b if (ord(b) < 128) else ('%%%02X' % ord(b))) for b in url] DCNL DCSP return ''.join(res)
 DCSP action_name = ugettext_noop('certificates DCSP generated') DCNL DCSP TASK_LOG.info(u'Task: DCSP %s, DCSP InstructorTask DCSP ID: DCSP %s, DCSP Task DCSP type: DCSP %s, DCSP Preparing DCSP for DCSP task DCSP execution', xmodule_instance_args.get('task_id'), entry_id, action_name) DCNL DCSP task_fn = partial(generate_students_certificates, xmodule_instance_args) DCNL DCSP return run_main_task(entry_id, task_fn, action_name)
 DCSP if (repo not in settings.FRONTEND_REPOS): DCNL DCSP  DCSP raise Http404 DCNL DCSP BUILD_ID = get_build_id(repo) DCNL DCSP ua = request.META.get('HTTP_USER_AGENT', '').lower() DCNL DCSP include_splash = False DCNL DCSP detect_region_with_geoip = False DCNL DCSP if (repo == 'fireplace'): DCNL DCSP  DCSP include_splash = True DCNL DCSP  DCSP has_sim_info_in_query = (('mccs' in request.GET) or (('mcc' in request.GET) and ('mnc' in request.GET))) DCNL DCSP  DCSP if (not has_sim_info_in_query): DCNL DCSP  DCSP  DCSP detect_region_with_geoip = True DCNL DCSP (fxa_auth_state, fxa_auth_url) = fxa_auth_info() DCNL DCSP site_settings = {'dev_pay_providers': settings.DEV_PAY_PROVIDERS, 'fxa_auth_state': fxa_auth_state, 'fxa_auth_url': fxa_auth_url} DCNL DCSP ctx = {'BUILD_ID': BUILD_ID, 'LANG': request.LANG, 'langdir': lang_dir(request.LANG), 'include_splash': include_splash, 'repo': repo, 'robots': ('googlebot' in ua), 'site_settings': site_settings, 'newrelic_header': newrelic.agent.get_browser_timing_header, 'newrelic_footer': newrelic.agent.get_browser_timing_footer} DCNL DCSP if (repo == 'fireplace'): DCNL DCSP  DCSP resolved_url = resolve(request.path) DCNL DCSP  DCSP if (resolved_url.url_name == 'detail'): DCNL DCSP  DCSP  DCSP ctx = add_app_ctx(ctx, resolved_url.kwargs['app_slug']) DCNL DCSP ctx['waffle_switches'] = list(waffle.models.Switch.objects.filter(active=True).values_list('name', flat=True)) DCNL DCSP media_url = urlparse(settings.MEDIA_URL) DCNL DCSP if media_url.netloc: DCNL DCSP  DCSP ctx['media_origin'] = ((media_url.scheme + '://') + media_url.netloc) DCNL DCSP if detect_region_with_geoip: DCNL DCSP  DCSP region_middleware = RegionMiddleware() DCNL DCSP  DCSP ctx['geoip_region'] = region_middleware.region_from_request(request) DCNL DCSP if (repo == 'marketplace-tv-front-end'): DCNL DCSP  DCSP return render(request, 'commonplace/index_tv.html', ctx) DCNL DCSP elif (repo in settings.REACT_REPOS): DCNL DCSP  DCSP return render(request, 'commonplace/index_react.html', ctx) DCNL DCSP elif (repo in settings.COMMONPLACE_REPOS): DCNL DCSP  DCSP return render(request, 'commonplace/index.html', ctx)
 DCSP print(('Determining DCSP list DCSP of DCSP input DCSP files DCSP and DCSP labels DCSP from DCSP %s.' % data_dir)) DCNL DCSP challenge_synsets = [l.strip() for l in tf.gfile.FastGFile(labels_file, 'r').readlines()] DCNL DCSP labels = [] DCNL DCSP filenames = [] DCNL DCSP synsets = [] DCNL DCSP label_index = 1 DCNL DCSP for synset in challenge_synsets: DCNL DCSP  DCSP jpeg_file_path = ('%s/%s/*.JPEG' % (data_dir, synset)) DCNL DCSP  DCSP matching_files = tf.gfile.Glob(jpeg_file_path) DCNL DCSP  DCSP labels.extend(([label_index] * len(matching_files))) DCNL DCSP  DCSP synsets.extend(([synset] * len(matching_files))) DCNL DCSP  DCSP filenames.extend(matching_files) DCNL DCSP  DCSP if (not (label_index % 100)): DCNL DCSP  DCSP  DCSP print(('Finished DCSP finding DCSP files DCSP in DCSP %d DCSP of DCSP %d DCSP classes.' % (label_index, len(challenge_synsets)))) DCNL DCSP  DCSP label_index += 1 DCNL DCSP shuffled_index = list(range(len(filenames))) DCNL DCSP random.seed(12345) DCNL DCSP random.shuffle(shuffled_index) DCNL DCSP filenames = [filenames[i] for i in shuffled_index] DCNL DCSP synsets = [synsets[i] for i in shuffled_index] DCNL DCSP labels = [labels[i] for i in shuffled_index] DCNL DCSP print(('Found DCSP %d DCSP JPEG DCSP files DCSP across DCSP %d DCSP labels DCSP inside DCSP %s.' % (len(filenames), len(challenge_synsets), data_dir))) DCNL DCSP return (filenames, synsets, labels)
 DCSP ret = [set(), set(), set(), set()] DCNL DCSP for media_type in media_type_lst: DCNL DCSP  DCSP precedence = _MediaType(media_type).precedence DCNL DCSP  DCSP ret[(3 - precedence)].add(media_type) DCNL DCSP return [media_types for media_types in ret if media_types]
 DCSP return False
 DCSP kw['exit'] = False DCNL DCSP return TestProgram(*arg, **kw).success
 DCSP testcase.assertEqual(text1.splitlines(), text2.splitlines(), msg)
 DCSP if (not args): DCNL DCSP  DCSP args = sys.argv[1:] DCNL DCSP logging.basicConfig(level=logging.INFO, stream=sys.stdout, format='%(message)s') DCNL DCSP for gt in args: DCNL DCSP  DCSP load_grammar(gt, save=True, force=True) DCNL DCSP return True
 DCSP return _callProtocolWithDeferred((lambda d: _BackRelay(d, errortoo=errortoo)), executable, args, env, path, reactor)
 DCSP return _contains(exp, Sorted)
 DCSP assert (not ((not_yet_run and running) or (not_yet_run and finished) or (running and finished))), 'Cannot DCSP specify DCSP more DCSP than DCSP one DCSP filter DCSP to DCSP this DCSP function' DCNL DCSP not_queued = ('(SELECT DCSP job_id DCSP FROM DCSP afe_host_queue_entries DCSP WHERE DCSP status DCSP != DCSP "%s")' % models.HostQueueEntry.Status.QUEUED) DCNL DCSP not_finished = '(SELECT DCSP job_id DCSP FROM DCSP afe_host_queue_entries DCSP WHERE DCSP not DCSP complete)' DCNL DCSP if not_yet_run: DCNL DCSP  DCSP where = [('id DCSP NOT DCSP IN DCSP ' + not_queued)] DCNL DCSP elif running: DCNL DCSP  DCSP where = [('(id DCSP IN DCSP %s) DCSP AND DCSP (id DCSP IN DCSP %s)' % (not_queued, not_finished))] DCNL DCSP elif finished: DCNL DCSP  DCSP where = [('id DCSP NOT DCSP IN DCSP ' + not_finished)] DCNL DCSP else: DCNL DCSP  DCSP return {} DCNL DCSP return {'where': where}
 DCSP plugins_whitelist = get_setting('plugins_whitelist', ['external', 'getTeXRoot', 'latextools_utils']) DCNL DCSP plugins_whitelist.append('latextools_plugin') DCNL DCSP overwritten_modules = {} DCNL DCSP whitelist = [(name, None) for name in plugins_whitelist] DCNL DCSP whitelist.extend(internal._WHITELIST_ADDED) DCNL DCSP __dir__ = os.path.dirname(__file__) DCNL DCSP if (__dir__ == '.'): DCNL DCSP  DCSP __dir__ = os.path.join(sublime.packages_path(), 'LaTeXTools') DCNL DCSP sys.path.insert(0, __dir__) DCNL DCSP for (name, module) in whitelist: DCNL DCSP  DCSP if callable(module): DCNL DCSP  DCSP  DCSP module = module() DCNL DCSP  DCSP if (name in sys.modules): DCNL DCSP  DCSP  DCSP overwritten_modules[name] = sys.modules[name] DCNL DCSP  DCSP if (module is None): DCNL DCSP  DCSP  DCSP latextools_module_name = _get_sublime_module_name(__dir__, name) DCNL DCSP  DCSP  DCSP if (latextools_module_name in sys.modules): DCNL DCSP  DCSP  DCSP  DCSP sys.modules[name] = sys.modules[latextools_module_name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.modules[name] = _load_module(name, name, __dir__) DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print('An DCSP error DCSP occurred DCSP while DCSP trying DCSP to DCSP load DCSP white-listed DCSP module DCSP {0}'.format(name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.modules[name] = module DCNL DCSP sys.path.pop(0) DCNL DCSP (yield) DCNL DCSP for module in plugins_whitelist: DCNL DCSP  DCSP if (_get_sublime_module_name(__dir__, module) != module): DCNL DCSP  DCSP  DCSP del sys.modules[module] DCNL DCSP  DCSP if (module in overwritten_modules): DCNL DCSP  DCSP  DCSP sys.modules[module] = overwritten_modules[module]
 DCSP return all((not_the_same(friend, other_user) for friend in user['friends']))
 DCSP fileName = fabmetheus_interpret.getFirstTranslatorFileNameUnmodified(fileName) DCNL DCSP if (fileName != ''): DCNL DCSP  DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'splodge')
 DCSP module = AnsibleModule(argument_spec=dict(name=dict(type='str', required=True), new_name=dict(type='str'), config=dict(type='dict'), description=dict(type='str'), devices=dict(type='dict'), state=dict(choices=PROFILES_STATES, default='present'), url=dict(type='str', default='unix:/var/lib/lxd/unix.socket'), key_file=dict(type='str', default='{}/.config/lxc/client.key'.format(os.environ['HOME'])), cert_file=dict(type='str', default='{}/.config/lxc/client.crt'.format(os.environ['HOME'])), trust_password=dict(type='str')), supports_check_mode=False) DCNL DCSP lxd_manage = LXDProfileManagement(module=module) DCNL DCSP lxd_manage.run()
 DCSP ring = f.ring DCNL DCSP k = ring.ngens DCNL DCSP yring = ring.clone(symbols=ring.symbols[(k - 1)]) DCNL DCSP y = yring.gens[0] DCNL DCSP degf = _deg(f) DCNL DCSP lcf = yring.zero DCNL DCSP for (monom, coeff) in f.iterterms(): DCNL DCSP  DCSP if (monom[:(-1)] == degf): DCNL DCSP  DCSP  DCSP lcf += (coeff * (y ** monom[(-1)])) DCNL DCSP return lcf
 DCSP if (_MAIN_SETTINGS is None): DCNL DCSP  DCSP initialize_dbs(pelican_obj.settings) DCNL DCSP  DCSP subscribe_filter_to_signals(pelican_obj.settings)
 DCSP logging.info('Shutting DCSP down DCSP Cassandra.') DCNL DCSP monit_interface.stop(cassandra_interface.CASSANDRA_MONIT_WATCH_NAME, is_group=False) DCNL DCSP logging.warning('Done!') DCNL DCSP return True
 DCSP for token in tokens: DCNL DCSP  DCSP (word, pos, lemma) = (token[0], token[1], token[0]) DCNL DCSP  DCSP if pos.startswith(('DT',)): DCNL DCSP  DCSP  DCSP lemma = singularize(word, pos='DT') DCNL DCSP  DCSP if pos.startswith('JJ'): DCNL DCSP  DCSP  DCSP lemma = predicative(word) DCNL DCSP  DCSP if (pos == 'NNS'): DCNL DCSP  DCSP  DCSP lemma = singularize(word) DCNL DCSP  DCSP if pos.startswith(('VB', 'MD')): DCNL DCSP  DCSP  DCSP lemma = (conjugate(word, INFINITIVE) or word) DCNL DCSP  DCSP token.append(lemma.lower()) DCNL DCSP return tokens
 DCSP P = np.array([[0.4, 0.6]]) DCNL DCSP assert_raises(ValueError, MarkovChain, P) DCNL DCSP assert_raises(ValueError, MarkovChain, sparse.csr_matrix(P))
 DCSP if ((node.name in ('Exception', 'BaseException')) and (node.root().name == EXCEPTIONS_MODULE)): DCNL DCSP  DCSP return True DCNL DCSP return any((inherit_from_std_ex(parent) for parent in node.ancestors(recurs=False)))
 DCSP kw = {} DCNL DCSP argspec = inspect.getargspec(fn) DCNL DCSP if argspec[2]: DCNL DCSP  DCSP kw = env DCNL DCSP else: DCNL DCSP  DCSP argnames = argspec[0][1:] DCNL DCSP  DCSP for name in argnames: DCNL DCSP  DCSP  DCSP if (name in env): DCNL DCSP  DCSP  DCSP  DCSP kw[name] = env[name] DCNL DCSP return kw
 DCSP try: DCNL DCSP  DCSP is_proxy = (len(parameter.Java.implements) > 0) DCNL DCSP except Exception: DCNL DCSP  DCSP is_proxy = False DCNL DCSP return is_proxy
 DCSP m = re.match(u'\\s*(\\d+)\\s*([ac-z]?)(b?)\\s*$', str(si), re.I) DCNL DCSP if m: DCNL DCSP  DCSP if ((not m.group(2)) and m.group(3)): DCNL DCSP  DCSP  DCSP times = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP times = (const.SIPrefixTimes[m.group(2).upper()] if m.group(2) else 1) DCNL DCSP  DCSP return (int(m.group(1)) * times) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError
 DCSP salt_vars = get_salt_vars() DCNL DCSP def salt_outputter(value): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Use DCSP Salt's DCSP outputters DCSP to DCSP print DCSP values DCSP to DCSP the DCSP shell\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP builtins._ = value DCNL DCSP  DCSP  DCSP salt.output.display_output(value, '', salt_vars['__opts__']) DCNL DCSP sys.displayhook = salt_outputter DCNL DCSP readline.set_history_length(300) DCNL DCSP if os.path.exists(HISTFILE): DCNL DCSP  DCSP readline.read_history_file(HISTFILE) DCNL DCSP atexit.register(savehist) DCNL DCSP atexit.register((lambda : sys.stdout.write('Salt DCSP you DCSP later!\n'))) DCNL DCSP saltrepl = InteractiveConsole(locals=salt_vars) DCNL DCSP saltrepl.interact(banner=__doc__)
 DCSP if (nodes is None): DCNL DCSP  DCSP nodes = set(G) DCNL DCSP else: DCNL DCSP  DCSP nodes = set(nodes) DCNL DCSP xdeg = G.degree DCNL DCSP ydeg = G.degree DCNL DCSP if G.is_directed(): DCNL DCSP  DCSP direction = {'out': G.out_degree, 'in': G.in_degree} DCNL DCSP  DCSP xdeg = direction[x] DCNL DCSP  DCSP ydeg = direction[y] DCNL DCSP for (u, degu) in xdeg(nodes, weight=weight): DCNL DCSP  DCSP neighbors = (nbr for (_, nbr) in G.edges(u) if (nbr in nodes)) DCNL DCSP  DCSP for (v, degv) in ydeg(neighbors, weight=weight): DCNL DCSP  DCSP  DCSP (yield (degu, degv))
 DCSP if (discovery_info is None): DCNL DCSP  DCSP _LOGGER.error('Configure DCSP Qwikswitch DCSP component') DCNL DCSP  DCSP return False DCNL DCSP add_devices(qwikswitch.QSUSB['switch']) DCNL DCSP return True
 DCSP asset_dir_prefix = '' DCNL DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP cache_slug = get_cache_slug() DCNL DCSP  DCSP asset_dir_prefix = ('/build/%s' % cache_slug) DCNL DCSP return asset_dir_prefix
 DCSP def wraps(fn): DCNL DCSP  DCSP dmm.register(typecls, fn) DCNL DCSP  DCSP return fn DCNL DCSP return wraps
 DCSP return linked_data(prefix).get(dist)
 DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is not postgresql.dialect): DCNL DCSP  DCSP meta = MetaData(bind=migrate_engine) DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
 DCSP return re.sub('([\\s:])(0)(px|em|%|in|cm|mm|pc|pt|ex)', '\\1\\2', css)
 DCSP return subproc_check_output(['svnlook', 'cat', repo_path, '-t', txn_id, filename])
 DCSP report_class = REGISTRY.GetRegisteredPlugins()[name] DCNL DCSP report_object = report_class() DCNL DCSP return report_object
 DCSP if (recurse_count >= 5): DCNL DCSP  DCSP err = 'save_load DCSP could DCSP not DCSP write DCSP job DCSP cache DCSP file DCSP after DCSP {0} DCSP retries.'.format(recurse_count) DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP raise salt.exceptions.SaltCacheError(err) DCNL DCSP jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__['hash_type']) DCNL DCSP serial = salt.payload.Serial(__opts__) DCNL DCSP try: DCNL DCSP  DCSP if (not os.path.exists(jid_dir)): DCNL DCSP  DCSP  DCSP os.makedirs(jid_dir) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP try: DCNL DCSP  DCSP serial.dump(clear_load, salt.utils.fopen(os.path.join(jid_dir, LOAD_P), 'w+b')) DCNL DCSP except IOError as exc: DCNL DCSP  DCSP log.warning('Could DCSP not DCSP write DCSP job DCSP invocation DCSP cache DCSP file: DCSP %s', exc) DCNL DCSP  DCSP time.sleep(0.1) DCNL DCSP  DCSP return save_load(jid=jid, clear_load=clear_load, recurse_count=(recurse_count + 1)) DCNL DCSP if (('tgt' in clear_load) and (clear_load['tgt'] != '')): DCNL DCSP  DCSP if (minions is None): DCNL DCSP  DCSP  DCSP ckminions = salt.utils.minions.CkMinions(__opts__) DCNL DCSP  DCSP  DCSP minions = ckminions.check_minions(clear_load['tgt'], clear_load.get('tgt_type', 'glob')) DCNL DCSP  DCSP save_minions(jid, minions)
 DCSP if ((not user) or user.is_anonymous()): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = User.objects.get(username=service_username) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP user = None DCNL DCSP return user
 DCSP m = X.shape[0] DCNL DCSP min_ = np.zeros(m) DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range((2 * m)): DCNL DCSP  DCSP  DCSP if ((j == i) or (j == (i + m))): DCNL DCSP  DCSP  DCSP  DCSP tableaux[0][(i, j)] = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tableaux[0][(i, j)] = 0 DCNL DCSP  DCSP tableaux[0][(i, (2 * m))] = 1 DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP if (j == i): DCNL DCSP  DCSP  DCSP  DCSP tableaux[1][(i, j)] = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tableaux[1][(i, j)] = 0 DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP d = (X[i] - Y[j]) DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] = (_square_sum(d) * (-1)) DCNL DCSP  DCSP  DCSP if (tableaux[1][(i, (m + j))] < min_[j]): DCNL DCSP  DCSP  DCSP  DCSP min_[j] = tableaux[1][(i, (m + j))] DCNL DCSP  DCSP tableaux[1][(i, (2 * m))] = 1 DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] -= min_[j] DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] += 1 DCNL DCSP for (pl, start) in enumerate([m, 0]): DCNL DCSP  DCSP for i in range(m): DCNL DCSP  DCSP  DCSP bases[pl][i] = (start + i) DCNL DCSP return (tableaux, bases)
 DCSP assert_nD(image, 2) DCNL DCSP image = img_as_float(image) DCNL DCSP result = convolve(image, VSOBEL_WEIGHTS) DCNL DCSP return _mask_filter_result(result, mask)
 DCSP (n_samples, n_features) = X.shape DCNL DCSP (n_components, _) = means.shape DCNL DCSP log_det = _compute_log_det_cholesky(precisions_chol, covariance_type, n_features) DCNL DCSP if (covariance_type == 'full'): DCNL DCSP  DCSP log_prob = np.empty((n_samples, n_components)) DCNL DCSP  DCSP for (k, (mu, prec_chol)) in enumerate(zip(means, precisions_chol)): DCNL DCSP  DCSP  DCSP y = (np.dot(X, prec_chol) - np.dot(mu, prec_chol)) DCNL DCSP  DCSP  DCSP log_prob[:, k] = np.sum(np.square(y), axis=1) DCNL DCSP elif (covariance_type == 'tied'): DCNL DCSP  DCSP log_prob = np.empty((n_samples, n_components)) DCNL DCSP  DCSP for (k, mu) in enumerate(means): DCNL DCSP  DCSP  DCSP y = (np.dot(X, precisions_chol) - np.dot(mu, precisions_chol)) DCNL DCSP  DCSP  DCSP log_prob[:, k] = np.sum(np.square(y), axis=1) DCNL DCSP elif (covariance_type == 'diag'): DCNL DCSP  DCSP precisions = (precisions_chol ** 2) DCNL DCSP  DCSP log_prob = ((np.sum(((means ** 2) * precisions), 1) - (2.0 * np.dot(X, (means * precisions).T))) + np.dot((X ** 2), precisions.T)) DCNL DCSP elif (covariance_type == 'spherical'): DCNL DCSP  DCSP precisions = (precisions_chol ** 2) DCNL DCSP  DCSP log_prob = (((np.sum((means ** 2), 1) * precisions) - (2 * np.dot(X, (means.T * precisions)))) + np.outer(row_norms(X, squared=True), precisions)) DCNL DCSP return (((-0.5) * ((n_features * np.log((2 * np.pi))) + log_prob)) + log_det)
 DCSP res = [] DCNL DCSP if isinstance(ob, dict): DCNL DCSP  DCSP role = ob.get('role') DCNL DCSP  DCSP asset_r = ob.get('asset') DCNL DCSP  DCSP user = ob.get('user') DCNL DCSP  DCSP if (not perm): DCNL DCSP  DCSP  DCSP perm = get_group_user_perm(user) DCNL DCSP  DCSP if role: DCNL DCSP  DCSP  DCSP roles = perm.get('role', {}).keys() DCNL DCSP  DCSP  DCSP if (role not in roles): DCNL DCSP  DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP  DCSP role_assets_all = perm.get('role').get(role).get('asset') DCNL DCSP  DCSP  DCSP assets = (set(role_assets_all) & set(asset_r)) DCNL DCSP  DCSP  DCSP for asset in assets: DCNL DCSP  DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP  DCSP role_key = get_role_key(user, role) DCNL DCSP  DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22), 'ansible_ssh_private_key_file': role_key, 'username': role.name} DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP  DCSP res.append(info) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (asset, asset_info) in perm.get('asset').items(): DCNL DCSP  DCSP  DCSP  DCSP if (asset not in asset_r): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP role = sorted(list(perm.get('asset').get(asset).get('role')))[0] DCNL DCSP  DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP role_key = get_role_key(user, role) DCNL DCSP  DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22), 'username': role.name, 'password': CRYPTOR.decrypt(role.password)} DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP  DCSP res.append(info) DCNL DCSP elif isinstance(ob, User): DCNL DCSP  DCSP if (not perm): DCNL DCSP  DCSP  DCSP perm = get_group_user_perm(ob) DCNL DCSP  DCSP for (asset, asset_info) in perm.get('asset').items(): DCNL DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22)} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP role = sorted(list(perm.get('asset').get(asset).get('role')))[0] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP info['username'] = role.name DCNL DCSP  DCSP  DCSP info['password'] = CRYPTOR.decrypt(role.password) DCNL DCSP  DCSP  DCSP role_key = get_role_key(ob, role) DCNL DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP res.append(info) DCNL DCSP elif isinstance(ob, (list, QuerySet)): DCNL DCSP  DCSP for asset in ob: DCNL DCSP  DCSP  DCSP info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP res.append(info) DCNL DCSP logger.debug(('\xe7\x94\x9f\xe6\x88\x90res: DCSP %s' % res)) DCNL DCSP return res
 DCSP from frappe.model import default_fields, optional_fields DCNL DCSP if isinstance(f, dict): DCNL DCSP  DCSP (key, value) = f.items()[0] DCNL DCSP  DCSP f = make_filter_tuple(doctype, key, value) DCNL DCSP if (not isinstance(f, (list, tuple))): DCNL DCSP  DCSP frappe.throw(u'Filter DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP (in DCSP a DCSP list)') DCNL DCSP if (len(f) == 3): DCNL DCSP  DCSP f = (doctype, f[0], f[1], f[2]) DCNL DCSP elif (len(f) != 4): DCNL DCSP  DCSP frappe.throw(u'Filter DCSP must DCSP have DCSP 4 DCSP values DCSP (doctype, DCSP fieldname, DCSP operator, DCSP value): DCSP {0}'.format(str(f))) DCNL DCSP f = frappe._dict(doctype=f[0], fieldname=f[1], operator=f[2], value=f[3]) DCNL DCSP if (not f.operator): DCNL DCSP  DCSP f.operator = u'=' DCNL DCSP valid_operators = (u'=', u'!=', u'>', u'<', u'>=', u'<=', u'like', u'not DCSP like', u'in', u'not DCSP in', u'Between') DCNL DCSP if (f.operator not in valid_operators): DCNL DCSP  DCSP frappe.throw(u'Operator DCSP must DCSP be DCSP one DCSP of DCSP {0}'.format(u', DCSP '.join(valid_operators))) DCNL DCSP if (f.doctype and (f.fieldname not in (default_fields + optional_fields))): DCNL DCSP  DCSP meta = frappe.get_meta(f.doctype) DCNL DCSP  DCSP if (not meta.has_field(f.fieldname)): DCNL DCSP  DCSP  DCSP for df in meta.get_table_fields(): DCNL DCSP  DCSP  DCSP  DCSP if frappe.get_meta(df.options).has_field(f.fieldname): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.doctype = df.options DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return f
 DCSP return re.sub(' DCSP +', ' DCSP ', normalize_newlines(text).replace('\n', '')).strip()
 DCSP core = CORE_MANAGER.get_core_service() DCNL DCSP peer = core.peer_manager.get_by_addr(neigh_ip_address) DCNL DCSP at_maps_key = const.ATTR_MAPS_LABEL_DEFAULT DCNL DCSP if (route_dist is not None): DCNL DCSP  DCSP at_maps_key = ':'.join([route_dist, route_family]) DCNL DCSP at_maps = peer.attribute_maps.get(at_maps_key) DCNL DCSP if at_maps: DCNL DCSP  DCSP return at_maps.get(const.ATTR_MAPS_ORG_KEY) DCNL DCSP else: DCNL DCSP  DCSP return []
 DCSP _options = _get_options(ret) DCNL DCSP dsn = _options.get('dsn') DCNL DCSP user = _options.get('user') DCNL DCSP passwd = _options.get('passwd') DCNL DCSP return pyodbc.connect('DSN={0};UID={1};PWD={2}'.format(dsn, user, passwd))
 DCSP try: DCNL DCSP  DCSP verify_vat(tax_number) DCNL DCSP  DCSP return u'vat' DCNL DCSP except VatCannotIdentifyValidationError: DCNL DCSP  DCSP pass DCNL DCSP return u'unknown'
 DCSP fname = os.path.basename(filename) DCNL DCSP same_name_files = get_same_name_files(files_path_list, fname) DCNL DCSP if (len(same_name_files) > 1): DCNL DCSP  DCSP compare_path = shortest_path(same_name_files) DCNL DCSP  DCSP if (compare_path == filename): DCNL DCSP  DCSP  DCSP same_name_files.remove(path_components(filename)) DCNL DCSP  DCSP  DCSP compare_path = shortest_path(same_name_files) DCNL DCSP  DCSP diff_path = differentiate_prefix(path_components(filename), path_components(compare_path)) DCNL DCSP  DCSP diff_path_length = len(diff_path) DCNL DCSP  DCSP path_component = path_components(diff_path) DCNL DCSP  DCSP if ((diff_path_length > 20) and (len(path_component) > 2)): DCNL DCSP  DCSP  DCSP if ((path_component[0] != '/') and (path_component[0] != '')): DCNL DCSP  DCSP  DCSP  DCSP path_component = [path_component[0], '...', path_component[(-1)]] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path_component = [path_component[2], '...', path_component[(-1)]] DCNL DCSP  DCSP  DCSP diff_path = os.path.join(*path_component) DCNL DCSP  DCSP fname = ((fname + ' DCSP - DCSP ') + diff_path) DCNL DCSP return fname
 DCSP ids = [] DCNL DCSP for (column, operator, value) in _get_query_comparisons(query): DCNL DCSP  DCSP if column.shares_lineage(weather_locations.c.continent): DCNL DCSP  DCSP  DCSP if (operator == operators.eq): DCNL DCSP  DCSP  DCSP  DCSP ids.append(shard_lookup[value]) DCNL DCSP  DCSP  DCSP elif (operator == operators.in_op): DCNL DCSP  DCSP  DCSP  DCSP ids.extend((shard_lookup[v] for v in value)) DCNL DCSP if (len(ids) == 0): DCNL DCSP  DCSP return ['north_america', 'asia', 'europe', 'south_america'] DCNL DCSP else: DCNL DCSP  DCSP return ids
 DCSP if (node.tail and (node.tail.strip() == '')): DCNL DCSP  DCSP node.tail = None DCNL DCSP for child in node: DCNL DCSP  DCSP if (node.text and (node.text.strip() == '')): DCNL DCSP  DCSP  DCSP node.text = None DCNL DCSP  DCSP remove_ignorable_whitespace(child)
 DCSP pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)] DCNL DCSP if pkg_list: DCNL DCSP  DCSP uninstall(pkg_list)
 DCSP palettes = import_required('bokeh.palettes', _BOKEH_MISSING_MSG) DCNL DCSP tz = import_required('toolz', _TOOLZ_MISSING_MSG) DCNL DCSP unique_funcs = list(sorted(tz.unique(funcs))) DCNL DCSP n_funcs = len(unique_funcs) DCNL DCSP palette_lookup = palettes.all_palettes[palette] DCNL DCSP keys = list(sorted(palette_lookup.keys())) DCNL DCSP index = keys[min(bisect_left(keys, n_funcs), (len(keys) - 1))] DCNL DCSP palette = palette_lookup[index] DCNL DCSP palette = list(tz.unique(palette)) DCNL DCSP if (len(palette) > n_funcs): DCNL DCSP  DCSP random.Random(42).shuffle(palette) DCNL DCSP color_lookup = dict(zip(unique_funcs, cycle(palette))) DCNL DCSP return [color_lookup[n] for n in funcs]
 DCSP return Locale.parse(locale).time_formats[format]
 DCSP return _interpret_as_from(selectable).alias(name=name, flat=flat)
 DCSP buf = buf.strip() DCNL DCSP if (not buf): DCNL DCSP  DCSP return buf DCNL DCSP html_parser = html5lib.HTMLParser(tree=treebuilders.getTreeBuilder('dom'), tokenizer=HTMLSanitizer) DCNL DCSP dom_tree = html_parser.parseFragment(buf) DCNL DCSP walker = treewalkers.getTreeWalker('dom') DCNL DCSP stream = walker(dom_tree) DCNL DCSP s = serializer.htmlserializer.HTMLSerializer(omit_optional_tags=False, quote_attr_values=True) DCNL DCSP output = s.render(stream, 'utf-8') DCNL DCSP while ('toberemoved' in output): DCNL DCSP  DCSP oldoutput = output DCNL DCSP  DCSP matches = re.findall('&lt;toberemoved.*?&gt;.*?&lt;/toberemoved&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP matches = re.findall('&lt;/toberemoved&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP matches = re.findall('&lt;toberemoved.*?&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP if (output == oldoutput): DCNL DCSP  DCSP  DCSP break DCNL DCSP return output
 DCSP try: DCNL DCSP  DCSP getReadRepository(repository) DCNL DCSP  DCSP return RepositoryDialog(repository, Tkinter.Tk()) DCNL DCSP except: DCNL DCSP  DCSP print 'this DCSP should DCSP never DCSP happen, DCSP getDisplayedDialogFromConstructor DCSP in DCSP settings DCSP could DCSP not DCSP open' DCNL DCSP  DCSP print repository DCNL DCSP  DCSP traceback.print_exc(file=sys.stdout) DCNL DCSP  DCSP return None
 DCSP if (not settings.DEBUG): DCNL DCSP  DCSP raise RuntimeError("Don't DCSP use DCSP kitsune.sumo.views.serve_cors DCSP in DCSP production.") DCNL DCSP from django.views.static import serve DCNL DCSP return serve(*args, **kwargs)
 DCSP return str(round(number, 3))
 DCSP if (not backup_retention_period): DCNL DCSP  DCSP raise SaltInvocationError('backup_retention_period DCSP is DCSP required') DCNL DCSP res = __salt__['boto_rds.exists'](source_name, tags, region, key, keyid, profile) DCNL DCSP if (not res.get('exists')): DCNL DCSP  DCSP return {'exists': bool(res), 'message': 'RDS DCSP instance DCSP source DCSP {0} DCSP does DCSP not DCSP exists.'.format(source_name)} DCNL DCSP res = __salt__['boto_rds.exists'](name, tags, region, key, keyid, profile) DCNL DCSP if res.get('exists'): DCNL DCSP  DCSP return {'exists': bool(res), 'message': 'RDS DCSP replica DCSP instance DCSP {0} DCSP already DCSP exists.'.format(name)} DCNL DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP kwargs = {} DCNL DCSP  DCSP for key in ('OptionGroupName', 'MonitoringRoleArn'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = str(locals()[key]) DCNL DCSP  DCSP for key in ('MonitoringInterval', 'Iops', 'Port'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = int(locals()[key]) DCNL DCSP  DCSP for key in ('CopyTagsToSnapshot', 'AutoMinorVersionUpgrade'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = bool(locals()[key]) DCNL DCSP  DCSP taglist = _tag_doc(tags) DCNL DCSP  DCSP rds_replica = conn.create_db_instance_read_replica(DBInstanceIdentifier=name, SourceDBInstanceIdentifier=source_name, DBInstanceClass=db_instance_class, AvailabilityZone=availability_zone, PubliclyAccessible=publicly_accessible, Tags=taglist, DBSubnetGroupName=db_subnet_group_name, StorageType=storage_type, **kwargs) DCNL DCSP  DCSP return {'exists': bool(rds_replica)} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}
 DCSP from mozillians.groups.models import Group, GroupMembership DCNL DCSP group = Group.objects.get(pk=group_pk) DCNL DCSP user = User.objects.get(pk=user_pk) DCNL DCSP activate('en-us') DCNL DCSP if (old_status in [GroupMembership.PENDING, GroupMembership.PENDING_TERMS]): DCNL DCSP  DCSP if (new_status == GroupMembership.MEMBER): DCNL DCSP  DCSP  DCSP subject = (_('Accepted DCSP to DCSP Mozillians DCSP group DCSP "%s"') % group.name) DCNL DCSP  DCSP  DCSP template_name = 'groups/email/accepted.txt' DCNL DCSP  DCSP elif (new_status is None): DCNL DCSP  DCSP  DCSP subject = (_('Not DCSP accepted DCSP to DCSP Mozillians DCSP group DCSP "%s"') % group.name) DCNL DCSP  DCSP  DCSP template_name = 'groups/email/rejected.txt' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('BAD DCSP ARGS DCSP TO DCSP email_membership_change') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('BAD DCSP ARGS DCSP TO DCSP email_membership_change') DCNL DCSP context = {'group': group, 'user': user} DCNL DCSP template = get_template(template_name) DCNL DCSP body = template.render(context) DCNL DCSP send_mail(subject, body, settings.FROM_NOREPLY, [user.email], fail_silently=False)
 DCSP if (n is None): DCNL DCSP  DCSP n = 4 DCNL DCSP if ((len(alphabet) ** n) < length): DCNL DCSP  DCSP log.error(("Can't DCSP create DCSP a DCSP pattern DCSP length=%i DCSP with DCSP len(alphabet)==%i DCSP and DCSP n==%i" % (length, len(alphabet), n))) DCNL DCSP out = [] DCNL DCSP for (ndx, c) in enumerate(de_bruijn(alphabet, n)): DCNL DCSP  DCSP if ((length != None) and (ndx >= length)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.append(c) DCNL DCSP if isinstance(alphabet, str): DCNL DCSP  DCSP return ''.join(out) DCNL DCSP else: DCNL DCSP  DCSP return out
 DCSP images = [ImageMetadata(image.image_id, image.filename, [caption]) for image in images for caption in image.captions] DCNL DCSP random.seed(12345) DCNL DCSP random.shuffle(images) DCNL DCSP num_threads = min(num_shards, FLAGS.num_threads) DCNL DCSP spacing = np.linspace(0, len(images), (num_threads + 1)).astype(np.int) DCNL DCSP ranges = [] DCNL DCSP threads = [] DCNL DCSP for i in xrange((len(spacing) - 1)): DCNL DCSP  DCSP ranges.append([spacing[i], spacing[(i + 1)]]) DCNL DCSP coord = tf.train.Coordinator() DCNL DCSP decoder = ImageDecoder() DCNL DCSP print(('Launching DCSP %d DCSP threads DCSP for DCSP spacings: DCSP %s' % (num_threads, ranges))) DCNL DCSP for thread_index in xrange(len(ranges)): DCNL DCSP  DCSP args = (thread_index, ranges, name, images, decoder, vocab, num_shards) DCNL DCSP  DCSP t = threading.Thread(target=_process_image_files, args=args) DCNL DCSP  DCSP t.start() DCNL DCSP  DCSP threads.append(t) DCNL DCSP coord.join(threads) DCNL DCSP print(("%s: DCSP Finished DCSP processing DCSP all DCSP %d DCSP image-caption DCSP pairs DCSP in DCSP data DCSP set DCSP '%s'." % (datetime.now(), len(images), name)))
 DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP policy_arn = _get_policy_arn(policy_name, region, key, keyid, profile) DCNL DCSP try: DCNL DCSP  DCSP conn.detach_user_policy(policy_arn, user_name) DCNL DCSP  DCSP log.info('Detached DCSP {0} DCSP policy DCSP to DCSP user DCSP {1}.'.format(policy_name, user_name)) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.debug(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP detach DCSP {0} DCSP policy DCSP to DCSP user DCSP {1}.' DCNL DCSP  DCSP log.error(msg.format(policy_name, user_name)) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP ret = [] DCNL DCSP devices = bluetooth.discover_devices(lookup_names=True) DCNL DCSP for device in devices: DCNL DCSP  DCSP ret.append({device[0]: device[1]}) DCNL DCSP return ret
 DCSP from castra import Castra DCNL DCSP if (not isinstance(x, Castra)): DCNL DCSP  DCSP x = Castra(x, readonly=True) DCNL DCSP elif (not x._readonly): DCNL DCSP  DCSP x = Castra(x.path, readonly=True) DCNL DCSP if (columns is None): DCNL DCSP  DCSP columns = x.columns DCNL DCSP name = ('from-castra-' + tokenize(os.path.getmtime(x.path), x.path, columns, index)) DCNL DCSP dsk = dict((((name, i), (load_castra_partition, x, part, columns, index)) for (i, part) in enumerate(x.partitions))) DCNL DCSP return Bag(dsk, name, len(x.partitions))
 DCSP warnings.warn("The DCSP 'execute_manager' DCSP function DCSP is DCSP deprecated, DCSP you DCSP likely DCSP need DCSP to DCSP update DCSP your DCSP 'manage.py'; DCSP please DCSP see DCSP the DCSP Django DCSP 1.4 DCSP release DCSP notes DCSP (https://docs.djangoproject.com/en/dev/releases/1.4/).", PendingDeprecationWarning) DCNL DCSP setup_environ(settings_mod) DCNL DCSP utility = ManagementUtility(argv) DCNL DCSP utility.execute()
 DCSP if (field.label == _FieldDescriptor.LABEL_REPEATED): DCNL DCSP  DCSP if (field.has_default_value and (field.default_value != [])): DCNL DCSP  DCSP  DCSP raise ValueError(('Repeated DCSP field DCSP default DCSP value DCSP not DCSP empty DCSP list: DCSP %s' % field.default_value)) DCNL DCSP  DCSP if (field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE): DCNL DCSP  DCSP  DCSP message_type = field.message_type DCNL DCSP  DCSP  DCSP def MakeRepeatedMessageDefault(message): DCNL DCSP  DCSP  DCSP  DCSP return containers.RepeatedCompositeFieldContainer(message._listener_for_children, field.message_type) DCNL DCSP  DCSP  DCSP return MakeRepeatedMessageDefault DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP type_checker = type_checkers.GetTypeChecker(field) DCNL DCSP  DCSP  DCSP def MakeRepeatedScalarDefault(message): DCNL DCSP  DCSP  DCSP  DCSP return containers.RepeatedScalarFieldContainer(message._listener_for_children, type_checker) DCNL DCSP  DCSP  DCSP return MakeRepeatedScalarDefault DCNL DCSP if (field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE): DCNL DCSP  DCSP message_type = field.message_type DCNL DCSP  DCSP def MakeSubMessageDefault(message): DCNL DCSP  DCSP  DCSP result = message_type._concrete_class() DCNL DCSP  DCSP  DCSP result._SetListener(message._listener_for_children) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return MakeSubMessageDefault DCNL DCSP def MakeScalarDefault(message): DCNL DCSP  DCSP return field.default_value DCNL DCSP return MakeScalarDefault
 DCSP canvas = FigureCanvasWebAgg(figure) DCNL DCSP manager = core.FigureManagerWebAgg(canvas, num) DCNL DCSP return manager
 DCSP G = complete_graph(4, create_using) DCNL DCSP G.name = 'Platonic DCSP Tetrahedral DCSP graph' DCNL DCSP return G
 DCSP (_, filename, _, _, _, _) = inspect.getouterframes(inspect.currentframe())[1] DCNL DCSP base_dir = os.path.abspath(os.path.dirname(filename)) DCNL DCSP return os.path.join(base_dir, 'data', f)
 DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=52) DCNL DCSP packet = (a / b) DCNL DCSP return packet
 DCSP return translateMessage(key, message, 'encrypt')
 DCSP return _sys_version()[1]
 DCSP if verbose: DCNL DCSP  DCSP factors0 = list(factors.keys()) DCNL DCSP nfactors = len(factors) DCNL DCSP for d in candidates: DCNL DCSP  DCSP if ((n % d) == 0): DCNL DCSP  DCSP  DCSP m = multiplicity(d, n) DCNL DCSP  DCSP  DCSP n //= (d ** m) DCNL DCSP  DCSP  DCSP factors[d] = m DCNL DCSP if verbose: DCNL DCSP  DCSP for k in sorted(set(factors).difference(set(factors0))): DCNL DCSP  DCSP  DCSP print((factor_msg % (k, factors[k]))) DCNL DCSP return (int(n), (len(factors) != nfactors))
 DCSP skip = set((token.NEWLINE, token.INDENT, token.DEDENT)) DCNL DCSP tokens = tokenize.generate_tokens(StringIO.StringIO(input).readline) DCNL DCSP for quintuple in tokens: DCNL DCSP  DCSP (type, value, start, end, line_text) = quintuple DCNL DCSP  DCSP if (type not in skip): DCNL DCSP  DCSP  DCSP (yield quintuple)
 DCSP setup_autoscale_group() DCNL DCSP conn = boto.connect_autoscale() DCNL DCSP policy = ScalingPolicy(name=u'ScaleUp', adjustment_type=u'PercentChangeInCapacity', as_name=u'tester_group', scaling_adjustment=1) DCNL DCSP conn.create_scaling_policy(policy) DCNL DCSP conn.execute_policy(u'ScaleUp') DCNL DCSP instances = list(conn.get_all_autoscaling_instances()) DCNL DCSP instances.should.have.length_of(3)
 DCSP if (transform and hasattr(self.model, 'formula') and (exog is not None)): DCNL DCSP  DCSP from patsy import dmatrix DCNL DCSP  DCSP exog = dmatrix(self.model.data.design_info.builder, exog) DCNL DCSP if (exog is not None): DCNL DCSP  DCSP if (row_labels is None): DCNL DCSP  DCSP  DCSP if hasattr(exog, 'index'): DCNL DCSP  DCSP  DCSP  DCSP row_labels = exog.index DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP row_labels = None DCNL DCSP  DCSP exog = np.asarray(exog) DCNL DCSP  DCSP if ((exog.ndim == 1) and ((self.model.exog.ndim == 1) or (self.model.exog.shape[1] == 1))): DCNL DCSP  DCSP  DCSP exog = exog[:, None] DCNL DCSP  DCSP exog = np.atleast_2d(exog) DCNL DCSP else: DCNL DCSP  DCSP exog = self.model.exog DCNL DCSP  DCSP if (weights is None): DCNL DCSP  DCSP  DCSP weights = getattr(self.model, 'weights', None) DCNL DCSP  DCSP if (row_labels is None): DCNL DCSP  DCSP  DCSP row_labels = getattr(self.model.data, 'row_labels', None) DCNL DCSP if (weights is not None): DCNL DCSP  DCSP weights = np.asarray(weights) DCNL DCSP  DCSP if ((weights.size > 1) and ((weights.ndim != 1) or (weights.shape[0] == exog.shape[1]))): DCNL DCSP  DCSP  DCSP raise ValueError('weights DCSP has DCSP wrong DCSP shape') DCNL DCSP if (pred_kwds is None): DCNL DCSP  DCSP pred_kwds = {} DCNL DCSP predicted_mean = self.model.predict(self.params, exog, **pred_kwds) DCNL DCSP covb = self.cov_params() DCNL DCSP var_pred_mean = (exog * np.dot(covb, exog.T).T).sum(1) DCNL DCSP var_resid = (self.scale / weights) DCNL DCSP if (self.cov_type == 'fixed DCSP scale'): DCNL DCSP  DCSP var_resid = (self.cov_kwds['scale'] / weights) DCNL DCSP dist = ['norm', 't'][self.use_t] DCNL DCSP return PredictionResults(predicted_mean, var_pred_mean, var_resid, df=self.df_resid, dist=dist, row_labels=row_labels)
 DCSP url = 'https://www.googleapis.com/storage/v1/b/{0}/o'.format(bucket_name) DCNL DCSP try: DCNL DCSP  DCSP response = gcs_get_request(url) DCNL DCSP  DCSP if (response.status_code != HTTP_OK): DCNL DCSP  DCSP  DCSP logging.error('Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket: DCSP {0}. DCSP Error: DCSP {1}'.format(bucket_name, response.status_code)) DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP content = json.loads(response.content) DCNL DCSP except requests.HTTPError as error: DCNL DCSP  DCSP logging.error('Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket: DCSP {0}. DCSP Error: DCSP {1}'.format(bucket_name, error)) DCNL DCSP  DCSP return [] DCNL DCSP if ('items' not in content.keys()): DCNL DCSP  DCSP return [] DCNL DCSP objects = [] DCNL DCSP for item in content['items']: DCNL DCSP  DCSP objects.append(item['name']) DCNL DCSP logging.debug('Bucket DCSP contents: DCSP {0}'.format(objects)) DCNL DCSP return objects
 DCSP return ((obj != other) or (type(obj) != type(other)))
 DCSP enable_site(config) DCNL DCSP reload_service('apache2')
 DCSP return read_edgelist(path, comments=comments, delimiter=delimiter, create_using=create_using, nodetype=nodetype, data=(('weight', float),), encoding=encoding)
 DCSP j = from_int(j) DCNL DCSP pi = mpf_pi(prec) DCNL DCSP a = mpf_div(sq23pi, j, prec) DCNL DCSP b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec) DCNL DCSP c = mpf_sqrt(b, prec) DCNL DCSP (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec) DCNL DCSP D = mpf_div(mpf_sqrt(j, prec), mpf_mul(mpf_mul(sqrt8, b), pi), prec) DCNL DCSP E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec) DCNL DCSP return mpf_mul(D, E)
 DCSP t.value = (t.value == 'true') DCNL DCSP return t
 DCSP filename = string_cam_file.get() DCNL DCSP file = open(filename, 'wb') DCNL DCSP units = cad.inches_per_unit DCNL DCSP file.write('%FSLAX24Y24*%\n') DCNL DCSP file.write('%MOIN*%\n') DCNL DCSP file.write('%OFA0B0*%\n') DCNL DCSP ixs = cad.x[::2] DCNL DCSP xs = (cad.xmin + (((cad.xmax - cad.xmin) * (ixs + 0.5)) / float(cad.nx))) DCNL DCSP ixe = cad.x[1::2] DCNL DCSP xe = (cad.xmin + (((cad.xmax - cad.xmin) * (ixe + 0.5)) / float(cad.nx))) DCNL DCSP idx = (ixe - ixs) DCNL DCSP dx = (xe - xs) DCNL DCSP iys = cad.y[::2] DCNL DCSP ys = (cad.ymin + (((cad.ymax - cad.ymin) * (iys + 0.5)) / float(cad.ny))) DCNL DCSP iye = cad.y[1::2] DCNL DCSP ye = (cad.ymin + (((cad.ymax - cad.ymin) * (iye + 0.5)) / float(cad.ny))) DCNL DCSP idy = (iye - iys) DCNL DCSP dy = (ye - ys) DCNL DCSP mins = where((idx < idy), idx, idy) DCNL DCSP uniques = unique(mins) DCNL DCSP apertures = (((cad.xmax - cad.xmin) * uniques) / float(cad.nx)) DCNL DCSP index = searchsorted(uniques, mins) DCNL DCSP for i in range(len(uniques)): DCNL DCSP  DCSP file.write(('%%ADD%dR,%.4fX%.4f*%%\n' % ((i + 10), apertures[i], apertures[i]))) DCNL DCSP coords = arange(len(mins)) DCNL DCSP for i in range(len(uniques)): DCNL DCSP  DCSP file.write(('D%d*\n' % (i + 10))) DCNL DCSP  DCSP coord = coords[(index == i)] DCNL DCSP  DCSP delta = (apertures[i] / 2.0) DCNL DCSP  DCSP ixs = (10000 * (xs + delta)).astype(int32) DCNL DCSP  DCSP ixe = (10000 * (xe - delta)).astype(int32) DCNL DCSP  DCSP iys = (10000 * (ys + delta)).astype(int32) DCNL DCSP  DCSP iye = (10000 * (ye - delta)).astype(int32) DCNL DCSP  DCSP for j in range(len(coord)): DCNL DCSP  DCSP  DCSP n = coord[j] DCNL DCSP  DCSP  DCSP if (idx[n] == idy[n]): DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%dY%dD03*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP elif (idx[n] > idy[n]): DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%dY%dD02*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%dY%dD01*\n' % (ixe[n], iys[n]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%dY%dD02*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%dY%dD01*\n' % (ixs[n], iye[n]))) DCNL DCSP file.write('M02*\n') DCNL DCSP file.close() DCNL DCSP string_msg.set(('wrote DCSP %s DCSP (RS-274X)' % filename)) DCNL DCSP root.update()
 DCSP X = np.asarray(X) DCNL DCSP if ((len(X.shape) == 2) and (X.shape[1] == 1)): DCNL DCSP  DCSP if (not assume_centered): DCNL DCSP  DCSP  DCSP X = (X - X.mean()) DCNL DCSP  DCSP return (np.atleast_2d((X ** 2).mean()), 0.0) DCNL DCSP if (X.ndim == 1): DCNL DCSP  DCSP X = np.reshape(X, (1, (-1))) DCNL DCSP  DCSP warnings.warn('Only DCSP one DCSP sample DCSP available. DCSP You DCSP may DCSP want DCSP to DCSP reshape DCSP your DCSP data DCSP array') DCNL DCSP  DCSP n_samples = 1 DCNL DCSP  DCSP n_features = X.size DCNL DCSP else: DCNL DCSP  DCSP (n_samples, n_features) = X.shape DCNL DCSP emp_cov = empirical_covariance(X, assume_centered=assume_centered) DCNL DCSP mu = (np.trace(emp_cov) / n_features) DCNL DCSP alpha = np.mean((emp_cov ** 2)) DCNL DCSP num = (alpha + (mu ** 2)) DCNL DCSP den = ((n_samples + 1.0) * (alpha - ((mu ** 2) / n_features))) DCNL DCSP shrinkage = (1.0 if (den == 0) else min((num / den), 1.0)) DCNL DCSP shrunk_cov = ((1.0 - shrinkage) * emp_cov) DCNL DCSP shrunk_cov.flat[::(n_features + 1)] += (shrinkage * mu) DCNL DCSP return (shrunk_cov, shrinkage)
 DCSP site_mod_dir = os.path.dirname(os.path.abspath(site.__file__)) DCNL DCSP no_global_file = os.path.join(site_mod_dir, 'no-global-site-packages.txt') DCNL DCSP if (running_under_virtualenv() and os.path.isfile(no_global_file)): DCNL DCSP  DCSP return True
 DCSP if (data is None): DCNL DCSP  DCSP return '0000' DCNL DCSP return (('%04x' % (len(data) + 4)).encode('ascii') + data)
 DCSP __tracebackhide__ = True DCNL DCSP try: DCNL DCSP  DCSP run(*args, **kwargs) DCNL DCSP  DCSP assert False, ('%s DCSP should DCSP have DCSP been DCSP thrown' % exception) DCNL DCSP except exception: DCNL DCSP  DCSP e = sys.exc_info()[1] DCNL DCSP  DCSP p = re.compile(reg) DCNL DCSP  DCSP assert p.search(str(e)), str(e)
 DCSP conn = get_conn() DCNL DCSP return conn.network_list()
 DCSP import inbox.actions.backends DCNL DCSP for backend in inbox.actions.backends.module_registry.values(): DCNL DCSP  DCSP for method_name in backend.__all__: DCNL DCSP  DCSP  DCSP monkeypatch.setattr(((backend.__name__ + '.') + method_name), (lambda *args, **kwargs: None))
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if ((exc.errno == errno.EEXIST) and os.path.isdir(path)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP with open(filename, 'rb') as fid: DCNL DCSP  DCSP content = fid.read() DCNL DCSP content = content.replace('\r\n', '\n') DCNL DCSP try: DCNL DCSP  DCSP node = ast.parse(content) DCNL DCSP except SyntaxError: DCNL DCSP  DCSP return (SYNTAX_ERROR_DOCSTRING, content.decode('utf-8')) DCNL DCSP if (not isinstance(node, ast.Module)): DCNL DCSP  DCSP raise TypeError('This DCSP function DCSP only DCSP supports DCSP modules. DCSP You DCSP provided DCSP {0}'.format(node.__class__.__name__)) DCNL DCSP if (node.body and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Str)): DCNL DCSP  DCSP docstring_node = node.body[0] DCNL DCSP  DCSP docstring = docstring_node.value.s DCNL DCSP  DCSP if hasattr(docstring, 'decode'): DCNL DCSP  DCSP  DCSP docstring = docstring.decode('utf-8') DCNL DCSP  DCSP rest = content.decode('utf-8').split('\n', docstring_node.lineno)[(-1)] DCNL DCSP  DCSP return (docstring, rest) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Could DCSP not DCSP find DCSP docstring DCSP in DCSP file DCSP "{0}". DCSP A DCSP docstring DCSP is DCSP required DCSP by DCSP sphinx-gallery'.format(filename))
 DCSP assert (utils.get_repr(Obj(), constructor, **attrs) == expected)
 DCSP ordered_product = get_object_or_404(OrderedProduct, pk=ordered_product_id) DCNL DCSP if ((not request.user.profile.has_permission(ordered_product, mode='w')) and (not request.user.profile.is_admin('treeio.sales'))): DCNL DCSP  DCSP return user_denied(request, "You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Status", response_format) DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('delete' in request.POST): DCNL DCSP  DCSP  DCSP order_id = ordered_product.order_id DCNL DCSP  DCSP  DCSP if ('trash' in request.POST): DCNL DCSP  DCSP  DCSP  DCSP ordered_product.trash = True DCNL DCSP  DCSP  DCSP  DCSP ordered_product.save() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ordered_product.delete() DCNL DCSP  DCSP  DCSP ordered_product.order.update_total() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('sales_order_view', args=[order_id])) DCNL DCSP  DCSP elif ('cancel' in request.POST): DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('sales_ordered_product_view', args=[ordered_product.id])) DCNL DCSP order = ordered_product.order DCNL DCSP return render_to_response('sales/ordered_product_delete', {'ordered_product': ordered_product, 'order': order}, context_instance=RequestContext(request), response_format=response_format)
 DCSP if (not (a_device.snmp_credentials.snmp_mode == 'snmp3')): DCNL DCSP  DCSP raise ValueError('Invalid DCSP SNMP DCSP mode DCSP in DCSP config_detect DCSP {}'.format(a_device.snmp_credentials.snmp_mode)) DCNL DCSP snmp_device = (a_device.ip_address, a_device.snmp_port) DCNL DCSP snmp_user = (a_device.snmp_credentials.username, a_device.snmp_credentials.auth_key, a_device.snmp_credentials.encrypt_key) DCNL DCSP auth_proto = a_device.snmp_credentials.auth_proto DCNL DCSP encrypt_proto = a_device.snmp_credentials.encrypt_proto DCNL DCSP return {'snmp_device': snmp_device, 'snmp_user': snmp_user, 'oid': oid, 'auth_proto': auth_proto, 'encrypt_proto': encrypt_proto}
 DCSP if (k < 1): DCNL DCSP  DCSP return False DCNL DCSP if (n < 0): DCNL DCSP  DCSP return False DCNL DCSP if (n == 0): DCNL DCSP  DCSP return True DCNL DCSP if (k == 1): DCNL DCSP  DCSP return is_square(n) DCNL DCSP if (k == 2): DCNL DCSP  DCSP if (n in (1, 2)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP if ((n % 4) == 1): DCNL DCSP  DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = factorint(n) DCNL DCSP  DCSP  DCSP for (p, m) in f.items(): DCNL DCSP  DCSP  DCSP  DCSP if (((p % 4) == 3) and (m % 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP if (k == 3): DCNL DCSP  DCSP if (((n // (4 ** multiplicity(4, n))) % 8) == 7): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP rows = session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(key=key).filter_by(deleted=False).all() DCNL DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP raise exception.GlanceMetadataExists(key=key, volume_id=volume_id) DCNL DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP vol_glance_metadata.key = key DCNL DCSP  DCSP vol_glance_metadata.value = value DCNL DCSP  DCSP vol_glance_metadata.save(session=session) DCNL DCSP return
 DCSP perimeter = _tile_perimeter(coord, projection, False) DCNL DCSP return (perimeter[8][0] - perimeter[0][0])
 DCSP get_pool().connection_pool_kw.update(maxsize=maxsize)
 DCSP return encode(raw_bytes, expr=re_alphanumeric, *a, **kw)
 DCSP f = (_Cfunctions.get('libvlc_media_list_set_media', None) or _Cfunction('libvlc_media_list_set_media', ((1,), (1,)), None, None, MediaList, Media)) DCNL DCSP return f(p_ml, p_md)
 DCSP config = target_dict['configurations'][config_name] DCNL DCSP msvs = config.setdefault('msvs_settings', {}) DCNL DCSP linker = msvs.get('VCLinkerTool', {}) DCNL DCSP pdb_path = linker.get('ProgramDatabaseFile') DCNL DCSP if pdb_path: DCNL DCSP  DCSP return pdb_path DCNL DCSP variables = target_dict.get('variables', {}) DCNL DCSP pdb_path = variables.get('msvs_large_pdb_path', None) DCNL DCSP if pdb_path: DCNL DCSP  DCSP return pdb_path DCNL DCSP pdb_base = target_dict.get('product_name', target_dict['target_name']) DCNL DCSP pdb_base = ('%s.%s.pdb' % (pdb_base, TARGET_TYPE_EXT[target_dict['type']])) DCNL DCSP pdb_path = ((vars['PRODUCT_DIR'] + '/') + pdb_base) DCNL DCSP return pdb_path
 DCSP try: DCNL DCSP  DCSP out = max_and_argmax(x, axis)[0] DCNL DCSP except Exception: DCNL DCSP  DCSP out = CAReduce(scal.maximum, axis)(x) DCNL DCSP if keepdims: DCNL DCSP  DCSP out = makeKeepDims(x, out, axis) DCNL DCSP return out
 DCSP def _checklogin(request, *args, **kwargs): DCNL DCSP  DCSP if (request.user.is_authenticated() and request.user.is_staff): DCNL DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP assert hasattr(request, 'session'), "The DCSP Django DCSP admin DCSP requires DCSP session DCSP middleware DCSP to DCSP be DCSP installed. DCSP Edit DCSP your DCSP MIDDLEWARE_CLASSES DCSP setting DCSP to DCSP insert DCSP 'django.contrib.sessions.middleware.SessionMiddleware'." DCNL DCSP  DCSP if (not request.POST.has_key(LOGIN_FORM_KEY)): DCNL DCSP  DCSP  DCSP if request.POST: DCNL DCSP  DCSP  DCSP  DCSP message = _('Please DCSP log DCSP in DCSP again, DCSP because DCSP your DCSP session DCSP has DCSP expired.') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP message = '' DCNL DCSP  DCSP  DCSP return _display_login_form(request, message) DCNL DCSP  DCSP if (not request.session.test_cookie_worked()): DCNL DCSP  DCSP  DCSP message = _("Looks DCSP like DCSP your DCSP browser DCSP isn't DCSP configured DCSP to DCSP accept DCSP cookies. DCSP Please DCSP enable DCSP cookies, DCSP reload DCSP this DCSP page, DCSP and DCSP try DCSP again.") DCNL DCSP  DCSP  DCSP return _display_login_form(request, message) DCNL DCSP  DCSP username = request.POST.get('username', None) DCNL DCSP  DCSP password = request.POST.get('password', None) DCNL DCSP  DCSP user = authenticate(username=username, password=password) DCNL DCSP  DCSP if (user is None): DCNL DCSP  DCSP  DCSP message = ERROR_MESSAGE DCNL DCSP  DCSP  DCSP if ('@' in username): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP user = User.objects.get(email=username) DCNL DCSP  DCSP  DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = _("Usernames DCSP cannot DCSP contain DCSP the DCSP '@' DCSP character.") DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = (_("Your DCSP e-mail DCSP address DCSP is DCSP not DCSP your DCSP username. DCSP Try DCSP '%s' DCSP instead.") % user.username) DCNL DCSP  DCSP  DCSP return _display_login_form(request, message) DCNL DCSP  DCSP elif (user.is_active and user.is_staff): DCNL DCSP  DCSP  DCSP login(request, user) DCNL DCSP  DCSP  DCSP user.last_login = datetime.datetime.now() DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP  DCSP  DCSP return http.HttpResponseRedirect(request.path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _display_login_form(request, ERROR_MESSAGE) DCNL DCSP return _checklogin
 DCSP is_ax = (coil['coil_class'] in (FIFF.FWD_COILC_MAG, FIFF.FWD_COILC_AXIAL_GRAD, FIFF.FWD_COILC_AXIAL_GRAD2)) DCNL DCSP return is_ax
 DCSP q = find_simple_recurrence_vector(v) DCNL DCSP n = len(q) DCNL DCSP if (n <= 1): DCNL DCSP  DCSP return None DCNL DCSP p = [sum(((v[(i - k)] * q[k]) for k in range(min((i + 1), n)))) for i in range(len(v))] DCNL DCSP return (sum(((p[k] * (X ** k)) for k in range(len(p)))) / sum(((q[k] * (X ** k)) for k in range(n))))
 DCSP statements = [] DCNL DCSP for _ in range(0, total_strings): DCNL DCSP  DCSP text = ''.join((random.choice(((string.ascii_letters + string.digits) + ' DCSP ')) for _ in range(string_length))) DCNL DCSP  DCSP statements.append(text) DCNL DCSP return statements
 DCSP lines = iter(yield_lines(strs)) DCNL DCSP def scan_list(ITEM, TERMINATOR, line, p, groups, item_name): DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP while (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP if CONTINUE(line, p): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP line = next(lines) DCNL DCSP  DCSP  DCSP  DCSP  DCSP p = 0 DCNL DCSP  DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('\\ DCSP must DCSP not DCSP appear DCSP on DCSP the DCSP last DCSP nonblank DCSP line') DCNL DCSP  DCSP  DCSP match = ITEM(line, p) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP msg = (('Expected DCSP ' + item_name) + ' DCSP in') DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg, line, 'at', line[p:]) DCNL DCSP  DCSP  DCSP items.append(match.group(*groups)) DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP match = COMMA(line, p) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP elif (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP  DCSP msg = "Expected DCSP ',' DCSP or DCSP end-of-list DCSP in" DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg, line, 'at', line[p:]) DCNL DCSP  DCSP match = TERMINATOR(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP return (line, p, items) DCNL DCSP for line in lines: DCNL DCSP  DCSP match = DISTRO(line) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP raise ValueError('Missing DCSP distribution DCSP spec', line) DCNL DCSP  DCSP project_name = match.group(1) DCNL DCSP  DCSP p = match.end() DCNL DCSP  DCSP extras = [] DCNL DCSP  DCSP match = OBRACKET(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.end() DCNL DCSP  DCSP  DCSP (line, p, extras) = scan_list(DISTRO, CBRACKET, line, p, (1,), "'extra' DCSP name") DCNL DCSP  DCSP (line, p, specs) = scan_list(VERSION, LINE_END, line, p, (1, 2), 'version DCSP spec') DCNL DCSP  DCSP specs = [(op, safe_version(val)) for (op, val) in specs] DCNL DCSP  DCSP (yield Requirement(project_name, specs, extras))
 DCSP dynamodb_type = get_dynamodb_type(val) DCNL DCSP if (dynamodb_type == 'N'): DCNL DCSP  DCSP val = {dynamodb_type: serialize_num(val)} DCNL DCSP elif (dynamodb_type == 'S'): DCNL DCSP  DCSP val = {dynamodb_type: val} DCNL DCSP elif (dynamodb_type == 'NS'): DCNL DCSP  DCSP val = {dynamodb_type: list(map(serialize_num, val))} DCNL DCSP elif (dynamodb_type == 'SS'): DCNL DCSP  DCSP val = {dynamodb_type: [n for n in val]} DCNL DCSP elif (dynamodb_type == 'B'): DCNL DCSP  DCSP if isinstance(val, bytes): DCNL DCSP  DCSP  DCSP val = Binary(val) DCNL DCSP  DCSP val = {dynamodb_type: val.encode()} DCNL DCSP elif (dynamodb_type == 'BS'): DCNL DCSP  DCSP val = {dynamodb_type: [n.encode() for n in val]} DCNL DCSP return val
 DCSP completer = QtWidgets.QCompleter(items, widget) DCNL DCSP completer.setCaseSensitivity(Qt.CaseInsensitive) DCNL DCSP completer.setCompletionMode(QtWidgets.QCompleter.InlineCompletion) DCNL DCSP widget.setCompleter(completer)
 DCSP uniquedeps = get_deps_dict['uniquedeps'] DCNL DCSP spec = get_deps_dict['spec'] DCNL DCSP hash.update(spec.text) DCNL DCSP for d in uniquedeps: DCNL DCSP  DCSP hash.update(roslib.msgs.get_registered(d).text) DCNL DCSP return hash.hexdigest()
 DCSP return NegativeSamplingFunction(sampler, sample_size)(x, t, W)
 DCSP redirect_to = request.REQUEST.get(redirect_field_name, '') DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP form = authentication_form(data=request.POST) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP if (not is_safe_url(url=redirect_to, host=request.get_host())): DCNL DCSP  DCSP  DCSP  DCSP redirect_to = resolve_url(settings.LOGIN_REDIRECT_URL) DCNL DCSP  DCSP  DCSP auth_login(request, form.get_user()) DCNL DCSP  DCSP  DCSP if request.session.test_cookie_worked(): DCNL DCSP  DCSP  DCSP  DCSP request.session.delete_test_cookie() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(redirect_to) DCNL DCSP else: DCNL DCSP  DCSP form = authentication_form(request) DCNL DCSP request.session.set_test_cookie() DCNL DCSP current_site = get_current_site(request) DCNL DCSP context = {'form': form, redirect_field_name: redirect_to, 'site': current_site, 'site_name': current_site.name} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.update(extra_context) DCNL DCSP return TemplateResponse(request, template_name, context, current_app=current_app)
 DCSP titles = [] DCNL DCSP if (not title): DCNL DCSP  DCSP return titles DCNL DCSP size = reverse_text_len(width, (title_fs * 1.1)) DCNL DCSP title_lines = title.split('\n') DCNL DCSP for title_line in title_lines: DCNL DCSP  DCSP while (len(title_line) > size): DCNL DCSP  DCSP  DCSP title_part = title_line[:size] DCNL DCSP  DCSP  DCSP i = title_part.rfind(' DCSP ') DCNL DCSP  DCSP  DCSP if (i == (-1)): DCNL DCSP  DCSP  DCSP  DCSP i = len(title_part) DCNL DCSP  DCSP  DCSP titles.append(title_part[:i]) DCNL DCSP  DCSP  DCSP title_line = title_line[i:].strip() DCNL DCSP  DCSP titles.append(title_line) DCNL DCSP return titles
 DCSP yh = SM.sineModelSynth(hfreq, hmag, hphase, N, H, fs) DCNL DCSP yst = STM.stochasticModelSynth(stocEnv, H, (H * 2)) DCNL DCSP y = (yh[:min(yh.size, yst.size)] + yst[:min(yh.size, yst.size)]) DCNL DCSP return (y, yh, yst)
 DCSP if is_nnf(expr, simplify): DCNL DCSP  DCSP return expr DCNL DCSP return expr.to_nnf(simplify)
 DCSP global ET DCNL DCSP _bootstrap() DCNL DCSP return ET.fromstring(*args, **kwargs)
 DCSP settings.POOTLE_CAPTCHA_ENABLED = False DCNL DCSP Comment = get_comment_model() DCNL DCSP unit = Unit.objects.filter(suggestion__state='pending', state=UNTRANSLATED)[0] DCNL DCSP sugg = Suggestion.objects.filter(unit=unit, state='pending')[0] DCNL DCSP user = request_users['user'] DCNL DCSP if (user.username != 'nobody'): DCNL DCSP  DCSP client.login(username=user.username, password=request_users['password']) DCNL DCSP url = ('/xhr/units/%d/' % unit.id) DCNL DCSP edited_target = ('Edited DCSP %s' % sugg.target_f) DCNL DCSP comment = 'This DCSP is DCSP a DCSP comment!' DCNL DCSP response = client.post(url, {'state': False, 'target_f_0': edited_target, 'suggestion': sugg.id, 'comment': comment}, HTTP_X_REQUESTED_WITH='XMLHttpRequest') DCNL DCSP if check_permission('translate', response.wsgi_request): DCNL DCSP  DCSP assert (response.status_code == 200) DCNL DCSP  DCSP content = json.loads(response.content) DCNL DCSP  DCSP assert (content['newtargets'] == [edited_target]) DCNL DCSP  DCSP assert (content['user_score'] == response.wsgi_request.user.public_score) DCNL DCSP  DCSP assert (content['checks'] is None) DCNL DCSP  DCSP accepted_suggestion = Suggestion.objects.get(id=sugg.id) DCNL DCSP  DCSP updated_unit = Unit.objects.get(id=unit.id) DCNL DCSP  DCSP assert (accepted_suggestion.state == 'accepted') DCNL DCSP  DCSP assert (str(updated_unit.target) == edited_target) DCNL DCSP  DCSP assert (Comment.objects.for_model(accepted_suggestion).get().comment == comment) DCNL DCSP else: DCNL DCSP  DCSP assert (response.status_code == 403)
 DCSP mappings = service_mapping(services, registry_path=registry_path) DCNL DCSP return webapp2.WSGIApplication(routes=mappings, debug=debug, config=config)
 DCSP matrixKey = (prefix + 'matrix') DCNL DCSP evaluatedDictionary = evaluate.getEvaluatedDictionary([matrixKey], xmlElement) DCNL DCSP if (len(evaluatedDictionary.keys()) < 1): DCNL DCSP  DCSP return matrixTetragrid DCNL DCSP value = evaluatedDictionary[matrixKey] DCNL DCSP if ((value == None) or (value == 'None')): DCNL DCSP  DCSP print 'Warning, DCSP value DCSP in DCSP getMatrixTetragridMatrix DCSP in DCSP matrix DCSP is DCSP None DCSP for DCSP matrixKey DCSP for DCSP dictionary:' DCNL DCSP  DCSP print matrixKey DCNL DCSP  DCSP print evaluatedDictionary DCNL DCSP else: DCNL DCSP  DCSP matrixTetragrid = getIdentityMatrixTetragrid(matrixTetragrid) DCNL DCSP  DCSP for (rowIndex, row) in enumerate(value): DCNL DCSP  DCSP  DCSP for (elementIndex, element) in enumerate(row): DCNL DCSP  DCSP  DCSP  DCSP matrixTetragrid[rowIndex][elementIndex] = element DCNL DCSP euclidean.removeListFromDictionary(xmlElement.attributeDictionary, [matrixKey]) DCNL DCSP return matrixTetragrid
 DCSP network_config = getattr(settings, 'OPENSTACK_NEUTRON_NETWORK', {}) DCNL DCSP feature_info = FEATURE_MAP.get(feature) DCNL DCSP if (not feature_info): DCNL DCSP  DCSP raise ValueError(_("The DCSP requested DCSP feature DCSP '%(feature)s' DCSP is DCSP unknown. DCSP Please DCSP make DCSP sure DCSP to DCSP specify DCSP a DCSP feature DCSP defined DCSP in DCSP FEATURE_MAP.")) DCNL DCSP feature_config = feature_info.get('config') DCNL DCSP if feature_config: DCNL DCSP  DCSP if (not network_config.get(feature_config['name'], feature_config['default'])): DCNL DCSP  DCSP  DCSP return False DCNL DCSP feature_policies = feature_info.get('policies') DCNL DCSP if feature_policies: DCNL DCSP  DCSP policy_name = feature_policies.get(operation) DCNL DCSP  DCSP if (not policy_name): DCNL DCSP  DCSP  DCSP raise ValueError((_("The DCSP 'operation' DCSP parameter DCSP for DCSP get_feature_permission DCSP '%(feature)s' DCSP is DCSP invalid. DCSP It DCSP should DCSP be DCSP one DCSP of DCSP %(allowed)s") % {'feature': feature, 'allowed': ' DCSP '.join(feature_policies.keys())})) DCNL DCSP  DCSP role = (('network', policy_name),) DCNL DCSP  DCSP if (not policy.check(role, request)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP feature_extension = feature_info.get('extension') DCNL DCSP if feature_extension: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return is_extension_supported(request, feature_extension) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP msg = (_("Failed DCSP to DCSP check DCSP Neutron DCSP '%s' DCSP extension DCSP is DCSP not DCSP supported") % feature_extension) DCNL DCSP  DCSP  DCSP LOG.info(msg) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (pytz is None): DCNL DCSP  DCSP if timezone_string: DCNL DCSP  DCSP  DCSP raise ValueError('need DCSP pytz DCSP in DCSP order DCSP to DCSP specify DCSP a DCSP timezone') DCNL DCSP  DCSP return None DCNL DCSP if timezone_string: DCNL DCSP  DCSP return pytz.timezone(timezone_string) DCNL DCSP else: DCNL DCSP  DCSP return pytz.utc
 DCSP a = a.split('.') DCNL DCSP b = b.split('.') DCNL DCSP for (va, vb) in zip(a, b): DCNL DCSP  DCSP ret = (int(va) - int(vb)) DCNL DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return (len(a) - len(b))
 DCSP if (v >= _MAX_SCATTERED_COUNTER): DCNL DCSP  DCSP raise datastore_errors.BadArgumentError(('counter DCSP value DCSP too DCSP large DCSP (%d)' % v)) DCNL DCSP return ((_MAX_SEQUENTIAL_ID + 1) + long(ReverseBitsInt64((v << _SCATTER_SHIFT))))
 DCSP try: DCNL DCSP  DCSP item = KnowledgeItem.by_path(folderPath, itemPath) DCNL DCSP except KnowledgeItem.DoesNotExist: DCNL DCSP  DCSP raise Http404 DCNL DCSP if (not item): DCNL DCSP  DCSP raise Http404 DCNL DCSP items = Object.filter_permitted(manager=KnowledgeItem.objects, user=request.user.profile, mode='r') DCNL DCSP if (not request.user.profile.has_permission(item)): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Knowledge DCSP Item") DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'items': items, 'item': item}) DCNL DCSP return render_to_response('knowledge/item_view', context, context_instance=RequestContext(request), response_format=response_format)
 DCSP if (len(splitLine) > 0): DCNL DCSP  DCSP return splitLine[0] DCNL DCSP return ''
 DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP elif (not os.access(path, os.W_OK)): DCNL DCSP  DCSP raise OSError('DATA_DIR DCSP {0} DCSP is DCSP not DCSP writable!'.format(path))
 DCSP first = param_values['name1'] DCNL DCSP second = param_values['name2'] DCNL DCSP if (first == second): DCNL DCSP  DCSP error_map['name1'] = 'The DCSP value DCSP names DCSP should DCSP be DCSP different.'
 DCSP return get_i18n().parse_date(string)
 DCSP result = script.pip('install', '--no-index', ('--find-links=' + data.find_links), 'simplewheel[nonexistent, DCSP nope]', expect_stderr=True) DCNL DCSP msg = " DCSP  DCSP simplewheel DCSP 2.0 DCSP does DCSP not DCSP provide DCSP the DCSP extra DCSP 'nonexistent'\n DCSP  DCSP simplewheel DCSP 2.0 DCSP does DCSP not DCSP provide DCSP the DCSP extra DCSP 'nope'" DCNL DCSP assert (msg in result.stderr)
 DCSP containers = dict([(c, (['all'] + (lxc.Container(c).get_config_item('lxc.group') or []))) for c in lxc.list_containers()]) DCNL DCSP groups = set(sum([g for g in containers.values()], [])) DCNL DCSP return dict([(g, {'hosts': [k for (k, v) in containers.items() if (g in v)], 'vars': {'ansible_connection': 'lxc'}}) for g in groups])
 DCSP try: DCNL DCSP  DCSP (status, addressVersion, streamNumber, ripe) = decodeAddress(address) DCNL DCSP  DCSP readPosition = 20 DCNL DCSP  DCSP (embeddedAddressVersion, varintLength) = decodeVarint(data[readPosition:(readPosition + 10)]) DCNL DCSP  DCSP readPosition += varintLength DCNL DCSP  DCSP (embeddedStreamNumber, varintLength) = decodeVarint(data[readPosition:(readPosition + 10)]) DCNL DCSP  DCSP readPosition += varintLength DCNL DCSP  DCSP storedData = data[20:readPosition] DCNL DCSP  DCSP if (addressVersion != embeddedAddressVersion): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP address DCSP version DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP if (streamNumber != embeddedStreamNumber): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP stream DCSP number DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP tag = data[readPosition:(readPosition + 32)] DCNL DCSP  DCSP readPosition += 32 DCNL DCSP  DCSP signedData = data[8:readPosition] DCNL DCSP  DCSP encryptedData = data[readPosition:] DCNL DCSP  DCSP (toAddress, cryptorObject) = shared.neededPubkeys[tag] DCNL DCSP  DCSP if (toAddress != address): DCNL DCSP  DCSP  DCSP logger.critical(('decryptAndCheckPubkeyPayload DCSP failed DCSP due DCSP to DCSP toAddress DCSP mismatch. DCSP This DCSP is DCSP very DCSP peculiar. DCSP toAddress: DCSP %s, DCSP address DCSP %s' % (toAddress, address))) DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP decryptedData = cryptorObject.decrypt(encryptedData) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP decryption DCSP was DCSP unsuccessful.') DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP readPosition = 0 DCNL DCSP  DCSP bitfieldBehaviors = decryptedData[readPosition:(readPosition + 4)] DCNL DCSP  DCSP readPosition += 4 DCNL DCSP  DCSP publicSigningKey = ('\x04' + decryptedData[readPosition:(readPosition + 64)]) DCNL DCSP  DCSP readPosition += 64 DCNL DCSP  DCSP publicEncryptionKey = ('\x04' + decryptedData[readPosition:(readPosition + 64)]) DCNL DCSP  DCSP readPosition += 64 DCNL DCSP  DCSP (specifiedNonceTrialsPerByte, specifiedNonceTrialsPerByteLength) = decodeVarint(decryptedData[readPosition:(readPosition + 10)]) DCNL DCSP  DCSP readPosition += specifiedNonceTrialsPerByteLength DCNL DCSP  DCSP (specifiedPayloadLengthExtraBytes, specifiedPayloadLengthExtraBytesLength) = decodeVarint(decryptedData[readPosition:(readPosition + 10)]) DCNL DCSP  DCSP readPosition += specifiedPayloadLengthExtraBytesLength DCNL DCSP  DCSP storedData += decryptedData[:readPosition] DCNL DCSP  DCSP signedData += decryptedData[:readPosition] DCNL DCSP  DCSP (signatureLength, signatureLengthLength) = decodeVarint(decryptedData[readPosition:(readPosition + 10)]) DCNL DCSP  DCSP readPosition += signatureLengthLength DCNL DCSP  DCSP signature = decryptedData[readPosition:(readPosition + signatureLength)] DCNL DCSP  DCSP if highlevelcrypto.verify(signedData, signature, hexlify(publicSigningKey)): DCNL DCSP  DCSP  DCSP logger.info('ECDSA DCSP verify DCSP passed DCSP (within DCSP decryptAndCheckPubkeyPayload)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('ECDSA DCSP verify DCSP failed DCSP (within DCSP decryptAndCheckPubkeyPayload)') DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP sha = hashlib.new('sha512') DCNL DCSP  DCSP sha.update((publicSigningKey + publicEncryptionKey)) DCNL DCSP  DCSP ripeHasher = hashlib.new('ripemd160') DCNL DCSP  DCSP ripeHasher.update(sha.digest()) DCNL DCSP  DCSP embeddedRipe = ripeHasher.digest() DCNL DCSP  DCSP if (embeddedRipe != ripe): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP RIPE DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'failed' DCNL DCSP  DCSP logger.info(('within DCSP decryptAndCheckPubkeyPayload, DCSP addressVersion: DCSP %s, DCSP streamNumber: DCSP %s DCSP \n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ripe DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP publicSigningKey DCSP in DCSP hex: DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP publicEncryptionKey DCSP in DCSP hex: DCSP %s' % (addressVersion, streamNumber, hexlify(ripe), hexlify(publicSigningKey), hexlify(publicEncryptionKey)))) DCNL DCSP  DCSP t = (address, addressVersion, storedData, int(time.time()), 'yes') DCNL DCSP  DCSP sqlExecute('INSERT DCSP INTO DCSP pubkeys DCSP VALUES DCSP (?,?,?,?,?)', *t) DCNL DCSP  DCSP return 'successful' DCNL DCSP except varintDecodeError as e: DCNL DCSP  DCSP logger.info('Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP a DCSP malformed DCSP varint.') DCNL DCSP  DCSP return 'failed' DCNL DCSP except Exception as e: DCNL DCSP  DCSP logger.critical(('Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP because DCSP of DCSP an DCSP unhandled DCSP exception! DCSP This DCSP is DCSP definitely DCSP a DCSP bug! DCSP \n%s' % traceback.format_exc())) DCNL DCSP  DCSP return 'failed'
 DCSP mac = hex(num)[2:] DCNL DCSP if (mac[(-1)] == u'L'): DCNL DCSP  DCSP mac = mac[:(-1)] DCNL DCSP pad = max((12 - len(mac)), 0) DCNL DCSP mac = ((u'0' * pad) + mac) DCNL DCSP mac = splitter.join([mac[x:(x + 2)] for x in range(0, 12, 2)]) DCNL DCSP mac = mac.upper() DCNL DCSP return mac
 DCSP all_rising = rising.get_all_rising() DCNL DCSP candidate_sr_ids = {sr_id for (link, score, sr_id) in all_rising}.difference(omit_sr_ids) DCNL DCSP link_fullnames = [link for (link, score, sr_id) in all_rising if (sr_id in candidate_sr_ids)] DCNL DCSP link_fullnames_to_show = random_sample(link_fullnames, count) DCNL DCSP rising_links = Link._by_fullname(link_fullnames_to_show, return_dict=False, data=True) DCNL DCSP rising_items = [ExploreItem(TYPE_RISING, 'ris', Subreddit._byID(l.sr_id), l) for l in rising_links] DCNL DCSP return rising_items
 DCSP if isinstance(profile, string_types): DCNL DCSP  DCSP profile = __salt__['config.option'](profile) DCNL DCSP if orgname: DCNL DCSP  DCSP switch_org(orgname, profile) DCNL DCSP response = requests.get('{0}/api/datasources'.format(profile['grafana_url']), auth=_get_auth(profile), headers=_get_headers(profile), timeout=profile.get('grafana_timeout', 3)) DCNL DCSP if (response.status_code >= 400): DCNL DCSP  DCSP response.raise_for_status() DCNL DCSP return response.json()
 DCSP (_, _, app_id) = app_id.replace(':', '_').rpartition('~') DCNL DCSP if (path is None): DCNL DCSP  DCSP for path in _generate_storage_paths(app_id): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.mkdir(path, 448) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((sys.platform == 'win32') or (((os.stat(path).st_mode & 511) == 448) and os.path.isdir(path))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return path DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return path DCNL DCSP elif (not os.path.exists(path)): DCNL DCSP  DCSP os.mkdir(path) DCNL DCSP  DCSP return path DCNL DCSP elif (not os.path.isdir(path)): DCNL DCSP  DCSP raise IOError(('the DCSP given DCSP storage DCSP path DCSP %r DCSP is DCSP a DCSP file, DCSP a DCSP directory DCSP was DCSP expected' % path)) DCNL DCSP else: DCNL DCSP  DCSP return path
 DCSP appctx = _app_ctx_stack.top DCNL DCSP reqctx = _request_ctx_stack.top DCNL DCSP if (appctx is None): DCNL DCSP  DCSP raise RuntimeError('Attempted DCSP to DCSP generate DCSP a DCSP URL DCSP without DCSP the DCSP application DCSP context DCSP being DCSP pushed. DCSP This DCSP has DCSP to DCSP be DCSP executed DCSP when DCSP application DCSP context DCSP is DCSP available.') DCNL DCSP if (reqctx is not None): DCNL DCSP  DCSP url_adapter = reqctx.url_adapter DCNL DCSP  DCSP blueprint_name = request.blueprint DCNL DCSP  DCSP if (not reqctx.request._is_old_module): DCNL DCSP  DCSP  DCSP if (endpoint[:1] == '.'): DCNL DCSP  DCSP  DCSP  DCSP if (blueprint_name is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP endpoint = (blueprint_name + endpoint) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP endpoint = endpoint[1:] DCNL DCSP  DCSP elif ('.' not in endpoint): DCNL DCSP  DCSP  DCSP if (blueprint_name is not None): DCNL DCSP  DCSP  DCSP  DCSP endpoint = ((blueprint_name + '.') + endpoint) DCNL DCSP  DCSP elif endpoint.startswith('.'): DCNL DCSP  DCSP  DCSP endpoint = endpoint[1:] DCNL DCSP  DCSP external = values.pop('_external', False) DCNL DCSP else: DCNL DCSP  DCSP url_adapter = appctx.url_adapter DCNL DCSP  DCSP if (url_adapter is None): DCNL DCSP  DCSP  DCSP raise RuntimeError('Application DCSP was DCSP not DCSP able DCSP to DCSP create DCSP a DCSP URL DCSP adapter DCSP for DCSP request DCSP independent DCSP URL DCSP generation. DCSP You DCSP might DCSP be DCSP able DCSP to DCSP fix DCSP this DCSP by DCSP setting DCSP the DCSP SERVER_NAME DCSP config DCSP variable.') DCNL DCSP  DCSP external = values.pop('_external', True) DCNL DCSP anchor = values.pop('_anchor', None) DCNL DCSP method = values.pop('_method', None) DCNL DCSP scheme = values.pop('_scheme', None) DCNL DCSP appctx.app.inject_url_defaults(endpoint, values) DCNL DCSP if (scheme is not None): DCNL DCSP  DCSP if (not external): DCNL DCSP  DCSP  DCSP raise ValueError('When DCSP specifying DCSP _scheme, DCSP _external DCSP must DCSP be DCSP True') DCNL DCSP  DCSP url_adapter.url_scheme = scheme DCNL DCSP try: DCNL DCSP  DCSP rv = url_adapter.build(endpoint, values, method=method, force_external=external) DCNL DCSP except BuildError as error: DCNL DCSP  DCSP values['_external'] = external DCNL DCSP  DCSP values['_anchor'] = anchor DCNL DCSP  DCSP values['_method'] = method DCNL DCSP  DCSP return appctx.app.handle_url_build_error(error, endpoint, values) DCNL DCSP if (anchor is not None): DCNL DCSP  DCSP rv += ('#' + url_quote(anchor)) DCNL DCSP return rv
 DCSP (raw, events, picks) = _get_data() DCNL DCSP events = events[:10] DCNL DCSP picks = np.concatenate([pick_types(raw.info, meg=True, eeg=True)[::22], pick_types(raw.info, meg=False, eeg=False, ecg=True, eog=True)]) DCNL DCSP picks = np.sort(picks) DCNL DCSP raw.load_data().pick_channels([raw.ch_names[pick] for pick in picks]) DCNL DCSP raw.info.normalize_proj() DCNL DCSP del picks DCNL DCSP n_epochs = 2 DCNL DCSP raw.info['lowpass'] = 40.0 DCNL DCSP for decim in (1, 3): DCNL DCSP  DCSP proj_data = Epochs(raw, events, event_id, tmin, tmax, proj=True, reject=reject, decim=decim) DCNL DCSP  DCSP use_tmin = proj_data.tmin DCNL DCSP  DCSP proj_data = proj_data.get_data() DCNL DCSP  DCSP noproj_data = Epochs(raw, events, event_id, tmin, tmax, proj=False, reject=reject, decim=decim).get_data() DCNL DCSP  DCSP assert_equal(proj_data.shape, noproj_data.shape) DCNL DCSP  DCSP assert_equal(proj_data.shape[0], n_epochs) DCNL DCSP  DCSP for preload in (True, False): DCNL DCSP  DCSP  DCSP for proj in (True, False, 'delayed'): DCNL DCSP  DCSP  DCSP  DCSP for ii in range(3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print (decim, preload, proj, ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP comp = (proj_data if (proj is True) else noproj_data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ii in (0, 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs = Epochs(raw, events, event_id, tmin, tmax, proj=proj, reject=reject, preload=preload, decim=decim) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events = np.zeros((len(comp), 3), int) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events[:, 0] = np.arange(len(comp)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events[:, 2] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs = EpochsArray(comp, raw.info, tmin=use_tmin, event_id=1, events=fake_events, proj=proj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs.info['sfreq'] /= decim DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_equal(len(epochs), n_epochs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_true((raw.proj is False)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_true((epochs.proj is (True if (proj is True) else False))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ii == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs.load_data() DCNL DCSP  DCSP  DCSP  DCSP  DCSP picks_data = pick_types(epochs.info, meg=True, eeg=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP evoked = epochs.average(picks=picks_data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_equal(evoked.nave, n_epochs, epochs.drop_log) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (proj is True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP evoked.apply_proj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_true((evoked.proj is False)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_array_equal(evoked.ch_names, np.array(epochs.ch_names)[picks_data]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(evoked.times, epochs.times) DCNL DCSP  DCSP  DCSP  DCSP  DCSP epochs_data = epochs.get_data() DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(evoked.data, epochs_data.mean(axis=0)[picks_data], rtol=1e-05, atol=1e-20) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(epochs_data, comp, rtol=1e-05, atol=1e-20)
 DCSP cmd = (git_cmd_base(path) + ['status', '--porcelain']) DCNL DCSP return run_subprocess(cmd, stderr=None, universal_newlines=True)[0]
 DCSP return GenericScript(c_instance, Live.MidiMap.MapMode.absolute, Live.MidiMap.MapMode.absolute, DEVICE_CONTROLS, TRANSPORT_CONTROLS, VOLUME_CONTROLS, TRACKARM_CONTROLS, BANK_CONTROLS, CONTROLLER_DESCRIPTIONS)
 DCSP url = ''.join([const.PAN_URL, 'rest/2.0/services/cloud_dl?channel=chunlei&clienttype=0&web=1', '&method=query_sinfo&app_id=250528', '&bdstoken=', tokens['bdstoken'], '&source_path=', encoder.encode_uri_component(source_path), '&type=2', '&t=', util.timestamp()]) DCNL DCSP req = net.urlopen(url, headers={'Cookie': cookie.header_output()}) DCNL DCSP if req: DCNL DCSP  DCSP content = req.data DCNL DCSP  DCSP return json.loads(content.decode()) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP embedding = tensor.tensor3('embedding', dtype='float32') DCNL DCSP embeddingr = embedding[::(-1)] DCNL DCSP x_mask = tensor.matrix('x_mask', dtype='float32') DCNL DCSP xr_mask = x_mask[::(-1)] DCNL DCSP proj = get_layer(options['encoder'])[1](tparams, embedding, options, prefix='encoder', mask=x_mask) DCNL DCSP projr = get_layer(options['encoder'])[1](tparams, embeddingr, options, prefix='encoder_r', mask=xr_mask) DCNL DCSP ctx = tensor.concatenate([proj[0][(-1)], projr[0][(-1)]], axis=1) DCNL DCSP return (embedding, x_mask, ctx)
 DCSP _check_unknown_options(unknown_options) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return_all DCNL DCSP x0 = asarray(x0).flatten() DCNL DCSP if (x0.ndim == 0): DCNL DCSP  DCSP x0.shape = (1,) DCNL DCSP if (maxiter is None): DCNL DCSP  DCSP maxiter = (len(x0) * 200) DCNL DCSP (func_calls, f) = wrap_function(f, args) DCNL DCSP if (fprime is None): DCNL DCSP  DCSP (grad_calls, myfprime) = wrap_function(approx_fprime, (f, epsilon)) DCNL DCSP else: DCNL DCSP  DCSP (grad_calls, myfprime) = wrap_function(fprime, args) DCNL DCSP gfk = myfprime(x0) DCNL DCSP k = 0 DCNL DCSP N = len(x0) DCNL DCSP I = numpy.eye(N, dtype=int) DCNL DCSP Hk = I DCNL DCSP old_fval = f(x0) DCNL DCSP old_old_fval = (old_fval + (np.linalg.norm(gfk) / 2)) DCNL DCSP xk = x0 DCNL DCSP if retall: DCNL DCSP  DCSP allvecs = [x0] DCNL DCSP sk = [(2 * gtol)] DCNL DCSP warnflag = 0 DCNL DCSP gnorm = vecnorm(gfk, ord=norm) DCNL DCSP while ((gnorm > gtol) and (k < maxiter)): DCNL DCSP  DCSP pk = (- numpy.dot(Hk, gfk)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (alpha_k, fc, gc, old_fval, old_old_fval, gfkp1) = _line_search_wolfe12(f, myfprime, xk, pk, gfk, old_fval, old_old_fval, amin=1e-100, amax=1e+100) DCNL DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP xkp1 = (xk + (alpha_k * pk)) DCNL DCSP  DCSP if retall: DCNL DCSP  DCSP  DCSP allvecs.append(xkp1) DCNL DCSP  DCSP sk = (xkp1 - xk) DCNL DCSP  DCSP xk = xkp1 DCNL DCSP  DCSP if (gfkp1 is None): DCNL DCSP  DCSP  DCSP gfkp1 = myfprime(xkp1) DCNL DCSP  DCSP yk = (gfkp1 - gfk) DCNL DCSP  DCSP gfk = gfkp1 DCNL DCSP  DCSP if (callback is not None): DCNL DCSP  DCSP  DCSP callback(xk) DCNL DCSP  DCSP k += 1 DCNL DCSP  DCSP gnorm = vecnorm(gfk, ord=norm) DCNL DCSP  DCSP if (gnorm <= gtol): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not numpy.isfinite(old_fval)): DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rhok = (1.0 / numpy.dot(yk, sk)) DCNL DCSP  DCSP except ZeroDivisionError: DCNL DCSP  DCSP  DCSP rhok = 1000.0 DCNL DCSP  DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP  DCSP print('Divide-by-zero DCSP encountered: DCSP rhok DCSP assumed DCSP large') DCNL DCSP  DCSP if isinf(rhok): DCNL DCSP  DCSP  DCSP rhok = 1000.0 DCNL DCSP  DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP  DCSP print('Divide-by-zero DCSP encountered: DCSP rhok DCSP assumed DCSP large') DCNL DCSP  DCSP A1 = (I - ((sk[:, numpy.newaxis] * yk[numpy.newaxis, :]) * rhok)) DCNL DCSP  DCSP A2 = (I - ((yk[:, numpy.newaxis] * sk[numpy.newaxis, :]) * rhok)) DCNL DCSP  DCSP Hk = (numpy.dot(A1, numpy.dot(Hk, A2)) + ((rhok * sk[:, numpy.newaxis]) * sk[numpy.newaxis, :])) DCNL DCSP fval = old_fval DCNL DCSP if np.isnan(fval): DCNL DCSP  DCSP warnflag = 2 DCNL DCSP if (warnflag == 2): DCNL DCSP  DCSP msg = _status_message['pr_loss'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP elif (k >= maxiter): DCNL DCSP  DCSP warnflag = 1 DCNL DCSP  DCSP msg = _status_message['maxiter'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP else: DCNL DCSP  DCSP msg = _status_message['success'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(msg) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP result = OptimizeResult(fun=fval, jac=gfk, hess_inv=Hk, nfev=func_calls[0], njev=grad_calls[0], status=warnflag, success=(warnflag == 0), message=msg, x=xk, nit=k) DCNL DCSP if retall: DCNL DCSP  DCSP result['allvecs'] = allvecs DCNL DCSP return result
 DCSP action = cmd_action(parent, cmds.LaunchTerminal, (lambda : utils.select_directory(fn())), hotkeys.TERMINAL) DCNL DCSP return action
 DCSP ret = {'name': DomainName, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP if (ElasticsearchClusterConfig is None): DCNL DCSP  DCSP ElasticsearchClusterConfig = {'DedicatedMasterEnabled': False, 'InstanceCount': 1, 'InstanceType': 'm3.medium.elasticsearch', 'ZoneAwarenessEnabled': False} DCNL DCSP if (EBSOptions is None): DCNL DCSP  DCSP EBSOptions = {'EBSEnabled': False} DCNL DCSP if (SnapshotOptions is None): DCNL DCSP  DCSP SnapshotOptions = {'AutomatedSnapshotStartHour': 0} DCNL DCSP if (AdvancedOptions is None): DCNL DCSP  DCSP AdvancedOptions = {'rest.action.multi.allow_explicit_index': 'true'} DCNL DCSP if (Tags is None): DCNL DCSP  DCSP Tags = {} DCNL DCSP if ((AccessPolicies is not None) and isinstance(AccessPolicies, six.string_types)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP AccessPolicies = json.loads(AccessPolicies) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP domain: DCSP {0}.'.format(e.message) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP r = __salt__['boto_elasticsearch_domain.exists'](DomainName=DomainName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP domain: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP if (not r.get('exists')): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Domain DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP created.'.format(DomainName) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP r = __salt__['boto_elasticsearch_domain.create'](DomainName=DomainName, ElasticsearchClusterConfig=ElasticsearchClusterConfig, EBSOptions=EBSOptions, AccessPolicies=AccessPolicies, SnapshotOptions=SnapshotOptions, AdvancedOptions=AdvancedOptions, ElasticsearchVersion=str(ElasticsearchVersion), region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if (not r.get('created')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP domain: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _describe = __salt__['boto_elasticsearch_domain.describe'](DomainName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP ret['changes']['old'] = {'domain': None} DCNL DCSP  DCSP ret['changes']['new'] = _describe DCNL DCSP  DCSP ret['comment'] = 'Domain DCSP {0} DCSP created.'.format(DomainName) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Domain DCSP {0} DCSP is DCSP present.'.format(DomainName)]) DCNL DCSP ret['changes'] = {} DCNL DCSP _status = __salt__['boto_elasticsearch_domain.status'](DomainName=DomainName, region=region, key=key, keyid=keyid, profile=profile)['domain'] DCNL DCSP if (_status.get('ElasticsearchVersion') != str(ElasticsearchVersion)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP update DCSP domain: DCSP version DCSP cannot DCSP be DCSP modified DCSP from DCSP {0} DCSP to DCSP {1}.'.format(_status.get('ElasticsearchVersion'), str(ElasticsearchVersion)) DCNL DCSP  DCSP return ret DCNL DCSP _describe = __salt__['boto_elasticsearch_domain.describe'](DomainName=DomainName, region=region, key=key, keyid=keyid, profile=profile)['domain'] DCNL DCSP _describe['AccessPolicies'] = json.loads(_describe['AccessPolicies']) DCNL DCSP if (not _describe.get('EBSOptions', {}).get('EBSEnabled')): DCNL DCSP  DCSP opts = _describe.get('EBSOptions', {}) DCNL DCSP  DCSP opts.pop('VolumeSize', None) DCNL DCSP  DCSP opts.pop('VolumeType', None) DCNL DCSP comm_args = {} DCNL DCSP need_update = False DCNL DCSP es_opts = {'ElasticsearchClusterConfig': ElasticsearchClusterConfig, 'EBSOptions': EBSOptions, 'AccessPolicies': AccessPolicies, 'SnapshotOptions': SnapshotOptions, 'AdvancedOptions': AdvancedOptions} DCNL DCSP for (k, v) in six.iteritems(es_opts): DCNL DCSP  DCSP if (not _compare_json(v, _describe[k])): DCNL DCSP  DCSP  DCSP need_update = True DCNL DCSP  DCSP  DCSP comm_args[k] = v DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('new', {})[k] = v DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('old', {})[k] = _describe[k] DCNL DCSP if need_update: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'Domain DCSP {0} DCSP set DCSP to DCSP be DCSP modified.'.format(DomainName) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Domain DCSP to DCSP be DCSP modified']) DCNL DCSP  DCSP r = __salt__['boto_elasticsearch_domain.update'](DomainName=DomainName, region=region, key=key, keyid=keyid, profile=profile, **comm_args) DCNL DCSP  DCSP if (not r.get('updated')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP update DCSP domain: DCSP {0}.'.format(r['error']) DCNL DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return ret
 DCSP if (name == ROOT_ENV_NAME): DCNL DCSP  DCSP return ctx.root_dir DCNL DCSP for envs_dir in chain((ctx.envs_dirs + (os.getcwd(),))): DCNL DCSP  DCSP prefix = join(envs_dir, name) DCNL DCSP  DCSP if isdir(prefix): DCNL DCSP  DCSP  DCSP return prefix DCNL DCSP raise CondaEnvironmentNotFoundError(name)
 DCSP if (not line.strip()): DCNL DCSP  DCSP raise exceptions.MpdNoCommand(u'No DCSP command DCSP given') DCNL DCSP match = WORD_RE.match(line) DCNL DCSP if (not match): DCNL DCSP  DCSP raise exceptions.MpdUnknownError(u'Invalid DCSP word DCSP character') DCNL DCSP (whitespace, command, remainder) = match.groups() DCNL DCSP if whitespace: DCNL DCSP  DCSP raise exceptions.MpdUnknownError(u'Letter DCSP expected') DCNL DCSP result = [command] DCNL DCSP while remainder: DCNL DCSP  DCSP match = PARAM_RE.match(remainder) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP msg = _determine_error_message(remainder) DCNL DCSP  DCSP  DCSP raise exceptions.MpdArgError(msg, command=command) DCNL DCSP  DCSP (unquoted, quoted, remainder) = match.groups() DCNL DCSP  DCSP result.append((unquoted or UNESCAPE_RE.sub(u'\\g<1>', quoted))) DCNL DCSP return result
 DCSP def flatten_tokens(tokens): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for token in tokens: DCNL DCSP  DCSP  DCSP if isinstance(token, str): DCNL DCSP  DCSP  DCSP  DCSP for char in token: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.append(char) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert isinstance(token, float) DCNL DCSP  DCSP  DCSP  DCSP l.append(token) DCNL DCSP  DCSP return l DCNL DCSP seq1 = flatten_tokens(tokenize_by_number(str1)) DCNL DCSP seq2 = flatten_tokens(tokenize_by_number(str2)) DCNL DCSP l = min(len(seq1), len(seq2)) DCNL DCSP i = 0 DCNL DCSP while (i < l): DCNL DCSP  DCSP if (isinstance(seq1[i], float) and isinstance(seq2[i], string_types)): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP elif (isinstance(seq1[i], string_types) and isinstance(seq2[i], float)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP elif (seq1[i] < seq2[i]): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP elif (seq1[i] > seq2[i]): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP i += 1 DCNL DCSP if (len(seq1) < len(seq2)): DCNL DCSP  DCSP return (-1) DCNL DCSP elif (len(seq1) > len(seq2)): DCNL DCSP  DCSP return 1 DCNL DCSP return 0
 DCSP service_obj = bus_get_object(bus, SS_PATH) DCNL DCSP service_props_iface = dbus.Interface(service_obj, dbus.PROPERTIES_IFACE) DCNL DCSP for collection_path in service_props_iface.Get(SERVICE_IFACE, 'Collections', signature='ss'): DCNL DCSP  DCSP (yield Collection(bus, collection_path))
 DCSP def err(msg): DCNL DCSP  DCSP formatted = ('kvToSeq DCSP warning: DCSP %s: DCSP %r' % (msg, data)) DCNL DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP raise KVFormError(formatted) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP oidutil.log(formatted) DCNL DCSP lines = data.split('\n') DCNL DCSP if lines[(-1)]: DCNL DCSP  DCSP err('Does DCSP not DCSP end DCSP in DCSP a DCSP newline') DCNL DCSP else: DCNL DCSP  DCSP del lines[(-1)] DCNL DCSP pairs = [] DCNL DCSP line_num = 0 DCNL DCSP for line in lines: DCNL DCSP  DCSP line_num += 1 DCNL DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP pair = line.split(':', 1) DCNL DCSP  DCSP if (len(pair) == 2): DCNL DCSP  DCSP  DCSP (k, v) = pair DCNL DCSP  DCSP  DCSP k_s = k.strip() DCNL DCSP  DCSP  DCSP if (k_s != k): DCNL DCSP  DCSP  DCSP  DCSP fmt = 'In DCSP line DCSP %d, DCSP ignoring DCSP leading DCSP or DCSP trailing DCSP whitespace DCSP in DCSP key DCSP %r' DCNL DCSP  DCSP  DCSP  DCSP err((fmt % (line_num, k))) DCNL DCSP  DCSP  DCSP if (not k_s): DCNL DCSP  DCSP  DCSP  DCSP err(('In DCSP line DCSP %d, DCSP got DCSP empty DCSP key' % (line_num,))) DCNL DCSP  DCSP  DCSP v_s = v.strip() DCNL DCSP  DCSP  DCSP if (v_s != v): DCNL DCSP  DCSP  DCSP  DCSP fmt = 'In DCSP line DCSP %d, DCSP ignoring DCSP leading DCSP or DCSP trailing DCSP whitespace DCSP in DCSP value DCSP %r' DCNL DCSP  DCSP  DCSP  DCSP err((fmt % (line_num, v))) DCNL DCSP  DCSP  DCSP pairs.append((k_s.decode('UTF8'), v_s.decode('UTF8'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err(('Line DCSP %d DCSP does DCSP not DCSP contain DCSP a DCSP colon' % line_num)) DCNL DCSP return pairs
 DCSP return (SIGNATURE in source)
 DCSP pass
 DCSP row_count = 0 DCNL DCSP for row in csv.reader(open(file_name)): DCNL DCSP  DCSP row_count += 1 DCNL DCSP if (row_limit > row_count): DCNL DCSP  DCSP parser.error("The DCSP 'row_count' DCSP of DCSP '{}' DCSP is DCSP > DCSP the DCSP number DCSP of DCSP rows DCSP in DCSP '{}'!".format(row_limit, file_name)) DCNL DCSP  DCSP sys.exit(1)
 DCSP return parse_object_id('certificates/issuers', id)
 DCSP return int(qsub_out.split()[2])
 DCSP raise falcon.HTTPNotFound()
 DCSP if isinstance(txt, six.string_types): DCNL DCSP  DCSP return txt.replace('\x1b', '?') DCNL DCSP else: DCNL DCSP  DCSP return txt
 DCSP var_use_map = {} DCNL DCSP var_def_map = {} DCNL DCSP for (offset, ir_block) in blocks.items(): DCNL DCSP  DCSP var_use_map[offset] = use_set = set() DCNL DCSP  DCSP var_def_map[offset] = def_set = set() DCNL DCSP  DCSP for stmt in ir_block.body: DCNL DCSP  DCSP  DCSP if isinstance(stmt, ir.Assign): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(stmt.value, ir.Inst): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = set((var.name for var in stmt.value.list_vars())) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(stmt.value, ir.Var): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = set([stmt.value.name]) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(stmt.value, (ir.Arg, ir.Const, ir.Global, ir.FreeVar)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = () DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise AssertionError('unreachable', type(stmt.value)) DCNL DCSP  DCSP  DCSP  DCSP if (stmt.target.name not in rhs_set): DCNL DCSP  DCSP  DCSP  DCSP  DCSP def_set.add(stmt.target.name) DCNL DCSP  DCSP  DCSP for var in stmt.list_vars(): DCNL DCSP  DCSP  DCSP  DCSP if (var.name not in def_set): DCNL DCSP  DCSP  DCSP  DCSP  DCSP use_set.add(var.name) DCNL DCSP return _use_defs_result(usemap=var_use_map, defmap=var_def_map)
 DCSP UserModel = get_user_model() DCNL DCSP assert ((uidb64 is not None) and (token is not None)) DCNL DCSP if (post_reset_redirect is None): DCNL DCSP  DCSP post_reset_redirect = reverse('password_reset_complete') DCNL DCSP else: DCNL DCSP  DCSP post_reset_redirect = resolve_url(post_reset_redirect) DCNL DCSP try: DCNL DCSP  DCSP uid = urlsafe_base64_decode(uidb64) DCNL DCSP  DCSP user = UserModel._default_manager.get(pk=uid) DCNL DCSP except (TypeError, ValueError, OverflowError, UserModel.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) and token_generator.check_token(user, token)): DCNL DCSP  DCSP validlink = True DCNL DCSP  DCSP if (request.method == 'POST'): DCNL DCSP  DCSP  DCSP form = set_password_form(user, request.POST) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(post_reset_redirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_password_form(None) DCNL DCSP else: DCNL DCSP  DCSP validlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'validlink': validlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.update(extra_context) DCNL DCSP return TemplateResponse(request, template_name, context, current_app=current_app)
 DCSP try: DCNL DCSP  DCSP _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS) DCNL DCSP  DCSP user_rights_list = [user_right] DCNL DCSP  DCSP _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.error('Error DCSP attempting DCSP to DCSP delete DCSP account DCSP right, DCSP exception DCSP was DCSP {0}'.format(e)) DCNL DCSP  DCSP return False
 DCSP columns = [c.name for c in model.__table__.columns] DCNL DCSP return dict(((k, v) for (k, v) in six.iteritems(data) if ((k in columns) or isinstance(getattr(model, k, None), associationproxy.AssociationProxy))))
 DCSP request['user_id'] = user_id DCNL DCSP (yield Activity.VerifyActivityId(client, user_id, device_id, request['activity']['activity_id'])) DCNL DCSP num_photos = 0 DCNL DCSP for ep_dict in request['episodes']: DCNL DCSP  DCSP (yield Episode.VerifyEpisodeId(client, user_id, device_id, ep_dict['new_episode_id'])) DCNL DCSP  DCSP num_photos += len(ep_dict['photo_ids']) DCNL DCSP (yield gen.Task(Operation.CreateAndExecute, client, user_id, device_id, 'ShareExistingOperation.Execute', request)) DCNL DCSP logging.info(('SHARE DCSP EXISTING: DCSP user: DCSP %d, DCSP device: DCSP %d, DCSP viewpoint: DCSP %s, DCSP %d DCSP episodes, DCSP %d DCSP photos' % (user_id, device_id, request['viewpoint_id'], len(request['episodes']), num_photos))) DCNL DCSP raise gen.Return({})
 DCSP global DATA DCNL DCSP resource_type_values = copy.deepcopy(values) DCNL DCSP resource_type_name = resource_type_values['name'] DCNL DCSP allowed_attrubites = ['name', 'protected'] DCNL DCSP for resource_type in DATA['metadef_resource_types']: DCNL DCSP  DCSP if (resource_type['name'] == resource_type_name): DCNL DCSP  DCSP  DCSP raise exception.Duplicate() DCNL DCSP incorrect_keys = (set(resource_type_values.keys()) - set(allowed_attrubites)) DCNL DCSP if incorrect_keys: DCNL DCSP  DCSP raise exception.Invalid(('The DCSP keys DCSP %s DCSP are DCSP not DCSP valid' % str(incorrect_keys))) DCNL DCSP resource_type = _format_resource_type(resource_type_values) DCNL DCSP DATA['metadef_resource_types'].append(resource_type) DCNL DCSP return resource_type
 DCSP if (get_configured_provider() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_dependencies() is False): DCNL DCSP  DCSP return False DCNL DCSP return __virtualname__
 DCSP (output, pub) = publish_programmatically(source_class=io.StringInput, source=source, source_path=source_path, destination_class=io.StringOutput, destination=None, destination_path=destination_path, reader=reader, reader_name=reader_name, parser=parser, parser_name=parser_name, writer=writer, writer_name=writer_name, settings=settings, settings_spec=settings_spec, settings_overrides=settings_overrides, config_section=config_section, enable_exit_status=enable_exit_status) DCNL DCSP return output
 DCSP @functools.wraps(f) DCNL DCSP def NewFunction(self, *args, **kw): DCNL DCSP  DCSP with self.lock: DCNL DCSP  DCSP  DCSP return f(self, *args, **kw) DCNL DCSP return NewFunction
 DCSP if (opts['root_dir'] is None): DCNL DCSP  DCSP root_dir = salt.syspaths.ROOT_DIR DCNL DCSP else: DCNL DCSP  DCSP root_dir = opts['root_dir'] DCNL DCSP config_dir = salt.syspaths.CONFIG_DIR DCNL DCSP if config_dir.startswith(salt.syspaths.ROOT_DIR): DCNL DCSP  DCSP config_dir = config_dir.split(salt.syspaths.ROOT_DIR, 1)[(-1)] DCNL DCSP id_cache = os.path.join(root_dir, config_dir.lstrip(os.path.sep), 'minion_id') DCNL DCSP if opts.get('minion_id_caching', True): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with salt.utils.fopen(id_cache) as idf: DCNL DCSP  DCSP  DCSP  DCSP name = idf.readline().strip() DCNL DCSP  DCSP  DCSP  DCSP bname = salt.utils.to_bytes(name) DCNL DCSP  DCSP  DCSP  DCSP if bname.startswith(codecs.BOM): DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = salt.utils.to_str(bname.replace(codecs.BOM, '', 1)) DCNL DCSP  DCSP  DCSP if (name and (name != 'localhost')): DCNL DCSP  DCSP  DCSP  DCSP log.debug('Using DCSP cached DCSP minion DCSP ID DCSP from DCSP {0}: DCSP {1}'.format(id_cache, name)) DCNL DCSP  DCSP  DCSP  DCSP return (name, False) DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (('__role' in opts) and (opts.get('__role') == 'minion')): DCNL DCSP  DCSP log.debug('Guessing DCSP ID. DCSP The DCSP id DCSP can DCSP be DCSP explicitly DCSP set DCSP in DCSP {0}'.format(os.path.join(salt.syspaths.CONFIG_DIR, 'minion'))) DCNL DCSP newid = salt.utils.network.generate_minion_id() DCNL DCSP if (('__role' in opts) and (opts.get('__role') == 'minion')): DCNL DCSP  DCSP log.debug('Found DCSP minion DCSP id DCSP from DCSP generate_minion_id(): DCSP {0}'.format(newid)) DCNL DCSP if (cache_minion_id and opts.get('minion_id_caching', True)): DCNL DCSP  DCSP _cache_id(newid, id_cache) DCNL DCSP is_ipv4 = salt.utils.network.is_ipv4(newid) DCNL DCSP return (newid, is_ipv4)
 DCSP return ((r / pi) * 180)
 DCSP match = re.search('"(.*)"', response) DCNL DCSP if match: DCNL DCSP  DCSP return match.groups()[0] DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP loss = tf.nn.seq2seq.sequence_loss_by_example([logits], [tf.reshape(target_seqs, [(-1)])], [tf.ones([(batch_size * num_steps)])]) DCNL DCSP cost = (tf.reduce_sum(loss) / batch_size) DCNL DCSP return cost
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kwds): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwds) DCNL DCSP return wrapper
 DCSP x = ColorArray(['r', 'g', 'b']) DCNL DCSP assert_array_equal(x.rgb, np.eye(3)) DCNL DCSP assert isinstance(x[0], ColorArray) DCNL DCSP assert isinstance(x[:], ColorArray) DCNL DCSP assert_array_equal(x.rgba[:], x[:].rgba) DCNL DCSP assert_array_equal(x.rgba[0], x[0].rgba.squeeze()) DCNL DCSP assert_array_equal(x.rgba[1:3], x[1:3].rgba) DCNL DCSP assert_raises(ValueError, x.__getitem__, (0, 1)) DCNL DCSP x[0] = 0 DCNL DCSP assert_array_equal(x.rgba[0, :], np.zeros(4)) DCNL DCSP assert_array_equal(x.rgba, x[:].rgba) DCNL DCSP x[1] = 1 DCNL DCSP assert_array_equal(x[1].rgba, np.ones((1, 4))) DCNL DCSP x[:] = 0.5 DCNL DCSP assert_array_equal(x.rgba, (0.5 * np.ones((3, 4)))) DCNL DCSP assert_raises(ValueError, x.__setitem__, (0, 1), 0) DCNL DCSP x = ColorArray(color_space='hsv', color=[(0, 0, 1), (0, 0, 0.5), (0, 0, 0)]) DCNL DCSP assert_array_equal(x.rgba[0], [1, 1, 1, 1]) DCNL DCSP assert_array_equal(x.rgba[1], [0.5, 0.5, 0.5, 1]) DCNL DCSP assert_array_equal(x.rgba[2], [0, 0, 0, 1]) DCNL DCSP x = ColorArray(color_space='hsv') DCNL DCSP assert_array_equal(x.rgba[0], [0, 0, 0, 1])
 DCSP context = SSLContext((ssl_version or ssl.PROTOCOL_SSLv23)) DCNL DCSP cert_reqs = (ssl.CERT_REQUIRED if (cert_reqs is None) else cert_reqs) DCNL DCSP if (options is None): DCNL DCSP  DCSP options = 0 DCNL DCSP  DCSP options |= OP_NO_SSLv2 DCNL DCSP  DCSP options |= OP_NO_SSLv3 DCNL DCSP  DCSP options |= OP_NO_COMPRESSION DCNL DCSP context.options |= options DCNL DCSP if getattr(context, 'supports_set_ciphers', True): DCNL DCSP  DCSP context.set_ciphers((ciphers or DEFAULT_CIPHERS)) DCNL DCSP context.verify_mode = cert_reqs DCNL DCSP if (getattr(context, 'check_hostname', None) is not None): DCNL DCSP  DCSP context.check_hostname = False DCNL DCSP return context
 DCSP for info in infos: DCNL DCSP  DCSP info._check_consistency() DCNL DCSP if (force_update_to_first is True): DCNL DCSP  DCSP infos = deepcopy(infos) DCNL DCSP  DCSP _force_update_info(infos[0], infos[1:]) DCNL DCSP info = Info() DCNL DCSP info['chs'] = [] DCNL DCSP for this_info in infos: DCNL DCSP  DCSP info['chs'].extend(this_info['chs']) DCNL DCSP info._update_redundant() DCNL DCSP duplicates = set([ch for ch in info['ch_names'] if (info['ch_names'].count(ch) > 1)]) DCNL DCSP if (len(duplicates) > 0): DCNL DCSP  DCSP msg = ('The DCSP following DCSP channels DCSP are DCSP present DCSP in DCSP more DCSP than DCSP one DCSP input DCSP measurement DCSP info DCSP objects: DCSP %s' % list(duplicates)) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP transforms = ['ctf_head_t', 'dev_head_t', 'dev_ctf_t'] DCNL DCSP for trans_name in transforms: DCNL DCSP  DCSP trans = [i[trans_name] for i in infos if i[trans_name]] DCNL DCSP  DCSP if (len(trans) == 0): DCNL DCSP  DCSP  DCSP info[trans_name] = None DCNL DCSP  DCSP elif (len(trans) == 1): DCNL DCSP  DCSP  DCSP info[trans_name] = trans[0] DCNL DCSP  DCSP elif all(((np.all((trans[0]['trans'] == x['trans'])) and (trans[0]['from'] == x['from']) and (trans[0]['to'] == x['to'])) for x in trans[1:])): DCNL DCSP  DCSP  DCSP info[trans_name] = trans[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('Measurement DCSP infos DCSP provide DCSP mutually DCSP inconsistent DCSP %s' % trans_name) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP kit_sys_ids = [i['kit_system_id'] for i in infos if i['kit_system_id']] DCNL DCSP if (len(kit_sys_ids) == 0): DCNL DCSP  DCSP info['kit_system_id'] = None DCNL DCSP elif (len(set(kit_sys_ids)) == 1): DCNL DCSP  DCSP info['kit_system_id'] = kit_sys_ids[0] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Trying DCSP to DCSP merge DCSP channels DCSP from DCSP different DCSP KIT DCSP systems') DCNL DCSP other_fields = ['acq_pars', 'acq_stim', 'bads', 'buffer_size_sec', 'comps', 'custom_ref_applied', 'description', 'dig', 'experimenter', 'file_id', 'highpass', 'hpi_results', 'hpi_meas', 'hpi_subsystem', 'events', 'line_freq', 'lowpass', 'meas_date', 'meas_id', 'proj_id', 'proj_name', 'projs', 'sfreq', 'subject_info', 'sfreq', 'xplotter_layout'] DCNL DCSP for k in other_fields: DCNL DCSP  DCSP info[k] = _merge_dict_values(infos, k) DCNL DCSP info._check_consistency() DCNL DCSP return info
 DCSP block_url = '' DCNL DCSP if (len(xblock_type_set) > 0): DCNL DCSP  DCSP block_url += '&all_blocks=true&block_counts=' DCNL DCSP  DCSP for (index, block_type) in enumerate(xblock_type_set): DCNL DCSP  DCSP  DCSP block_url += block_type DCNL DCSP  DCSP  DCSP if (index < (len(xblock_type_set) - 1)): DCNL DCSP  DCSP  DCSP  DCSP block_url += ',' DCNL DCSP return block_url
 DCSP from frappe.utils.nestedset import get_root_of DCNL DCSP country = frappe.db.get_default(u'country') DCNL DCSP root_territory = get_root_of(u'Territory') DCNL DCSP for name in (country, _(u'Rest DCSP Of DCSP The DCSP World')): DCNL DCSP  DCSP if (name and (not frappe.db.exists(u'Territory', name))): DCNL DCSP  DCSP  DCSP frappe.get_doc({u'doctype': u'Territory', u'territory_name': name.replace(u"'", u''), u'parent_territory': root_territory, u'is_group': u'No'}).insert()
 DCSP shortversion = get_sympy_short_version() DCNL DCSP htmltable = table() DCNL DCSP out = 'See DCSP https://github.com/sympy/sympy/wiki/release-notes-for-{shortversion} DCSP for DCSP the DCSP release DCSP notes.\n\n{htmltable}\n\n**Note**: DCSP Do DCSP not DCSP download DCSP the DCSP **Source DCSP code DCSP (zip)** DCSP or DCSP the DCSP **Source DCSP code DCSP (tar.gz)**\nfiles DCSP below.\n' DCNL DCSP out = out.format(shortversion=shortversion, htmltable=htmltable) DCNL DCSP print(blue('Here DCSP are DCSP the DCSP release DCSP notes DCSP to DCSP copy DCSP into DCSP the DCSP GitHub DCSP release DCSP Markdown DCSP form:', bold=True)) DCNL DCSP print() DCNL DCSP print(out) DCNL DCSP return out
 DCSP module.custom_desired_config = {'addr_family': None, 'auto': True, 'config': {}, 'name': module.params.get('name')} DCNL DCSP build_addr_method(module) DCNL DCSP build_address(module) DCNL DCSP build_vids(module) DCNL DCSP build_pvid(module) DCNL DCSP build_speed(module) DCNL DCSP build_alias_name(module) DCNL DCSP build_vrr(module) DCNL DCSP for _attr in ['mtu', 'mstpctl_portnetwork', 'mstpctl_portadminedge', 'mstpctl_bpduguard', 'clagd_enable', 'clagd_priority', 'clagd_peer_ip', 'clagd_sys_mac', 'clagd_args']: DCNL DCSP  DCSP build_generic_attr(module, _attr)
 DCSP if (type(id_token) == bytes): DCNL DCSP  DCSP segments = id_token.split('.') DCNL DCSP else: DCNL DCSP  DCSP segments = id_token.split(u'.') DCNL DCSP if (len(segments) != 3): DCNL DCSP  DCSP raise VerifyJwtTokenError('Wrong DCSP number DCSP of DCSP segments DCSP in DCSP token: DCSP {0}'.format(id_token)) DCNL DCSP return json.loads(_helpers._from_bytes(_helpers._urlsafe_b64decode(segments[1])))
 DCSP log_root = logging.getLogger(None).logger DCNL DCSP to_replace = [h for h in log_root.handlers if isinstance(h, handlers.WatchedFileHandler)] DCNL DCSP for handler in to_replace: DCNL DCSP  DCSP new_handler = std_logging.FileHandler(handler.baseFilename, mode=handler.mode, encoding=handler.encoding) DCNL DCSP  DCSP log_root.removeHandler(handler) DCNL DCSP  DCSP log_root.addHandler(new_handler)
 DCSP import zlib DCNL DCSP (yield '\x1f\x8b') DCNL DCSP (yield '\x08') DCNL DCSP (yield '\x00') DCNL DCSP (yield struct.pack('<L', (int(time.time()) & 4294967295L))) DCNL DCSP (yield '\x02') DCNL DCSP (yield '\xff') DCNL DCSP crc = zlib.crc32('') DCNL DCSP size = 0 DCNL DCSP zobj = zlib.compressobj(compress_level, zlib.DEFLATED, (- zlib.MAX_WBITS), zlib.DEF_MEM_LEVEL, 0) DCNL DCSP for line in body: DCNL DCSP  DCSP size += len(line) DCNL DCSP  DCSP crc = zlib.crc32(line, crc) DCNL DCSP  DCSP (yield zobj.compress(line)) DCNL DCSP (yield zobj.flush()) DCNL DCSP (yield struct.pack('<L', (crc & 4294967295L))) DCNL DCSP (yield struct.pack('<L', (size & 4294967295L)))
 DCSP answer = [] DCNL DCSP alignment_len = alignment.get_alignment_length() DCNL DCSP rec_count = len(alignment) DCNL DCSP if (rec_count < vertical_threshold): DCNL DCSP  DCSP for record in alignment: DCNL DCSP  DCSP  DCSP answer.append(('%s%s DCSP %s' % (index, str_summary(str(record.seq)), record.id))) DCNL DCSP else: DCNL DCSP  DCSP for i in range(min(5, alignment_len)): DCNL DCSP  DCSP  DCSP answer.append(((index + str_summary(alignment[:, i])) + (' DCSP alignment DCSP column DCSP %i' % i))) DCNL DCSP  DCSP if (alignment_len > 5): DCNL DCSP  DCSP  DCSP i = (alignment_len - 1) DCNL DCSP  DCSP  DCSP answer.append(((index + str_summary(('|' * rec_count))) + ' DCSP ...')) DCNL DCSP  DCSP  DCSP answer.append(((index + str_summary(alignment[:, i])) + (' DCSP alignment DCSP column DCSP %i' % i))) DCNL DCSP return '\n'.join(answer)
 DCSP for (module_name, module_metadata) in REQUIRED_MODULE_METADATA: DCNL DCSP  DCSP if (not (is_imbalanced_dataset_installing and (not module_metadata['required_at_installation']))): DCNL DCSP  DCSP  DCSP _import_module_with_version_check(module_name=module_name, minimum_version=module_metadata['min_version'], install_info=module_metadata.get('install_info'))
 DCSP import pyowm DCNL DCSP longitude = config.get(CONF_LONGITUDE, round(hass.config.longitude, 5)) DCNL DCSP latitude = config.get(CONF_LATITUDE, round(hass.config.latitude, 5)) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP try: DCNL DCSP  DCSP owm = pyowm.OWM(config.get(CONF_API_KEY)) DCNL DCSP except pyowm.exceptions.api_call_error.APICallError: DCNL DCSP  DCSP _LOGGER.error('Error DCSP while DCSP connecting DCSP to DCSP OpenWeatherMap') DCNL DCSP  DCSP return False DCNL DCSP data = WeatherData(owm, latitude, longitude) DCNL DCSP add_devices([OpenWeatherMapWeather(name, data, hass.config.units.temperature_unit)], True)
 DCSP cmd = '{0} DCSP {1} DCSP onerestart'.format(_cmd(jail), name) DCNL DCSP return (not __salt__['cmd.retcode'](cmd, python_shell=False))
 DCSP t = table.Table([['Hello', 'World']], dtype=['S10']) DCNL DCSP out = StringIO() DCNL DCSP ascii.write(t, out, fast_writer=fast_writer) DCNL DCSP assert (out.getvalue().splitlines() == ['col0', 'Hello', 'World'])
 DCSP try: DCNL DCSP  DCSP return _ENCODERS[type(value)](name, value, check_keys, opts) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP marker = getattr(value, '_type_marker', None) DCNL DCSP if (isinstance(marker, int) and (marker in _MARKERS)): DCNL DCSP  DCSP func = _MARKERS[marker] DCNL DCSP  DCSP _ENCODERS[type(value)] = func DCNL DCSP  DCSP return func(name, value, check_keys, opts) DCNL DCSP for base in _ENCODERS: DCNL DCSP  DCSP if isinstance(value, base): DCNL DCSP  DCSP  DCSP func = _ENCODERS[base] DCNL DCSP  DCSP  DCSP _ENCODERS[type(value)] = func DCNL DCSP  DCSP  DCSP return func(name, value, check_keys, opts) DCNL DCSP raise InvalidDocument(('cannot DCSP convert DCSP value DCSP of DCSP type DCSP %s DCSP to DCSP bson' % type(value)))
 DCSP if (derivation == None): DCNL DCSP  DCSP derivation = ExtrudeDerivation(elementNode) DCNL DCSP if (len(euclidean.getConcatenatedList(derivation.target)) == 0): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP extrude DCSP there DCSP are DCSP no DCSP paths.' DCNL DCSP  DCSP print elementNode.attributes DCNL DCSP  DCSP return None DCNL DCSP return getGeometryOutputByLoops(derivation, derivation.target)
 DCSP range_ = ((b - a) - 1) DCNL DCSP bits = size(range_) DCNL DCSP value = getRandomInteger(bits, randfunc) DCNL DCSP while (value > range_): DCNL DCSP  DCSP value = getRandomInteger(bits, randfunc) DCNL DCSP return (a + value)
 DCSP root = _convert_tree(beautiful_soup_tree, makeelement) DCNL DCSP children = root.getchildren() DCNL DCSP for child in children: DCNL DCSP  DCSP root.remove(child) DCNL DCSP return children
 DCSP parser.add_option('--retain_upload_dir', action='store_true', dest='retain_upload_dir', default=False, help='Do DCSP not DCSP delete DCSP temporary DCSP (staging) DCSP directory DCSP used DCSP in DCSP uploading DCSP Java DCSP apps') DCNL DCSP parser.add_option('--no_symlinks', action='store_true', dest='no_symlinks', default=False, help='Do DCSP not DCSP use DCSP symbolic DCSP links DCSP when DCSP making DCSP the DCSP temporary DCSP (staging) DCSP directory DCSP for DCSP uploading DCSP Java DCSP apps') DCNL DCSP parser.add_option('--compile_encoding', action='store', dest='compile_encoding', default='UTF-8', help='Set DCSP the DCSP encoding DCSP to DCSP be DCSP used DCSP when DCSP compiling DCSP Java DCSP source DCSP files DCSP (default DCSP "UTF-8").') DCNL DCSP parser.add_option('--disable_jar_jsps', action='store_false', dest='jar_jsps', default=True, help='Do DCSP not DCSP jar DCSP the DCSP classes DCSP generated DCSP from DCSP JSPs.') DCNL DCSP parser.add_option('--delete_jsps', action='store_true', dest='delete_jsps', default=False, help='Delete DCSP the DCSP JSP DCSP source DCSP files DCSP after DCSP compilation.') DCNL DCSP parser.add_option('--enable_jar_classes', action='store_true', dest='do_jar_classes', default=False, help='Jar DCSP the DCSP WEB-INF/classes DCSP content.') DCNL DCSP parser.add_option('--enable_jar_splitting', action='store_true', dest='do_jar_splitting', default=False, help='Split DCSP large DCSP jar DCSP files DCSP (> DCSP 32M) DCSP into DCSP smaller DCSP fragments.') DCNL DCSP parser.add_option('--jar_splitting_excludes', action='store', dest='jar_splitting_exclude_suffixes', default='', help='When DCSP --enable_jar_splitting DCSP is DCSP specified DCSP and DCSP --jar_splitting_excludes DCSP specifies DCSP a DCSP comma-separated DCSP list DCSP of DCSP suffixes, DCSP a DCSP file DCSP in DCSP a DCSP jar DCSP whose DCSP name DCSP ends DCSP with DCSP one DCSP of DCSP the DCSP suffixes DCSP will DCSP not DCSP be DCSP included DCSP in DCSP the DCSP split DCSP jar DCSP fragments.')
 DCSP for (toggle, definition) in six.iteritems(toggles): DCNL DCSP  DCSP if (definition['value'] is not None): DCNL DCSP  DCSP  DCSP if (((definition['value'] is True) or (definition['value'] == 'yes')) and (definition['type'] == 'yes_no')): DCNL DCSP  DCSP  DCSP  DCSP payload[toggle] = 'yes' DCNL DCSP  DCSP  DCSP elif (((definition['value'] is False) or (definition['value'] == 'no')) and (definition['type'] == 'yes_no')): DCNL DCSP  DCSP  DCSP  DCSP payload[toggle] = 'no' DCNL DCSP  DCSP  DCSP if (((definition['value'] is True) or (definition['value'] == 'yes')) and (definition['type'] == 'true_false')): DCNL DCSP  DCSP  DCSP  DCSP payload[toggle] = True DCNL DCSP  DCSP  DCSP elif (((definition['value'] is False) or (definition['value'] == 'no')) and (definition['type'] == 'true_false')): DCNL DCSP  DCSP  DCSP  DCSP payload[toggle] = False DCNL DCSP return payload
 DCSP if (fig is None): DCNL DCSP  DCSP plt = _import_mpl() DCNL DCSP  DCSP fig = plt.figure(figsize=figsize) DCNL DCSP return fig
 DCSP if anon: DCNL DCSP  DCSP user = None DCNL DCSP else: DCNL DCSP  DCSP user = {u'name': version.creator.fullname, u'url': version.creator.url} DCNL DCSP return {u'user': user, u'index': (index + 1), u'date': version.date_created.isoformat(), u'downloads': record.get_download_count(version=index), u'md5': version.metadata.get(u'md5'), u'sha256': version.metadata.get(u'sha256')}
 DCSP bits = token.contents.split('"') DCNL DCSP if (len(bits) != 3): DCNL DCSP  DCSP raise TemplateSyntaxError("'now' DCSP statement DCSP takes DCSP one DCSP argument") DCNL DCSP format_string = bits[1] DCNL DCSP return NowNode(format_string)
 DCSP for (ind, element) in enumerate(value): DCNL DCSP  DCSP if (not (isinstance(element, basestring) or isinstance(element, datetime.date) or isinstance(element, datetime.datetime) or isinstance(element, numbers.Number))): DCNL DCSP  DCSP  DCSP raise ValueError(('All DCSP values DCSP of DCSP a DCSP multi-valued DCSP field DCSP must DCSP be DCSP numbers, DCSP strings, DCSP date DCSP or DCSP datetime DCSP instances, DCSP The DCSP %dth DCSP value DCSP for DCSP field DCSP %s DCSP has DCSP type DCSP %s.' % (ind, key, type(element))))
 DCSP y = np.linspace(0, 1, 20) DCNL DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y)
 DCSP return struct.unpack('!I', bs)[0]
 DCSP def bruteforcewrap(func, alphabet, length, method, start, databag): DCNL DCSP  DCSP oldloglevel = context.log_level DCNL DCSP  DCSP context.log_level = 'critical' DCNL DCSP  DCSP res = bruteforce(func, alphabet, length, method=method, start=start, databag=databag) DCNL DCSP  DCSP context.log_level = oldloglevel DCNL DCSP  DCSP databag['result'] = res DCNL DCSP if (start == None): DCNL DCSP  DCSP start = (1, 1) DCNL DCSP if (threads == None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP threads = multiprocessing.cpu_count() DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP threads = 1 DCNL DCSP h = log.waitfor('MBruteforcing') DCNL DCSP processes = ([None] * threads) DCNL DCSP shareddata = ([None] * threads) DCNL DCSP (i2, N2) = start DCNL DCSP totalchunks = (threads * N2) DCNL DCSP for i in range(threads): DCNL DCSP  DCSP shareddata[i] = multiprocessing.Manager().dict() DCNL DCSP  DCSP shareddata[i]['result'] = None DCNL DCSP  DCSP shareddata[i]['current_item'] = '' DCNL DCSP  DCSP shareddata[i]['items_done'] = 0 DCNL DCSP  DCSP shareddata[i]['items_total'] = 0 DCNL DCSP  DCSP chunkid = (((i2 - 1) + (i * N2)) + 1) DCNL DCSP  DCSP processes[i] = multiprocessing.Process(target=bruteforcewrap, args=(func, alphabet, length, method, (chunkid, totalchunks), shareddata[i])) DCNL DCSP  DCSP processes[i].start() DCNL DCSP done = False DCNL DCSP while (not done): DCNL DCSP  DCSP current_item_list = ','.join([('"%s"' % x['current_item']) for x in shareddata if (x != None)]) DCNL DCSP  DCSP items_done = sum([x['items_done'] for x in shareddata if (x != None)]) DCNL DCSP  DCSP items_total = sum([x['items_total'] for x in shareddata if (x != None)]) DCNL DCSP  DCSP progress = (((100.0 * items_done) / items_total) if (items_total != 0) else 0.0) DCNL DCSP  DCSP h.status(('Trying DCSP %s DCSP -- DCSP %0.3f%%' % (current_item_list, progress))) DCNL DCSP  DCSP for i in range(threads): DCNL DCSP  DCSP  DCSP if (processes[i] and (processes[i].exitcode != None)): DCNL DCSP  DCSP  DCSP  DCSP res = shareddata[i]['result'] DCNL DCSP  DCSP  DCSP  DCSP processes[i].join() DCNL DCSP  DCSP  DCSP  DCSP processes[i] = None DCNL DCSP  DCSP  DCSP  DCSP if (res != None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in range(threads): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (processes[i] != None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i].terminate() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i].join() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP h.success(('Found DCSP key: DCSP "%s"' % res)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return res DCNL DCSP  DCSP  DCSP  DCSP if all([(x == None) for x in processes]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP time.sleep(0.3) DCNL DCSP h.failure('No DCSP matches DCSP found')
 DCSP (data_dir, data_file) = os.path.split(dataset) DCNL DCSP if ((data_dir == '') and (not os.path.isfile(dataset))): DCNL DCSP  DCSP new_path = os.path.join(os.path.split(__file__)[0], '..', 'data', dataset) DCNL DCSP  DCSP if (os.path.isfile(new_path) or (data_file == default_dataset)): DCNL DCSP  DCSP  DCSP dataset = new_path DCNL DCSP if ((not os.path.isfile(dataset)) and (data_file == default_dataset)): DCNL DCSP  DCSP from six.moves import urllib DCNL DCSP  DCSP print(('Downloading DCSP data DCSP from DCSP %s' % origin)) DCNL DCSP  DCSP urllib.request.urlretrieve(origin, dataset) DCNL DCSP return dataset
 DCSP (raw, events) = _get_data()[:2] DCNL DCSP epochs = Epochs(raw, events, event_id, tmin, tmax) DCNL DCSP assert_raises(RuntimeError, epochs.__hash__) DCNL DCSP epochs = Epochs(raw, events, event_id, tmin, tmax, preload=True) DCNL DCSP assert_equal(hash(epochs), hash(epochs)) DCNL DCSP epochs_2 = Epochs(raw, events, event_id, tmin, tmax, preload=True) DCNL DCSP assert_equal(hash(epochs), hash(epochs_2)) DCNL DCSP assert_true((pickle.dumps(epochs) == pickle.dumps(epochs_2))) DCNL DCSP epochs_2._data[(0, 0, 0)] -= 1 DCNL DCSP assert_not_equal(hash(epochs), hash(epochs_2))
 DCSP length = (4 * count) DCNL DCSP data = file_obj.read(length) DCNL DCSP if (len(data) != length): DCNL DCSP  DCSP raise EOFError(u'Expected DCSP {0} DCSP bytes DCSP but DCSP got DCSP {1} DCSP bytes'.format(length, len(data))) DCNL DCSP res = struct.unpack('<{0}i'.format(count).encode(u'utf-8'), data) DCNL DCSP return res
 DCSP return cache.load_parser(path, (item.change_time - 1))
 DCSP conf = {'bind_host': CONF.bind_host, 'bind_port': CONF.bind_port, 'tcp_keepidle': CONF.cert_file, 'backlog': CONF.backlog, 'key_file': CONF.key_file, 'cert_file': CONF.cert_file} DCNL DCSP return conf
 DCSP return s
 DCSP n = (width - len(s)) DCNL DCSP if (n <= 0): DCNL DCSP  DCSP return s DCNL DCSP return ((' DCSP ' * n) + s)
 DCSP p1 = utils.full_process(s1, force_ascii=force_ascii) DCNL DCSP p2 = utils.full_process(s2, force_ascii=force_ascii) DCNL DCSP if (not utils.validate_string(p1)): DCNL DCSP  DCSP return 0 DCNL DCSP if (not utils.validate_string(p2)): DCNL DCSP  DCSP return 0 DCNL DCSP try_partial = True DCNL DCSP unbase_scale = 0.95 DCNL DCSP partial_scale = 0.9 DCNL DCSP base = ratio(p1, p2) DCNL DCSP len_ratio = (float(max(len(p1), len(p2))) / min(len(p1), len(p2))) DCNL DCSP if (len_ratio < 1.5): DCNL DCSP  DCSP try_partial = False DCNL DCSP if (len_ratio > 8): DCNL DCSP  DCSP partial_scale = 0.6 DCNL DCSP if try_partial: DCNL DCSP  DCSP partial = (partial_ratio(p1, p2) * partial_scale) DCNL DCSP  DCSP ptsor = ((partial_token_sort_ratio(p1, p2, full_process=False) * unbase_scale) * partial_scale) DCNL DCSP  DCSP ptser = ((partial_token_set_ratio(p1, p2, full_process=False) * unbase_scale) * partial_scale) DCNL DCSP  DCSP return utils.intr(max(base, partial, ptsor, ptser)) DCNL DCSP else: DCNL DCSP  DCSP tsor = (token_sort_ratio(p1, p2, full_process=False) * unbase_scale) DCNL DCSP  DCSP tser = (token_set_ratio(p1, p2, full_process=False) * unbase_scale) DCNL DCSP  DCSP return utils.intr(max(base, tsor, tser))
 DCSP client = _get_conn(key=key, keyid=keyid, profile=profile, region=region) DCNL DCSP new_tags = [] DCNL DCSP for (k, v) in tags.iteritems(): DCNL DCSP  DCSP new_tags.append({'Key': k, 'Value': v}) DCNL DCSP client.create_tags(FileSystemId=filesystemid, Tags=new_tags)
 DCSP if (flag in get_flags_from_package_conf(conf, atom)): DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP if pkg_resources.resource_exists('roscreate', tmplf): DCNL DCSP  DCSP f = pkg_resources.resource_stream('roscreate', tmplf) DCNL DCSP  DCSP t = f.read() DCNL DCSP else: DCNL DCSP  DCSP r = rospkg.RosPack() DCNL DCSP  DCSP with open(os.path.join(r.get_path('roscreate'), 'templates', tmplf)) as f: DCNL DCSP  DCSP  DCSP t = f.read() DCNL DCSP try: DCNL DCSP  DCSP t = t.decode('utf-8') DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP return t
 DCSP create_app_context() DCNL DCSP job = ArchiveJob.load(job_pk) DCNL DCSP (src, dst, user) = job.info() DCNL DCSP provider = data['source']['provider'] DCNL DCSP logger.info('Sending DCSP copy DCSP request DCSP for DCSP addon: DCSP {0} DCSP on DCSP node: DCSP {1}'.format(provider, dst._id)) DCNL DCSP res = requests.post(url, data=json.dumps(data)) DCNL DCSP if (res.status_code not in (http.OK, http.CREATED, http.ACCEPTED)): DCNL DCSP  DCSP raise HTTPError(res.status_code)
 DCSP for id in board_ids(): DCNL DCSP  DCSP if _obtain_lock(id): DCNL DCSP  DCSP  DCSP return id DCNL DCSP return (-1)
 DCSP project = get_project(options) DCNL DCSP print 'Creating DCSP instance DCSP {project}/{zone}/{instance}'.format(project=project, zone=get_zone(options), instance=options.instance) DCNL DCSP print ' DCSP  DCSP with DCSP --machine_type={type} DCSP and DCSP --disk_size={disk_size}...'.format(type=options.machine_type, disk_size=options.disk_size) DCNL DCSP google_dev_dir = os.path.join(os.path.dirname(__file__), '../google/dev') DCNL DCSP dev_dir = os.path.dirname(__file__) DCNL DCSP project_dir = os.path.join(dev_dir, '..') DCNL DCSP install_dir = '{dir}/../install'.format(dir=dev_dir) DCNL DCSP startup_command = ['/opt/spinnaker/install/install_spinnaker.sh DCSP --dependencies_only', '/opt/spinnaker/install/install_development.sh'] DCNL DCSP (fd, temp_startup) = tempfile.mkstemp() DCNL DCSP os.write(fd, ';'.join(startup_command)) DCNL DCSP os.close(fd) DCNL DCSP metadata_files = ['startup-script={google_dev_dir}/google_install_loader.py,sh_bootstrap_dev={dev_dir}/bootstrap_dev.sh,sh_install_spinnaker={project_dir}/InstallSpinnaker.sh,sh_install_development={dev_dir}/install_development.sh,startup_command={temp_startup}'.format(google_dev_dir=google_dev_dir, dev_dir=dev_dir, project_dir=project_dir, temp_startup=temp_startup)] DCNL DCSP metadata = ','.join(['startup_loader_files=sh_install_spinnaker+sh_install_development+sh_bootstrap_dev']) DCNL DCSP command = ['gcloud', 'compute', 'instances', 'create', options.instance, '--project', get_project(options), '--zone', get_zone(options), '--machine-type', options.machine_type, '--image', 'ubuntu-14-04', '--scopes', 'compute-rw,storage-rw', '--boot-disk-size={size}'.format(size=options.disk_size), '--boot-disk-type={type}'.format(type=options.disk_type), '--metadata', metadata, '--metadata-from-file={files}'.format(files=','.join(metadata_files))] DCNL DCSP if options.address: DCNL DCSP  DCSP command.extend(['--address', options.address]) DCNL DCSP check_run_quick(' DCSP '.join(command), echo=False)
 DCSP make_or_verify_core_dir(config.config_dir, constants.CONFIG_DIRS_MODE, os.geteuid(), config.strict_permissions) DCNL DCSP make_or_verify_core_dir(config.work_dir, constants.CONFIG_DIRS_MODE, os.geteuid(), config.strict_permissions) DCNL DCSP make_or_verify_core_dir(config.logs_dir, 448, os.geteuid(), config.strict_permissions)
 DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP raise Invalid(_('Names DCSP must DCSP be DCSP strings')) DCNL DCSP if (value in ['new', 'edit', 'search']): DCNL DCSP  DCSP raise Invalid(_('That DCSP name DCSP cannot DCSP be DCSP used')) DCNL DCSP if (len(value) < 2): DCNL DCSP  DCSP raise Invalid((_('Must DCSP be DCSP at DCSP least DCSP %s DCSP characters DCSP long') % 2)) DCNL DCSP if (len(value) > PACKAGE_NAME_MAX_LENGTH): DCNL DCSP  DCSP raise Invalid((_('Name DCSP must DCSP be DCSP a DCSP maximum DCSP of DCSP %i DCSP characters DCSP long') % PACKAGE_NAME_MAX_LENGTH)) DCNL DCSP if (not name_match.match(value)): DCNL DCSP  DCSP raise Invalid(_('Must DCSP be DCSP purely DCSP lowercase DCSP alphanumeric DCSP (ascii) DCSP characters DCSP and DCSP these DCSP symbols: DCSP -_')) DCNL DCSP return value
 DCSP repeats = tensor.as_tensor_variable(repeats) DCNL DCSP if (repeats.ndim > 1): DCNL DCSP  DCSP raise ValueError('The DCSP dimension DCSP of DCSP repeats DCSP should DCSP not DCSP exceed DCSP 1.') DCNL DCSP if ((repeats.ndim == 1) and (not repeats.broadcastable[0])): DCNL DCSP  DCSP return RepeatOp(axis=axis)(x, repeats) DCNL DCSP else: DCNL DCSP  DCSP if (repeats.ndim == 1): DCNL DCSP  DCSP  DCSP repeats = repeats[0] DCNL DCSP  DCSP if (x.dtype == 'uint64'): DCNL DCSP  DCSP  DCSP raise TypeError("theano.tensor.repeat DCSP don't DCSP support DCSP dtype DCSP uint64") DCNL DCSP  DCSP if (axis is None): DCNL DCSP  DCSP  DCSP axis = 0 DCNL DCSP  DCSP  DCSP x = x.flatten() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (axis >= x.ndim): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Axis DCSP should DCSP not DCSP exceed DCSP x.ndim-1.') DCNL DCSP  DCSP  DCSP if (axis < 0): DCNL DCSP  DCSP  DCSP  DCSP axis = (x.ndim + axis) DCNL DCSP  DCSP shape = [x.shape[i] for i in xrange(x.ndim)] DCNL DCSP  DCSP shape_ = shape[:] DCNL DCSP  DCSP shape_.insert((axis + 1), repeats) DCNL DCSP  DCSP shape[axis] = (shape[axis] * repeats) DCNL DCSP  DCSP dims_ = list(numpy.arange(x.ndim)) DCNL DCSP  DCSP dims_.insert((axis + 1), 'x') DCNL DCSP  DCSP z = tensor.alloc(x.dimshuffle(*dims_), *shape_).reshape(shape) DCNL DCSP  DCSP return z
 DCSP ((nbins, offset), dim, dtype, (name, inp_gen)) = nbin_offset_dim_dtype_inp DCNL DCSP gpuflag = (check_gpu.get_compute_capability(0) >= 3.0) DCNL DCSP if (gpuflag is False): DCNL DCSP  DCSP raise RuntimeError('Device DCSP does DCSP not DCSP have DCSP CUDA DCSP compute DCSP capability DCSP 3.0 DCSP or DCSP greater') DCNL DCSP (ng, nc) = backend_pair DCNL DCSP ng.set_hist_buffers(nbins, offset) DCNL DCSP nc.set_hist_buffers(nbins, offset) DCNL DCSP np_inp = inp_gen(dim).astype(dtype) DCNL DCSP np_hist = ref_hist(np_inp, nbins=nbins, offset=offset) DCNL DCSP for be in [ng, nc]: DCNL DCSP  DCSP be_inp = be.array(np_inp, dtype=dtype) DCNL DCSP  DCSP be_hist = be_inp.hist(name) DCNL DCSP  DCSP assert tensors_allclose(np_hist, be_hist)
 DCSP picks_list = _picks_by_type(info) DCNL DCSP scalings = _handle_default('scalings_cov_rank', scalings) DCNL DCSP _apply_scaling_cov(data, picks_list, scalings) DCNL DCSP if (data.shape[1] < data.shape[0]): DCNL DCSP  DCSP ValueError("You've DCSP got DCSP fewer DCSP samples DCSP than DCSP channels, DCSP your DCSP rank DCSP estimate DCSP might DCSP be DCSP inaccurate.") DCNL DCSP out = estimate_rank(data, tol=tol, norm=False, return_singular=return_singular) DCNL DCSP rank = (out[0] if isinstance(out, tuple) else out) DCNL DCSP ch_type = ' DCSP + DCSP '.join(list(zip(*picks_list))[0]) DCNL DCSP logger.info(('estimated DCSP rank DCSP (%s): DCSP %d' % (ch_type, rank))) DCNL DCSP _undo_scaling_cov(data, picks_list, scalings) DCNL DCSP return out
 DCSP if getattr(x, 'is_Matrix', False): DCNL DCSP  DCSP return x.as_mutable() DCNL DCSP elif isinstance(x, Basic): DCNL DCSP  DCSP return x DCNL DCSP elif hasattr(x, '__array__'): DCNL DCSP  DCSP a = x.__array__() DCNL DCSP  DCSP if (len(a.shape) == 0): DCNL DCSP  DCSP  DCSP return sympify(a) DCNL DCSP  DCSP return Matrix(x) DCNL DCSP return x
 DCSP if (value is None): DCNL DCSP  DCSP value = '' DCNL DCSP lst = __salt__['cron.list_tab'](user) DCNL DCSP for env in lst['env']: DCNL DCSP  DCSP if (name == env['name']): DCNL DCSP  DCSP  DCSP if (value != env['value']): DCNL DCSP  DCSP  DCSP  DCSP return 'update' DCNL DCSP  DCSP  DCSP return 'present' DCNL DCSP return 'absent'
 DCSP table = ascii.read('t/daophot2.dat', Reader=ascii.Daophot) DCNL DCSP for colname in table.colnames: DCNL DCSP  DCSP mask_value = (colname in ('OTIME', 'MAG', 'MERR', 'XAIRMASS')) DCNL DCSP  DCSP assert np.all((table[colname].mask == mask_value))
 DCSP log.debug('Called DCSP state DCSP to DCSP delete DCSP VPC DCSP peering DCSP connection') DCNL DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': 'Boto DCSP VPC DCSP peering DCSP state'} DCNL DCSP if conn_name: DCNL DCSP  DCSP vpc_ids = __salt__['boto_vpc.describe_vpc_peering_connection'](conn_name, region=region, key=key, keyid=keyid, profile=profile).get('VPC-Peerings', []) DCNL DCSP else: DCNL DCSP  DCSP vpc_ids = [conn_id] DCNL DCSP if (not vpc_ids): DCNL DCSP  DCSP ret['comment'] = 'No DCSP VPC DCSP connection DCSP found, DCSP nothing DCSP to DCSP be DCSP done.' DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP if vpc_ids: DCNL DCSP  DCSP  DCSP ret['comment'] = 'VPC DCSP peering DCSP connection DCSP would DCSP be DCSP deleted' DCNL DCSP  DCSP return ret DCNL DCSP log.debug('Called DCSP module DCSP to DCSP delete DCSP VPC DCSP peering DCSP connection') DCNL DCSP result = __salt__['boto_vpc.delete_vpc_peering_connection'](conn_id=conn_id, conn_name=conn_name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in result): DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP delete DCSP VPC DCSP peering: DCSP {0}'.format(result['error']) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP ret['changes'].update({'old': '', 'new': result['msg']}) DCNL DCSP return ret
 DCSP if (arg is None): DCNL DCSP  DCSP return type(None) DCNL DCSP if isinstance(arg, basestring): DCNL DCSP  DCSP arg = _ForwardRef(arg) DCNL DCSP if ((isinstance(arg, _TypingBase) and (type(arg).__name__ == u'_ClassVar')) or ((not isinstance(arg, (type, _TypingBase))) and (not callable(arg)))): DCNL DCSP  DCSP raise TypeError((msg + (u' DCSP Got DCSP %.100r.' % (arg,)))) DCNL DCSP if (((type(arg).__name__ in (u'_Union', u'_Optional')) and (not getattr(arg, u'__origin__', None))) or (isinstance(arg, TypingMeta) and (_gorg(arg) in (Generic, _Protocol)))): DCNL DCSP  DCSP raise TypeError((u'Plain DCSP %s DCSP is DCSP not DCSP valid DCSP as DCSP type DCSP argument' % arg)) DCNL DCSP return arg
 DCSP y = np.linspace(0, 1, 15) DCNL DCSP iht = InstanceHardnessThreshold(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP iht = InstanceHardnessThreshold(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y)
 DCSP if (UNRAR_TOOL == ALT_TOOL): DCNL DCSP  DCSP return DCNL DCSP if (psw is not None): DCNL DCSP  DCSP cmd.append(('-p' + psw)) DCNL DCSP else: DCNL DCSP  DCSP cmd.append('-p-')
 DCSP return SolidDerivation(elementNode)
 DCSP return LockType()
 DCSP if (min_num is None): DCNL DCSP  DCSP min_num = DEFAULT_MIN_NUM DCNL DCSP if (max_num is None): DCNL DCSP  DCSP max_num = DEFAULT_MAX_NUM DCNL DCSP absolute_max = (max_num + DEFAULT_MAX_NUM) DCNL DCSP attrs = {'form': form, 'extra': extra, 'can_order': can_order, 'can_delete': can_delete, 'min_num': min_num, 'max_num': max_num, 'absolute_max': absolute_max, 'validate_min': validate_min, 'validate_max': validate_max} DCNL DCSP return type((form.__name__ + 'FormSet'), (formset,), attrs)
 DCSP INFO_MSG('onLoggerAppShutDown()')
 DCSP return IMPL.project_get_networks(context, project_id, associate)
 DCSP client = cls(debug_logging=True) DCNL DCSP client.login(**kwargs) DCNL DCSP return client
 DCSP path = _SITES_RELPATH_DB.get((lang, target_lang), None) DCNL DCSP if (path is None): DCNL DCSP  DCSP siteurl = _SITE_DB.get(lang, _MAIN_SITEURL) DCNL DCSP  DCSP target_siteurl = _SITE_DB.get(target_lang, _MAIN_SITEURL) DCNL DCSP  DCSP path = posixpath.relpath(get_site_path(target_siteurl), get_site_path(siteurl)) DCNL DCSP  DCSP _SITES_RELPATH_DB[(lang, target_lang)] = path DCNL DCSP return path
 DCSP spec = vim.vm.ConfigSpec() DCNL DCSP nic_changes = [] DCNL DCSP nic_spec = vim.vm.device.VirtualDeviceSpec() DCNL DCSP nic_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add DCNL DCSP nic_spec.device = vim.vm.device.VirtualE1000() DCNL DCSP nic_spec.device.deviceInfo = vim.Description() DCNL DCSP nic_spec.device.deviceInfo.summary = 'vCenter DCSP API DCSP test' DCNL DCSP nic_spec.device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo() DCNL DCSP nic_spec.device.backing.useAutoDetect = False DCNL DCSP content = si.RetrieveContent() DCNL DCSP nic_spec.device.backing.network = get_obj(content, [vim.Network], network) DCNL DCSP nic_spec.device.backing.deviceName = network DCNL DCSP nic_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo() DCNL DCSP nic_spec.device.connectable.startConnected = True DCNL DCSP nic_spec.device.connectable.startConnected = True DCNL DCSP nic_spec.device.connectable.allowGuestControl = True DCNL DCSP nic_spec.device.connectable.connected = False DCNL DCSP nic_spec.device.connectable.status = 'untried' DCNL DCSP nic_spec.device.wakeOnLanEnabled = True DCNL DCSP nic_spec.device.addressType = 'assigned' DCNL DCSP nic_changes.append(nic_spec) DCNL DCSP spec.deviceChange = nic_changes DCNL DCSP e = vm.ReconfigVM_Task(spec=spec) DCNL DCSP print 'NIC DCSP CARD DCSP ADDED'
 DCSP test_dir = os.path.join(os.path.dirname(__file__), TESTS_DIR) DCNL DCSP return driver.build_tests(test_dir, loader, host=None, intercept=fixture_module.setup_app, fixture_module=fixture_module)
 DCSP return _format_value(val, limit, level)
 DCSP return {'html': {'nbconvert_template': 'basic', 'label': 'Notebook', 'icon': 'book'}, 'slides': {'nbconvert_template': 'slides_reveal', 'label': 'Slides', 'icon': 'gift', 'test': (lambda nb, json: ('"slideshow"' in json))}, 'script': {'label': 'Code', 'icon': 'code', 'content_type': 'text/plain; DCSP charset=UTF-8'}}
 DCSP try: DCNL DCSP  DCSP page = requests.get(u'http://download.flexget.com/latestversion') DCNL DCSP except requests.RequestException: DCNL DCSP  DCSP return DCNL DCSP ver = page.text.strip() DCNL DCSP return ver
 DCSP cmd = '{0} DCSP -E DCSP {1}'.format(__detect_os(), _build_cmd(protocol=protocol, service_address=service_address, scheduler=scheduler)) DCNL DCSP out = __salt__['cmd.run_all'](cmd, python_shell=False) DCNL DCSP if out['retcode']: DCNL DCSP  DCSP ret = out['stderr'].strip() DCNL DCSP else: DCNL DCSP  DCSP ret = True DCNL DCSP return ret
 DCSP if (not keywords): DCNL DCSP  DCSP raise NotThisMethod('no DCSP keywords DCSP at DCSP all, DCSP weird') DCNL DCSP date = keywords.get('date') DCNL DCSP if (date is not None): DCNL DCSP  DCSP date = date.strip().replace(' DCSP ', 'T', 1).replace(' DCSP ', '', 1) DCNL DCSP refnames = keywords['refnames'].strip() DCNL DCSP if refnames.startswith('$Format'): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print('keywords DCSP are DCSP unexpanded, DCSP not DCSP using') DCNL DCSP  DCSP raise NotThisMethod('unexpanded DCSP keywords, DCSP not DCSP a DCSP git-archive DCSP tarball') DCNL DCSP refs = set([r.strip() for r in refnames.strip('()').split(',')]) DCNL DCSP TAG = 'tag: DCSP ' DCNL DCSP tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)]) DCNL DCSP if (not tags): DCNL DCSP  DCSP tags = set([r for r in refs if re.search('\\d', r)]) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print(("discarding DCSP '%s', DCSP no DCSP digits" % ','.join((refs - tags)))) DCNL DCSP if verbose: DCNL DCSP  DCSP print(('likely DCSP tags: DCSP %s' % ','.join(sorted(tags)))) DCNL DCSP for ref in sorted(tags): DCNL DCSP  DCSP if ref.startswith(tag_prefix): DCNL DCSP  DCSP  DCSP r = ref[len(tag_prefix):] DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print(('picking DCSP %s' % r)) DCNL DCSP  DCSP  DCSP return {'version': r, 'full-revisionid': keywords['full'].strip(), 'dirty': False, 'error': None, 'date': date} DCNL DCSP if verbose: DCNL DCSP  DCSP print('no DCSP suitable DCSP tags, DCSP using DCSP unknown DCSP + DCSP full DCSP revision DCSP id') DCNL DCSP return {'version': '0+unknown', 'full-revisionid': keywords['full'].strip(), 'dirty': False, 'error': 'no DCSP suitable DCSP tags', 'date': None}
 DCSP ret = {'name': name, 'result': False, 'changes': {}, 'comment': ''} DCNL DCSP existing = __salt__['cisconso.get_data'](datastore, path) DCNL DCSP if cmp(existing, config): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Config DCSP is DCSP already DCSP set' DCNL DCSP elif (__opts__['test'] is True): DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Config DCSP will DCSP be DCSP added' DCNL DCSP  DCSP diff = _DictDiffer(existing, config) DCNL DCSP  DCSP ret['changes']['new'] = diff.added() DCNL DCSP  DCSP ret['changes']['removed'] = diff.removed() DCNL DCSP  DCSP ret['changes']['changed'] = diff.changed() DCNL DCSP else: DCNL DCSP  DCSP __salt__['cisconso.set_data_value'](datastore, path, config) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Successfully DCSP added DCSP config' DCNL DCSP  DCSP diff = _DictDiffer(existing, config) DCNL DCSP  DCSP ret['changes']['new'] = diff.added() DCNL DCSP  DCSP ret['changes']['removed'] = diff.removed() DCNL DCSP  DCSP ret['changes']['changed'] = diff.changed() DCNL DCSP return ret
 DCSP config_stub.data = {'storage': {'cache-size': 1024}, 'general': {'private-browsing': True}} DCNL DCSP disk_cache = cache.DiskCache(str(tmpdir)) DCNL DCSP url = QUrl('http://www.example.com/') DCNL DCSP assert (disk_cache.data(url) is None)
 DCSP if (not api_key): DCNL DCSP  DCSP return 'This DCSP command DCSP requires DCSP an DCSP API DCSP key DCSP from DCSP wordnik.com.' DCNL DCSP word = sanitize(text) DCNL DCSP url = (API_URL + 'word.json/{}/examples'.format(word)) DCNL DCSP params = {'api_key': api_key, 'limit': 10} DCNL DCSP json = requests.get(url, params=params).json() DCNL DCSP if json: DCNL DCSP  DCSP out = '\x02{}\x02: DCSP '.format(word) DCNL DCSP  DCSP example = random.choice(json['examples']) DCNL DCSP  DCSP out += '{} DCSP '.format(example['text']) DCNL DCSP  DCSP return ' DCSP '.join(out.split()) DCNL DCSP else: DCNL DCSP  DCSP return 'I DCSP could DCSP not DCSP find DCSP any DCSP usage DCSP examples DCSP for DCSP \x02{}\x02.'.format(word)
 DCSP if files: DCNL DCSP  DCSP osname = get_os_name() DCNL DCSP  DCSP opener = _OPENER_BY_OS.get(osname) DCNL DCSP  DCSP if opener: DCNL DCSP  DCSP  DCSP opener(files) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise OpenError((u'Open DCSP currently DCSP not DCSP supported DCSP for DCSP ' + osname))
 DCSP allowed_ops = (tensor.basic.DimShuffle, tensor.basic.Elemwise) DCNL DCSP owner = graph.owner DCNL DCSP op = (graph.owner.op if (graph.owner is not None) else None) DCNL DCSP if ((owner is None) and (graph in inputs)): DCNL DCSP  DCSP return True DCNL DCSP elif ((owner is None) and isinstance(graph, tensor.basic.TensorConstant)): DCNL DCSP  DCSP return True DCNL DCSP elif ((owner is None) and (graph not in inputs)): DCNL DCSP  DCSP return False DCNL DCSP elif ((op is not None) and (not isinstance(op, allowed_ops))): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP if isinstance(graph.owner.op, tensor.basic.DimShuffle): DCNL DCSP  DCSP  DCSP shuffled = graph.owner.inputs[0] DCNL DCSP  DCSP  DCSP if (not isinstance(shuffled, tensor.basic.TensorConstant)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for inp in graph.owner.inputs: DCNL DCSP  DCSP  DCSP if (not is_pure_elemwise(inp, inputs)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True
 DCSP rebulk = Rebulk().regex_defaults(flags=re.IGNORECASE, abbreviations=[dash]).string_defaults(ignore_case=True) DCNL DCSP def audio_codec_priority(match1, match2): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gives DCSP priority DCSP to DCSP audio_codec\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :param DCSP match1:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :type DCSP match1:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :param DCSP match2:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :type DCSP match2:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :return:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :rtype:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if ((match1.name == 'audio_codec') and (match2.name in ['audio_profile', 'audio_channels'])): DCNL DCSP  DCSP  DCSP return match2 DCNL DCSP  DCSP if ((match1.name in ['audio_profile', 'audio_channels']) and (match2.name == 'audio_codec')): DCNL DCSP  DCSP  DCSP return match1 DCNL DCSP  DCSP return '__default__' DCNL DCSP rebulk.defaults(name='audio_codec', conflict_solver=audio_codec_priority) DCNL DCSP rebulk.regex('MP3', 'LAME', 'LAME(?:\\d)+-?(?:\\d)+', value='MP3') DCNL DCSP rebulk.regex('Dolby', 'DolbyDigital', 'Dolby-Digital', 'DD', value='DolbyDigital') DCNL DCSP rebulk.regex('DolbyAtmos', 'Dolby-Atmos', 'Atmos', value='DolbyAtmos') DCNL DCSP rebulk.regex('AAC', value='AAC') DCNL DCSP rebulk.regex('AC3D?', value='AC3') DCNL DCSP rebulk.regex('Flac', value='FLAC') DCNL DCSP rebulk.regex('DTS', value='DTS') DCNL DCSP rebulk.regex('True-?HD', value='TrueHD') DCNL DCSP rebulk.defaults(name='audio_profile') DCNL DCSP rebulk.string('HD', value='HD', tags='DTS') DCNL DCSP rebulk.regex('HD-?MA', value='HDMA', tags='DTS') DCNL DCSP rebulk.string('HE', value='HE', tags='AAC') DCNL DCSP rebulk.string('LC', value='LC', tags='AAC') DCNL DCSP rebulk.string('HQ', value='HQ', tags='AC3') DCNL DCSP rebulk.defaults(name='audio_channels') DCNL DCSP rebulk.regex('(7[\\W_][01](?:ch)?)(?:[^\\d]|$)', value='7.1', children=True) DCNL DCSP rebulk.regex('(5[\\W_][01](?:ch)?)(?:[^\\d]|$)', value='5.1', children=True) DCNL DCSP rebulk.regex('(2[\\W_]0(?:ch)?)(?:[^\\d]|$)', value='2.0', children=True) DCNL DCSP rebulk.string('7ch', '8ch', value='7.1') DCNL DCSP rebulk.string('5ch', '6ch', value='5.1') DCNL DCSP rebulk.string('2ch', 'stereo', value='2.0') DCNL DCSP rebulk.string('1ch', 'mono', value='1.0') DCNL DCSP rebulk.rules(DtsRule, AacRule, Ac3Rule, AudioValidatorRule, HqConflictRule) DCNL DCSP return rebulk
 DCSP bucket = conn.get_bucket(bucket_id) DCNL DCSP if (not bucket): DCNL DCSP  DCSP msg = (_('Could DCSP not DCSP find DCSP bucket DCSP with DCSP ID DCSP %(bucket_id)s') % locals()) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise exception.NotFound(msg) DCNL DCSP return bucket
 DCSP if (error_message is None): DCNL DCSP  DCSP error_message = ('Enter DCSP ' + what_to_enter) DCNL DCSP  DCSP if ((minimum is not None) and (maximum is not None)): DCNL DCSP  DCSP  DCSP error_message += ' DCSP between DCSP %(min)g DCSP and DCSP %(max)g' DCNL DCSP  DCSP elif (minimum is not None): DCNL DCSP  DCSP  DCSP error_message += ' DCSP greater DCSP than DCSP or DCSP equal DCSP to DCSP %(min)g' DCNL DCSP  DCSP elif (maximum is not None): DCNL DCSP  DCSP  DCSP error_message += ' DCSP less DCSP than DCSP or DCSP equal DCSP to DCSP %(max)g' DCNL DCSP if (type(maximum) in [int, long]): DCNL DCSP  DCSP maximum -= 1 DCNL DCSP return (translate(error_message) % dict(min=minimum, max=maximum))
 DCSP return IMPL.instance_get_floating_address(context, instance_id)
 DCSP source = credentials.source DCNL DCSP username = credentials.username DCNL DCSP password = credentials.password DCNL DCSP response = sock_info.command(source, {'getnonce': 1}) DCNL DCSP nonce = response['nonce'] DCNL DCSP key = _auth_key(nonce, username, password) DCNL DCSP query = SON([('authenticate', 1), ('user', username), ('nonce', nonce), ('key', key)]) DCNL DCSP sock_info.command(source, query)
 DCSP formula_set = list(formula_set) DCNL DCSP formula_set.append(Not(expr)) DCNL DCSP return (not satisfiable(And(*formula_set)))
 DCSP if (not callable(function)): DCNL DCSP  DCSP raise TypeError('function DCSP must DCSP be DCSP callable') DCNL DCSP hub = get_hub() DCNL DCSP if kwargs: DCNL DCSP  DCSP function = _functools_partial(function, *args, **kwargs) DCNL DCSP  DCSP g = RawGreenlet(function, hub) DCNL DCSP  DCSP hub.loop.run_callback(g.switch) DCNL DCSP else: DCNL DCSP  DCSP g = RawGreenlet(function, hub) DCNL DCSP  DCSP hub.loop.run_callback(g.switch, *args) DCNL DCSP return g
 DCSP return orig_isinstance(obj, NetProxy)
 DCSP error_map = {app_identity_service_pb.AppIdentityServiceError.NOT_A_VALID_APP: InternalError, app_identity_service_pb.AppIdentityServiceError.DEADLINE_EXCEEDED: BackendDeadlineExceeded, app_identity_service_pb.AppIdentityServiceError.BLOB_TOO_LARGE: BlobSizeTooLarge, app_identity_service_pb.AppIdentityServiceError.UNKNOWN_ERROR: InternalError, app_identity_service_pb.AppIdentityServiceError.UNKNOWN_SCOPE: InvalidScope, app_identity_service_pb.AppIdentityServiceError.NOT_ALLOWED: NotAllowed, app_identity_service_pb.AppIdentityServiceError.NOT_IMPLEMENTED: OperationNotImplemented} DCNL DCSP if (error.application_error in error_map): DCNL DCSP  DCSP return error_map[error.application_error](error.error_detail) DCNL DCSP else: DCNL DCSP  DCSP return InternalError(('%s: DCSP %s' % (error.application_error, error.error_detail)))
 DCSP if ((position is None) and (keyword is None)): DCNL DCSP  DCSP raise ValueError('Must DCSP specify DCSP at DCSP least DCSP one DCSP of: DCSP position DCSP or DCSP keyword.') DCNL DCSP try: DCNL DCSP  DCSP if ((position is not None) and (not isinstance(callfunc_node.args[position], astroid.Keyword))): DCNL DCSP  DCSP  DCSP return callfunc_node.args[position] DCNL DCSP except IndexError as error: DCNL DCSP  DCSP raise NoSuchArgumentError(error) DCNL DCSP if keyword: DCNL DCSP  DCSP for arg in callfunc_node.args: DCNL DCSP  DCSP  DCSP if (isinstance(arg, astroid.Keyword) and (arg.arg == keyword)): DCNL DCSP  DCSP  DCSP  DCSP return arg.value DCNL DCSP raise NoSuchArgumentError
 DCSP try: DCNL DCSP  DCSP tmp = class_path.split('.') DCNL DCSP  DCSP module_path = '.'.join(tmp[0:(-1)]) DCNL DCSP  DCSP package = __import__(module_path) DCNL DCSP  DCSP return reduce(getattr, tmp[1:], package) DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.error(LOGMSG_ERR_FAB_ADDON_IMPORT.format(class_path, e))
 DCSP (w, V) = LA.eigh(P, lower=lower, check_finite=check_finite) DCNL DCSP if (rcond is not None): DCNL DCSP  DCSP cond = rcond DCNL DCSP if (cond in (None, (-1))): DCNL DCSP  DCSP t = V.dtype.char.lower() DCNL DCSP  DCSP factor = {'f': 1000.0, 'd': 1000000.0} DCNL DCSP  DCSP cond = (factor[t] * np.finfo(t).eps) DCNL DCSP scale = max(np.absolute(w)) DCNL DCSP w_scaled = (w / scale) DCNL DCSP maskp = (w_scaled > cond) DCNL DCSP maskn = (w_scaled < (- cond)) DCNL DCSP if (np.any(maskp) and np.any(maskn)): DCNL DCSP  DCSP warnings.warn('Forming DCSP a DCSP nonconvex DCSP expression DCSP quad_form(x, DCSP indefinite).') DCNL DCSP M1 = (V[:, maskp] * np.sqrt(w_scaled[maskp])) DCNL DCSP M2 = (V[:, maskn] * np.sqrt((- w_scaled[maskn]))) DCNL DCSP return (scale, M1, M2)
 DCSP fileName = fabmetheus_interpret.getFirstTranslatorFileNameUnmodified(fileName) DCNL DCSP if (fileName != ''): DCNL DCSP  DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'unpause')
 DCSP try: DCNL DCSP  DCSP result = f(*args, **kwargs) DCNL DCSP except Exception: DCNL DCSP  DCSP f = failure.Failure() DCNL DCSP  DCSP reactor.callFromThread(deferred.errback, f) DCNL DCSP else: DCNL DCSP  DCSP reactor.callFromThread(deferred.callback, result)
 DCSP tmp = _asfarray(x) DCNL DCSP try: DCNL DCSP  DCSP work_function = _DTYPE_TO_FFT[tmp.dtype] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('type DCSP %s DCSP is DCSP not DCSP supported' % tmp.dtype)) DCNL DCSP if (not (istype(tmp, numpy.complex64) or istype(tmp, numpy.complex128))): DCNL DCSP  DCSP overwrite_x = 1 DCNL DCSP overwrite_x = (overwrite_x or _datacopied(tmp, x)) DCNL DCSP if (n is None): DCNL DCSP  DCSP n = tmp.shape[axis] DCNL DCSP elif (n != tmp.shape[axis]): DCNL DCSP  DCSP (tmp, copy_made) = _fix_shape(tmp, n, axis) DCNL DCSP  DCSP overwrite_x = (overwrite_x or copy_made) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP number DCSP of DCSP FFT DCSP data DCSP points DCSP (%d) DCSP specified.' % n)) DCNL DCSP if ((axis == (-1)) or (axis == (len(tmp.shape) - 1))): DCNL DCSP  DCSP return work_function(tmp, n, 1, 0, overwrite_x) DCNL DCSP tmp = swapaxes(tmp, axis, (-1)) DCNL DCSP tmp = work_function(tmp, n, 1, 0, overwrite_x) DCNL DCSP return swapaxes(tmp, axis, (-1))
 DCSP os.makedirs(os.path.join(HOME_TEST_DIR, 'ipython'))
 DCSP try: DCNL DCSP  DCSP user = User.objects.get(username=username) DCNL DCSP  DCSP if recreate: DCNL DCSP  DCSP  DCSP user.delete() DCNL DCSP  DCSP  DCSP raise User.DoesNotExist DCNL DCSP except User.DoesNotExist: DCNL DCSP  DCSP user = User.objects.create_user(username, (username + '@localhost'), password) DCNL DCSP  DCSP user.is_superuser = is_superuser DCNL DCSP  DCSP user.save() DCNL DCSP else: DCNL DCSP  DCSP if (user.is_superuser != is_superuser): DCNL DCSP  DCSP  DCSP user.is_superuser = is_superuser DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP if (groupname is not None): DCNL DCSP  DCSP (group, created) = Group.objects.get_or_create(name=groupname) DCNL DCSP  DCSP if (not user.groups.filter(name=group.name).exists()): DCNL DCSP  DCSP  DCSP user.groups.add(group) DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP c = Client() DCNL DCSP ret = c.login(username=username, password=password) DCNL DCSP assert ret, ("Login DCSP failed DCSP (user DCSP '%s')." % username) DCNL DCSP return c
 DCSP data = np.ones((5, 5)) DCNL DCSP data[(2, 2)] = 1000 DCNL DCSP data[(3, 4)] = np.nan DCNL DCSP data[(1, 1)] = np.inf DCNL DCSP result = sigma_clip(data) DCNL DCSP assert result.mask[(2, 2)] DCNL DCSP assert result.mask[(3, 4)] DCNL DCSP assert result.mask[(1, 1)]
 DCSP for (dirpath, _, filenames) in os.walk(pelican.settings['OUTPUT_PATH']): DCNL DCSP  DCSP for name in filenames: DCNL DCSP  DCSP  DCSP if should_compress(name): DCNL DCSP  DCSP  DCSP  DCSP filepath = os.path.join(dirpath, name) DCNL DCSP  DCSP  DCSP  DCSP create_gzip_file(filepath, should_overwrite(pelican.settings))
 DCSP return client_session.request(*args, **kwargs)
 DCSP return [unique_substring(s, [x for x in l if (x is not s)], min_size) for s in l]
 DCSP ret = {'name': None, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP r = __salt__['boto_lambda.event_source_mapping_exists'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP event DCSP source DCSP mapping: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP if (not r.get('exists')): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Event DCSP source DCSP mapping DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP created.'.format(FunctionName) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP r = __salt__['boto_lambda.create_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, StartingPosition=StartingPosition, Enabled=Enabled, BatchSize=BatchSize, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if (not r.get('created')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP event DCSP source DCSP mapping: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _describe = __salt__['boto_lambda.describe_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP ret['name'] = _describe['event_source_mapping']['UUID'] DCNL DCSP  DCSP ret['changes']['old'] = {'event_source_mapping': None} DCNL DCSP  DCSP ret['changes']['new'] = _describe DCNL DCSP  DCSP ret['comment'] = 'Event DCSP source DCSP mapping DCSP {0} DCSP created.'.format(ret['name']) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Event DCSP source DCSP mapping DCSP is DCSP present.']) DCNL DCSP ret['changes'] = {} DCNL DCSP _describe = __salt__['boto_lambda.describe_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyid=keyid, profile=profile)['event_source_mapping'] DCNL DCSP need_update = False DCNL DCSP options = {'BatchSize': 'BatchSize'} DCNL DCSP for (val, var) in six.iteritems(options): DCNL DCSP  DCSP if (_describe[val] != locals()[var]): DCNL DCSP  DCSP  DCSP need_update = True DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('new', {})[var] = locals()[var] DCNL DCSP  DCSP  DCSP ret['changes'].setdefault('old', {})[var] = _describe[val] DCNL DCSP function_arn = _get_function_arn(FunctionName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (_describe['FunctionArn'] != function_arn): DCNL DCSP  DCSP need_update = True DCNL DCSP  DCSP ret['changes'].setdefault('new', {})['FunctionArn'] = function_arn DCNL DCSP  DCSP ret['changes'].setdefault('old', {})['FunctionArn'] = _describe['FunctionArn'] DCNL DCSP if need_update: DCNL DCSP  DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Event DCSP source DCSP mapping DCSP to DCSP be DCSP modified']) DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'Event DCSP source DCSP mapping DCSP {0} DCSP set DCSP to DCSP be DCSP modified.'.format(_describe['UUID']) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _r = __salt__['boto_lambda.update_event_source_mapping'](UUID=_describe['UUID'], FunctionName=FunctionName, Enabled=Enabled, BatchSize=BatchSize, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if (not _r.get('updated')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP update DCSP mapping: DCSP {0}.'.format(_r['error']['message']) DCNL DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP return ret
 DCSP if gcodec.isProcedureDoneOrFileIsEmpty(gcodeText, 'export'): DCNL DCSP  DCSP return gcodeText DCNL DCSP if (exportRepository == None): DCNL DCSP  DCSP exportRepository = settings.getReadRepository(ExportRepository()) DCNL DCSP if (not exportRepository.activateExport.value): DCNL DCSP  DCSP return gcodeText DCNL DCSP return ExportSkein().getCraftedGcode(exportRepository, gcodeText)
 DCSP clf = GaussianNB() DCNL DCSP clf.fit(X, y) DCNL DCSP assert_raises(ValueError, clf.partial_fit, np.hstack((X, X)), y)
 DCSP code = int(key[(key.index(u'k') + 1):]) DCNL DCSP value = chr(code) DCNL DCSP if ((code >= 65) and (code <= 90)): DCNL DCSP  DCSP if (u'shift+' in key): DCNL DCSP  DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = value.lower() DCNL DCSP elif ((code >= 48) and (code <= 57)): DCNL DCSP  DCSP if (u'shift+' in key): DCNL DCSP  DCSP  DCSP value = u')!@#$%^&*('[int(value)] DCNL DCSP  DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP elif ((code >= 112) and (code <= 123)): DCNL DCSP  DCSP value = (u'f%s' % (code - 111)) DCNL DCSP elif ((code >= 96) and (code <= 105)): DCNL DCSP  DCSP value = (u'%s' % (code - 96)) DCNL DCSP elif ((code in _SHIFT_LUT) and (u'shift+' in key)): DCNL DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP  DCSP value = _SHIFT_LUT[code] DCNL DCSP elif (code in _LUT): DCNL DCSP  DCSP value = _LUT[code] DCNL DCSP key = (key[:key.index(u'k')] + value) DCNL DCSP return key
 DCSP conn = boto.connect_vpc(u'the_key', u'the_secret') DCNL DCSP igw = conn.create_internet_gateway() DCNL DCSP igw_by_search = conn.get_all_internet_gateways([igw.id])[0] DCNL DCSP igw.id.should.equal(igw_by_search.id)
 DCSP conn = __proxy__['junos.conn']() DCNL DCSP ret = dict() DCNL DCSP ret['out'] = True DCNL DCSP op = dict() DCNL DCSP if ('__pub_arg' in kwargs): DCNL DCSP  DCSP if isinstance(kwargs['__pub_arg'][(-1)], dict): DCNL DCSP  DCSP  DCSP op.update(kwargs['__pub_arg'][(-1)]) DCNL DCSP else: DCNL DCSP  DCSP op.update(kwargs) DCNL DCSP if ((dest is None) and (format != 'xml')): DCNL DCSP  DCSP log.warning('Format DCSP ignored DCSP as DCSP it DCSP is DCSP only DCSP used DCSP for DCSP output DCSP which DCSP is DCSP dumped DCSP in DCSP the DCSP file.') DCNL DCSP write_response = '' DCNL DCSP try: DCNL DCSP  DCSP if (cmd in ['get-config', 'get_config']): DCNL DCSP  DCSP  DCSP filter_reply = None DCNL DCSP  DCSP  DCSP if ('filter' in op): DCNL DCSP  DCSP  DCSP  DCSP filter_reply = etree.XML(op['filter']) DCNL DCSP  DCSP  DCSP xml_reply = getattr(conn.rpc, cmd.replace('-', '_'))(filter_reply, options=op) DCNL DCSP  DCSP  DCSP ret['message'] = jxmlease.parse(etree.tostring(xml_reply)) DCNL DCSP  DCSP  DCSP write_response = etree.tostring(xml_reply) DCNL DCSP  DCSP  DCSP if ((dest is not None) and (format != 'xml')): DCNL DCSP  DCSP  DCSP  DCSP op.update({'format': format}) DCNL DCSP  DCSP  DCSP  DCSP rpc_reply = getattr(conn.rpc, cmd.replace('-', '_'))(filter_reply, options=op) DCNL DCSP  DCSP  DCSP  DCSP if (format == 'json'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = json.dumps(rpc_reply, indent=1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = rpc_reply.text DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xml_reply = getattr(conn.rpc, cmd.replace('-', '_'))(**op) DCNL DCSP  DCSP  DCSP ret['message'] = jxmlease.parse(etree.tostring(xml_reply)) DCNL DCSP  DCSP  DCSP write_response = etree.tostring(xml_reply) DCNL DCSP  DCSP  DCSP if ((dest is not None) and (format != 'xml')): DCNL DCSP  DCSP  DCSP  DCSP rpc_reply = getattr(conn.rpc, cmd.replace('-', '_'))({'format': format}, **op) DCNL DCSP  DCSP  DCSP  DCSP if (format == 'json'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = json.dumps(rpc_reply, indent=1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = rpc_reply.text DCNL DCSP except Exception as exception: DCNL DCSP  DCSP ret['message'] = 'Execution DCSP failed DCSP due DCSP to DCSP "{0}"'.format(exception) DCNL DCSP  DCSP ret['out'] = False DCNL DCSP if (dest is not None): DCNL DCSP  DCSP with fopen(dest, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(write_response) DCNL DCSP return ret
 DCSP results = {} DCNL DCSP if (not os.path.exists(results_file)): DCNL DCSP  DCSP raise IOError('Results DCSP file DCSP does DCSP not DCSP exist.') DCNL DCSP with open(results_file) as handle: DCNL DCSP  DCSP lines = handle.readlines() DCNL DCSP (results, num_params) = _parse_baseml.parse_basics(lines, results) DCNL DCSP results = _parse_baseml.parse_parameters(lines, results, num_params) DCNL DCSP if (results.get('version') is None): DCNL DCSP  DCSP raise ValueError('Invalid DCSP results DCSP file') DCNL DCSP return results
 DCSP subprj = get_subproject(request, project, subproject) DCNL DCSP data = [trans.get_stats() for trans in subprj.translation_set.all()] DCNL DCSP return export_response(request, ('stats-%s-%s.csv' % (subprj.project.slug, subprj.slug)), ('name', 'code', 'total', 'translated', 'translated_percent', 'total_words', 'translated_words', 'failing', 'failing_percent', 'fuzzy', 'fuzzy_percent', 'url_translate', 'url', 'last_change', 'last_author'), data)
 DCSP nodes = Node.query.order_by(Node.updated.desc()).all() DCNL DCSP return render_template('node/nodes.html', nodes=nodes)
 DCSP return strip_tags(value)
 DCSP try: DCNL DCSP  DCSP gce.ex_delete_image(name) DCNL DCSP  DCSP return True DCNL DCSP except ResourceNotFoundError: DCNL DCSP  DCSP return False DCNL DCSP except GoogleBaseError as e: DCNL DCSP  DCSP module.fail_json(msg=str(e), changed=False)
 DCSP if ('proc_history' not in info): DCNL DCSP  DCSP return DCNL DCSP if (len(info['proc_history']) > 0): DCNL DCSP  DCSP start_block(fid, FIFF.FIFFB_PROCESSING_HISTORY) DCNL DCSP  DCSP for record in info['proc_history']: DCNL DCSP  DCSP  DCSP start_block(fid, FIFF.FIFFB_PROCESSING_RECORD) DCNL DCSP  DCSP  DCSP for (key, id_, writer) in zip(_proc_keys, _proc_ids, _proc_writers): DCNL DCSP  DCSP  DCSP  DCSP if (key in record): DCNL DCSP  DCSP  DCSP  DCSP  DCSP writer(fid, id_, record[key]) DCNL DCSP  DCSP  DCSP _write_maxfilter_record(fid, record['max_info']) DCNL DCSP  DCSP  DCSP if ('smartshield' in record): DCNL DCSP  DCSP  DCSP  DCSP for ss in record['smartshield']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_block(fid, FIFF.FIFFB_SMARTSHIELD) DCNL DCSP  DCSP  DCSP  DCSP  DCSP end_block(fid, FIFF.FIFFB_SMARTSHIELD) DCNL DCSP  DCSP  DCSP end_block(fid, FIFF.FIFFB_PROCESSING_RECORD) DCNL DCSP  DCSP end_block(fid, FIFF.FIFFB_PROCESSING_HISTORY)
 DCSP req = InstallRequirement.from_line('bar', None) DCNL DCSP finder = PackageFinder([], [data.index_url('pre')], allow_all_prereleases=True, session=PipSession()) DCNL DCSP link = finder.find_requirement(req, False) DCNL DCSP assert link.url.endswith('bar-2.0b1.tar.gz'), link.url DCNL DCSP links = ['https://foo/bar-1.0.tar.gz', 'https://foo/bar-2.0b1.tar.gz'] DCNL DCSP finder = PackageFinder(links, [], allow_all_prereleases=True, session=PipSession()) DCNL DCSP with patch.object(finder, '_get_pages', (lambda x, y: [])): DCNL DCSP  DCSP link = finder.find_requirement(req, False) DCNL DCSP  DCSP assert (link.url == 'https://foo/bar-2.0b1.tar.gz') DCNL DCSP links.reverse() DCNL DCSP finder = PackageFinder(links, [], allow_all_prereleases=True, session=PipSession()) DCNL DCSP with patch.object(finder, '_get_pages', (lambda x, y: [])): DCNL DCSP  DCSP link = finder.find_requirement(req, False) DCNL DCSP  DCSP assert (link.url == 'https://foo/bar-2.0b1.tar.gz')
 DCSP profiles = {} DCNL DCSP curr = None DCNL DCSP cmd = ['netsh', 'advfirewall', 'show', 'allprofiles'] DCNL DCSP for line in __salt__['cmd.run'](cmd, python_shell=False).splitlines(): DCNL DCSP  DCSP if (not curr): DCNL DCSP  DCSP  DCSP tmp = re.search('(.*) DCSP Profile DCSP Settings:', line) DCNL DCSP  DCSP  DCSP if tmp: DCNL DCSP  DCSP  DCSP  DCSP curr = tmp.group(1) DCNL DCSP  DCSP elif line.startswith('State'): DCNL DCSP  DCSP  DCSP profiles[curr] = (line.split()[1] == 'ON') DCNL DCSP  DCSP  DCSP curr = None DCNL DCSP return profiles
 DCSP mapping = ''.join((([chr(0) for ascii in range(0, 59)] + [chr(ascii) for ascii in range(59, 127)]) + [chr(0) for ascii in range(127, 256)])) DCNL DCSP assert (len(mapping) == 256) DCNL DCSP return _fastq_generic(in_handle, out_handle, mapping)
 DCSP filter_length = len(filter_) DCNL DCSP if (scope == 'collection'): DCNL DCSP  DCSP tag = item.collection.get_meta('tag') DCNL DCSP else: DCNL DCSP  DCSP for component in item.components(): DCNL DCSP  DCSP  DCSP if (component.name in ('VTODO', 'VEVENT', 'VJOURNAL')): DCNL DCSP  DCSP  DCSP  DCSP tag = component.name DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (filter_length == 0): DCNL DCSP  DCSP return (filter_.get('name') == tag) DCNL DCSP else: DCNL DCSP  DCSP if (filter_length == 1): DCNL DCSP  DCSP  DCSP if (filter_[0].tag == _tag('C', 'is-not-defined')): DCNL DCSP  DCSP  DCSP  DCSP return (filter_.get('name') != tag) DCNL DCSP  DCSP if (filter_[0].tag == _tag('C', 'time-range')): DCNL DCSP  DCSP  DCSP if (not _time_range_match(item.item, filter_[0], tag)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP filter_ = filter_[1:] DCNL DCSP  DCSP return all(((_prop_match(item, child) if (child.tag == _tag('C', 'prop-filter')) else _comp_match(item, child, scope='component')) for child in filter_))
 DCSP if (src_image.shape != target_image.shape): DCNL DCSP  DCSP raise ValueError('Error: DCSP images DCSP must DCSP be DCSP same DCSP size DCSP for DCSP register_translation') DCNL DCSP if ((src_image.ndim != 2) and (upsample_factor > 1)): DCNL DCSP  DCSP raise NotImplementedError('Error: DCSP register_translation DCSP only DCSP supports DCSP subpixel DCSP registration DCSP for DCSP 2D DCSP images') DCNL DCSP if (space.lower() == 'fourier'): DCNL DCSP  DCSP src_freq = src_image DCNL DCSP  DCSP target_freq = target_image DCNL DCSP elif (space.lower() == 'real'): DCNL DCSP  DCSP src_image = np.array(src_image, dtype=np.complex128, copy=False) DCNL DCSP  DCSP target_image = np.array(target_image, dtype=np.complex128, copy=False) DCNL DCSP  DCSP src_freq = np.fft.fftn(src_image) DCNL DCSP  DCSP target_freq = np.fft.fftn(target_image) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Error: DCSP register_translation DCSP only DCSP knows DCSP the DCSP "real" DCSP and DCSP "fourier" DCSP values DCSP for DCSP the DCSP ``space`` DCSP argument.') DCNL DCSP shape = src_freq.shape DCNL DCSP image_product = (src_freq * target_freq.conj()) DCNL DCSP cross_correlation = np.fft.ifftn(image_product) DCNL DCSP maxima = np.unravel_index(np.argmax(np.abs(cross_correlation)), cross_correlation.shape) DCNL DCSP midpoints = np.array([np.fix((axis_size / 2)) for axis_size in shape]) DCNL DCSP shifts = np.array(maxima, dtype=np.float64) DCNL DCSP shifts[(shifts > midpoints)] -= np.array(shape)[(shifts > midpoints)] DCNL DCSP if (upsample_factor == 1): DCNL DCSP  DCSP src_amp = (np.sum((np.abs(src_freq) ** 2)) / src_freq.size) DCNL DCSP  DCSP target_amp = (np.sum((np.abs(target_freq) ** 2)) / target_freq.size) DCNL DCSP  DCSP CCmax = cross_correlation.max() DCNL DCSP else: DCNL DCSP  DCSP shifts = (np.round((shifts * upsample_factor)) / upsample_factor) DCNL DCSP  DCSP upsampled_region_size = np.ceil((upsample_factor * 1.5)) DCNL DCSP  DCSP dftshift = np.fix((upsampled_region_size / 2.0)) DCNL DCSP  DCSP upsample_factor = np.array(upsample_factor, dtype=np.float64) DCNL DCSP  DCSP normalization = (src_freq.size * (upsample_factor ** 2)) DCNL DCSP  DCSP sample_region_offset = (dftshift - (shifts * upsample_factor)) DCNL DCSP  DCSP cross_correlation = _upsampled_dft(image_product.conj(), upsampled_region_size, upsample_factor, sample_region_offset).conj() DCNL DCSP  DCSP cross_correlation /= normalization DCNL DCSP  DCSP maxima = np.array(np.unravel_index(np.argmax(np.abs(cross_correlation)), cross_correlation.shape), dtype=np.float64) DCNL DCSP  DCSP maxima -= dftshift DCNL DCSP  DCSP shifts = (shifts + (maxima / upsample_factor)) DCNL DCSP  DCSP CCmax = cross_correlation.max() DCNL DCSP  DCSP src_amp = _upsampled_dft((src_freq * src_freq.conj()), 1, upsample_factor)[(0, 0)] DCNL DCSP  DCSP src_amp /= normalization DCNL DCSP  DCSP target_amp = _upsampled_dft((target_freq * target_freq.conj()), 1, upsample_factor)[(0, 0)] DCNL DCSP  DCSP target_amp /= normalization DCNL DCSP for dim in range(src_freq.ndim): DCNL DCSP  DCSP if (shape[dim] == 1): DCNL DCSP  DCSP  DCSP shifts[dim] = 0 DCNL DCSP return (shifts, _compute_error(CCmax, src_amp, target_amp), _compute_phasediff(CCmax))
 DCSP badge = get_or_create_badge(badge_template, year) DCNL DCSP if badge.is_awarded_to(user): DCNL DCSP  DCSP return DCNL DCSP from kitsune.questions.models import Answer DCNL DCSP qs = Answer.objects.filter(creator=user, created__gte=date(year, 1, 1), created__lt=date((year + 1), 1, 1)) DCNL DCSP if (qs.count() >= 30): DCNL DCSP  DCSP badge.award_to(user) DCNL DCSP  DCSP return True
 DCSP return win32api.RegQueryValue(GetRootKey(), ((GetAppPathsKey() + '\\') + exeAlias))
 DCSP return json.loads(x, object_hook=json_hook)
 DCSP rgb_cie_converter = rgb_cie.Converter() DCNL DCSP hex_color_re = re.compile('(?<!\\w)([a-f0-9]){2}([a-f0-9]){2}([a-f0-9]){2}\\b', re.IGNORECASE) DCNL DCSP if (color in CSS_LITERALS): DCNL DCSP  DCSP color = CSS_LITERALS[color] DCNL DCSP color = color.lstrip('#') DCNL DCSP if (not hex_color_re.match(color)): DCNL DCSP  DCSP print 'Invalid DCSP color. DCSP Please DCSP use DCSP a DCSP 6-digit DCSP hex DCSP color.' DCNL DCSP  DCSP sys.exit() DCNL DCSP return rgb_cie_converter.hexToCIE1931(color)
 DCSP try: DCNL DCSP  DCSP if (int(kodi_setting) == 0): DCNL DCSP  DCSP  DCSP return 'remove_this_line' DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return kodi_setting
 DCSP single = False DCNL DCSP if (not is_sequence(exprs)): DCNL DCSP  DCSP (exprs, single) = ([exprs], True) DCNL DCSP exprs = list(map(sympify, exprs)) DCNL DCSP opt = build_options(symbols, options) DCNL DCSP (reps, opt) = _parallel_dict_from_expr(exprs, opt) DCNL DCSP if (opt.domain is None): DCNL DCSP  DCSP coeffs = sum([list(rep.values()) for rep in reps], []) DCNL DCSP  DCSP (opt.domain, _) = construct_domain(coeffs, opt=opt) DCNL DCSP _ring = PolyRing(opt.gens, opt.domain, opt.order) DCNL DCSP polys = list(map(_ring.from_dict, reps)) DCNL DCSP if single: DCNL DCSP  DCSP return (_ring, polys[0]) DCNL DCSP else: DCNL DCSP  DCSP return (_ring, polys)
 DCSP insetLoops = [] DCNL DCSP for loop in loops: DCNL DCSP  DCSP insetLoops += getInsetLoopsFromLoop(loop, radius) DCNL DCSP return insetLoops
 DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(LOG_LEVEL) DCNL DCSP fmt = logging.Formatter('[%(asctime)s] DCSP %(levelname)s: DCSP %(message)s') DCNL DCSP handler = logging.StreamHandler() DCNL DCSP handler.setFormatter(fmt) DCNL DCSP logger.addHandler(handler)
 DCSP return (16 * MB)
 DCSP if (key == 'env'): DCNL DCSP  DCSP val = env_to_str(val) DCNL DCSP elif (val is None): DCNL DCSP  DCSP val = '' DCNL DCSP else: DCNL DCSP  DCSP val = str(val) DCNL DCSP return val
 DCSP zip = zipfile.ZipFile(target, 'w', zipfile.ZIP_DEFLATED) DCNL DCSP manifest = _archive_package_sources(zip.write, sources, sources_dir) DCNL DCSP zip.writestr(_PACKAGE_MANIFEST, ('\n'.join(manifest) + '\n')) DCNL DCSP zip.close() DCNL DCSP return None
 DCSP return PostscriptRepository()
 DCSP if (cls is None): DCNL DCSP  DCSP cls = MultiDict DCNL DCSP if (isinstance(s, text_type) and (not isinstance(separator, text_type))): DCNL DCSP  DCSP separator = separator.decode((charset or 'ascii')) DCNL DCSP elif (isinstance(s, bytes) and (not isinstance(separator, bytes))): DCNL DCSP  DCSP separator = separator.encode((charset or 'ascii')) DCNL DCSP return cls(_url_decode_impl(s.split(separator), charset, decode_keys, include_empty, errors))
 DCSP attrs = {} DCNL DCSP _escapedKey = escape4xml(key) DCNL DCSP if (fullpath in TAGS_TO_MODIFY): DCNL DCSP  DCSP (tagName, useTitle) = TAGS_TO_MODIFY[fullpath] DCNL DCSP  DCSP if useTitle: DCNL DCSP  DCSP  DCSP attrs['key'] = _escapedKey DCNL DCSP elif (not isinstance(key, unicode)): DCNL DCSP  DCSP if isinstance(key, str): DCNL DCSP  DCSP  DCSP tagName = unicode(key, 'ascii', 'ignore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP strType = str(type(key)).replace("<type DCSP '", '').replace("'>", '') DCNL DCSP  DCSP  DCSP attrs['keytype'] = strType DCNL DCSP  DCSP  DCSP tagName = unicode(key) DCNL DCSP else: DCNL DCSP  DCSP tagName = key DCNL DCSP if isinstance(key, int): DCNL DCSP  DCSP attrs['keytype'] = 'int' DCNL DCSP origTagName = tagName DCNL DCSP tagName = tagName.lower().replace(' DCSP ', '-') DCNL DCSP tagName = str(tagName).translate(_allchars, _keepchars) DCNL DCSP if (origTagName != tagName): DCNL DCSP  DCSP if ('key' not in attrs): DCNL DCSP  DCSP  DCSP attrs['key'] = _escapedKey DCNL DCSP if ((not tagName) or tagName[0].isdigit() or (tagName[0] == '-')): DCNL DCSP  DCSP tagName = 'item' DCNL DCSP  DCSP _utils_logger.error(('invalid DCSP tag: DCSP %s DCSP [%s]' % (_escapedKey, fullpath))) DCNL DCSP  DCSP attrs['key'] = _escapedKey DCNL DCSP return (tagName, u' DCSP '.join([(u'%s="%s"' % i) for i in attrs.items()]))
 DCSP module_path = dirname(__file__) DCNL DCSP fdescr_name = join(module_path, 'descr', 'boston_house_prices.rst') DCNL DCSP with open(fdescr_name) as f: DCNL DCSP  DCSP descr_text = f.read() DCNL DCSP data_file_name = join(module_path, 'data', 'boston_house_prices.csv') DCNL DCSP with open(data_file_name) as f: DCNL DCSP  DCSP data_file = csv.reader(f) DCNL DCSP  DCSP temp = next(data_file) DCNL DCSP  DCSP n_samples = int(temp[0]) DCNL DCSP  DCSP n_features = int(temp[1]) DCNL DCSP  DCSP data = np.empty((n_samples, n_features)) DCNL DCSP  DCSP target = np.empty((n_samples,)) DCNL DCSP  DCSP temp = next(data_file) DCNL DCSP  DCSP feature_names = np.array(temp) DCNL DCSP  DCSP for (i, d) in enumerate(data_file): DCNL DCSP  DCSP  DCSP data[i] = np.asarray(d[:(-1)], dtype=np.float64) DCNL DCSP  DCSP  DCSP target[i] = np.asarray(d[(-1)], dtype=np.float64) DCNL DCSP if return_X_y: DCNL DCSP  DCSP return (data, target) DCNL DCSP return Bunch(data=data, target=target, feature_names=feature_names[:(-1)], DESCR=descr_text)
 DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP tRet = __salt__['win_dacl.check_inheritance'](name, objectType) DCNL DCSP if tRet['result']: DCNL DCSP  DCSP if tRet['Inheritance']: DCNL DCSP  DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['Inheritance'] = 'Disabled' DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Inheritance DCSP is DCSP set DCSP to DCSP be DCSP disabled.' DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['Inherited DCSP ACLs'] = ('Are DCSP set DCSP to DCSP be DCSP kept' if copy_inherited_acl else 'Are DCSP set DCSP to DCSP be DCSP removed') DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP eRet = __salt__['win_dacl.disable_inheritance'](name, objectType, copy_inherited_acl) DCNL DCSP  DCSP  DCSP ret['result'] = eRet['result'] DCNL DCSP  DCSP  DCSP if eRet['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes'] = dict(ret['changes'], **eRet['changes']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = ' DCSP '.join([ret['comment'], eRet['comment']]) DCNL DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Inheritance DCSP is DCSP disabled.' DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = tRet['comment'] DCNL DCSP return ret
 DCSP query = 'SELECT DCSP load DCSP FROM DCSP salt.jids DCSP WHERE DCSP jid DCSP = DCSP ?;' DCNL DCSP ret = {} DCNL DCSP try: DCNL DCSP  DCSP data = __salt__['cassandra_cql.cql_query_with_prepare'](query, 'get_load', [jid]) DCNL DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP load = data[0].get('load') DCNL DCSP  DCSP  DCSP if load: DCNL DCSP  DCSP  DCSP  DCSP ret = json.loads(load) DCNL DCSP except CommandExecutionError: DCNL DCSP  DCSP log.critical('Could DCSP not DCSP get DCSP load DCSP from DCSP jids DCSP table.') DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.critical('Unexpected DCSP error DCSP while DCSP getting DCSP load DCSP from DCSP jids: DCSP {0}'.format(str(e))) DCNL DCSP  DCSP raise DCNL DCSP return ret
 DCSP assert (n > 0) DCNL DCSP s = '' DCNL DCSP while n: DCNL DCSP  DCSP (n, m) = divmod((n - 1), 26) DCNL DCSP  DCSP s = (chr((m + ord('A'))) + s) DCNL DCSP return s
 DCSP reserved_requests.add(request)
 DCSP sheet = container.parse_css(raw) DCNL DCSP return serialize(sheet, u'text/css')
 DCSP report = ('blocked-uri', 'violated-directive', 'original-policy') DCNL DCSP if (not waffle.sample_is_active('csp-store-reports')): DCNL DCSP  DCSP return HttpResponse() DCNL DCSP try: DCNL DCSP  DCSP v = json.loads(request.body)['csp-report'] DCNL DCSP  DCSP meta = request.META.copy() DCNL DCSP  DCSP meta['PATH_INFO'] = v.get('document-uri', meta['PATH_INFO']) DCNL DCSP  DCSP v = [(k, v[k]) for k in report if (k in v)] DCNL DCSP  DCSP log_cef('CSPViolation', 5, meta, signature='CSPREPORT', msg='A DCSP client DCSP reported DCSP a DCSP CSP DCSP violation', cs6=v, cs6Label='ContentPolicy') DCNL DCSP except (KeyError, ValueError) as e: DCNL DCSP  DCSP log.debug(('Exception DCSP in DCSP CSP DCSP report: DCSP %s' % e), exc_info=True) DCNL DCSP  DCSP return HttpResponseBadRequest() DCNL DCSP return HttpResponse()
 DCSP if (str(value).lower() not in ('true', 'false')): DCNL DCSP  DCSP raise ValueError((_('Unrecognized DCSP value DCSP "%(value)s" DCSP for DCSP "%(name)s", DCSP acceptable DCSP values DCSP are: DCSP true, DCSP false.') % {'value': value, 'name': name})) DCNL DCSP return strutils.bool_from_string(value, strict=True)
 DCSP try: DCNL DCSP  DCSP if call: DCNL DCSP  DCSP  DCSP version = getattr(module, attr)() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP version = getattr(module, attr) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print e DCNL DCSP  DCSP version = 'Version DCSP could DCSP not DCSP be DCSP acquired!' DCNL DCSP if (not isinstance(version, str)): DCNL DCSP  DCSP version = list2string(version) DCNL DCSP return version
 DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self.closed: DCNL DCSP  DCSP  DCSP raise IOError(errno.EBADF, 'I/O DCSP operation DCSP on DCSP closed DCSP file') DCNL DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapper
 DCSP hps.batch_size = 100 DCNL DCSP with tf.Graph().as_default(): DCNL DCSP  DCSP with tf.device('/cpu:0'): DCNL DCSP  DCSP  DCSP with tf.variable_scope('model') as var_scope: DCNL DCSP  DCSP  DCSP  DCSP eval_model = RealNVP(hps) DCNL DCSP  DCSP  DCSP  DCSP summary_writer = tf.summary.FileWriter(logdir) DCNL DCSP  DCSP  DCSP  DCSP var_scope.reuse_variables() DCNL DCSP  DCSP  DCSP saver = tf.train.Saver() DCNL DCSP  DCSP  DCSP sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)) DCNL DCSP  DCSP  DCSP tf.train.start_queue_runners(sess) DCNL DCSP  DCSP  DCSP previous_global_step = 0 DCNL DCSP  DCSP  DCSP with sess.as_default(): DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ckpt_state = tf.train.get_checkpoint_state(traindir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ckpt_state and ckpt_state.model_checkpoint_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('No DCSP model DCSP to DCSP eval DCSP yet DCSP at DCSP %s' % traindir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Loading DCSP file DCSP %s' % ckpt_state.model_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP saver.restore(sess, ckpt_state.model_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_step = tf.train.global_step(sess, eval_model.step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_step == previous_global_step): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP updated.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP previous_global_step = current_step DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Evaluating...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP bit_per_dim = eval_model.eval_epoch(hps) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Epoch: DCSP %d, DCSP %s DCSP -> DCSP %.3f DCSP bits/dim' % (current_step, subset, bit_per_dim)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Writing DCSP summary...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary = tf.Summary() DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary.value.extend([tf.Summary.Value(tag='bit_per_dim', simple_value=bit_per_dim)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_writer.add_summary(summary, current_step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if return_val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (current_step, bit_per_dim)
 DCSP parser.skip_past('endcomment') DCNL DCSP return CommentNode()
 DCSP path = find_cmd('ls') DCNL DCSP nt.assert_true(path.endswith('ls'))
 DCSP return trapz(y=y, x=x)
 DCSP if _PY3: DCNL DCSP  DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP  DCSP s = s.decode('utf-8') DCNL DCSP  DCSP if (type(s) is not text_type): DCNL DCSP  DCSP  DCSP s = text_type(s) DCNL DCSP else: DCNL DCSP  DCSP if (isinstance(s, str) and (HAS_UTF8.search(s) is not None)): DCNL DCSP  DCSP  DCSP s = s.decode('utf-8') DCNL DCSP  DCSP if (type(s) not in string_types): DCNL DCSP  DCSP  DCSP s = text_type(s) DCNL DCSP def replace(match): DCNL DCSP  DCSP s = match.group(0) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return ESCAPE_DCT[s] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP n = ord(s) DCNL DCSP  DCSP  DCSP if (n < 65536): DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x' % (n,)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP n -= 65536 DCNL DCSP  DCSP  DCSP  DCSP s1 = (55296 | ((n >> 10) & 1023)) DCNL DCSP  DCSP  DCSP  DCSP s2 = (56320 | (n & 1023)) DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x\\u%04x' % (s1, s2)) DCNL DCSP return (('"' + str(ESCAPE_ASCII.sub(replace, s))) + '"')
 DCSP return __salt__['reg.set_value'](hive='HKLM', key=MINION_VOLATILE_KEY, volatile=True, vname=REBOOT_REQUIRED_NAME, vdata=1, vtype='REG_DWORD')
 DCSP with tf.name_scope(scope, 'eval_image', [image, height, width]): DCNL DCSP  DCSP if (image.dtype != tf.float32): DCNL DCSP  DCSP  DCSP image = tf.image.convert_image_dtype(image, dtype=tf.float32) DCNL DCSP  DCSP if central_fraction: DCNL DCSP  DCSP  DCSP image = tf.image.central_crop(image, central_fraction=central_fraction) DCNL DCSP  DCSP if (height and width): DCNL DCSP  DCSP  DCSP image = tf.expand_dims(image, 0) DCNL DCSP  DCSP  DCSP image = tf.image.resize_bilinear(image, [height, width], align_corners=False) DCNL DCSP  DCSP  DCSP image = tf.squeeze(image, [0]) DCNL DCSP  DCSP image = tf.sub(image, 0.5) DCNL DCSP  DCSP image = tf.mul(image, 2.0) DCNL DCSP  DCSP return image
 DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP if siteconfig.get(u'mail_send_new_user_mail'): DCNL DCSP  DCSP mail_new_user(user)
 DCSP if (path is None): DCNL DCSP  DCSP path = os.path.join(os.path.dirname(__file__), os.pardir) DCNL DCSP elif os.path.isfile(path): DCNL DCSP  DCSP path = os.path.dirname(path) DCNL DCSP source_dir = os.path.abspath(path) DCNL DCSP return os.path.exists(os.path.join(source_dir, '.astropy-root'))
 DCSP print ('Converting DCSP data DCSP into DCSP %s DCSP ...' % filename) DCNL DCSP cwd = os.getcwd() DCNL DCSP writer = tf.python_io.TFRecordWriter(filename) DCNL DCSP for (index, img) in enumerate(images): DCNL DCSP  DCSP img_raw = img.tobytes() DCNL DCSP  DCSP label = int(labels[index]) DCNL DCSP  DCSP example = tf.train.Example(features=tf.train.Features(feature={'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[label])), 'img_raw': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw]))})) DCNL DCSP  DCSP writer.write(example.SerializeToString()) DCNL DCSP writer.close()
 DCSP new_fd = False DCNL DCSP if isinstance(f, str): DCNL DCSP  DCSP new_fd = True DCNL DCSP  DCSP f = open(f, 'wb') DCNL DCSP try: DCNL DCSP  DCSP return _save(obj, f, pickle_module, pickle_protocol) DCNL DCSP finally: DCNL DCSP  DCSP if new_fd: DCNL DCSP  DCSP  DCSP f.close()
 DCSP size = len(list1) DCNL DCSP sum1 = sum(list1) DCNL DCSP sum2 = sum(list2) DCNL DCSP sum_sq1 = sum([pow(l, 2) for l in list1]) DCNL DCSP sum_sq2 = sum([pow(l, 2) for l in list2]) DCNL DCSP prod_sum = sum([(list1[i] * list2[i]) for i in range(size)]) DCNL DCSP num = (prod_sum - ((sum1 * sum2) / float(size))) DCNL DCSP den = sqrt(((sum_sq1 - (pow(sum1, 2.0) / size)) * (sum_sq2 - (pow(sum2, 2.0) / size)))) DCNL DCSP return (num / den)
 DCSP _initialize() DCNL DCSP _interact() DCNL DCSP d = GetNewDialog(id, (-1)) DCNL DCSP if (not d): DCNL DCSP  DCSP print "EasyDialogs: DCSP Can't DCSP get DCSP DLOG DCSP resource DCSP with DCSP id DCSP =", id, ' DCSP (missing DCSP resource DCSP file?)' DCNL DCSP  DCSP return DCNL DCSP h = d.GetDialogItemAsControl(3) DCNL DCSP SetDialogItemText(h, lf2cr(prompt)) DCNL DCSP h = d.GetDialogItemAsControl(4) DCNL DCSP SetDialogItemText(h, lf2cr(default)) DCNL DCSP d.SelectDialogItemText(4, 0, 999) DCNL DCSP if (ok is not None): DCNL DCSP  DCSP h = d.GetDialogItemAsControl(1) DCNL DCSP  DCSP h.SetControlTitle(ok) DCNL DCSP if (cancel is not None): DCNL DCSP  DCSP h = d.GetDialogItemAsControl(2) DCNL DCSP  DCSP h.SetControlTitle(cancel) DCNL DCSP d.SetDialogDefaultItem(1) DCNL DCSP d.SetDialogCancelItem(2) DCNL DCSP d.AutoSizeDialog() DCNL DCSP d.GetDialogWindow().ShowWindow() DCNL DCSP while 1: DCNL DCSP  DCSP n = ModalDialog(None) DCNL DCSP  DCSP if (n == 1): DCNL DCSP  DCSP  DCSP h = d.GetDialogItemAsControl(4) DCNL DCSP  DCSP  DCSP return cr2lf(GetDialogItemText(h)) DCNL DCSP  DCSP if (n == 2): DCNL DCSP  DCSP  DCSP return None
 DCSP for fmt in formats.available: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if fmt.detect(stream): DCNL DCSP  DCSP  DCSP  DCSP return (fmt, stream) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return (None, stream)
 DCSP if ('neutron/tests' in filename): DCNL DCSP  DCSP return DCNL DCSP if pep8.noqa(physical_line): DCNL DCSP  DCSP return DCNL DCSP msg = 'N320: DCSP Log DCSP messages DCSP require DCSP translation DCSP hints!' DCNL DCSP if log_translation_hint.match(logical_line): DCNL DCSP  DCSP (yield (0, msg))
 DCSP newfiles = [] DCNL DCSP bufsize = ((24 * 1024) * 1024) DCNL DCSP joinable_sets = {} DCNL DCSP joinable_set = None DCNL DCSP for joinable in joinables: DCNL DCSP  DCSP (head, tail) = os.path.splitext(joinable) DCNL DCSP  DCSP if (tail == '.ts'): DCNL DCSP  DCSP  DCSP head = match_ts(joinable)[1] DCNL DCSP  DCSP if (head not in joinable_sets): DCNL DCSP  DCSP  DCSP joinable_sets[head] = [] DCNL DCSP  DCSP joinable_sets[head].append(joinable) DCNL DCSP logging.debug('joinable_sets: DCSP %s', joinable_sets) DCNL DCSP try: DCNL DCSP  DCSP for joinable_set in joinable_sets: DCNL DCSP  DCSP  DCSP current = joinable_sets[joinable_set] DCNL DCSP  DCSP  DCSP joinable_sets[joinable_set].sort() DCNL DCSP  DCSP  DCSP if os.path.exists(joinable_set): DCNL DCSP  DCSP  DCSP  DCSP logging.debug('file_join(): DCSP Skipping DCSP %s, DCSP (probably) DCSP joined DCSP by DCSP par2', joinable_set) DCNL DCSP  DCSP  DCSP  DCSP if delete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP clean_up_joinables(current) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP size = len(current) DCNL DCSP  DCSP  DCSP if (size < 2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP filename = joinable_set DCNL DCSP  DCSP  DCSP if workdir_complete: DCNL DCSP  DCSP  DCSP  DCSP filename = filename.replace(workdir, workdir_complete) DCNL DCSP  DCSP  DCSP logging.debug('file_join(): DCSP Assembling DCSP %s', filename) DCNL DCSP  DCSP  DCSP joined_file = open(filename, 'ab') DCNL DCSP  DCSP  DCSP n = get_seq_number(current[0]) DCNL DCSP  DCSP  DCSP seq_error = (n > 1) DCNL DCSP  DCSP  DCSP for joinable in current: DCNL DCSP  DCSP  DCSP  DCSP if (get_seq_number(joinable) != n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seq_error = True DCNL DCSP  DCSP  DCSP  DCSP perc = ((100.0 / size) * n) DCNL DCSP  DCSP  DCSP  DCSP logging.debug('Processing DCSP %s', joinable) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_action_line(T('Joining'), ('%.0f%%' % perc)) DCNL DCSP  DCSP  DCSP  DCSP f = open(joinable, 'rb') DCNL DCSP  DCSP  DCSP  DCSP shutil.copyfileobj(f, joined_file, bufsize) DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP if delete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.debug('Deleting DCSP %s', joinable) DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.remove(joinable) DCNL DCSP  DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP  DCSP clean_up_joinables(current) DCNL DCSP  DCSP  DCSP joined_file.flush() DCNL DCSP  DCSP  DCSP joined_file.close() DCNL DCSP  DCSP  DCSP newfiles.append(filename) DCNL DCSP  DCSP  DCSP if seq_error: DCNL DCSP  DCSP  DCSP  DCSP msg = T('Incomplete DCSP sequence DCSP of DCSP joinable DCSP files') DCNL DCSP  DCSP  DCSP  DCSP nzo.fail_msg = (T('File DCSP join DCSP of DCSP %s DCSP failed') % unicoder(joinable_set)) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_unpack_info('Filejoin', (T('[%s] DCSP Error DCSP "%s" DCSP while DCSP joining DCSP files') % (unicoder(joinable_set), msg))) DCNL DCSP  DCSP  DCSP  DCSP logging.error(T('Error DCSP "%s" DCSP while DCSP running DCSP file_join DCSP on DCSP %s'), msg, nzo.final_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = (T('[%s] DCSP Joined DCSP %s DCSP files') % (unicoder(joinable_set), size)) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_unpack_info('Filejoin', msg, set=joinable_set) DCNL DCSP except: DCNL DCSP  DCSP msg = sys.exc_info()[1] DCNL DCSP  DCSP nzo.fail_msg = (T('File DCSP join DCSP of DCSP %s DCSP failed') % msg) DCNL DCSP  DCSP nzo.set_unpack_info('Filejoin', (T('[%s] DCSP Error DCSP "%s" DCSP while DCSP joining DCSP files') % (unicoder(joinable_set), msg))) DCNL DCSP  DCSP logging.error(T('Error DCSP "%s" DCSP while DCSP running DCSP file_join DCSP on DCSP %s'), msg, nzo.final_name) DCNL DCSP  DCSP return (True, []) DCNL DCSP return (False, newfiles)
 DCSP if (not isinstance(client_id, basestring)): DCNL DCSP  DCSP raise InvalidChannelClientIdError(('"%s" DCSP is DCSP not DCSP a DCSP string.' % client_id)) DCNL DCSP if isinstance(client_id, unicode): DCNL DCSP  DCSP client_id = client_id.encode('utf-8') DCNL DCSP if (len(client_id) > MAXIMUM_CLIENT_ID_LENGTH): DCNL DCSP  DCSP msg = ('Client DCSP id DCSP length DCSP %d DCSP is DCSP greater DCSP than DCSP max DCSP length DCSP %d' % (len(client_id), MAXIMUM_CLIENT_ID_LENGTH)) DCNL DCSP  DCSP raise InvalidChannelClientIdError(msg) DCNL DCSP return client_id
 DCSP warnings.warn('isvector DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.isvector(x, y, xi, extrap=extrap)
 DCSP if (isinstance(node.op, T.Elemwise) and isinstance(node.op.scalar_op, (theano.scalar.IntDiv, theano.scalar.TrueDiv))): DCNL DCSP  DCSP if (local_mul_canonizer.get_constant(node.inputs[0]) == 0): DCNL DCSP  DCSP  DCSP ret = broadcast_like(0, node.outputs[0], node.fgraph) DCNL DCSP  DCSP  DCSP ret.tag.values_eq_approx = values_eq_approx_remove_nan DCNL DCSP  DCSP  DCSP return [ret]
 DCSP def one(): DCNL DCSP  DCSP return a DCNL DCSP def two(): DCNL DCSP  DCSP return b DCNL DCSP def three(): DCNL DCSP  DCSP return c DCNL DCSP def new_closure(a, b): DCNL DCSP  DCSP def sum(): DCNL DCSP  DCSP  DCSP return (a + b) DCNL DCSP  DCSP return sum DCNL DCSP (yield one) DCNL DCSP (yield two) DCNL DCSP (yield three) DCNL DCSP (yield new_closure(a, c))
 DCSP if use_sfftools: DCNL DCSP  DCSP _fail_on_gzipped_sff(sff_fp) DCNL DCSP  DCSP check_sffinfo() DCNL DCSP  DCSP if no_trim: DCNL DCSP  DCSP  DCSP _check_call(['sffinfo', '-notrim', '-s', sff_fp], stdout=open(output_fp, 'w')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _check_call(['sffinfo', '-s', sff_fp], stdout=open(output_fp, 'w')) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP format_binary_sff_as_fna(qiime_open(sff_fp, 'rb'), open(output_fp, 'w')) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise IOError(('Could DCSP not DCSP parse DCSP SFF DCSP %s' % sff_fp))
 DCSP logger.debug('worker DCSP process DCSP entering DCSP E-step DCSP loop') DCNL DCSP while True: DCNL DCSP  DCSP logger.debug('getting DCSP a DCSP new DCSP job') DCNL DCSP  DCSP (chunk_no, chunk, worker_lda) = input_queue.get() DCNL DCSP  DCSP logger.debug('processing DCSP chunk DCSP #%i DCSP of DCSP %i DCSP documents', chunk_no, len(chunk)) DCNL DCSP  DCSP worker_lda.state.reset() DCNL DCSP  DCSP worker_lda.do_estep(chunk) DCNL DCSP  DCSP del chunk DCNL DCSP  DCSP logger.debug('processed DCSP chunk, DCSP queuing DCSP the DCSP result') DCNL DCSP  DCSP result_queue.put(worker_lda.state) DCNL DCSP  DCSP del worker_lda DCNL DCSP  DCSP logger.debug('result DCSP put')
 DCSP from sklearn.base import clone DCNL DCSP estimators_ = list() DCNL DCSP for ii in range(X.shape[(-1)]): DCNL DCSP  DCSP est = clone(estimator) DCNL DCSP  DCSP est.fit(X[..., ii], y) DCNL DCSP  DCSP estimators_.append(est) DCNL DCSP return estimators_
 DCSP if (not isinstance(t, TensExpr)): DCNL DCSP  DCSP return t DCNL DCSP new_tids = get_tids(t).perm2tensor(g, canon_bp) DCNL DCSP coeff = get_coeff(t) DCNL DCSP if (g[(-1)] != (len(g) - 1)): DCNL DCSP  DCSP coeff = (- coeff) DCNL DCSP res = TensMul.from_TIDS(coeff, new_tids, is_canon_bp=canon_bp) DCNL DCSP return res
 DCSP r_url = get_results_raw_url(build) DCNL DCSP if (not r_url): DCNL DCSP  DCSP return DCNL DCSP return convert_json_to_df(r_url)
 DCSP import hashlib DCNL DCSP m = hashlib.md5() DCNL DCSP m.update(f) DCNL DCSP return m.hexdigest()
 DCSP from sklearn.linear_model import Ridge, LogisticRegression DCNL DCSP from sklearn.pipeline import make_pipeline DCNL DCSP from sklearn.metrics import roc_auc_score, get_scorer, make_scorer DCNL DCSP (X, y) = make_data() DCNL DCSP (n_epochs, _, n_time) = X.shape DCNL DCSP assert_raises(ValueError, _SearchLight, 'foo') DCNL DCSP sl = _SearchLight(Ridge()) DCNL DCSP sl = _SearchLight(LogisticRegression()) DCNL DCSP assert_equal(sl.__repr__()[:14], '<_SearchLight(') DCNL DCSP sl.fit(X, y) DCNL DCSP assert_equal(sl.__repr__()[(-28):], ', DCSP fitted DCSP with DCSP 10 DCSP estimators>') DCNL DCSP assert_raises(ValueError, sl.fit, X[1:], y) DCNL DCSP assert_raises(ValueError, sl.fit, X[:, :, 0], y) DCNL DCSP assert_raises(ValueError, sl.predict, X[:, :, :2]) DCNL DCSP y_pred = sl.predict(X) DCNL DCSP assert_true((y_pred.dtype == int)) DCNL DCSP assert_array_equal(y_pred.shape, [n_epochs, n_time]) DCNL DCSP y_proba = sl.predict_proba(X) DCNL DCSP assert_true((y_proba.dtype == float)) DCNL DCSP assert_array_equal(y_proba.shape, [n_epochs, n_time, 2]) DCNL DCSP score = sl.score(X, y) DCNL DCSP assert_array_equal(score.shape, [n_time]) DCNL DCSP assert_true((np.sum(np.abs(score)) != 0)) DCNL DCSP assert_true((score.dtype == float)) DCNL DCSP sl = _SearchLight(LogisticRegression()) DCNL DCSP assert_equal(sl.scoring, None) DCNL DCSP for (err, scoring) in [(ValueError, 'foo'), (TypeError, 999)]: DCNL DCSP  DCSP sl = _SearchLight(LogisticRegression(), scoring=scoring) DCNL DCSP  DCSP sl.fit(X, y) DCNL DCSP  DCSP assert_raises(err, sl.score, X, y) DCNL DCSP sl = _SearchLight(LogisticRegression(), scoring='roc_auc') DCNL DCSP y = (np.arange(len(X)) % 3) DCNL DCSP sl.fit(X, y) DCNL DCSP assert_raises(ValueError, sl.score, X, y) DCNL DCSP y = ((np.arange(len(X)) % 2) + 1) DCNL DCSP sl.fit(X, y) DCNL DCSP score = sl.score(X, y) DCNL DCSP assert_array_equal(score, [roc_auc_score((y - 1), (_y_pred - 1)) for _y_pred in sl.decision_function(X).T]) DCNL DCSP y = (np.arange(len(X)) % 2) DCNL DCSP for (method, scoring) in [('predict_proba', 'roc_auc'), ('predict', roc_auc_score)]: DCNL DCSP  DCSP sl1 = _SearchLight(LogisticRegression(), scoring=scoring) DCNL DCSP  DCSP sl1.fit(X, y) DCNL DCSP  DCSP np.random.seed(0) DCNL DCSP  DCSP X = np.random.randn(*X.shape) DCNL DCSP  DCSP score_sl = sl1.score(X, y) DCNL DCSP  DCSP assert_array_equal(score_sl.shape, [n_time]) DCNL DCSP  DCSP assert_true((score_sl.dtype == float)) DCNL DCSP  DCSP if isinstance(scoring, str): DCNL DCSP  DCSP  DCSP scoring = get_scorer(scoring) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scoring = make_scorer(scoring) DCNL DCSP  DCSP score_manual = [scoring(est, x, y) for (est, x) in zip(sl1.estimators_, X.transpose(2, 0, 1))] DCNL DCSP  DCSP assert_array_equal(score_manual, score_sl) DCNL DCSP sl = _SearchLight(LogisticRegression(), n_jobs=2) DCNL DCSP sl.fit(X, y) DCNL DCSP sl.predict(X) DCNL DCSP sl.score(X, y) DCNL DCSP sl.fit(X[..., [0]], y) DCNL DCSP sl.predict(X[..., [0]]) DCNL DCSP class _LogRegTransformer(LogisticRegression, ): DCNL DCSP  DCSP def transform(self, X): DCNL DCSP  DCSP  DCSP return super(_LogRegTransformer, self).predict_proba(X)[..., 1] DCNL DCSP pipe = make_pipeline(_SearchLight(_LogRegTransformer()), LogisticRegression()) DCNL DCSP pipe.fit(X, y) DCNL DCSP pipe.predict(X) DCNL DCSP X = np.random.rand(10, 3, 4, 2) DCNL DCSP y = (np.arange(10) % 2) DCNL DCSP y_preds = list() DCNL DCSP for n_jobs in [1, 2]: DCNL DCSP  DCSP pipe = _SearchLight(make_pipeline(Vectorizer(), LogisticRegression()), n_jobs=n_jobs) DCNL DCSP  DCSP y_preds.append(pipe.fit(X, y).predict(X)) DCNL DCSP  DCSP features_shape = pipe.estimators_[0].steps[0][1].features_shape_ DCNL DCSP  DCSP assert_array_equal(features_shape, [3, 4]) DCNL DCSP assert_array_equal(y_preds[0], y_preds[1])
 DCSP ret = {} DCNL DCSP index = 0 DCNL DCSP if (not (output and template)): DCNL DCSP  DCSP return ret DCNL DCSP if ('translate' in template): DCNL DCSP  DCSP ret = _translate_output(output) DCNL DCSP else: DCNL DCSP  DCSP output_list = output.strip().replace('\n', '').split(' DCSP ') DCNL DCSP  DCSP if (sum(template.values()) != len(output_list)): DCNL DCSP  DCSP  DCSP raise ipmiexcept.IPMIException(_('ipmitool DCSP output DCSP length DCSP mismatch')) DCNL DCSP  DCSP for item in template.items(): DCNL DCSP  DCSP  DCSP index_end = (index + item[1]) DCNL DCSP  DCSP  DCSP update_value = output_list[index:index_end] DCNL DCSP  DCSP  DCSP ret[item[0]] = update_value DCNL DCSP  DCSP  DCSP index = index_end DCNL DCSP return ret
 DCSP if (x.tzinfo is None): DCNL DCSP  DCSP x = x.replace(tzinfo=utc) DCNL DCSP if hasattr(x, 'timestamp'): DCNL DCSP  DCSP return x.timestamp() DCNL DCSP else: DCNL DCSP  DCSP return (x - datetime(1970, 1, 1, tzinfo=utc)).total_seconds()
 DCSP sa_session = app.model.context.current DCNL DCSP repository = sa_session.query(app.model.Repository).get(decoded_repository_id) DCNL DCSP repo = hg_util.get_repo_for_repository(app, repository=repository, repo_path=None, create=False) DCNL DCSP if downloadable: DCNL DCSP  DCSP changeset_revision = get_latest_downloadable_changeset_revision(app, repository, repo) DCNL DCSP else: DCNL DCSP  DCSP changeset_revision = get_latest_changeset_revision(app, repository, repo) DCNL DCSP return get_repository_metadata_by_changeset_revision(app, app.security.encode_id(repository.id), changeset_revision)
 DCSP schema = vol.Schema(cv.string) DCNL DCSP with pytest.raises(vol.MultipleInvalid): DCNL DCSP  DCSP schema(None) DCNL DCSP for value in (True, 1, 'hello'): DCNL DCSP  DCSP schema(value)
 DCSP results = (yield gen.Task(ListAllKeys, store, prefix=PrefixFromPattern(pattern))) DCNL DCSP callback(results)
 DCSP if (markers[1] == ''): DCNL DCSP  DCSP return _extract_doc_comment_simple(content, line, column, markers) DCNL DCSP elif (markers[1] == markers[2]): DCNL DCSP  DCSP return _extract_doc_comment_continuous(content, line, column, markers) DCNL DCSP else: DCNL DCSP  DCSP return _extract_doc_comment_standard(content, line, column, markers)
 DCSP if isinstance(date_time, (int, float)): DCNL DCSP  DCSP tt = time.localtime(date_time) DCNL DCSP elif isinstance(date_time, (tuple, time.struct_time)): DCNL DCSP  DCSP tt = date_time DCNL DCSP elif (isinstance(date_time, str) and ((date_time[0], date_time[(-1)]) == ('"', '"'))): DCNL DCSP  DCSP return date_time DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('date_time DCSP not DCSP of DCSP a DCSP known DCSP type') DCNL DCSP dt = time.strftime('%d-%b-%Y DCSP %H:%M:%S', tt) DCNL DCSP if (dt[0] == '0'): DCNL DCSP  DCSP dt = (' DCSP ' + dt[1:]) DCNL DCSP if (time.daylight and tt[(-1)]): DCNL DCSP  DCSP zone = (- time.altzone) DCNL DCSP else: DCNL DCSP  DCSP zone = (- time.timezone) DCNL DCSP return ((('"' + dt) + (' DCSP %+03d%02d' % divmod((zone // 60), 60))) + '"')
 DCSP assert isinstance(s, basestring) DCNL DCSP sdr = [int(c) for c in s if (c in ('0', '1'))] DCNL DCSP if (len(sdr) != len(s)): DCNL DCSP  DCSP raise ValueError("The DCSP provided DCSP string DCSP %s DCSP is DCSP malformed. DCSP The DCSP string DCSP should DCSP have DCSP only DCSP 0's DCSP and DCSP 1's.") DCNL DCSP return sdr
 DCSP if (not path): DCNL DCSP  DCSP raise ValueError('no DCSP path DCSP specified') DCNL DCSP startList = os.path.abspath(start).split(os.path.sep) DCNL DCSP pathList = os.path.abspath(path).split(os.path.sep) DCNL DCSP i = len(os.path.commonprefix([startList, pathList])) DCNL DCSP relList = ((['..'] * (len(startList) - i)) + pathList[i:]) DCNL DCSP if (not relList): DCNL DCSP  DCSP return path DCNL DCSP return os.path.join(*relList)
 DCSP pkg_list = [pkg for pkg in pkg_list if (not is_installed(pkg))] DCNL DCSP if pkg_list: DCNL DCSP  DCSP install(pkg_list, update)
 DCSP return ('mirror_' + six.text_type(volume.id))
 DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP floating_ip_create DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function') DCNL DCSP if ('pool' not in kwargs): DCNL DCSP  DCSP log.error('pool DCSP is DCSP required') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP return conn.floating_ip_create(kwargs['pool'])
 DCSP query = RevisionMetricsMappingType.search().facet('creator_id', filtered=True, size=BIG_NUMBER) DCNL DCSP if (locale is None): DCNL DCSP  DCSP query = query.filter((~ F(locale=settings.WIKI_DEFAULT_LANGUAGE))) DCNL DCSP query = _apply_filters(query, start, end, locale, product) DCNL DCSP return _get_creator_counts(query, count, page)
 DCSP numpy.testing.assert_array_max_ulp(cupy.asnumpy(a), cupy.asnumpy(b), maxulp=maxulp, dtype=dtype)
 DCSP course_key = CourseKey.from_string(course_key_string) DCNL DCSP if (not has_course_author_access(request.user, course_key)): DCNL DCSP  DCSP raise PermissionDenied() DCNL DCSP response_format = (request.GET.get('format') or request.POST.get('format') or 'html') DCNL DCSP if ((response_format == 'json') or ('application/json' in request.META.get('HTTP_ACCEPT', 'application/json'))): DCNL DCSP  DCSP if (request.method == 'GET'): DCNL DCSP  DCSP  DCSP return _assets_json(request, course_key) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP asset_key = (AssetKey.from_string(asset_key_string) if asset_key_string else None) DCNL DCSP  DCSP  DCSP return _update_asset(request, course_key, asset_key) DCNL DCSP elif (request.method == 'GET'): DCNL DCSP  DCSP return _asset_index(request, course_key) DCNL DCSP else: DCNL DCSP  DCSP return HttpResponseNotFound()
 DCSP if (polyorder >= window_length): DCNL DCSP  DCSP raise ValueError('polyorder DCSP must DCSP be DCSP less DCSP than DCSP window_length.') DCNL DCSP (halflen, rem) = divmod(window_length, 2) DCNL DCSP if (rem == 0): DCNL DCSP  DCSP raise ValueError('window_length DCSP must DCSP be DCSP odd.') DCNL DCSP if (pos is None): DCNL DCSP  DCSP pos = halflen DCNL DCSP if (not (0 <= pos < window_length)): DCNL DCSP  DCSP raise ValueError('pos DCSP must DCSP be DCSP nonnegative DCSP and DCSP less DCSP than DCSP window_length.') DCNL DCSP if (use not in ['conv', 'dot']): DCNL DCSP  DCSP raise ValueError("`use` DCSP must DCSP be DCSP 'conv' DCSP or DCSP 'dot'") DCNL DCSP x = np.arange((- pos), (window_length - pos), dtype=float) DCNL DCSP if (use == 'conv'): DCNL DCSP  DCSP x = x[::(-1)] DCNL DCSP order = np.arange((polyorder + 1)).reshape((-1), 1) DCNL DCSP A = (x ** order) DCNL DCSP y = np.zeros((polyorder + 1)) DCNL DCSP y[deriv] = (factorial(deriv) / (delta ** deriv)) DCNL DCSP (coeffs, _, _, _) = lstsq(A, y) DCNL DCSP return coeffs
 DCSP clamav = XML.SubElement(xml_parent, 'org.jenkinsci.plugins.clamav.ClamAvRecorder') DCNL DCSP clamav.set('plugin', 'clamav') DCNL DCSP mappings = [('includes', 'includes', ''), ('excludes', 'excludes', '')] DCNL DCSP helpers.convert_mapping_to_xml(clamav, data, mappings, fail_required=True)
 DCSP if salt.utils.which('nft'): DCNL DCSP  DCSP return 'nftables' DCNL DCSP return (False, 'The DCSP nftables DCSP execution DCSP module DCSP failed DCSP to DCSP load: DCSP nftables DCSP is DCSP not DCSP installed.')
 DCSP master_tipnames = set(master.getTipNames()) DCNL DCSP subsampled_tree_trimmed = copy.deepcopy(subsampled_tree) DCNL DCSP def delete_test(node): DCNL DCSP  DCSP if (not node.isTip()): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (node.Name not in master_tipnames) DCNL DCSP subsampled_tree_trimmed.removeDeleted(delete_test) DCNL DCSP subsampled_tree_trimmed.prune() DCNL DCSP subsampled_tree_nodes_names = [] DCNL DCSP for node in subsampled_tree_trimmed.iterNontips(include_self=True): DCNL DCSP  DCSP subsampled_tree_nodes_names.append(node.getTipNames()) DCNL DCSP subsampled_tree_nodes_names = map(set, subsampled_tree_nodes_names) DCNL DCSP for master_node in master.iterNontips(include_self=True): DCNL DCSP  DCSP if (set(master_node.getTipNames()) in subsampled_tree_nodes_names): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP master_node.bootstrap_support += 1 DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP master_node.bootstrap_support = 1
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP register_swift_info('formpost') DCNL DCSP return (lambda app: FormPost(app, conf))
 DCSP if throttle: DCNL DCSP  DCSP Waiter() DCNL DCSP if params: DCNL DCSP  DCSP url = ('%s/%s?%s' % (DLCS_API, path, urllib.urlencode(dict0(params)))) DCNL DCSP else: DCNL DCSP  DCSP url = ('%s/%s' % (DLCS_API, path)) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print >>sys.stderr, ('dlcs_api_request: DCSP %s' % url) DCNL DCSP try: DCNL DCSP  DCSP return http_auth_request(url, DLCS_API_HOST, user, passwd, USER_AGENT) DCNL DCSP except DefaultErrorHandler as e: DCNL DCSP  DCSP print >>sys.stderr, ('%s' % e)
 DCSP import functools DCNL DCSP import mpmath DCNL DCSP def func_wrapper(*args, **kwargs): DCNL DCSP  DCSP dps = mpmath.mp.dps DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP mpmath.mp.dps = dps DCNL DCSP func_wrapper = functools.update_wrapper(func_wrapper, func) DCNL DCSP return func_wrapper
 DCSP for repo in repos: DCNL DCSP  DCSP if fnmatch(path, repo): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP x0 = np.asarray(x0) DCNL DCSP if (x0.dtype.kind in np.typecodes['AllInteger']): DCNL DCSP  DCSP x0 = np.asarray(x0, dtype=float) DCNL DCSP if (not isinstance(args, tuple)): DCNL DCSP  DCSP args = (args,) DCNL DCSP if (method is None): DCNL DCSP  DCSP if constraints: DCNL DCSP  DCSP  DCSP method = 'SLSQP' DCNL DCSP  DCSP elif (bounds is not None): DCNL DCSP  DCSP  DCSP method = 'L-BFGS-B' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP method = 'BFGS' DCNL DCSP if callable(method): DCNL DCSP  DCSP meth = '_custom' DCNL DCSP else: DCNL DCSP  DCSP meth = method.lower() DCNL DCSP if (options is None): DCNL DCSP  DCSP options = {} DCNL DCSP if ((meth in ['nelder-mead', 'powell', 'cobyla']) and bool(jac)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP does DCSP not DCSP use DCSP gradient DCSP information DCSP (jac).' % method), RuntimeWarning) DCNL DCSP if ((meth not in ('newton-cg', 'dogleg', 'trust-ncg', '_custom')) and (hess is not None)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP does DCSP not DCSP use DCSP Hessian DCSP information DCSP (hess).' % method), RuntimeWarning) DCNL DCSP if ((meth not in ('newton-cg', 'dogleg', 'trust-ncg', '_custom')) and (hessp is not None)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP does DCSP not DCSP use DCSP Hessian-vector DCSP product DCSP information DCSP (hessp).' % method), RuntimeWarning) DCNL DCSP if ((meth in ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg', 'dogleg', 'trust-ncg']) and ((bounds is not None) or np.any(constraints))): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP cannot DCSP handle DCSP constraints DCSP nor DCSP bounds.' % method), RuntimeWarning) DCNL DCSP if ((meth in ['l-bfgs-b', 'tnc']) and np.any(constraints)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP cannot DCSP handle DCSP constraints.' % method), RuntimeWarning) DCNL DCSP if ((meth == 'cobyla') and (bounds is not None)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP cannot DCSP handle DCSP bounds.' % method), RuntimeWarning) DCNL DCSP if ((meth in ['cobyla']) and (callback is not None)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP does DCSP not DCSP support DCSP callback.' % method), RuntimeWarning) DCNL DCSP if ((meth in ['l-bfgs-b', 'tnc', 'cobyla', 'slsqp']) and options.get('return_all', False)): DCNL DCSP  DCSP warn(('Method DCSP %s DCSP does DCSP not DCSP support DCSP the DCSP return_all DCSP option.' % method), RuntimeWarning) DCNL DCSP if (not callable(jac)): DCNL DCSP  DCSP if bool(jac): DCNL DCSP  DCSP  DCSP fun = MemoizeJac(fun) DCNL DCSP  DCSP  DCSP jac = fun.derivative DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP jac = None DCNL DCSP if (tol is not None): DCNL DCSP  DCSP options = dict(options) DCNL DCSP  DCSP if (meth == 'nelder-mead'): DCNL DCSP  DCSP  DCSP options.setdefault('xatol', tol) DCNL DCSP  DCSP  DCSP options.setdefault('fatol', tol) DCNL DCSP  DCSP if (meth in ['newton-cg', 'powell', 'tnc']): DCNL DCSP  DCSP  DCSP options.setdefault('xtol', tol) DCNL DCSP  DCSP if (meth in ['powell', 'l-bfgs-b', 'tnc', 'slsqp']): DCNL DCSP  DCSP  DCSP options.setdefault('ftol', tol) DCNL DCSP  DCSP if (meth in ['bfgs', 'cg', 'l-bfgs-b', 'tnc', 'dogleg', 'trust-ncg']): DCNL DCSP  DCSP  DCSP options.setdefault('gtol', tol) DCNL DCSP  DCSP if (meth in ['cobyla', '_custom']): DCNL DCSP  DCSP  DCSP options.setdefault('tol', tol) DCNL DCSP if (meth == '_custom'): DCNL DCSP  DCSP return method(fun, x0, args=args, jac=jac, hess=hess, hessp=hessp, bounds=bounds, constraints=constraints, callback=callback, **options) DCNL DCSP elif (meth == 'nelder-mead'): DCNL DCSP  DCSP return _minimize_neldermead(fun, x0, args, callback, **options) DCNL DCSP elif (meth == 'powell'): DCNL DCSP  DCSP return _minimize_powell(fun, x0, args, callback, **options) DCNL DCSP elif (meth == 'cg'): DCNL DCSP  DCSP return _minimize_cg(fun, x0, args, jac, callback, **options) DCNL DCSP elif (meth == 'bfgs'): DCNL DCSP  DCSP return _minimize_bfgs(fun, x0, args, jac, callback, **options) DCNL DCSP elif (meth == 'newton-cg'): DCNL DCSP  DCSP return _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback, **options) DCNL DCSP elif (meth == 'l-bfgs-b'): DCNL DCSP  DCSP return _minimize_lbfgsb(fun, x0, args, jac, bounds, callback=callback, **options) DCNL DCSP elif (meth == 'tnc'): DCNL DCSP  DCSP return _minimize_tnc(fun, x0, args, jac, bounds, callback=callback, **options) DCNL DCSP elif (meth == 'cobyla'): DCNL DCSP  DCSP return _minimize_cobyla(fun, x0, args, constraints, **options) DCNL DCSP elif (meth == 'slsqp'): DCNL DCSP  DCSP return _minimize_slsqp(fun, x0, args, jac, bounds, constraints, callback=callback, **options) DCNL DCSP elif (meth == 'dogleg'): DCNL DCSP  DCSP return _minimize_dogleg(fun, x0, args, jac, hess, callback=callback, **options) DCNL DCSP elif (meth == 'trust-ncg'): DCNL DCSP  DCSP return _minimize_trust_ncg(fun, x0, args, jac, hess, hessp, callback=callback, **options) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP solver DCSP %s' % method))
 DCSP x = hp.uniform('x', (-15), 15) DCNL DCSP f1 = old_div(1.0, (1.0 + scope.exp((- x)))) DCNL DCSP f2 = (2 * scope.exp((- ((x + 10) ** 2)))) DCNL DCSP return {'loss': ((- f1) - f2), 'status': base.STATUS_OK}
 DCSP current = node DCNL DCSP while (current and (not isinstance(current.parent, astroid.ExceptHandler))): DCNL DCSP  DCSP current = current.parent DCNL DCSP return (current and (current is current.parent.name))
 DCSP if ((not skipkeys) and ensure_ascii and check_circular and allow_nan and (cls is None) and (indent is None) and (separators is None) and (encoding == 'utf-8') and (default is None) and (not kw)): DCNL DCSP  DCSP iterable = _default_encoder.iterencode(obj) DCNL DCSP else: DCNL DCSP  DCSP if (cls is None): DCNL DCSP  DCSP  DCSP cls = JSONEncoder DCNL DCSP  DCSP iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, use_decimal=use_decimal, **kw).iterencode(obj) DCNL DCSP for chunk in iterable: DCNL DCSP  DCSP fp.write(chunk)
 DCSP seen_names = set() DCNL DCSP if prefix: DCNL DCSP  DCSP prefix += '.' DCNL DCSP for d in (_hy_macros, _hy_reader): DCNL DCSP  DCSP for (name, macro) in d[source_module].items(): DCNL DCSP  DCSP  DCSP seen_names.add(name) DCNL DCSP  DCSP  DCSP if all_macros: DCNL DCSP  DCSP  DCSP  DCSP d[target_module][(prefix + name)] = macro DCNL DCSP  DCSP  DCSP elif (name in assignments): DCNL DCSP  DCSP  DCSP  DCSP d[target_module][(prefix + assignments[name])] = macro DCNL DCSP if (not all_macros): DCNL DCSP  DCSP unseen = frozenset(assignments.keys()).difference(seen_names) DCNL DCSP  DCSP if unseen: DCNL DCSP  DCSP  DCSP raise ImportError(('cannot DCSP require DCSP names: DCSP ' + repr(list(unseen))))
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_get_state', None) or _Cfunction('libvlc_media_list_player_get_state', ((1,),), None, State, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP pre = ('\n DCSP  DCSP  DCSP  DCSP py_%(name)s DCSP = DCSP Py_None;\n DCSP  DCSP  DCSP  DCSP {Py_XINCREF(py_%(name)s);}\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP return (pre + r.type.c_init(name, sub))
 DCSP np = import_module('numpy') DCNL DCSP if isinstance(x, (int, float)): DCNL DCSP  DCSP return interval(np.exp(x), np.exp(x)) DCNL DCSP elif isinstance(x, interval): DCNL DCSP  DCSP return interval(np.exp(x.start), np.exp(x.end), is_valid=x.is_valid) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError
 DCSP infos = {} DCNL DCSP fullinfos = {} DCNL DCSP data = spec.get('fullvalue', spec['value']).split(None, 1) DCNL DCSP if data[1:]: DCNL DCSP  DCSP if (data[0].lower() == 'basic'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (infos['username'], infos['password']) = ''.join(data[1].strip()).decode('base64').decode('latin-1').split(':', 1) DCNL DCSP  DCSP  DCSP  DCSP for field in ['username', 'password']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(infos[field]) > utils.MAXVALLEN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fullinfos[field] = infos[field] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP infos[field] = infos[field][:utils.MAXVALLEN] DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (data[0].lower() == 'digest'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP infos = dict(((value.split('=', 1) if ('=' in value) else [value, None]) for value in _split_digest_auth(data[1].strip()))) DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in infos.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (value.startswith('"') and value.endswith('"')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP infos[key] = value[1:(-1)] DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP res = {} DCNL DCSP if infos: DCNL DCSP  DCSP res['infos'] = infos DCNL DCSP if fullinfos: DCNL DCSP  DCSP res['fullinfos'] = fullinfos DCNL DCSP return res
 DCSP if (root_module_name in sys.modules): DCNL DCSP  DCSP return DCNL DCSP _create_module_and_parents(root_module_name) DCNL DCSP imp.load_package(root_module_name, base_path) DCNL DCSP sys.path.insert(0, os.path.join(base_path, 'site-packages'))
 DCSP return getattr(request, '_messages', [])
 DCSP l = logging.getLogger('paramiko') DCNL DCSP l.setLevel(logging.DEBUG) DCNL DCSP static.create_sc_config_dirs() DCNL DCSP lh = logging.handlers.RotatingFileHandler(static.SSH_DEBUG_FILE, maxBytes=1048576, backupCount=2) DCNL DCSP lh.setLevel(logging.DEBUG) DCNL DCSP format = (('PID: DCSP %s DCSP ' % str(static.PID)) + '%(levelname)-.3s DCSP [%(asctime)s.%(msecs)03d] DCSP thr=%(_threadid)-3d DCSP %(name)s: DCSP %(message)s') DCNL DCSP date_format = '%Y%m%d-%H:%M:%S' DCNL DCSP lh.setFormatter(logging.Formatter(format, date_format)) DCNL DCSP l.addHandler(lh)
 DCSP return IMPL.fixed_ip_get_by_host(context, host)
 DCSP X = (X.data if sp.issparse(X) else X) DCNL DCSP if (X < 0).any(): DCNL DCSP  DCSP raise ValueError(('Negative DCSP values DCSP in DCSP data DCSP passed DCSP to DCSP %s' % whom))
 DCSP initLogging(verbose=True) DCNL DCSP initExperimentPrng() DCNL DCSP @staticmethod DCNL DCSP def _mockCreate(*args, **kwargs): DCNL DCSP  DCSP kwargs.pop('implementation', None) DCNL DCSP  DCSP return CLAClassifierDiff(*args, **kwargs) DCNL DCSP CLAClassifierFactory.create = _mockCreate DCNL DCSP runExperiment(sys.argv[1:])
 DCSP call_command('refresh_scores', '--reset', '--user=system') DCNL DCSP (out, err) = capfd.readouterr() DCNL DCSP assert ('Scores DCSP for DCSP specified DCSP users DCSP were DCSP reset DCSP to DCSP 0.' in out)
 DCSP rq = Queue() DCNL DCSP abort = Event() DCNL DCSP run_download(log, rq, abort, title=title, authors=authors, identifiers=identifiers, timeout=timeout, get_best_cover=True) DCNL DCSP results = [] DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP results.append(rq.get_nowait()) DCNL DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP break DCNL DCSP cp = msprefs[u'cover_priorities'] DCNL DCSP def keygen(result): DCNL DCSP  DCSP (plugin, width, height, fmt, data) = result DCNL DCSP  DCSP return (cp.get(plugin.name, 1), (1 / (width * height))) DCNL DCSP results.sort(key=keygen) DCNL DCSP return (results[0] if results else None)
 DCSP list_map = game_map.split('\n') DCNL DCSP return [(character.decode('UTF-8') if isinstance(character, basestring) else character) for character in list_map]
 DCSP i = ('\n' + (level * ' DCSP  DCSP ')) DCNL DCSP if len(elem): DCNL DCSP  DCSP if ((not elem.text) or (not elem.text.strip())): DCNL DCSP  DCSP  DCSP elem.text = (i + ' DCSP  DCSP ') DCNL DCSP  DCSP for e in elem: DCNL DCSP  DCSP  DCSP _indent(e, (level + 1)) DCNL DCSP  DCSP  DCSP if ((not e.tail) or (not e.tail.strip())): DCNL DCSP  DCSP  DCSP  DCSP e.tail = (i + ' DCSP  DCSP ') DCNL DCSP  DCSP if ((not e.tail) or (not e.tail.strip())): DCNL DCSP  DCSP  DCSP e.tail = i DCNL DCSP elif (level and ((not elem.tail) or (not elem.tail.strip()))): DCNL DCSP  DCSP elem.tail = i
 DCSP query = ('SET DCSP GLOBAL DCSP %s DCSP = DCSP ' % mysql_quote_identifier(mysqlvar, 'vars')) DCNL DCSP try: DCNL DCSP  DCSP cursor.execute((query + '%s'), (value,)) DCNL DCSP  DCSP cursor.fetchall() DCNL DCSP  DCSP result = True DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP result = str(e) DCNL DCSP return result
 DCSP s3db.hrm_configure_pr_group_membership() DCNL DCSP table = db.pr_group_membership DCNL DCSP gtable = db.pr_group DCNL DCSP htable = s3db.hrm_human_resource DCNL DCSP s3.filter = ((((gtable.system == False) & (gtable.group_type == 3)) & (htable.type == 1)) & (htable.person_id == table.person_id)) DCNL DCSP def prep(r): DCNL DCSP  DCSP if (r.method in ('create', 'create.popup', 'update', 'update.popup')): DCNL DCSP  DCSP  DCSP person_id = get_vars.get('~.person_id', None) DCNL DCSP  DCSP  DCSP if person_id: DCNL DCSP  DCSP  DCSP  DCSP field = table.person_id DCNL DCSP  DCSP  DCSP  DCSP field.default = person_id DCNL DCSP  DCSP  DCSP  DCSP field.readable = field.writable = False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller('pr', 'group_membership', csv_stylesheet=('hrm', 'group_membership.xsl'), csv_template='group_membership') DCNL DCSP return output
 DCSP intf_type = get_interface_type(interface) DCNL DCSP if (intf_type == 'ethernet'): DCNL DCSP  DCSP command = ('show DCSP interface DCSP ' + interface) DCNL DCSP  DCSP body = execute_show_command(command, module) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP interface_table = body[0]['TABLE_interface']['ROW_interface'] DCNL DCSP  DCSP except (KeyError, AttributeError, IndexError): DCNL DCSP  DCSP  DCSP interface_table = None DCNL DCSP  DCSP if interface_table: DCNL DCSP  DCSP  DCSP state = interface_table.get('eth_bundle') DCNL DCSP  DCSP  DCSP if state: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return False
 DCSP (yield (word, sum(counts)))
 DCSP def wrapper(obj, journal, *args, **kwargs): DCNL DCSP  DCSP return journal.executeCommand(cmdClass(methodName, args, kwargs)) DCNL DCSP return wrapper
 DCSP distribution_name = CURRENT_DISTRIBUTION.name.lower() DCNL DCSP for (package_type, distribution_names) in PACKAGE_TYPE_MAP.items(): DCNL DCSP  DCSP if (distribution_name.lower() in distribution_names): DCNL DCSP  DCSP  DCSP return package_type DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unknown DCSP distribution.', distribution_name)
 DCSP if callable(lookup_view): DCNL DCSP  DCSP return lookup_view DCNL DCSP if (not isinstance(lookup_view, str)): DCNL DCSP  DCSP raise ViewDoesNotExist(("'%s' DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP a DCSP dot-notation DCSP path" % lookup_view)) DCNL DCSP (mod_name, func_name) = get_mod_func(lookup_view) DCNL DCSP if (not func_name): DCNL DCSP  DCSP raise ImportError(("Could DCSP not DCSP import DCSP '%s'. DCSP The DCSP path DCSP must DCSP be DCSP fully DCSP qualified." % lookup_view)) DCNL DCSP try: DCNL DCSP  DCSP mod = import_module(mod_name) DCNL DCSP except ImportError: DCNL DCSP  DCSP (parentmod, submod) = get_mod_func(mod_name) DCNL DCSP  DCSP if (submod and (not module_has_submodule(import_module(parentmod), submod))): DCNL DCSP  DCSP  DCSP raise ViewDoesNotExist(("Could DCSP not DCSP import DCSP '%s'. DCSP Parent DCSP module DCSP %s DCSP does DCSP not DCSP exist." % (lookup_view, mod_name))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP view_func = getattr(mod, func_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ViewDoesNotExist(("Could DCSP not DCSP import DCSP '%s'. DCSP View DCSP does DCSP not DCSP exist DCSP in DCSP module DCSP %s." % (lookup_view, mod_name))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not callable(view_func)): DCNL DCSP  DCSP  DCSP  DCSP raise ViewDoesNotExist(("Could DCSP not DCSP import DCSP '%s.%s'. DCSP View DCSP is DCSP not DCSP callable." % (mod_name, func_name))) DCNL DCSP  DCSP  DCSP return view_func
 DCSP validation = fix_addons_linter_output(validation) DCNL DCSP if is_compatibility: DCNL DCSP  DCSP mangle_compatibility_messages(validation) DCNL DCSP validation.setdefault('ending_tier', 0) DCNL DCSP if ((not validation['ending_tier']) and validation['messages']): DCNL DCSP  DCSP validation['ending_tier'] = max((msg.get('tier', (-1)) for msg in validation['messages'])) DCNL DCSP if file_hash: DCNL DCSP  DCSP ValidationComparator(validation).annotate_results(file_hash) DCNL DCSP limit_validation_results(validation) DCNL DCSP htmlify_validation(validation) DCNL DCSP return validation
 DCSP cart = Order.get_cart_for_user(request.user) DCNL DCSP (is_any_course_expired, expired_cart_items, expired_cart_item_names, valid_cart_item_tuples) = verify_for_closed_enrollment(request.user, cart) DCNL DCSP site_name = configuration_helpers.get_value('SITE_NAME', settings.SITE_NAME) DCNL DCSP if is_any_course_expired: DCNL DCSP  DCSP for expired_item in expired_cart_items: DCNL DCSP  DCSP  DCSP Order.remove_cart_item_from_order(expired_item, request.user) DCNL DCSP  DCSP cart.update_order_type() DCNL DCSP callback_url = request.build_absolute_uri(reverse('shoppingcart.views.postpay_callback')) DCNL DCSP form_html = render_purchase_form_html(cart, callback_url=callback_url) DCNL DCSP context = {'order': cart, 'shoppingcart_items': valid_cart_item_tuples, 'amount': cart.total_cost, 'is_course_enrollment_closed': is_any_course_expired, 'expired_course_names': expired_cart_item_names, 'site_name': site_name, 'form_html': form_html, 'currency_symbol': settings.PAID_COURSE_REGISTRATION_CURRENCY[1], 'currency': settings.PAID_COURSE_REGISTRATION_CURRENCY[0], 'enable_bulk_purchase': configuration_helpers.get_value('ENABLE_SHOPPING_CART_BULK_PURCHASE', True)} DCNL DCSP return render_to_response('shoppingcart/shopping_cart.html', context)
 DCSP f = (_Cfunctions.get('libvlc_video_set_deinterlace', None) or _Cfunction('libvlc_video_set_deinterlace', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_mode)
 DCSP echo_command = (u'echom' if warning else u'echo') DCNL DCSP vim.command(u'redraw') DCNL DCSP if warning: DCNL DCSP  DCSP vim.command(u'echohl DCSP WarningMsg') DCNL DCSP message = ToUnicode(message) DCNL DCSP if truncate: DCNL DCSP  DCSP vim_width = GetIntValue(u'&columns') DCNL DCSP  DCSP message = message.replace(u'\n', u' DCSP ') DCNL DCSP  DCSP if (len(message) > vim_width): DCNL DCSP  DCSP  DCSP message = (message[:(vim_width - 4)] + u'...') DCNL DCSP  DCSP old_ruler = GetIntValue(u'&ruler') DCNL DCSP  DCSP old_showcmd = GetIntValue(u'&showcmd') DCNL DCSP  DCSP vim.command(u'set DCSP noruler DCSP noshowcmd') DCNL DCSP  DCSP vim.command(u"{0} DCSP '{1}'".format(echo_command, EscapeForVim(message))) DCNL DCSP  DCSP SetVariableValue(u'&ruler', old_ruler) DCNL DCSP  DCSP SetVariableValue(u'&showcmd', old_showcmd) DCNL DCSP else: DCNL DCSP  DCSP for line in message.split(u'\n'): DCNL DCSP  DCSP  DCSP vim.command(u"{0} DCSP '{1}'".format(echo_command, EscapeForVim(line))) DCNL DCSP if warning: DCNL DCSP  DCSP vim.command(u'echohl DCSP None')
 DCSP radius = getFloatByPrefixSide((prefix + 'radius'), sideLength, xmlElement) DCNL DCSP radius += (0.5 * getFloatByPrefixSide((prefix + 'diameter'), sideLength, xmlElement)) DCNL DCSP return (radius + (0.5 * getFloatByPrefixSide((prefix + 'size'), sideLength, xmlElement)))
 DCSP repository.displayEntities = [] DCNL DCSP repository.executeTitle = None DCNL DCSP repository.fileNameHelp = fileNameHelp DCNL DCSP repository.fileNameInput = None DCNL DCSP repository.lowerName = fileNameHelp.split('.')[(-2)] DCNL DCSP repository.baseName = (repository.lowerName + '.csv') DCNL DCSP repository.baseNameSynonym = None DCNL DCSP repository.capitalizedName = getEachWordCapitalized(repository.lowerName) DCNL DCSP repository.getProfileDirectory = getProfileDirectory DCNL DCSP repository.openLocalHelpPage = HelpPage().getOpenFromDocumentationSubName(repository.fileNameHelp) DCNL DCSP repository.openWikiManualHelpPage = None DCNL DCSP repository.preferences = [] DCNL DCSP repository.repositoryDialog = None DCNL DCSP repository.saveListenerTable = {} DCNL DCSP repository.title = (repository.capitalizedName + ' DCSP Settings') DCNL DCSP repository.menuEntities = [] DCNL DCSP repository.saveCloseTitle = 'Save DCSP and DCSP Close' DCNL DCSP repository.windowPosition = WindowPosition().getFromValue(repository, '0+0') DCNL DCSP for setting in repository.preferences: DCNL DCSP  DCSP setting.repository = repository
 DCSP if (id is None): DCNL DCSP  DCSP msg = _('id DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidGroupType(reason=msg) DCNL DCSP elevated = (context if context.is_admin else context.elevated()) DCNL DCSP try: DCNL DCSP  DCSP type_updated = db.group_type_update(elevated, id, dict(name=name, description=description, is_public=is_public)) DCNL DCSP except db_exc.DBError: DCNL DCSP  DCSP LOG.exception(_LE('DB DCSP error:')) DCNL DCSP  DCSP raise exception.GroupTypeUpdateFailed(id=id) DCNL DCSP return type_updated
 DCSP try: DCNL DCSP  DCSP app_name = get_commands()[name] DCNL DCSP  DCSP if isinstance(app_name, BaseCommand): DCNL DCSP  DCSP  DCSP klass = app_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP klass = load_command_class(app_name, name) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise CommandError(('Unknown DCSP command: DCSP %r' % name)) DCNL DCSP defaults = dict([(o.dest, o.default) for o in klass.option_list if (o.default is not NO_DEFAULT)]) DCNL DCSP defaults.update(options) DCNL DCSP return klass.execute(*args, **defaults)
 DCSP comment = get_object_or_404(comments.get_model(), pk=comment_id, site__pk=settings.SITE_ID) DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP perform_delete(request, comment) DCNL DCSP  DCSP return next_redirect(request, next, delete_done, c=comment.pk) DCNL DCSP else: DCNL DCSP  DCSP return render_to_response('comments/delete.html', {'comment': comment, 'next': next}, template.RequestContext(request))
 DCSP if rendering_params['summary']: DCNL DCSP  DCSP return doc.get_summary_html() DCNL DCSP if (not (rendering_params['section'] or rendering_params['raw'] or rendering_params['edit_links'] or rendering_params['include'])): DCNL DCSP  DCSP return doc_html DCNL DCSP tool = kuma.wiki.content.parse(doc_html) DCNL DCSP if rendering_params['raw']: DCNL DCSP  DCSP tool.injectSectionIDs() DCNL DCSP  DCSP tool.filterEditorSafety() DCNL DCSP if rendering_params['section']: DCNL DCSP  DCSP tool.extractSection(rendering_params['section']) DCNL DCSP if ((rendering_params['edit_links'] or (not rendering_params['raw'])) and request.user.is_authenticated() and doc.allows_revision_by(request.user)): DCNL DCSP  DCSP tool.injectSectionEditingLinks(doc.slug, doc.locale) DCNL DCSP doc_html = tool.serialize() DCNL DCSP if rendering_params['include']: DCNL DCSP  DCSP doc_html = kuma.wiki.content.filter_out_noinclude(doc_html) DCNL DCSP return doc_html
 DCSP if epoch_axis: DCNL DCSP  DCSP x = np.zeros((minibatches,)) DCNL DCSP  DCSP last_e = 0 DCNL DCSP  DCSP for (e_idx, e) in enumerate(minibatch_markers): DCNL DCSP  DCSP  DCSP e_minibatches = (e - last_e) DCNL DCSP  DCSP  DCSP x[last_e:e] = (e_idx + (np.arange(float(e_minibatches)) / e_minibatches)) DCNL DCSP  DCSP  DCSP last_e = e DCNL DCSP else: DCNL DCSP  DCSP x = np.arange(minibatches) DCNL DCSP return x
 DCSP return call_talib_with_ohlc(barDs, count, talib.CDLMORNINGDOJISTAR, penetration)
 DCSP return ((1.0 / np.sqrt((4 * np.pi))) * np.exp(((- ((Xi - x) ** 2)) / ((h ** 2) * 4.0))))
 DCSP reg_dir = _reg_dir() DCNL DCSP regfile = os.path.join(reg_dir, 'register') DCNL DCSP try: DCNL DCSP  DCSP with salt.utils.fopen(regfile, 'r') as fh_: DCNL DCSP  DCSP  DCSP return msgpack.load(fh_) DCNL DCSP except: DCNL DCSP  DCSP log.error('Could DCSP not DCSP write DCSP to DCSP msgpack DCSP file DCSP {0}'.format(__opts__['outdir'])) DCNL DCSP  DCSP raise
 DCSP Node = namedtuple('Node', ['name', 'type']) DCNL DCSP for d in dirs: DCNL DCSP  DCSP d = pathlib2.Path(git_dir, d) DCNL DCSP  DCSP for item in d.iterdir(): DCNL DCSP  DCSP  DCSP if item.match('*.yml'): DCNL DCSP  DCSP  DCSP  DCSP yaml_file = _open_yaml_file(item) DCNL DCSP  DCSP  DCSP  DCSP if (yaml_file is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for play in yaml_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (key in play): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for role in play[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = _get_role_name(role) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP node_1 = Node(item.stem, type_1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP node_2 = Node(name, type_2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP graph.add_edge(node_2, node_1)
 DCSP if (fd == (-1)): DCNL DCSP  DCSP signal.signal(signal.SIGCHLD, signal.SIG_DFL) DCNL DCSP else: DCNL DCSP  DCSP signal.signal(signal.SIGCHLD, _Handler(None)) DCNL DCSP  DCSP siginterrupt(signal.SIGCHLD, False) DCNL DCSP return set_wakeup_fd(fd)
 DCSP try: DCNL DCSP  DCSP model = get_model(AUTH_USER_APP_LABEL, AUTH_USER_MODEL_NAME) DCNL DCSP except LookupError: DCNL DCSP  DCSP raise ImproperlyConfigured(("AUTH_USER_MODEL DCSP refers DCSP to DCSP model DCSP '%s' DCSP that DCSP has DCSP not DCSP been DCSP installed" % settings.AUTH_USER_MODEL)) DCNL DCSP core_fields = set([f.name for f in User._meta.fields]) DCNL DCSP model_fields = set([f.name for f in model._meta.fields]) DCNL DCSP new_fields = model_fields.difference(core_fields) DCNL DCSP model._meta.has_additional_fields = (len(new_fields) > 0) DCNL DCSP model._meta.additional_fields = new_fields DCNL DCSP return model
 DCSP view_name = 'xblock_handler' DCNL DCSP if handler_name: DCNL DCSP  DCSP func = getattr(block.__class__, handler_name, None) DCNL DCSP  DCSP if (not func): DCNL DCSP  DCSP  DCSP raise ValueError('{!r} DCSP is DCSP not DCSP a DCSP function DCSP name'.format(handler_name)) DCNL DCSP if thirdparty: DCNL DCSP  DCSP view_name = 'xblock_handler_noauth' DCNL DCSP url = reverse(view_name, kwargs={'course_id': unicode(block.location.course_key), 'usage_id': quote_slashes(unicode(block.scope_ids.usage_id).encode('utf-8')), 'handler': handler_name, 'suffix': suffix}) DCNL DCSP if (not suffix): DCNL DCSP  DCSP url = url.rstrip('/') DCNL DCSP if query: DCNL DCSP  DCSP url += ('?' + query) DCNL DCSP if thirdparty: DCNL DCSP  DCSP scheme = ('https' if (settings.HTTPS == 'on') else 'http') DCNL DCSP  DCSP url = '{scheme}://{host}{path}'.format(scheme=scheme, host=settings.SITE_NAME, path=url) DCNL DCSP return url
 DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only', False) DCNL DCSP def issubclassof_nova_base(obj): DCNL DCSP  DCSP return (isinstance(obj, type) and issubclass(obj, models.NovaBase)) DCNL DCSP base_model = model DCNL DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP base_model = kwargs.get('base_model', None) DCNL DCSP  DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP  DCSP raise Exception(_('model DCSP or DCSP base_model DCSP parameter DCSP should DCSP be DCSP subclass DCSP of DCSP NovaBase')) DCNL DCSP query = session.query(model, *args) DCNL DCSP default_deleted_value = base_model.__mapper__.c.deleted.default.arg DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter((base_model.deleted == default_deleted_value)) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter((base_model.deleted != default_deleted_value)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (nova.context.is_user_context(context) and project_only): DCNL DCSP  DCSP if (project_only == 'allow_none'): DCNL DCSP  DCSP  DCSP query = query.filter(or_((base_model.project_id == context.project_id), (base_model.project_id == None))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP try: DCNL DCSP  DCSP import numpy as np DCNL DCSP  DCSP from scipy import sparse DCNL DCSP except ImportError: DCNL DCSP  DCSP raise ImportError('attr_sparse_matrix() DCSP requires DCSP scipy: DCSP http://scipy.org/ DCSP ') DCNL DCSP edge_value = _edge_value(G, edge_attr) DCNL DCSP node_value = _node_value(G, node_attr) DCNL DCSP if (rc_order is None): DCNL DCSP  DCSP ordering = list(set([node_value(n) for n in G])) DCNL DCSP else: DCNL DCSP  DCSP ordering = rc_order DCNL DCSP N = len(ordering) DCNL DCSP undirected = (not G.is_directed()) DCNL DCSP index = dict(zip(ordering, range(N))) DCNL DCSP M = sparse.lil_matrix((N, N), dtype=dtype) DCNL DCSP seen = set([]) DCNL DCSP for (u, nbrdict) in G.adjacency(): DCNL DCSP  DCSP for v in nbrdict: DCNL DCSP  DCSP  DCSP (i, j) = (index[node_value(u)], index[node_value(v)]) DCNL DCSP  DCSP  DCSP if (v not in seen): DCNL DCSP  DCSP  DCSP  DCSP M[(i, j)] += edge_value(u, v) DCNL DCSP  DCSP  DCSP  DCSP if undirected: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(j, i)] = M[(i, j)] DCNL DCSP  DCSP if undirected: DCNL DCSP  DCSP  DCSP seen.add(u) DCNL DCSP if normalized: DCNL DCSP  DCSP norms = np.asarray(M.sum(axis=1)).ravel() DCNL DCSP  DCSP for (i, norm) in enumerate(norms): DCNL DCSP  DCSP  DCSP M[i, :] /= norm DCNL DCSP if (rc_order is None): DCNL DCSP  DCSP return (M, ordering) DCNL DCSP else: DCNL DCSP  DCSP return M
 DCSP context.dispatcher.command_list_receiving = True DCNL DCSP context.dispatcher.command_list_ok = True DCNL DCSP context.dispatcher.command_list = []
 DCSP dc = daclConstants() DCNL DCSP objectType = dc.getObjectTypeBit(objectType) DCNL DCSP try: DCNL DCSP  DCSP userSid = win32security.LookupAccountSid('', ace[2]) DCNL DCSP  DCSP if userSid[1]: DCNL DCSP  DCSP  DCSP userSid = '{1}\\{0}'.format(userSid[0], userSid[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP userSid = '{0}'.format(userSid[0]) DCNL DCSP except Exception: DCNL DCSP  DCSP userSid = win32security.ConvertSidToStringSid(ace[2]) DCNL DCSP tPerm = ace[1] DCNL DCSP tAceType = ace[0][0] DCNL DCSP tProps = ace[0][1] DCNL DCSP tInherited = '' DCNL DCSP for x in dc.validAceTypes: DCNL DCSP  DCSP if (dc.validAceTypes[x]['BITS'] == tAceType): DCNL DCSP  DCSP  DCSP tAceType = dc.validAceTypes[x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP for x in dc.rights[objectType]: DCNL DCSP  DCSP if (dc.rights[objectType][x]['BITS'] == tPerm): DCNL DCSP  DCSP  DCSP tPerm = dc.rights[objectType][x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP if ((tProps & win32security.INHERITED_ACE) == win32security.INHERITED_ACE): DCNL DCSP  DCSP tInherited = '[Inherited]' DCNL DCSP  DCSP tProps = (tProps ^ win32security.INHERITED_ACE) DCNL DCSP for x in dc.validPropagations[objectType]: DCNL DCSP  DCSP if (dc.validPropagations[objectType][x]['BITS'] == tProps): DCNL DCSP  DCSP  DCSP tProps = dc.validPropagations[objectType][x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return '{0} DCSP {1} DCSP {2} DCSP on DCSP {3} DCSP {4}'.format(userSid, tAceType, tPerm, tProps, tInherited)
 DCSP if (offset is None): DCNL DCSP  DCSP if (not kwargs): DCNL DCSP  DCSP  DCSP return default DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _td_check(datetime.timedelta(**kwargs)) DCNL DCSP elif kwargs: DCNL DCSP  DCSP raise ValueError('Cannot DCSP pass DCSP kwargs DCSP and DCSP an DCSP offset') DCNL DCSP elif isinstance(offset, datetime.timedelta): DCNL DCSP  DCSP return _td_check(offset) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError("Must DCSP pass DCSP 'hours' DCSP and/or DCSP 'minutes' DCSP as DCSP keywords")
 DCSP if use_cpickle: DCNL DCSP  DCSP pickler = cPickle.Pickler DCNL DCSP else: DCNL DCSP  DCSP pickler = _PicklerWithWarning DCNL DCSP with closing(tarfile.TarFile(fileobj=file_, mode='w')) as tar_file: DCNL DCSP  DCSP external_objects = {} DCNL DCSP  DCSP def _save_parameters(f): DCNL DCSP  DCSP  DCSP renamer = _Renamer() DCNL DCSP  DCSP  DCSP named_parameters = {renamer(p): p for p in parameters} DCNL DCSP  DCSP  DCSP numpy.savez(f, **{n: p.get_value() for (n, p) in named_parameters.items()}) DCNL DCSP  DCSP  DCSP for (name, p) in named_parameters.items(): DCNL DCSP  DCSP  DCSP  DCSP array_ = p.container.storage[0] DCNL DCSP  DCSP  DCSP  DCSP external_objects[id(array_)] = _mangle_parameter_name(p, name) DCNL DCSP  DCSP if parameters: DCNL DCSP  DCSP  DCSP _taradd(_save_parameters, tar_file, '_parameters') DCNL DCSP  DCSP if (object_ is not None): DCNL DCSP  DCSP  DCSP save_object = _SaveObject(pickler, object_, external_objects, protocol, **kwargs) DCNL DCSP  DCSP  DCSP _taradd(save_object, tar_file, '_pkl')
 DCSP for key in ('discussion_id', 'discussion_category', 'discussion_target'): DCNL DCSP  DCSP if (getattr(xblock, key, None) is None): DCNL DCSP  DCSP  DCSP log.debug("Required DCSP key DCSP '%s' DCSP not DCSP in DCSP discussion DCSP %s, DCSP leaving DCSP out DCSP of DCSP category DCSP map", key, xblock.location) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if isinstance(train, theano.tensor.sharedvar.SharedVariable): DCNL DCSP  DCSP train = train.get_value(borrow=True) DCNL DCSP if isinstance(label, theano.tensor.sharedvar.SharedVariable): DCNL DCSP  DCSP label = label.get_value(borrow=True) DCNL DCSP if (not (isinstance(train, numpy.ndarray) or scipy.sparse.issparse(train))): DCNL DCSP  DCSP raise TypeError('train DCSP must DCSP be DCSP a DCSP numpy DCSP array, DCSP a DCSP scipy DCSP sparse DCSP matrix, DCSP or DCSP a DCSP theano DCSP shared DCSP array') DCNL DCSP if (classes is not None): DCNL DCSP  DCSP label = label[:, classes] DCNL DCSP if scipy.sparse.issparse(train): DCNL DCSP  DCSP idx = label.sum(axis=1).nonzero()[0] DCNL DCSP  DCSP return (train[idx], label[idx]) DCNL DCSP condition = label.any(axis=1) DCNL DCSP return tuple((var.compress(condition, axis=0) for var in (train, label)))
 DCSP frappe.db.sql(u'delete DCSP from DCSP `tabDesktop DCSP Icon` DCSP where DCSP standard=0') DCNL DCSP frappe.db.sql(u'update DCSP `tabDesktop DCSP Icon` DCSP set DCSP blocked=0, DCSP hidden=1') DCNL DCSP for module_name in visible_list: DCNL DCSP  DCSP name = frappe.db.get_value(u'Desktop DCSP Icon', {u'module_name': module_name}) DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP frappe.db.set_value(u'Desktop DCSP Icon', name, u'hidden', 0) DCNL DCSP  DCSP elif frappe.db.exists(u'DocType', module_name): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP add_user_icon(module_name, standard=1) DCNL DCSP  DCSP  DCSP except frappe.UniqueValidationError as e: DCNL DCSP  DCSP  DCSP  DCSP if (not ignore_duplicate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP visible_list.remove(module_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if frappe.message_log: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP frappe.message_log.pop() DCNL DCSP set_order(visible_list) DCNL DCSP clear_desktop_icons_cache()
 DCSP n = as_int(nth) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError('nth DCSP must DCSP be DCSP a DCSP positive DCSP integer; DCSP prime(1) DCSP == DCSP 2') DCNL DCSP if (n <= len(sieve._list)): DCNL DCSP  DCSP return sieve[n] DCNL DCSP from sympy.functions.special.error_functions import li DCNL DCSP from sympy.functions.elementary.exponential import log DCNL DCSP a = 2 DCNL DCSP b = int((n * (log(n) + log(log(n))))) DCNL DCSP while (a < b): DCNL DCSP  DCSP mid = ((a + b) >> 1) DCNL DCSP  DCSP if (li(mid) > n): DCNL DCSP  DCSP  DCSP b = mid DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = (mid + 1) DCNL DCSP n_primes = primepi((a - 1)) DCNL DCSP while (n_primes < n): DCNL DCSP  DCSP if isprime(a): DCNL DCSP  DCSP  DCSP n_primes += 1 DCNL DCSP  DCSP a += 1 DCNL DCSP return (a - 1)
 DCSP c = dict(context.items()) DCNL DCSP request = c['request'] DCNL DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP is_favorite = (addon.id in request.user.favorite_addons) DCNL DCSP  DCSP faved_class = ('faved' if is_favorite else '') DCNL DCSP  DCSP unfaved_text = ('' if condensed else _('Add DCSP to DCSP favorites')) DCNL DCSP  DCSP faved_text = (_('Favorite') if condensed else _('Remove DCSP from DCSP favorites')) DCNL DCSP  DCSP add_url = reverse('collections.alter', args=[request.user.username, 'favorites', 'add']) DCNL DCSP  DCSP remove_url = reverse('collections.alter', args=[request.user.username, 'favorites', 'remove']) DCNL DCSP  DCSP c.update(locals()) DCNL DCSP  DCSP t = get_env().get_template('bandwagon/favorites_widget.html').render(c) DCNL DCSP  DCSP return jinja2.Markup(t)
 DCSP with io.open(filename, 'rt', encoding='utf8') as names_file: DCNL DCSP  DCSP for name in filter_koan_names(names_file): DCNL DCSP  DCSP  DCSP (yield name) DCNL DCSP return
 DCSP if settings.USE_L10N: DCNL DCSP  DCSP decimal_separator = get_format('DECIMAL_SEPARATOR') DCNL DCSP  DCSP if isinstance(value, six.string_types): DCNL DCSP  DCSP  DCSP parts = [] DCNL DCSP  DCSP  DCSP if (decimal_separator in value): DCNL DCSP  DCSP  DCSP  DCSP (value, decimals) = value.split(decimal_separator, 1) DCNL DCSP  DCSP  DCSP  DCSP parts.append(decimals) DCNL DCSP  DCSP  DCSP if settings.USE_THOUSAND_SEPARATOR: DCNL DCSP  DCSP  DCSP  DCSP parts.append(value.replace(get_format('THOUSAND_SEPARATOR'), '')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parts.append(value) DCNL DCSP  DCSP  DCSP value = '.'.join(reversed(parts)) DCNL DCSP return value
 DCSP if six.PY2: DCNL DCSP  DCSP if isinstance(func, functools.partial): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.func) DCNL DCSP  DCSP elif inspect.isroutine(func): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.__call__) DCNL DCSP  DCSP args = [arg for arg in spec.args if (arg != 'self')] DCNL DCSP else: DCNL DCSP  DCSP sig = inspect.signature(func) DCNL DCSP  DCSP args = [param.name for param in sig.parameters.values() if (param.kind not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD))] DCNL DCSP return args
 DCSP try: DCNL DCSP  DCSP indices = list(client.indices.get_settings(index='_all', params={'expand_wildcards': 'open,closed'})) DCNL DCSP  DCSP version_number = get_version(client) DCNL DCSP  DCSP logger.debug('Detected DCSP Elasticsearch DCSP version DCSP {0}'.format('.'.join(map(str, version_number)))) DCNL DCSP  DCSP if ((version_number >= (2, 4, 2)) and (version_number < (5, 0, 0))): DCNL DCSP  DCSP  DCSP logger.debug('Using DCSP Elasticsearch DCSP >= DCSP 2.4.2 DCSP < DCSP 5.0.0') DCNL DCSP  DCSP  DCSP if client.indices.exists(index='.security'): DCNL DCSP  DCSP  DCSP  DCSP logger.debug('Found DCSP the DCSP ".security" DCSP index. DCSP  DCSP Adding DCSP to DCSP list DCSP of DCSP all DCSP indices') DCNL DCSP  DCSP  DCSP  DCSP if (not ('.security' in indices)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP indices.append('.security') DCNL DCSP  DCSP logger.debug('All DCSP indices: DCSP {0}'.format(indices)) DCNL DCSP  DCSP return indices DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise FailedExecution('Failed DCSP to DCSP get DCSP indices. DCSP Error: DCSP {0}'.format(e))
 DCSP with qtbot.waitSignal(view._clear_timer.timeout): DCNL DCSP  DCSP view.show_message(usertypes.MessageLevel.info, 'test') DCNL DCSP assert (not view._messages)
 DCSP print 'Updating DCSP fancy-dmg DCSP Makefile...' DCNL DCSP url = 'https://raw.githubusercontent.com/remko/fancy-dmg/master/Makefile' DCNL DCSP target_path = os.path.join('scripts', 'dev', 'Makefile-dmg') DCNL DCSP urllib.request.urlretrieve(url, target_path) DCNL DCSP urllib.request.urlcleanup()
 DCSP return ({} if (headers is None) else dict(headers))
 DCSP orig_model = None DCNL DCSP try: DCNL DCSP  DCSP orig_model = loading.cache.app_models['tests']['secret'] DCNL DCSP  DCSP del loading.cache.app_models['tests']['secret'] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP attrs = {'name': EncryptedCharField('Name', max_length=Secret._meta.get_field('name').max_length), 'text': EncryptedTextField('Text'), '__module__': 'django_extensions.tests.models', 'Meta': type('Meta', (object,), {'managed': False, 'db_table': Secret._meta.db_table})} DCNL DCSP  DCSP (yield type('Secret', (models.Model,), attrs)) DCNL DCSP except: DCNL DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP loading.cache.app_models['tests']['secret'] = orig_model DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass
 DCSP ret = [] DCNL DCSP for line in __salt__['cmd.run']('kldstat').splitlines(): DCNL DCSP  DCSP comps = line.split() DCNL DCSP  DCSP if (not (len(comps) > 2)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (comps[0] == 'Id'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (comps[4] == 'kernel'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.append({'module': comps[4][:(-3)], 'size': comps[3], 'depcount': comps[1]}) DCNL DCSP return ret
 DCSP if (name not in container.mime_map): DCNL DCSP  DCSP raise ValueError((u'Cannot DCSP mark DCSP %s DCSP as DCSP cover DCSP as DCSP it DCSP does DCSP not DCSP exist' % name)) DCNL DCSP mt = container.mime_map[name] DCNL DCSP if (not is_raster_image(mt)): DCNL DCSP  DCSP raise ValueError((u'Cannot DCSP mark DCSP %s DCSP as DCSP the DCSP cover DCSP image DCSP as DCSP it DCSP is DCSP not DCSP a DCSP raster DCSP image' % name)) DCNL DCSP if (container.book_type == u'azw3'): DCNL DCSP  DCSP mark_as_cover_azw3(container, name) DCNL DCSP else: DCNL DCSP  DCSP mark_as_cover_epub(container, name)
 DCSP vbd_rec['currently_attached'] = False DCNL DCSP vbd_rec['device'] = '' DCNL DCSP vm_ref = vbd_rec['VM'] DCNL DCSP vm_rec = _db_content['VM'][vm_ref] DCNL DCSP vm_rec['VBDs'].append(vbd_ref) DCNL DCSP vdi_ref = vbd_rec['VDI'] DCNL DCSP vdi_rec = _db_content['VDI'][vdi_ref] DCNL DCSP vdi_rec['VBDs'].append(vbd_ref) DCNL DCSP vm_name_label = _db_content['VM'][vm_ref]['name_label'] DCNL DCSP vbd_rec['vm_name_label'] = vm_name_label
 DCSP if (xblock.category == 'vertical'): DCNL DCSP  DCSP if (parent_xblock is None): DCNL DCSP  DCSP  DCSP parent_xblock = get_parent_xblock(xblock) DCNL DCSP  DCSP parent_category = (parent_xblock.category if parent_xblock else None) DCNL DCSP  DCSP return (parent_category == 'sequential') DCNL DCSP return False
 DCSP return wechat.response_news(app.config['BUS_ROUTES_NEWS'])
 DCSP valid_formats = [] DCNL DCSP for (data_format, data_class) in _identifiers: DCNL DCSP  DCSP if _is_best_match(data_class_required, data_class, _identifiers): DCNL DCSP  DCSP  DCSP if _identifiers[(data_format, data_class)](origin, path, fileobj, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP valid_formats.append(data_format) DCNL DCSP return valid_formats
 DCSP return _get_messages_from_page_or_report(u'Page', name)
 DCSP try: DCNL DCSP  DCSP return _env.get_template(template).render(**kwargs) DCNL DCSP except jinja2.exceptions.UndefinedError: DCNL DCSP  DCSP log.misc.exception(('UndefinedError DCSP while DCSP rendering DCSP ' + template)) DCNL DCSP  DCSP err_path = os.path.join('html', 'undef_error.html') DCNL DCSP  DCSP err_template = utils.read_file(err_path) DCNL DCSP  DCSP tb = traceback.format_exc() DCNL DCSP  DCSP return err_template.format(pagename=template, traceback=tb)
 DCSP _assert_no_element_by(context, By.ID, _id, wait_time)
 DCSP return _resize(original_size, 1, padding=padding, keep_aspect_ratio=True)
 DCSP archs = ('x86', 'x64') DCNL DCSP if generator_flags.get('ninja_use_custom_environment_files', 0): DCNL DCSP  DCSP cl_paths = {} DCNL DCSP  DCSP for arch in archs: DCNL DCSP  DCSP  DCSP cl_paths[arch] = 'cl.exe' DCNL DCSP  DCSP return cl_paths DCNL DCSP vs = GetVSVersion(generator_flags) DCNL DCSP cl_paths = {} DCNL DCSP for arch in archs: DCNL DCSP  DCSP args = vs.SetupScript(arch) DCNL DCSP  DCSP args.extend(('&&', 'set')) DCNL DCSP  DCSP popen = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) DCNL DCSP  DCSP (variables, _) = popen.communicate() DCNL DCSP  DCSP env = _ExtractImportantEnvironment(variables) DCNL DCSP  DCSP if system_includes: DCNL DCSP  DCSP  DCSP system_includes = (system_includes | OrderedSet(env.get('INCLUDE', '').split(';'))) DCNL DCSP  DCSP  DCSP env['INCLUDE'] = ';'.join(system_includes) DCNL DCSP  DCSP env_block = _FormatAsEnvironmentBlock(env) DCNL DCSP  DCSP f = open_out(os.path.join(toplevel_build_dir, ('environment.' + arch)), 'wb') DCNL DCSP  DCSP f.write(env_block) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP args = vs.SetupScript(arch) DCNL DCSP  DCSP args.extend(('&&', 'for', '%i', 'in', '(cl.exe)', 'do', '@echo', 'LOC:%~$PATH:i')) DCNL DCSP  DCSP popen = subprocess.Popen(args, shell=True, stdout=subprocess.PIPE) DCNL DCSP  DCSP (output, _) = popen.communicate() DCNL DCSP  DCSP cl_paths[arch] = _ExtractCLPath(output) DCNL DCSP return cl_paths
 DCSP src = files['src'] DCNL DCSP dest = files['dest'] DCNL DCSP src_type = src['type'] DCNL DCSP dest_type = dest['type'] DCNL DCSP if (src_path is None): DCNL DCSP  DCSP src_path = src['path'] DCNL DCSP sep_table = {'s3': '/', 'local': os.sep} DCNL DCSP if files['dir_op']: DCNL DCSP  DCSP rel_path = src_path[len(src['path']):] DCNL DCSP else: DCNL DCSP  DCSP rel_path = src_path.split(sep_table[src_type])[(-1)] DCNL DCSP compare_key = rel_path.replace(sep_table[src_type], '/') DCNL DCSP if files['use_src_name']: DCNL DCSP  DCSP dest_path = dest['path'] DCNL DCSP  DCSP dest_path += rel_path.replace(sep_table[src_type], sep_table[dest_type]) DCNL DCSP else: DCNL DCSP  DCSP dest_path = dest['path'] DCNL DCSP return (dest_path, compare_key)
 DCSP return 'Mangle DCSP plugins DCSP modify DCSP requests DCSP on DCSP the DCSP fly.\n DCSP  DCSP  DCSP  DCSP '
 DCSP msg = 'N321: DCSP jsonutils.%(fun)s DCSP must DCSP be DCSP used DCSP instead DCSP of DCSP json.%(fun)s' DCNL DCSP json_check_skipped_patterns = ['neutron/plugins/ml2/drivers/openvswitch/agent/xenapi/etc/xapi.d/plugins/netwrap'] DCNL DCSP for pattern in json_check_skipped_patterns: DCNL DCSP  DCSP if (pattern in filename): DCNL DCSP  DCSP  DCSP return DCNL DCSP if ('json.' in logical_line): DCNL DCSP  DCSP json_funcs = ['dumps(', 'dump(', 'loads(', 'load('] DCNL DCSP  DCSP for f in json_funcs: DCNL DCSP  DCSP  DCSP pos = logical_line.find(('json.%s' % f)) DCNL DCSP  DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP  DCSP (yield (pos, (msg % {'fun': f[:(-1)]})))
 DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(network_models_v2.VlanID).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP config_file = basic_util.strip_path(config_file) DCNL DCSP for changeset in reversed_upper_bounded_changelog(repo, ctx): DCNL DCSP  DCSP changeset_ctx = repo.changectx(changeset) DCNL DCSP  DCSP for ctx_file in changeset_ctx.files(): DCNL DCSP  DCSP  DCSP ctx_file_name = basic_util.strip_path(ctx_file) DCNL DCSP  DCSP  DCSP if (ctx_file_name == config_file): DCNL DCSP  DCSP  DCSP  DCSP return get_named_tmpfile_from_ctx(changeset_ctx, ctx_file, dir) DCNL DCSP return None
 DCSP log.msg('stop') DCNL DCSP if GlobalObject().stophandler: DCNL DCSP  DCSP GlobalObject().stophandler() DCNL DCSP reactor.callLater(0.5, reactor.stop) DCNL DCSP return True
 DCSP b0 = safe_ord(rlp[start]) DCNL DCSP if (b0 < 128): DCNL DCSP  DCSP return (str, 1, start) DCNL DCSP elif (b0 < (128 + 56)): DCNL DCSP  DCSP return (str, (b0 - 128), (start + 1)) DCNL DCSP elif (b0 < 192): DCNL DCSP  DCSP ll = (((b0 - 128) - 56) + 1) DCNL DCSP  DCSP l = big_endian_to_int(rlp[(start + 1):((start + 1) + ll)]) DCNL DCSP  DCSP return (str, l, ((start + 1) + ll)) DCNL DCSP elif (b0 < (192 + 56)): DCNL DCSP  DCSP return (list, (b0 - 192), (start + 1)) DCNL DCSP else: DCNL DCSP  DCSP ll = (((b0 - 192) - 56) + 1) DCNL DCSP  DCSP l = big_endian_to_int(rlp[(start + 1):((start + 1) + ll)]) DCNL DCSP  DCSP return (list, l, ((start + 1) + ll))
 DCSP addCageGroove(derivation, negatives, positives) DCNL DCSP for pegCenterX in derivation.pegCenterXs: DCNL DCSP  DCSP addPositivePeg(derivation, positives, pegCenterX, (- derivation.pegY)) DCNL DCSP  DCSP addPositivePeg(derivation, positives, pegCenterX, derivation.pegY) DCNL DCSP translate.translateNegativesPositives(negatives, positives, Vector3(0.0, (- derivation.halfSeparationWidth))) DCNL DCSP femaleNegatives = [] DCNL DCSP femalePositives = [] DCNL DCSP addCageGroove(derivation, femaleNegatives, femalePositives) DCNL DCSP for pegCenterX in derivation.pegCenterXs: DCNL DCSP  DCSP addNegativePeg(derivation, femaleNegatives, pegCenterX, (- derivation.pegY)) DCNL DCSP  DCSP addNegativePeg(derivation, femaleNegatives, pegCenterX, derivation.pegY) DCNL DCSP translate.translateNegativesPositives(femaleNegatives, femalePositives, Vector3(0.0, derivation.halfSeparationWidth)) DCNL DCSP negatives += femaleNegatives DCNL DCSP positives += femalePositives
 DCSP order = get_object_or_404(SaleOrder, pk=order_id) DCNL DCSP if ((not request.user.profile.has_permission(order)) and (not request.user.profile.is_admin('treeio.sales'))): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Sale") DCNL DCSP ordered_products = order.orderedproduct_set.filter(trash=False) DCNL DCSP try: DCNL DCSP  DCSP conf = ModuleSetting.get_for_module('treeio.finance', 'my_company')[0] DCNL DCSP  DCSP my_company = Contact.objects.get(pk=long(conf.value)) DCNL DCSP except: DCNL DCSP  DCSP my_company = None DCNL DCSP return render_to_response('sales/order_invoice_view', {'order': order, 'ordered_products': ordered_products, 'my_company': my_company}, context_instance=RequestContext(request), response_format=response_format)
 DCSP return ExportRepository()
 DCSP return _underscore_dict(json(body, charset=charset))
 DCSP (_, files_modified, _) = run('git DCSP diff-index DCSP --cached DCSP --name-only DCSP HEAD') DCNL DCSP options = parse_options() DCNL DCSP setup_logger(options) DCNL DCSP candidates = list(map(str, files_modified)) DCNL DCSP if candidates: DCNL DCSP  DCSP process_paths(options, candidates=candidates)
 DCSP if (item_shape is None): DCNL DCSP  DCSP item_shape = (N,) DCNL DCSP offset = 0 DCNL DCSP mgr_items = [] DCNL DCSP block_placements = OrderedDict() DCNL DCSP for d in descr.split(';'): DCNL DCSP  DCSP d = d.strip() DCNL DCSP  DCSP if (not len(d)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (names, blockstr) = d.partition(':')[::2] DCNL DCSP  DCSP blockstr = blockstr.strip() DCNL DCSP  DCSP names = names.strip().split(',') DCNL DCSP  DCSP mgr_items.extend(names) DCNL DCSP  DCSP placement = list((np.arange(len(names)) + offset)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP block_placements[blockstr].extend(placement) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP block_placements[blockstr] = placement DCNL DCSP  DCSP offset += len(names) DCNL DCSP mgr_items = Index(mgr_items) DCNL DCSP blocks = [] DCNL DCSP num_offset = 0 DCNL DCSP for (blockstr, placement) in block_placements.items(): DCNL DCSP  DCSP typestr = blockstr.split('-')[0] DCNL DCSP  DCSP blocks.append(create_block(typestr, placement, item_shape=item_shape, num_offset=num_offset)) DCNL DCSP  DCSP num_offset += len(placement) DCNL DCSP return BlockManager(sorted(blocks, key=(lambda b: b.mgr_locs[0])), ([mgr_items] + [np.arange(n) for n in item_shape]))
 DCSP kstone = auth(profile, **connection_args) DCNL DCSP if name: DCNL DCSP  DCSP for role in kstone.roles.list(): DCNL DCSP  DCSP  DCSP if (role.name == name): DCNL DCSP  DCSP  DCSP  DCSP role_id = role.id DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not role_id): DCNL DCSP  DCSP return {'Error': 'Unable DCSP to DCSP resolve DCSP role DCSP id'} DCNL DCSP role = kstone.roles.get(role_id) DCNL DCSP kstone.roles.delete(role) DCNL DCSP ret = 'Role DCSP ID DCSP {0} DCSP deleted'.format(role_id) DCNL DCSP if name: DCNL DCSP  DCSP ret += ' DCSP ({0})'.format(name) DCNL DCSP return ret
 DCSP eeg_sel = pick_types(info, meg=False, eeg=True, ref_meg=False, exclude='bads') DCNL DCSP return ((len(eeg_sel) > 0) and (not info['custom_ref_applied']) and (not _has_eeg_average_ref_proj(info['projs'])))
 DCSP DocTags(dt).add(dn, tag) DCNL DCSP return tag
 DCSP budget_service = client.GetService('BudgetService', version='v201609') DCNL DCSP budget = {'name': ('Interplanetary DCSP Cruise DCSP App DCSP Budget DCSP #%s' % uuid.uuid4()), 'amount': {'microAmount': '50000000'}, 'deliveryMethod': 'STANDARD', 'isExplicitlyShared': False} DCNL DCSP budget_operations = [{'operator': 'ADD', 'operand': budget}] DCNL DCSP budget_id = budget_service.mutate(budget_operations)['value'][0]['budgetId'] DCNL DCSP return budget_id
 DCSP for (cls, fields_list) in class_dict.items(): DCNL DCSP  DCSP for fields in fields_list: DCNL DCSP  DCSP  DCSP (yield (cls, fields))
 DCSP netobj = objects.network.Network(id=network['id'], bridge_interface=network.get_meta('bridge_interface'), subnets=_nova_to_osvif_subnets(network['subnets'])) DCNL DCSP if (network['bridge'] is not None): DCNL DCSP  DCSP netobj.bridge = network['bridge'] DCNL DCSP if (network['label'] is not None): DCNL DCSP  DCSP netobj.label = network['label'] DCNL DCSP if (network.get_meta('mtu') is not None): DCNL DCSP  DCSP netobj.mtu = network.get_meta('mtu') DCNL DCSP if (network.get_meta('multi_host') is not None): DCNL DCSP  DCSP netobj.multi_host = network.get_meta('multi_host') DCNL DCSP if (network.get_meta('should_create_bridge') is not None): DCNL DCSP  DCSP netobj.should_provide_bridge = network.get_meta('should_create_bridge') DCNL DCSP if (network.get_meta('should_create_vlan') is not None): DCNL DCSP  DCSP netobj.should_provide_vlan = network.get_meta('should_create_vlan') DCNL DCSP  DCSP if (network.get_meta('vlan') is None): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Missing DCSP vlan DCSP number DCSP in DCSP %s') % network)) DCNL DCSP  DCSP netobj.vlan = network.get_meta('vlan') DCNL DCSP return netobj
 DCSP ndim = tensor_var.ndim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (ndim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (ndim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, ndim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupported DCSP tensor DCSP dimensionality DCSP {}.Must DCSP specify DCSP `norm_axes`'.format(ndim)) DCNL DCSP dtype = np.dtype(theano.config.floatX).type DCNL DCSP norms = T.sqrt(T.sum(T.sqr(tensor_var), axis=sum_over, keepdims=True)) DCNL DCSP target_norms = T.clip(norms, 0, dtype(max_norm)) DCNL DCSP constrained_output = (tensor_var * (target_norms / (dtype(epsilon) + norms))) DCNL DCSP return constrained_output
 DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP delete_disk DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if ((not kwargs) or ('disk_name' not in kwargs)): DCNL DCSP  DCSP log.error('A DCSP disk_name DCSP must DCSP be DCSP specified DCSP when DCSP deleting DCSP a DCSP disk.') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP disk = conn.ex_get_volume(kwargs.get('disk_name')) DCNL DCSP __utils__['cloud.fire_event']('event', 'delete DCSP disk', 'salt/cloud/disk/deleting', args={'name': disk.name, 'location': disk.extra['zone'].name, 'size': disk.size}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP try: DCNL DCSP  DCSP result = conn.destroy_volume(disk) DCNL DCSP except ResourceInUseError as exc: DCNL DCSP  DCSP log.error('Disk DCSP {0} DCSP is DCSP in DCSP use DCSP and DCSP must DCSP be DCSP detached DCSP before DCSP deleting.\nThe DCSP following DCSP exception DCSP was DCSP thrown DCSP by DCSP libcloud:\n{1}'.format(disk.name, exc), exc_info_on_loglevel=logging.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP __utils__['cloud.fire_event']('event', 'deleted DCSP disk', 'salt/cloud/disk/deleted', args={'name': disk.name, 'location': disk.extra['zone'].name, 'size': disk.size}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP return result
 DCSP wxapp = wx.GetApp() DCNL DCSP if (wxapp is None): DCNL DCSP  DCSP wxapp = wx.PySimpleApp() DCNL DCSP  DCSP wxapp.SetExitOnFrameDelete(True) DCNL DCSP  DCSP _create_wx_app.theWxApp = wxapp
 DCSP found = False DCNL DCSP f = open(filename, 'rt') DCNL DCSP for line in iter(f.readline, ''): DCNL DCSP  DCSP parts = line.split() DCNL DCSP  DCSP if (len(parts) == 2): DCNL DCSP  DCSP  DCSP (kind, length) = parts DCNL DCSP  DCSP  DCSP data = f.read(int(length)) DCNL DCSP  DCSP  DCSP if ((kind == 'K') and (data == 'svn:externals')): DCNL DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP elif ((kind == 'V') and found): DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP return DCNL DCSP for line in data.splitlines(): DCNL DCSP  DCSP parts = line.split() DCNL DCSP  DCSP if parts: DCNL DCSP  DCSP  DCSP (yield joinpath(dirname, parts[0]))
 DCSP try: DCNL DCSP  DCSP closable.close() DCNL DCSP except Exception: DCNL DCSP  DCSP logger.debug(u'Exception DCSP while DCSP closing', exc_info=True)
 DCSP assert (len(roidb) > 0) DCNL DCSP assert ('max_classes' in roidb[0]), 'Did DCSP you DCSP call DCSP prepare_roidb DCSP first?' DCNL DCSP num_images = len(roidb) DCNL DCSP num_classes = roidb[0]['gt_overlaps'].shape[1] DCNL DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP rois = roidb[im_i]['boxes'] DCNL DCSP  DCSP max_overlaps = roidb[im_i]['max_overlaps'] DCNL DCSP  DCSP max_classes = roidb[im_i]['max_classes'] DCNL DCSP  DCSP roidb[im_i]['bbox_targets'] = _compute_targets(rois, max_overlaps, max_classes) DCNL DCSP if cfg.TRAIN.BBOX_NORMALIZE_TARGETS_PRECOMPUTED: DCNL DCSP  DCSP means = np.tile(np.array(cfg.TRAIN.BBOX_NORMALIZE_MEANS), (num_classes, 1)) DCNL DCSP  DCSP stds = np.tile(np.array(cfg.TRAIN.BBOX_NORMALIZE_STDS), (num_classes, 1)) DCNL DCSP else: DCNL DCSP  DCSP class_counts = (np.zeros((num_classes, 1)) + cfg.EPS) DCNL DCSP  DCSP sums = np.zeros((num_classes, 4)) DCNL DCSP  DCSP squared_sums = np.zeros((num_classes, 4)) DCNL DCSP  DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP  DCSP targets = roidb[im_i]['bbox_targets'] DCNL DCSP  DCSP  DCSP for cls in xrange(1, num_classes): DCNL DCSP  DCSP  DCSP  DCSP cls_inds = np.where((targets[:, 0] == cls))[0] DCNL DCSP  DCSP  DCSP  DCSP if (cls_inds.size > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP class_counts[cls] += cls_inds.size DCNL DCSP  DCSP  DCSP  DCSP  DCSP sums[cls, :] += targets[cls_inds, 1:].sum(axis=0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP squared_sums[cls, :] += (targets[cls_inds, 1:] ** 2).sum(axis=0) DCNL DCSP  DCSP means = (sums / class_counts) DCNL DCSP  DCSP stds = np.sqrt(((squared_sums / class_counts) - (means ** 2))) DCNL DCSP print 'bbox DCSP target DCSP means:' DCNL DCSP print means DCNL DCSP print means[1:, :].mean(axis=0) DCNL DCSP print 'bbox DCSP target DCSP stdevs:' DCNL DCSP print stds DCNL DCSP print stds[1:, :].mean(axis=0) DCNL DCSP if cfg.TRAIN.BBOX_NORMALIZE_TARGETS: DCNL DCSP  DCSP print 'Normalizing DCSP targets' DCNL DCSP  DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP  DCSP targets = roidb[im_i]['bbox_targets'] DCNL DCSP  DCSP  DCSP for cls in xrange(1, num_classes): DCNL DCSP  DCSP  DCSP  DCSP cls_inds = np.where((targets[:, 0] == cls))[0] DCNL DCSP  DCSP  DCSP  DCSP roidb[im_i]['bbox_targets'][cls_inds, 1:] -= means[cls, :] DCNL DCSP  DCSP  DCSP  DCSP roidb[im_i]['bbox_targets'][cls_inds, 1:] /= stds[cls, :] DCNL DCSP else: DCNL DCSP  DCSP print 'NOT DCSP normalizing DCSP targets' DCNL DCSP return (means.ravel(), stds.ravel())
 DCSP with settings(warn_only=True): DCNL DCSP  DCSP res = run(('pkg_info DCSP -e DCSP %s' % pkg_name)) DCNL DCSP  DCSP return (res.succeeded is True)
 DCSP n = b.size DCNL DCSP assert (A.n == n) DCNL DCSP assert (A.m == n) DCNL DCSP b_norm = np.linalg.norm(b) DCNL DCSP kvec = A.diag DCNL DCSP kvec = np.where((kvec > 1e-06), kvec, 1e-06) DCNL DCSP if (x0 is None): DCNL DCSP  DCSP x = np.zeros(n) DCNL DCSP else: DCNL DCSP  DCSP x = x0 DCNL DCSP r = (b - A.dot(x)) DCNL DCSP w = (r / kvec) DCNL DCSP p = np.zeros(n) DCNL DCSP beta = 0.0 DCNL DCSP rho = np.dot(r, w) DCNL DCSP k = 0 DCNL DCSP while ((np.sqrt(abs(rho)) > (tol * b_norm)) and (k < maxiter)): DCNL DCSP  DCSP p = (w + (beta * p)) DCNL DCSP  DCSP z = A.dot(p) DCNL DCSP  DCSP alpha = (rho / np.dot(p, z)) DCNL DCSP  DCSP r = (r - (alpha * z)) DCNL DCSP  DCSP w = (r / kvec) DCNL DCSP  DCSP rhoold = rho DCNL DCSP  DCSP rho = np.dot(r, w) DCNL DCSP  DCSP x = (x + (alpha * p)) DCNL DCSP  DCSP beta = (rho / rhoold) DCNL DCSP  DCSP k += 1 DCNL DCSP err = np.linalg.norm((A.dot(x) - b)) DCNL DCSP return (x, err)
 DCSP if (not G.has_edge(*edge)): DCNL DCSP  DCSP raise ValueError('Edge DCSP {0} DCSP does DCSP not DCSP exist DCSP in DCSP graph DCSP G; DCSP cannot DCSP contract DCSP it'.format(edge)) DCNL DCSP return contracted_nodes(G, self_loops=self_loops, *edge)
 DCSP script.pip('install', '--compile', 'simple.dist==0.1', '--no-index', ('--find-links=' + data.find_links)) DCNL DCSP exists = [os.path.exists((script.site_packages_path / 'simpledist/__init__.pyc'))] DCNL DCSP exists += glob.glob((script.site_packages_path / 'simpledist/__pycache__/__init__*.pyc')) DCNL DCSP assert any(exists)
 DCSP n = (n / np.sqrt(np.square(n).sum(axis=(-1)))) DCNL DCSP if (abs(n[0]) == 1): DCNL DCSP  DCSP l = np.r_[(n[2], 0, (- n[0]))] DCNL DCSP else: DCNL DCSP  DCSP l = np.r_[(0, n[2], (- n[1]))] DCNL DCSP l = (l / np.sqrt(np.square(l).sum(axis=(-1)))) DCNL DCSP m = np.cross(n, l) DCNL DCSP return (n, l, m)
 DCSP return Date(*time.localtime(ticks)[:3])
 DCSP return IMPL.instance_tag_delete_all(context, instance_uuid)
 DCSP try: DCNL DCSP  DCSP parser_cache_item = parser_cache[path] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP _invalidate_star_import_cache_module(parser_cache_item.parser.module)
 DCSP fp = TraceFuncCoverage(fn) DCNL DCSP def new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__doc__ = fn.__doc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__dict__ = fn.__dict__ DCNL DCSP new_fn.__module__ = fn.__module__ DCNL DCSP return new_fn
 DCSP sql_commands = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP disk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_disk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP  DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for command in sql_commands: DCNL DCSP  DCSP meta.bind.execute(command) DCNL DCSP _sqlite_table_swap(t_image_members, t_image_properties, t_images)
 DCSP print 'TODO'
 DCSP if (not date): DCNL DCSP  DCSP return u'' DCNL DCSP right_now = now() DCNL DCSP today = datetime(right_now.year, right_now.month, right_now.day, tzinfo=right_now.tzinfo) DCNL DCSP delta = (right_now - date) DCNL DCSP delta_midnight = (today - date) DCNL DCSP days = delta.days DCNL DCSP hours = (delta.seconds // 3600) DCNL DCSP minutes = (delta.seconds // 60) DCNL DCSP seconds = delta.seconds DCNL DCSP if (days < 0): DCNL DCSP  DCSP return _(u'just DCSP now') DCNL DCSP if (days == 0): DCNL DCSP  DCSP if (hours == 0): DCNL DCSP  DCSP  DCSP if (minutes > 0): DCNL DCSP  DCSP  DCSP  DCSP return ungettext(_(u'{minutes} DCSP minute DCSP ago'), _(u'{minutes} DCSP minutes DCSP ago'), minutes).format(minutes=minutes) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (include_seconds and seconds): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ungettext(_(u'{seconds} DCSP second DCSP ago'), _(u'{seconds} DCSP seconds DCSP ago'), seconds).format(seconds=seconds) DCNL DCSP  DCSP  DCSP  DCSP return _(u'just DCSP now') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ungettext(_(u'{hours} DCSP hour DCSP ago'), _(u'{hours} DCSP hours DCSP ago'), hours).format(hours=hours) DCNL DCSP if (delta_midnight.days == 0): DCNL DCSP  DCSP return _(u'yesterday DCSP at DCSP {time}').format(time=date.strftime(u'%H:%M')) DCNL DCSP count = 0 DCNL DCSP for (chunk, pluralizefun) in OLDER_CHUNKS: DCNL DCSP  DCSP if (days >= chunk): DCNL DCSP  DCSP  DCSP count = int(round(((delta_midnight.days + 1) / chunk), 0)) DCNL DCSP  DCSP  DCSP fmt = pluralizefun(count) DCNL DCSP  DCSP  DCSP return fmt.format(num=count)
 DCSP output_dict = {} DCNL DCSP for (module_name, module) in module_dict.iteritems(): DCNL DCSP  DCSP if (module is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if IsEncodingsModule(module_name): DCNL DCSP  DCSP  DCSP output_dict[module_name] = module DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP shared_prefix = ModuleNameHasPrefix(module_name, SHARED_MODULE_PREFIXES) DCNL DCSP  DCSP banned_prefix = ModuleNameHasPrefix(module_name, NOT_SHARED_MODULE_PREFIXES) DCNL DCSP  DCSP if (shared_prefix and (not banned_prefix)): DCNL DCSP  DCSP  DCSP output_dict[module_name] = module DCNL DCSP return output_dict
 DCSP path('build').rmtree() DCNL DCSP path('dist').rmtree()
 DCSP ratio = (1.0 / 10000.0) DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ada.fit, X, Y)
 DCSP @custom_model DCNL DCSP def model_a(x, a=1): DCNL DCSP  DCSP return (x * a) DCNL DCSP class model_b(model_a, ): DCNL DCSP  DCSP @classmethod DCNL DCSP  DCSP def evaluate(cls, x, a): DCNL DCSP  DCSP  DCSP return (- super(model_b, cls).evaluate(x, a)) DCNL DCSP b = model_b() DCNL DCSP assert (b.param_names == (u'a',)) DCNL DCSP assert (b.a == 1) DCNL DCSP assert (b(1) == (-1)) DCNL DCSP sig = signature(model_b.__init__) DCNL DCSP assert (list(sig.parameters.keys()) == [u'self', u'a', u'kwargs']) DCNL DCSP sig = signature(model_b.__call__) DCNL DCSP assert (list(sig.parameters.keys()) == [u'self', u'x', u'model_set_axis'])
 DCSP counter = 0 DCNL DCSP for i in range(len(string)): DCNL DCSP  DCSP if ((ord(string[i]) <= 31) or (ord(string[i]) > 127)): DCNL DCSP  DCSP  DCSP counter += 1 DCNL DCSP return counter
 DCSP if isinstance(video, Episode): DCNL DCSP  DCSP return episode_scores DCNL DCSP elif isinstance(video, Movie): DCNL DCSP  DCSP return movie_scores DCNL DCSP raise ValueError('video DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP Episode DCSP or DCSP Movie')
 DCSP try: DCNL DCSP  DCSP psutil.Process(pid).send_signal(signal) DCNL DCSP  DCSP return True DCNL DCSP except psutil.NoSuchProcess: DCNL DCSP  DCSP return False
 DCSP text = text.replace('\\', '\\\\') DCNL DCSP text = text.replace('"""', '""\\"') DCNL DCSP text = text.replace(' DCSP \n', ' DCSP \\n\\\n') DCNL DCSP return text
 DCSP try: DCNL DCSP  DCSP int(value) DCNL DCSP except: DCNL DCSP  DCSP raise ValueError('expected DCSP an DCSP integer DCSP value') DCNL DCSP content = str(value) DCNL DCSP while (len(content) < length): DCNL DCSP  DCSP content = ('0' + content) DCNL DCSP return content
 DCSP if check_required: DCNL DCSP  DCSP for key in api_model: DCNL DCSP  DCSP  DCSP if (api_model[key].required and (key not in payload)): DCNL DCSP  DCSP  DCSP  DCSP raise ValidationError(field=key, message="Required DCSP field DCSP '{}' DCSP missing".format(key)) DCNL DCSP for key in payload: DCNL DCSP  DCSP field = api_model[key] DCNL DCSP  DCSP if isinstance(field, fields.List): DCNL DCSP  DCSP  DCSP field = field.container DCNL DCSP  DCSP  DCSP data = payload[key] DCNL DCSP  DCSP elif isinstance(field, fields.Nested): DCNL DCSP  DCSP  DCSP if payload[key]: DCNL DCSP  DCSP  DCSP  DCSP validate_payload(payload[key], field.model) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP data = [payload[key]] DCNL DCSP  DCSP if (isinstance(field, CustomField) and hasattr(field, 'validate')): DCNL DCSP  DCSP  DCSP field.payload = payload DCNL DCSP  DCSP  DCSP for i in data: DCNL DCSP  DCSP  DCSP  DCSP if (not field.validate(i)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValidationError(field=key, message=(field.validation_error % ("'%s'" % key)))
 DCSP if ((item.name is None) or (item.name == '')): DCNL DCSP  DCSP raise exceptions.RuntimeError('name DCSP unset DCSP for DCSP item!') DCNL DCSP if (collection.collection_type() in ['mgmtclass']): DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ses/%s' % (collection.collection_type(), item.name)) DCNL DCSP else: DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ss/%s' % (collection.collection_type(), item.name)) DCNL DCSP _dict = item.to_dict() DCNL DCSP if capi.CobblerAPI().settings().serializer_pretty_json: DCNL DCSP  DCSP sort_keys = True DCNL DCSP  DCSP indent = 4 DCNL DCSP else: DCNL DCSP  DCSP sort_keys = False DCNL DCSP  DCSP indent = None DCNL DCSP filename += '.json' DCNL DCSP _dict = item.to_dict() DCNL DCSP fd = open(filename, 'w+') DCNL DCSP data = simplejson.dumps(_dict, encoding='utf-8', sort_keys=sort_keys, indent=indent) DCNL DCSP fd.write(data) DCNL DCSP fd.close()
 DCSP if (not tb): DCNL DCSP  DCSP tb = sys.exc_info()[2] DCNL DCSP (filename, lineno, _context, _line) = traceback.extract_tb(tb)[(-1)] DCNL DCSP return (filename, lineno)
 DCSP _check_unknown_options(unknown_options) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return_all DCNL DCSP x0 = asarray(x0).flatten() DCNL DCSP if (maxiter is None): DCNL DCSP  DCSP maxiter = (len(x0) * 200) DCNL DCSP (func_calls, f) = wrap_function(f, args) DCNL DCSP if (fprime is None): DCNL DCSP  DCSP (grad_calls, myfprime) = wrap_function(approx_fprime, (f, epsilon)) DCNL DCSP else: DCNL DCSP  DCSP (grad_calls, myfprime) = wrap_function(fprime, args) DCNL DCSP gfk = myfprime(x0) DCNL DCSP k = 0 DCNL DCSP xk = x0 DCNL DCSP old_fval = f(xk) DCNL DCSP old_old_fval = (old_fval + (np.linalg.norm(gfk) / 2)) DCNL DCSP if retall: DCNL DCSP  DCSP allvecs = [xk] DCNL DCSP warnflag = 0 DCNL DCSP pk = (- gfk) DCNL DCSP gnorm = vecnorm(gfk, ord=norm) DCNL DCSP while ((gnorm > gtol) and (k < maxiter)): DCNL DCSP  DCSP deltak = numpy.dot(gfk, gfk) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (alpha_k, fc, gc, old_fval, old_old_fval, gfkp1) = _line_search_wolfe12(f, myfprime, xk, pk, gfk, old_fval, old_old_fval, c2=0.4, amin=1e-100, amax=1e+100) DCNL DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP xk = (xk + (alpha_k * pk)) DCNL DCSP  DCSP if retall: DCNL DCSP  DCSP  DCSP allvecs.append(xk) DCNL DCSP  DCSP if (gfkp1 is None): DCNL DCSP  DCSP  DCSP gfkp1 = myfprime(xk) DCNL DCSP  DCSP yk = (gfkp1 - gfk) DCNL DCSP  DCSP beta_k = max(0, (numpy.dot(yk, gfkp1) / deltak)) DCNL DCSP  DCSP pk = ((- gfkp1) + (beta_k * pk)) DCNL DCSP  DCSP gfk = gfkp1 DCNL DCSP  DCSP gnorm = vecnorm(gfk, ord=norm) DCNL DCSP  DCSP if (callback is not None): DCNL DCSP  DCSP  DCSP callback(xk) DCNL DCSP  DCSP k += 1 DCNL DCSP fval = old_fval DCNL DCSP if (warnflag == 2): DCNL DCSP  DCSP msg = _status_message['pr_loss'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP elif (k >= maxiter): DCNL DCSP  DCSP warnflag = 1 DCNL DCSP  DCSP msg = _status_message['maxiter'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP else: DCNL DCSP  DCSP msg = _status_message['success'] DCNL DCSP  DCSP if disp: DCNL DCSP  DCSP  DCSP print(msg) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %d' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %d' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gradient DCSP evaluations: DCSP %d' % grad_calls[0])) DCNL DCSP result = OptimizeResult(fun=fval, jac=gfk, nfev=func_calls[0], njev=grad_calls[0], status=warnflag, success=(warnflag == 0), message=msg, x=xk, nit=k) DCNL DCSP if retall: DCNL DCSP  DCSP result['allvecs'] = allvecs DCNL DCSP return result
 DCSP return rpc_utils.prepare_rows_as_nested_dicts(models.RecurringRun.query_objects(filter_data), ('job', 'owner'))
 DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP grp_info = __salt__['group.info'](name) DCNL DCSP if grp_info: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Group DCSP {0} DCSP is DCSP set DCSP for DCSP removal'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP ret['result'] = __salt__['group.delete'](name) DCNL DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP ret['changes'] = {name: ''} DCNL DCSP  DCSP  DCSP ret['comment'] = 'Removed DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP remove DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Group DCSP not DCSP present' DCNL DCSP  DCSP return ret
 DCSP global globalRepositoryDialogListTable DCNL DCSP globalRepositoryDialogValues = euclidean.getListTableElements(globalRepositoryDialogListTable) DCNL DCSP for globalRepositoryDialogValue in globalRepositoryDialogValues: DCNL DCSP  DCSP quitWindow(globalRepositoryDialogValue.root)
 DCSP data = _get_values(profile) DCNL DCSP return salt.utils.traverse_dict_and_list(data, key, None)
 DCSP return for_dtypes(_make_all_dtypes(no_float16, no_bool), name=name)
 DCSP map_dict = {} DCNL DCSP for i in range(len(mapping_data)): DCNL DCSP  DCSP sam = mapping_data[i] DCNL DCSP  DCSP map_dict[sam[0]] = {} DCNL DCSP  DCSP for j in range(len(header)): DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP map_dict[sam[0]][header[j]] = sam[j] DCNL DCSP return map_dict
 DCSP bits = token.split_contents()[1:] DCNL DCSP if (len(bits) < 1): DCNL DCSP  DCSP raise TemplateSyntaxError("'firstof' DCSP statement DCSP requires DCSP at DCSP least DCSP one DCSP argument") DCNL DCSP return FirstOfNode([parser.compile_filter(bit) for bit in bits])
 DCSP scan_info = get_scan_info_from_id(scan_id) DCNL DCSP if (scan_info is None): DCNL DCSP  DCSP abort(404, 'Scan DCSP not DCSP found') DCNL DCSP data = [] DCNL DCSP all_exceptions = scan_info.w3af_core.exception_handler.get_all_exceptions() DCNL DCSP for (exception_id, exception_data) in enumerate(all_exceptions): DCNL DCSP  DCSP data.append(exception_to_json(exception_data, scan_id, exception_id)) DCNL DCSP return jsonify({'items': data})
 DCSP return (func(arg).args[0] == (- arg))
 DCSP if (not isinstance(jid, six.string_types)): DCNL DCSP  DCSP return False DCNL DCSP if (len(jid) != 20): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP int(jid) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
 DCSP (base, sub, _) = typ DCNL DCSP if (base == 'uint'): DCNL DCSP  DCSP sub = int(sub) DCNL DCSP  DCSP if (not ((0 < sub <= 256) and ((sub % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invalid DCSP unsigned DCSP integer DCSP bit DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i = decint(arg, signed=False) DCNL DCSP  DCSP except EncodingError: DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP if (not (0 <= i < (2 ** sub))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP value_encoded = int_to_big_endian(i) DCNL DCSP  DCSP return zpad(value_encoded, 32) DCNL DCSP if (base == 'int'): DCNL DCSP  DCSP sub = int(sub) DCNL DCSP  DCSP bits = (sub - 1) DCNL DCSP  DCSP if (not ((0 < sub <= 256) and ((sub % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invalid DCSP integer DCSP bit DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i = decint(arg, signed=True) DCNL DCSP  DCSP except EncodingError: DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP if (not ((- (2 ** bits)) <= i < (2 ** bits))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP value = (i % (2 ** sub)) DCNL DCSP  DCSP value_encoded = int_to_big_endian(value) DCNL DCSP  DCSP return zpad(value_encoded, 32) DCNL DCSP if (base == 'bool'): DCNL DCSP  DCSP if (arg is True): DCNL DCSP  DCSP  DCSP value_encoded = int_to_big_endian(1) DCNL DCSP  DCSP elif (arg is False): DCNL DCSP  DCSP  DCSP value_encoded = int_to_big_endian(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('%r DCSP is DCSP not DCSP bool' % arg)) DCNL DCSP  DCSP return zpad(value_encoded, 32) DCNL DCSP if (base == 'ufixed'): DCNL DCSP  DCSP sub = str(sub) DCNL DCSP  DCSP (high_str, low_str) = sub.split('x') DCNL DCSP  DCSP high = int(high_str) DCNL DCSP  DCSP low = int(low_str) DCNL DCSP  DCSP if (not ((0 < (high + low) <= 256) and ((high % 8) == 0) and ((low % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invalid DCSP unsigned DCSP fixed DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP if (not (0 <= arg < (2 ** high))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP float_point = (arg * (2 ** low)) DCNL DCSP  DCSP fixed_point = int(float_point) DCNL DCSP  DCSP return zpad(int_to_big_endian(fixed_point), 32) DCNL DCSP if (base == 'fixed'): DCNL DCSP  DCSP sub = str(sub) DCNL DCSP  DCSP (high_str, low_str) = sub.split('x') DCNL DCSP  DCSP high = int(high_str) DCNL DCSP  DCSP low = int(low_str) DCNL DCSP  DCSP bits = (high - 1) DCNL DCSP  DCSP if (not ((0 < (high + low) <= 256) and ((high % 8) == 0) and ((low % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invalid DCSP unsigned DCSP fixed DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP if (not ((- (2 ** bits)) <= arg < (2 ** bits))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounds(repr(arg)) DCNL DCSP  DCSP float_point = (arg * (2 ** low)) DCNL DCSP  DCSP fixed_point = int(float_point) DCNL DCSP  DCSP value = (fixed_point % (2 ** 256)) DCNL DCSP  DCSP return zpad(int_to_big_endian(value), 32) DCNL DCSP if (base == 'string'): DCNL DCSP  DCSP if isinstance(arg, utils.unicode): DCNL DCSP  DCSP  DCSP arg = arg.encode('utf8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP arg.decode('utf8') DCNL DCSP  DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoded') DCNL DCSP  DCSP if len(sub): DCNL DCSP  DCSP  DCSP if (not (0 <= len(arg) <= int(sub))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invalid DCSP string DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP  DCSP if (not (0 <= int(sub) <= 32)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invalid DCSP string DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP  DCSP return rzpad(arg, 32) DCNL DCSP  DCSP if (not (0 <= len(arg) < TT256)): DCNL DCSP  DCSP  DCSP raise Exception(('Integer DCSP invalid DCSP or DCSP out DCSP of DCSP range: DCSP %r' % arg)) DCNL DCSP  DCSP length_encoded = zpad(int_to_big_endian(len(arg)), 32) DCNL DCSP  DCSP value_encoded = rzpad(arg, utils.ceil32(len(arg))) DCNL DCSP  DCSP return (length_encoded + value_encoded) DCNL DCSP if (base == 'bytes'): DCNL DCSP  DCSP if (not is_string(arg)): DCNL DCSP  DCSP  DCSP raise EncodingError(('Expecting DCSP string: DCSP %r' % arg)) DCNL DCSP  DCSP arg = utils.to_string(arg) DCNL DCSP  DCSP if len(sub): DCNL DCSP  DCSP  DCSP if (not (0 <= len(arg) <= int(sub))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoded') DCNL DCSP  DCSP  DCSP if (not (0 <= int(sub) <= 32)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoded') DCNL DCSP  DCSP  DCSP return rzpad(arg, 32) DCNL DCSP  DCSP if (not (0 <= len(arg) < TT256)): DCNL DCSP  DCSP  DCSP raise Exception(('Integer DCSP invalid DCSP or DCSP out DCSP of DCSP range: DCSP %r' % arg)) DCNL DCSP  DCSP length_encoded = zpad(int_to_big_endian(len(arg)), 32) DCNL DCSP  DCSP value_encoded = rzpad(arg, utils.ceil32(len(arg))) DCNL DCSP  DCSP return (length_encoded + value_encoded) DCNL DCSP if (base == 'hash'): DCNL DCSP  DCSP if (not (int(sub) and (int(sub) <= 32))): DCNL DCSP  DCSP  DCSP raise EncodingError(('too DCSP long: DCSP %r' % arg)) DCNL DCSP  DCSP if isnumeric(arg): DCNL DCSP  DCSP  DCSP return zpad(encode_int(arg), 32) DCNL DCSP  DCSP if (len(arg) == int(sub)): DCNL DCSP  DCSP  DCSP return zpad(arg, 32) DCNL DCSP  DCSP if (len(arg) == (int(sub) * 2)): DCNL DCSP  DCSP  DCSP return zpad(decode_hex(arg), 32) DCNL DCSP  DCSP raise EncodingError(('Could DCSP not DCSP parse DCSP hash: DCSP %r' % arg)) DCNL DCSP if (base == 'address'): DCNL DCSP  DCSP assert (sub == '') DCNL DCSP  DCSP if isnumeric(arg): DCNL DCSP  DCSP  DCSP return zpad(encode_int(arg), 32) DCNL DCSP  DCSP if (len(arg) == 20): DCNL DCSP  DCSP  DCSP return zpad(arg, 32) DCNL DCSP  DCSP if (len(arg) == 40): DCNL DCSP  DCSP  DCSP return zpad(decode_hex(arg), 32) DCNL DCSP  DCSP if ((len(arg) == 42) and (arg[:2] == '0x')): DCNL DCSP  DCSP  DCSP return zpad(decode_hex(arg[2:]), 32) DCNL DCSP  DCSP raise EncodingError(('Could DCSP not DCSP parse DCSP address: DCSP %r' % arg)) DCNL DCSP raise EncodingError(('Unhandled DCSP type: DCSP %r DCSP %r' % (base, sub)))
 DCSP global shell DCNL DCSP cmds = {} DCNL DCSP for cmdlet in InvokeCommand('get-command'): DCNL DCSP  DCSP cmds[translate(cmdlet.Name)] = ShellCommand(cmdlet.Name) DCNL DCSP for alias in InvokeCommand('get-alias'): DCNL DCSP  DCSP cmdName = translate(alias.ReferencedCommand.Name) DCNL DCSP  DCSP if (cmdName in cmds): DCNL DCSP  DCSP  DCSP cmds[translate(alias.Name)] = cmds[cmdName] DCNL DCSP shell = Shell(cmds) DCNL DCSP for key in cmds.keys(): DCNL DCSP  DCSP setattr(ShellOutput, key, cmds[key])
 DCSP assert (hsl_to_rgb(6120, 100, 50) == (255, 0, 0)) DCNL DCSP assert (hsl_to_rgb((-9660), 100, 50) == (255, 255, 0)) DCNL DCSP assert (hsl_to_rgb(99840, 100, 50) == (0, 255, 0)) DCNL DCSP assert (hsl_to_rgb((-900), 100, 50) == (0, 255, 255)) DCNL DCSP assert (hsl_to_rgb((-104880), 100, 50) == (0, 0, 255)) DCNL DCSP assert (hsl_to_rgb(2820, 100, 50) == (255, 0, 255))
 DCSP if (('ORACLE_HOME' not in os.environ) and ('ORACLE_INSTANTCLIENT_HOME' not in os.environ)): DCNL DCSP  DCSP raise SkipTest DCNL DCSP try: DCNL DCSP  DCSP import cx_Oracle DCNL DCSP  DCSP return DCNL DCSP except ImportError as ex: DCNL DCSP  DCSP if ('No DCSP module DCSP named' in ex.message): DCNL DCSP  DCSP  DCSP assert_true(False, 'cx_Oracle DCSP skipped DCSP its DCSP build. DCSP This DCSP happens DCSP if DCSP env DCSP var DCSP ORACLE_HOME DCSP or DCSP ORACLE_INSTANTCLIENT_HOME DCSP is DCSP not DCSP defined. DCSP So DCSP ignore DCSP this DCSP test DCSP failure DCSP if DCSP your DCSP build DCSP does DCSP not DCSP need DCSP to DCSP work DCSP with DCSP an DCSP oracle DCSP backend.')
 DCSP try: DCNL DCSP  DCSP chan = _open_session() DCNL DCSP except ssh.SSHException as err: DCNL DCSP  DCSP if (str(err) == 'SSH DCSP session DCSP not DCSP active'): DCNL DCSP  DCSP  DCSP connections[env.host_string].close() DCNL DCSP  DCSP  DCSP del connections[env.host_string] DCNL DCSP  DCSP  DCSP chan = _open_session() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP chan.settimeout(0.1) DCNL DCSP chan.input_enabled = True DCNL DCSP return chan
 DCSP return int((value * 9525))
 DCSP for function in list(globals().values()): DCNL DCSP  DCSP if inspect.isfunction(function): DCNL DCSP  DCSP  DCSP arguments = inspect.getargspec(function)[0] DCNL DCSP  DCSP  DCSP if (arguments[:1] != [u'source']): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP code = extract_code_from_function(function) DCNL DCSP  DCSP  DCSP if code: DCNL DCSP  DCSP  DCSP  DCSP (yield (code, function))
 DCSP lrf = (stream if isinstance(stream, LRFMetaFile) else LRFMetaFile(stream)) DCNL DCSP authors = string_to_authors(lrf.author) DCNL DCSP mi = MetaInformation(lrf.title.strip(), authors) DCNL DCSP mi.author = lrf.author.strip() DCNL DCSP mi.comments = lrf.free_text.strip() DCNL DCSP mi.category = ((lrf.category.strip() + ', DCSP ') + lrf.classification.strip()) DCNL DCSP tags = [x.strip() for x in mi.category.split(',') if x.strip()] DCNL DCSP if tags: DCNL DCSP  DCSP mi.tags = tags DCNL DCSP if (mi.category.strip() == ','): DCNL DCSP  DCSP mi.category = None DCNL DCSP mi.publisher = lrf.publisher.strip() DCNL DCSP mi.cover_data = lrf.get_cover() DCNL DCSP try: DCNL DCSP  DCSP mi.title_sort = lrf.title_reading.strip() DCNL DCSP  DCSP if (not mi.title_sort): DCNL DCSP  DCSP  DCSP mi.title_sort = None DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP mi.author_sort = lrf.author_reading.strip() DCNL DCSP  DCSP if (not mi.author_sort): DCNL DCSP  DCSP  DCSP mi.author_sort = None DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP if ((not mi.title) or ('unknown' in mi.title.lower())): DCNL DCSP  DCSP mi.title = None DCNL DCSP if (not mi.authors): DCNL DCSP  DCSP mi.authors = None DCNL DCSP if ((not mi.author) or ('unknown' in mi.author.lower())): DCNL DCSP  DCSP mi.author = None DCNL DCSP if ((not mi.category) or ('unknown' in mi.category.lower())): DCNL DCSP  DCSP mi.category = None DCNL DCSP if ((not mi.publisher) or ('unknown' in mi.publisher.lower()) or ('some DCSP publisher' in mi.publisher.lower())): DCNL DCSP  DCSP mi.publisher = None DCNL DCSP return mi
 DCSP pre = seq[:phase] DCNL DCSP np_seq = seq[phase:] DCNL DCSP non_triplets = (len(np_seq) % 3) DCNL DCSP post = ('' if (not non_triplets) else np_seq[((-1) * non_triplets):]) DCNL DCSP intacts = [np_seq[(3 * i):(3 * (i + 1))] for i in range((len(np_seq) // 3))] DCNL DCSP return (pre, intacts, post)
 DCSP if (':' in classpath): DCNL DCSP  DCSP (modname, objname) = classpath.split(':', 1) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __import__(modname) DCNL DCSP  DCSP  DCSP module = modules[modname] DCNL DCSP  DCSP  DCSP _class = eval(objname, module.__dict__) DCNL DCSP  DCSP  DCSP if (_class is None): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('eval(%(objname)s) DCSP in DCSP %(modname)s DCSP came DCSP up DCSP None' % locals())) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Tried DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % (classpath, e))) DCNL DCSP else: DCNL DCSP  DCSP classpath = classpath.split('.') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP module = __import__('.'.join(classpath[:(-1)]), fromlist=str(classpath[(-1)])) DCNL DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Tried DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % ('.'.join(classpath), e))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _class = getattr(module, classpath[(-1)]) DCNL DCSP  DCSP except AttributeError as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Tried DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % ('.'.join(classpath), e))) DCNL DCSP return _class
 DCSP if opts: DCNL DCSP  DCSP key = (args, frozenset(opts.items())) DCNL DCSP else: DCNL DCSP  DCSP key = args DCNL DCSP cache = func.cache DCNL DCSP try: DCNL DCSP  DCSP result = cache[key] DCNL DCSP except KeyError: DCNL DCSP  DCSP result = cache[key] = func(*args, **opts) DCNL DCSP return result
 DCSP app = get_app() DCNL DCSP if (not have_git): DCNL DCSP  DCSP session.flash = GIT_MISSING DCNL DCSP  DCSP redirect(URL('site')) DCNL DCSP dialog = FORM.confirm(T('Pull'), {T('Cancel'): URL('site')}) DCNL DCSP if dialog.accepted: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP repo = git.Repo(os.path.join(apath(r=request), app)) DCNL DCSP  DCSP  DCSP origin = repo.remotes.origin DCNL DCSP  DCSP  DCSP origin.fetch() DCNL DCSP  DCSP  DCSP origin.pull() DCNL DCSP  DCSP  DCSP session.flash = T('Application DCSP updated DCSP via DCSP git DCSP pull') DCNL DCSP  DCSP  DCSP redirect(URL('site')) DCNL DCSP  DCSP except git.CheckoutError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP failed, DCSP certain DCSP files DCSP could DCSP not DCSP be DCSP checked DCSP out. DCSP Check DCSP logs DCSP for DCSP details.') DCNL DCSP  DCSP  DCSP redirect(URL('site')) DCNL DCSP  DCSP except git.UnmergedEntriesError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmerged DCSP files. DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree, DCSP and DCSP then DCSP try DCSP again.') DCNL DCSP  DCSP  DCSP redirect(URL('site')) DCNL DCSP  DCSP except git.GitCommandError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP failed, DCSP git DCSP exited DCSP abnormally. DCSP See DCSP logs DCSP for DCSP details.') DCNL DCSP  DCSP  DCSP redirect(URL('site')) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmerged DCSP files. DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree, DCSP and DCSP then DCSP try DCSP again.') DCNL DCSP  DCSP  DCSP redirect(URL('site')) DCNL DCSP elif ('cancel' in request.vars): DCNL DCSP  DCSP redirect(URL('site')) DCNL DCSP return dict(app=app, dialog=dialog)
 DCSP try: DCNL DCSP  DCSP import cssutils DCNL DCSP except (ImportError, re.error): DCNL DCSP  DCSP return None DCNL DCSP parser = cssutils.CSSParser(loglevel=100, fetcher=(lambda url: (None, '')), validate=False) DCNL DCSP if (not inline): DCNL DCSP  DCSP sheet = parser.parseString(data) DCNL DCSP  DCSP return list(cssutils.getUrls(sheet)) DCNL DCSP else: DCNL DCSP  DCSP urls = [] DCNL DCSP  DCSP declaration = parser.parseStyle(data) DCNL DCSP  DCSP for prop in declaration: DCNL DCSP  DCSP  DCSP for value in prop.propertyValue: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, cssutils.css.URIValue): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value.uri: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP urls.append(value.uri) DCNL DCSP  DCSP return urls
 DCSP s_path = None DCNL DCSP path = cfg.script_dir.get_path() DCNL DCSP if (path and script): DCNL DCSP  DCSP if (script.lower() not in ('none', 'default')): DCNL DCSP  DCSP  DCSP s_path = os.path.join(path, script) DCNL DCSP  DCSP  DCSP if (not os.path.exists(s_path)): DCNL DCSP  DCSP  DCSP  DCSP s_path = None DCNL DCSP return s_path
 DCSP t = Twitter(auth=authen()) DCNL DCSP screen_name = g['stuff'].split()[0] DCNL DCSP if screen_name.startswith('@'): DCNL DCSP  DCSP t.friendships.create(screen_name=screen_name[1:], follow=True) DCNL DCSP  DCSP printNicely(green((('You DCSP are DCSP following DCSP ' + screen_name) + ' DCSP now!'))) DCNL DCSP else: DCNL DCSP  DCSP printNicely(red("A DCSP name DCSP should DCSP begin DCSP with DCSP a DCSP '@'"))
 DCSP not_found = [] DCNL DCSP for template_name in template_name_list: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return get_template(template_name) DCNL DCSP  DCSP except TemplateDoesNotExist as e: DCNL DCSP  DCSP  DCSP if (e.args[0] not in not_found): DCNL DCSP  DCSP  DCSP  DCSP not_found.append(e.args[0]) DCNL DCSP  DCSP  DCSP continue DCNL DCSP raise TemplateDoesNotExist(', DCSP '.join(not_found))
 DCSP data_obj = SAMLProviderData.current(entity_id) DCNL DCSP fetched_at = datetime.datetime.now() DCNL DCSP if (data_obj and ((data_obj.public_key == public_key) and (data_obj.sso_url == sso_url))): DCNL DCSP  DCSP data_obj.expires_at = expires_at DCNL DCSP  DCSP data_obj.fetched_at = fetched_at DCNL DCSP  DCSP data_obj.save() DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP SAMLProviderData.objects.create(entity_id=entity_id, fetched_at=fetched_at, expires_at=expires_at, sso_url=sso_url, public_key=public_key) DCNL DCSP  DCSP return True
 DCSP km = objc.KextManager() DCNL DCSP cf_kext_path = km.PyStringToCFString(kext_path) DCNL DCSP kext_url = km.dll.CFURLCreateWithFileSystemPath(objc.CF_DEFAULT_ALLOCATOR, cf_kext_path, objc.POSIX_PATH_STYLE, True) DCNL DCSP status = km.iokit.KextManagerLoadKextWithURL(kext_url, None) DCNL DCSP km.dll.CFRelease(kext_url) DCNL DCSP km.dll.CFRelease(cf_kext_path) DCNL DCSP if (status is not objc.OS_SUCCESS): DCNL DCSP  DCSP raise OSError('Failed DCSP to DCSP load DCSP kext DCSP at DCSP {0}: DCSP {1}'.format(kext_path, status))
 DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, password=password, protocol=protocol, port=port) DCNL DCSP return salt.utils.vmware.list_hosts(service_instance)
 DCSP cluster_option = options['cluster'] DCNL DCSP if cluster_option: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cluster = BenchmarkCluster.from_cluster_yaml(FilePath(cluster_option)) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP usage(options, 'Cluster DCSP file DCSP {!r} DCSP not DCSP found.'.format(e.filename)) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cluster = BenchmarkCluster.from_acceptance_test_env(env) DCNL DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP usage(options, 'Environment DCSP variable DCSP {!r} DCSP not DCSP set.'.format(e.args[0])) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP usage(options, e.args[0]) DCNL DCSP  DCSP except ValidationError as e: DCNL DCSP  DCSP  DCSP usage(options, e.message) DCNL DCSP return cluster
 DCSP import SimpleHTTPServer, SocketServer, BaseHTTPServer, urlparse DCNL DCSP import socket, errno DCNL DCSP import traceback DCNL DCSP class WSGIHandler(SimpleHTTPServer.SimpleHTTPRequestHandler, ): DCNL DCSP  DCSP def run_wsgi_app(self): DCNL DCSP  DCSP  DCSP (protocol, host, path, parameters, query, fragment) = urlparse.urlparse(('http://dummyhost%s' % self.path)) DCNL DCSP  DCSP  DCSP env = {'wsgi.version': (1, 0), 'wsgi.url_scheme': 'http', 'wsgi.input': self.rfile, 'wsgi.errors': sys.stderr, 'wsgi.multithread': 1, 'wsgi.multiprocess': 0, 'wsgi.run_once': 0, 'REQUEST_METHOD': self.command, 'REQUEST_URI': self.path, 'PATH_INFO': path, 'QUERY_STRING': query, 'CONTENT_TYPE': self.headers.get('Content-Type', ''), 'CONTENT_LENGTH': self.headers.get('Content-Length', ''), 'REMOTE_ADDR': self.client_address[0], 'SERVER_NAME': self.server.server_address[0], 'SERVER_PORT': str(self.server.server_address[1]), 'SERVER_PROTOCOL': self.request_version} DCNL DCSP  DCSP  DCSP for (http_header, http_value) in self.headers.items(): DCNL DCSP  DCSP  DCSP  DCSP env[('HTTP_%s' % http_header.replace('-', '_').upper())] = http_value DCNL DCSP  DCSP  DCSP self.wsgi_sent_headers = 0 DCNL DCSP  DCSP  DCSP self.wsgi_headers = [] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result = self.server.app(env, self.wsgi_start_response) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for data in result: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.wsgi_write_data(data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(result, 'close'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.close() DCNL DCSP  DCSP  DCSP  DCSP except socket.error as socket_err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (socket_err.args[0] in (errno.ECONNABORTED, errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP except socket.timeout as socket_timeout: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print >>debug, traceback.format_exc(), DCNL DCSP  DCSP  DCSP  DCSP internalerror() DCNL DCSP  DCSP  DCSP  DCSP if (not self.wsgi_sent_headers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.wsgi_start_response(ctx.status, ctx.headers) DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_write_data(ctx.output) DCNL DCSP  DCSP  DCSP if (not self.wsgi_sent_headers): DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_write_data(' DCSP ') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP do_POST = run_wsgi_app DCNL DCSP  DCSP def do_GET(self): DCNL DCSP  DCSP  DCSP if self.path.startswith('/static/'): DCNL DCSP  DCSP  DCSP  DCSP SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.run_wsgi_app() DCNL DCSP  DCSP def wsgi_start_response(self, response_status, response_headers, exc_info=None): DCNL DCSP  DCSP  DCSP if self.wsgi_sent_headers: DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Headers DCSP already DCSP sent DCSP and DCSP start_response DCSP called DCSP again!') DCNL DCSP  DCSP  DCSP self.wsgi_headers = (response_status, response_headers) DCNL DCSP  DCSP  DCSP return self.wsgi_write_data DCNL DCSP  DCSP def wsgi_write_data(self, data): DCNL DCSP  DCSP  DCSP if (not self.wsgi_sent_headers): DCNL DCSP  DCSP  DCSP  DCSP (status, headers) = self.wsgi_headers DCNL DCSP  DCSP  DCSP  DCSP status_code = status[:status.find(' DCSP ')] DCNL DCSP  DCSP  DCSP  DCSP status_msg = status[(status.find(' DCSP ') + 1):] DCNL DCSP  DCSP  DCSP  DCSP self.send_response(int(status_code), status_msg) DCNL DCSP  DCSP  DCSP  DCSP for (header, value) in headers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.send_header(header, value) DCNL DCSP  DCSP  DCSP  DCSP self.end_headers() DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_sent_headers = 1 DCNL DCSP  DCSP  DCSP self.wfile.write(data) DCNL DCSP class WSGIServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer, ): DCNL DCSP  DCSP def __init__(self, func): DCNL DCSP  DCSP  DCSP BaseHTTPServer.HTTPServer.__init__(self, ('0.0.0.0', int(port)), WSGIHandler) DCNL DCSP  DCSP  DCSP self.app = func DCNL DCSP  DCSP  DCSP self.serverShuttingDown = 0 DCNL DCSP print (('Launching DCSP server: DCSP http://0.0.0.0:' + str(port)) + '/') DCNL DCSP WSGIServer(func).serve_forever()
 DCSP view.request = request DCNL DCSP try: DCNL DCSP  DCSP view.request.user = request.user DCNL DCSP except AttributeError: DCNL DCSP  DCSP view.request.user = UserFactory() DCNL DCSP view.args = args DCNL DCSP view.kwargs = kwargs DCNL DCSP view.form = form DCNL DCSP return view
 DCSP retVal = value DCNL DCSP if (retVal and isinstance(retVal, basestring)): DCNL DCSP  DCSP if (not (retVal[0] == retVal[(-1)] == '"')): DCNL DCSP  DCSP  DCSP if any(((_ in retVal) for _ in (conf.get('csvDel', defaults.csvDel), '"', '\n'))): DCNL DCSP  DCSP  DCSP  DCSP retVal = ('"%s"' % retVal.replace('"', '""')) DCNL DCSP return retVal
 DCSP if table: DCNL DCSP  DCSP field = abs(table, field) DCNL DCSP if (isinstance(value, basestring) and (value.startswith(('*', '%')) or value.endswith(('*', '%')))): DCNL DCSP  DCSP if (comparison in ('=', 'i=', '==', LIKE)): DCNL DCSP  DCSP  DCSP return ('%s DCSP like DCSP %s' % (field, escape(value.replace('*', '%')))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP like DCSP %s' % (field, escape(value.replace('*', '%')))) DCNL DCSP if isinstance(value, basestring): DCNL DCSP  DCSP if (comparison == 'i='): DCNL DCSP  DCSP  DCSP return ('%s DCSP like DCSP %s' % (field, escape(value))) DCNL DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP if find((lambda v: (isinstance(v, basestring) and (v.startswith('*') or v.endswith('*')))), value): DCNL DCSP  DCSP  DCSP return ('(%s)' % any(*[(field, v) for v in value]).sql(escape=escape)) DCNL DCSP  DCSP if (comparison in ('=', '==', IN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP in DCSP (%s)' % (field, ','.join((escape(v) for v in value)))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP in DCSP (%s)' % (field, ','.join((escape(v) for v in value)))) DCNL DCSP  DCSP if (comparison in (':', BETWEEN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP between DCSP %s DCSP and DCSP %s' % (field, escape(value[0]), escape(value[1]))) DCNL DCSP if isinstance(value, type(None)): DCNL DCSP  DCSP if (comparison in ('=', '==')): DCNL DCSP  DCSP  DCSP return ('%s DCSP is DCSP null' % field) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP is DCSP not DCSP null' % field) DCNL DCSP if isinstance(value, Query): DCNL DCSP  DCSP if (comparison in ('=', '==', IN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP in DCSP %s' % (field, escape(value))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP in DCSP %s' % (field, escape(value))) DCNL DCSP return ('%s%s%s' % (field, comparison, escape(value)))
 DCSP lower = name.lower() DCNL DCSP (base, py_ver) = (None, None) DCNL DCSP if lower.endswith('.exe'): DCNL DCSP  DCSP if lower.endswith('.win32.exe'): DCNL DCSP  DCSP  DCSP base = name[:(-10)] DCNL DCSP  DCSP elif lower.startswith('.win32-py', (-16)): DCNL DCSP  DCSP  DCSP py_ver = name[(-7):(-4)] DCNL DCSP  DCSP  DCSP base = name[:(-16)] DCNL DCSP return (base, py_ver)
 DCSP try: DCNL DCSP  DCSP from pylint.gui import Run DCNL DCSP  DCSP Run(sys.argv[1:]) DCNL DCSP except ImportError: DCNL DCSP  DCSP sys.exit('tkinter DCSP is DCSP not DCSP available')
 DCSP tokenized_caption = [FLAGS.start_word] DCNL DCSP tokenized_caption.extend(nltk.tokenize.word_tokenize(caption.lower())) DCNL DCSP tokenized_caption.append(FLAGS.end_word) DCNL DCSP return tokenized_caption
 DCSP from openpyxl.worksheet import Worksheet DCNL DCSP return Worksheet
 DCSP for (xi, yi) in zip(x, y): DCNL DCSP  DCSP if (not (abs((xi - yi)) <= (atol + (rtol * abs(yi))))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP title = N_(u'Abort DCSP Merge...') DCNL DCSP txt = N_(u'Aborting DCSP the DCSP current DCSP merge DCSP will DCSP cause DCSP *ALL* DCSP uncommitted DCSP changes DCSP to DCSP be DCSP lost.\nRecovering DCSP uncommitted DCSP changes DCSP is DCSP not DCSP possible.') DCNL DCSP info_txt = N_(u'Aborting DCSP the DCSP current DCSP merge?') DCNL DCSP ok_txt = N_(u'Abort DCSP Merge') DCNL DCSP if qtutils.confirm(title, txt, info_txt, ok_txt, default=False, icon=icons.undo()): DCNL DCSP  DCSP gitcmds.abort_merge()
 DCSP try: DCNL DCSP  DCSP boto.emr.emrobject.ClusterTimeline = _PatchedClusterTimeline DCNL DCSP  DCSP return emr_conn.list_steps(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP boto.emr.emrobject.ClusterTimeline = ClusterTimeline
 DCSP return (bound_field.errors and (not hasattr(bound_field.field.widget, u'render_with_errors')))
 DCSP scrubbed_text = text.rstrip().replace('\n', '\\n').replace(' DCTB ', (' DCSP ' * 4)) DCNL DCSP return scrubbed_text
 DCSP i = 0 DCNL DCSP bytes = 0 DCNL DCSP for size in msgs: DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP bytes += size DCNL DCSP  DCSP (yield None) DCNL DCSP (yield successResponse(('%d DCSP %d' % (i, bytes))))
 DCSP if (query is None): DCNL DCSP  DCSP query = {} DCNL DCSP _validate_query(query) DCNL DCSP for (field, values) in query.items(): DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP if (field == u'track_no'): DCNL DCSP  DCSP  DCSP  DCSP q = _convert_to_int(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP q = value.strip() DCNL DCSP  DCSP  DCSP def uri_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == t.uri) DCNL DCSP  DCSP  DCSP def track_name_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == t.name) DCNL DCSP  DCSP  DCSP def album_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == getattr(getattr(t, u'album', None), u'name', None)) DCNL DCSP  DCSP  DCSP def artist_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return filter((lambda a: (q == a.name)), t.artists) DCNL DCSP  DCSP  DCSP def albumartist_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(q == a.name) for a in getattr(t.album, u'artists', [])]) DCNL DCSP  DCSP  DCSP def composer_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(q == a.name) for a in getattr(t, u'composers', [])]) DCNL DCSP  DCSP  DCSP def performer_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(q == a.name) for a in getattr(t, u'performers', [])]) DCNL DCSP  DCSP  DCSP def track_no_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == t.track_no) DCNL DCSP  DCSP  DCSP def genre_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (t.genre and (q == t.genre)) DCNL DCSP  DCSP  DCSP def date_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == t.date) DCNL DCSP  DCSP  DCSP def comment_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (q == t.comment) DCNL DCSP  DCSP  DCSP def any_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (uri_filter(t) or track_name_filter(t) or album_filter(t) or artist_filter(t) or albumartist_filter(t) or composer_filter(t) or performer_filter(t) or track_no_filter(t) or genre_filter(t) or date_filter(t) or comment_filter(t)) DCNL DCSP  DCSP  DCSP if (field == u'uri'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(uri_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'track_name'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(track_name_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'album'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(album_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'artist'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(artist_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'albumartist'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(albumartist_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'composer'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(composer_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'performer'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(performer_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'track_no'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(track_no_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'genre'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(genre_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'date'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(date_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'comment'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(comment_filter, tracks) DCNL DCSP  DCSP  DCSP elif (field == u'any'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(any_filter, tracks) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise LookupError((u'Invalid DCSP lookup DCSP field: DCSP %s' % field)) DCNL DCSP if (limit is None): DCNL DCSP  DCSP tracks = tracks[offset:] DCNL DCSP else: DCNL DCSP  DCSP tracks = tracks[offset:(offset + limit)] DCNL DCSP return SearchResult(uri=u'local:search', tracks=tracks)
 DCSP if (not ccx): DCNL DCSP  DCSP raise Http404 DCNL DCSP ccx_key = CCXLocator.from_course_locator(course.id, unicode(ccx.id)) DCNL DCSP with ccx_course(ccx_key) as course: DCNL DCSP  DCSP prep_course_for_grading(course, request) DCNL DCSP  DCSP enrolled_students = User.objects.filter(courseenrollment__course_id=ccx_key, courseenrollment__is_active=1).order_by('username').select_related('profile') DCNL DCSP  DCSP grades = CourseGradeFactory().iter(course, enrolled_students) DCNL DCSP  DCSP header = None DCNL DCSP  DCSP rows = [] DCNL DCSP  DCSP for (student, course_grade, __) in grades: DCNL DCSP  DCSP  DCSP if course_grade: DCNL DCSP  DCSP  DCSP  DCSP if (not header): DCNL DCSP  DCSP  DCSP  DCSP  DCSP header = [section['label'].encode('utf-8') for section in course_grade.summary[u'section_breakdown']] DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows.append((['id', 'email', 'username', 'grade'] + header)) DCNL DCSP  DCSP  DCSP  DCSP percents = {section['label']: section.get('percent', 0.0) for section in course_grade.summary[u'section_breakdown'] if ('label' in section)} DCNL DCSP  DCSP  DCSP  DCSP row_percents = [percents.get(label, 0.0) for label in header] DCNL DCSP  DCSP  DCSP  DCSP rows.append(([student.id, student.email, student.username, course_grade.percent] + row_percents)) DCNL DCSP  DCSP buf = StringIO() DCNL DCSP  DCSP writer = csv.writer(buf) DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP writer.writerow(row) DCNL DCSP  DCSP response = HttpResponse(buf.getvalue(), content_type='text/csv') DCNL DCSP  DCSP response['Content-Disposition'] = 'attachment' DCNL DCSP  DCSP return response
 DCSP if isinstance(node.op, T.CAReduce): DCNL DCSP  DCSP (reduced,) = node.inputs DCNL DCSP  DCSP odtype = node.outputs[0].dtype DCNL DCSP  DCSP if (node.op.axis is None): DCNL DCSP  DCSP  DCSP if all(reduced.broadcastable): DCNL DCSP  DCSP  DCSP  DCSP return [reduced.dimshuffle().astype(odtype)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP axis = list(node.op.axis) DCNL DCSP  DCSP  DCSP cuttable = [a for a in axis if reduced.broadcastable[a]] DCNL DCSP  DCSP  DCSP if cuttable: DCNL DCSP  DCSP  DCSP  DCSP new_axis = [] DCNL DCSP  DCSP  DCSP  DCSP pattern = [] DCNL DCSP  DCSP  DCSP  DCSP ii = 0 DCNL DCSP  DCSP  DCSP  DCSP for p in xrange(reduced.ndim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p not in cuttable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (p in axis): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_axis.append(ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pattern.append(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ii += 1 DCNL DCSP  DCSP  DCSP  DCSP new_reduced = reduced.dimshuffle(*pattern) DCNL DCSP  DCSP  DCSP  DCSP if new_axis: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (type(node.op) == theano.tensor.elemwise.CAReduce): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_op = node.op.__class__(node.op.scalar_op, axis=new_axis) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_op = node.op.__class__(axis=new_axis) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [new_op(new_reduced)] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [new_reduced.astype(odtype)]
 DCSP if (not issubclass(cls, object)): DCNL DCSP  DCSP return None DCNL DCSP for base in cls.__mro__: DCNL DCSP  DCSP _is_declarative_inherits = hasattr(base, '_decl_class_registry') DCNL DCSP  DCSP if ((attrname in base.__dict__) and ((base is cls) or (((base in cls.__bases__) if strict else True) and (not _is_declarative_inherits)))): DCNL DCSP  DCSP  DCSP return getattr(base, attrname) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP ret = [] DCNL DCSP for word in s.split(): DCNL DCSP  DCSP if re.match('[A-Z]+[a-z]+[A-Z]', word): DCNL DCSP  DCSP  DCSP word = ('!%s' % word) DCNL DCSP  DCSP ret.append(word) DCNL DCSP return ' DCSP '.join(ret)
 DCSP all = COMMASPACE.join(fieldvalues) DCNL DCSP a = _AddressList(all) DCNL DCSP return a.addresslist
 DCSP errors = 0 DCNL DCSP fits_files = handle_options(sys.argv[1:]) DCNL DCSP setup_logging() DCNL DCSP for filename in fits_files: DCNL DCSP  DCSP errors += process_file(filename) DCNL DCSP if errors: DCNL DCSP  DCSP log.warning('{} DCSP errors'.format(errors)) DCNL DCSP return int(bool(errors))
 DCSP if (net_db.external is not None): DCNL DCSP  DCSP net_res[IS_DEFAULT] = net_db.external.is_default DCNL DCSP return net_res
 DCSP datasets = load_data(mnist_pkl_gz) DCNL DCSP (train_set_x, train_set_y) = datasets[0] DCNL DCSP (valid_set_x, valid_set_y) = datasets[1] DCNL DCSP (test_set_x, test_set_y) = datasets[2] DCNL DCSP batch_size = 600 DCNL DCSP n_train_batches = (train_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_valid_batches = (valid_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_test_batches = (test_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_in = (28 * 28) DCNL DCSP n_out = 10 DCNL DCSP print('... DCSP building DCSP the DCSP model') DCNL DCSP minibatch_offset = T.lscalar() DCNL DCSP x = T.matrix() DCNL DCSP y = T.ivector() DCNL DCSP classifier = LogisticRegression(input=x, n_in=(28 * 28), n_out=10) DCNL DCSP cost = classifier.negative_log_likelihood(y).mean() DCNL DCSP test_model = theano.function([minibatch_offset], classifier.errors(y), givens={x: test_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: test_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='test') DCNL DCSP validate_model = theano.function([minibatch_offset], classifier.errors(y), givens={x: valid_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: valid_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='validate') DCNL DCSP batch_cost = theano.function([minibatch_offset], cost, givens={x: train_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: train_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='batch_cost') DCNL DCSP batch_grad = theano.function([minibatch_offset], T.grad(cost, classifier.theta), givens={x: train_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: train_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='batch_grad') DCNL DCSP def train_fn(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP train_losses = [batch_cost((i * batch_size)) for i in range(n_train_batches)] DCNL DCSP  DCSP return numpy.mean(train_losses) DCNL DCSP def train_fn_grad(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP grad = batch_grad(0) DCNL DCSP  DCSP for i in range(1, n_train_batches): DCNL DCSP  DCSP  DCSP grad += batch_grad((i * batch_size)) DCNL DCSP  DCSP return (grad / n_train_batches) DCNL DCSP validation_scores = [numpy.inf, 0] DCNL DCSP def callback(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP validation_losses = [validate_model((i * batch_size)) for i in range(n_valid_batches)] DCNL DCSP  DCSP this_validation_loss = numpy.mean(validation_losses) DCNL DCSP  DCSP print(('validation DCSP error DCSP %f DCSP %%' % ((this_validation_loss * 100.0),))) DCNL DCSP  DCSP if (this_validation_loss < validation_scores[0]): DCNL DCSP  DCSP  DCSP validation_scores[0] = this_validation_loss DCNL DCSP  DCSP  DCSP test_losses = [test_model((i * batch_size)) for i in range(n_test_batches)] DCNL DCSP  DCSP  DCSP validation_scores[1] = numpy.mean(test_losses) DCNL DCSP import scipy.optimize DCNL DCSP print('Optimizing DCSP using DCSP scipy.optimize.fmin_cg...') DCNL DCSP start_time = timeit.default_timer() DCNL DCSP best_w_b = scipy.optimize.fmin_cg(f=train_fn, x0=numpy.zeros(((n_in + 1) * n_out), dtype=x.dtype), fprime=train_fn_grad, callback=callback, disp=0, maxiter=n_epochs) DCNL DCSP end_time = timeit.default_timer() DCNL DCSP print(('Optimization DCSP complete DCSP with DCSP best DCSP validation DCSP score DCSP of DCSP %f DCSP %%, DCSP with DCSP test DCSP performance DCSP %f DCSP %%' % ((validation_scores[0] * 100.0), (validation_scores[1] * 100.0)))) DCNL DCSP print((('The DCSP code DCSP for DCSP file DCSP ' + os.path.split(__file__)[1]) + (' DCSP ran DCSP for DCSP %.1fs' % (end_time - start_time))), file=sys.stderr)
 DCSP params = {'connection-limit': connection_limit, 'description': description, 'dynamic-ratio': dynamic_ratio, 'logging': logging, 'monitor': monitor, 'rate-limit': rate_limit, 'ratio': ratio, 'session': session, 'state': state} DCNL DCSP bigip_session = _build_session(username, password, trans_label) DCNL DCSP payload = _loop_payload(params) DCNL DCSP payload['name'] = name DCNL DCSP try: DCNL DCSP  DCSP response = bigip_session.put((BIG_IP_URL_BASE.format(host=hostname) + '/ltm/node/{name}'.format(name=name)), data=json.dumps(payload)) DCNL DCSP except requests.exceptions.ConnectionError as e: DCNL DCSP  DCSP return _load_connection_error(hostname, e) DCNL DCSP return _load_response(response)
 DCSP db_user = boto.config.get('DB', 'db_user', None) DCNL DCSP db_passwd = boto.config.get('DB', 'db_passwd', None) DCNL DCSP db_type = boto.config.get('DB', 'db_type', 'SimpleDB') DCNL DCSP db_name = boto.config.get('DB', 'db_name', None) DCNL DCSP db_table = boto.config.get('DB', 'db_table', None) DCNL DCSP db_host = boto.config.get('DB', 'db_host', 'sdb.amazonaws.com') DCNL DCSP db_port = boto.config.getint('DB', 'db_port', 443) DCNL DCSP enable_ssl = boto.config.getbool('DB', 'enable_ssl', True) DCNL DCSP sql_dir = boto.config.get('DB', 'sql_dir', None) DCNL DCSP debug = boto.config.getint('DB', 'debug', 0) DCNL DCSP module_name = cls.__module__.replace('.', '_') DCNL DCSP db_section = ((('DB_' + module_name) + '_') + cls.__name__) DCNL DCSP if (not boto.config.has_section(db_section)): DCNL DCSP  DCSP db_section = ('DB_' + cls.__name__) DCNL DCSP if boto.config.has_section(db_section): DCNL DCSP  DCSP db_user = boto.config.get(db_section, 'db_user', db_user) DCNL DCSP  DCSP db_passwd = boto.config.get(db_section, 'db_passwd', db_passwd) DCNL DCSP  DCSP db_type = boto.config.get(db_section, 'db_type', db_type) DCNL DCSP  DCSP db_name = boto.config.get(db_section, 'db_name', db_name) DCNL DCSP  DCSP db_table = boto.config.get(db_section, 'db_table', db_table) DCNL DCSP  DCSP db_host = boto.config.get(db_section, 'db_host', db_host) DCNL DCSP  DCSP db_port = boto.config.getint(db_section, 'db_port', db_port) DCNL DCSP  DCSP enable_ssl = boto.config.getint(db_section, 'enable_ssl', enable_ssl) DCNL DCSP  DCSP debug = boto.config.getint(db_section, 'debug', debug) DCNL DCSP elif (hasattr(cls, '_db_name') and (cls._db_name is not None)): DCNL DCSP  DCSP db_name = cls._db_name DCNL DCSP elif hasattr(cls.__bases__[0], '_manager'): DCNL DCSP  DCSP return cls.__bases__[0]._manager DCNL DCSP if (db_type == 'SimpleDB'): DCNL DCSP  DCSP from boto.sdb.db.manager.sdbmanager import SDBManager DCNL DCSP  DCSP return SDBManager(cls, db_name, db_user, db_passwd, db_host, db_port, db_table, sql_dir, enable_ssl) DCNL DCSP elif (db_type == 'XML'): DCNL DCSP  DCSP from boto.sdb.db.manager.xmlmanager import XMLManager DCNL DCSP  DCSP return XMLManager(cls, db_name, db_user, db_passwd, db_host, db_port, db_table, sql_dir, enable_ssl) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP db_type: DCSP %s' % db_type))
 DCSP return range_property(attr, 0, 4294967295)
 DCSP if (flag and could_edit(request)): DCNL DCSP  DCSP request.session[EDIT_FLAG_NAME] = True DCNL DCSP else: DCNL DCSP  DCSP request.session.pop(EDIT_FLAG_NAME, None)
 DCSP if (msg_type and (msg_type not in MSG_TYPE_MAP)): DCNL DCSP  DCSP raise InvalidHandlerType(('Invalid DCSP message DCSP type DCSP [%s]: DCSP type DCSP should DCSP be DCSP in DCSP %s' % (msg_type, str(MSG_TYPES)))) DCNL DCSP handler = Handler(func=func, name=dispatcher_name) DCNL DCSP if (msg_type is None): DCNL DCSP  DCSP _registry[RAW_TYPE].append(handler) DCNL DCSP else: DCNL DCSP  DCSP _registry[msg_type].append(handler) DCNL DCSP if active_by_default: DCNL DCSP  DCSP _active.add(dispatcher_name)
 DCSP path = 'https://api.qingcloud.com/iaas/' DCNL DCSP access_key_id = config.get_cloud_config_value('access_key_id', get_configured_provider(), __opts__, search_global=False) DCNL DCSP access_key_secret = config.get_cloud_config_value('secret_access_key', get_configured_provider(), __opts__, search_global=False) DCNL DCSP real_parameters = {'access_key_id': access_key_id, 'signature_version': DEFAULT_QINGCLOUD_SIGNATURE_VERSION, 'time_stamp': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'version': DEFAULT_QINGCLOUD_API_VERSION} DCNL DCSP if params: DCNL DCSP  DCSP for (key, value) in params.items(): DCNL DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP for i in range(1, (len(value) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(value[(i - 1)], dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (sk, sv) in value[(i - 1)].items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (isinstance(sv, dict) or isinstance(sv, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sv = json.dumps(sv, separators=(',', ':')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP real_parameters['{0}.{1}.{2}'.format(key, i, sk)] = sv DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP real_parameters['{0}.{1}'.format(key, i)] = value[(i - 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP real_parameters[key] = value DCNL DCSP signature = _compute_signature(real_parameters, access_key_secret, 'GET', '/iaas/') DCNL DCSP real_parameters['signature'] = signature DCNL DCSP request = requests.get(path, params=real_parameters, verify=False) DCNL DCSP if (request.status_code != 200): DCNL DCSP  DCSP raise SaltCloudSystemExit("An DCSP error DCSP occurred DCSP while DCSP querying DCSP QingCloud. DCSP HTTP DCSP Code: DCSP {0} DCSP  DCSP Error: DCSP '{1}'".format(request.status_code, request.text)) DCNL DCSP log.debug(request.url) DCNL DCSP content = request.text DCNL DCSP result = json.loads(content, object_hook=salt.utils.decode_dict) DCNL DCSP if (result['ret_code'] != 0): DCNL DCSP  DCSP raise SaltCloudSystemExit(pprint.pformat(result.get('message', {}))) DCNL DCSP return result
 DCSP if (not isinstance(intlist, list)): DCNL DCSP  DCSP return False DCNL DCSP for i in intlist: DCNL DCSP  DCSP if (not isinstance(i, int)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP an = asarray(an) DCNL DCSP N = (len(an) - 1) DCNL DCSP n = (N - m) DCNL DCSP if (n < 0): DCNL DCSP  DCSP raise ValueError('Order DCSP of DCSP q DCSP <m> DCSP must DCSP be DCSP smaller DCSP than DCSP len(an)-1.') DCNL DCSP Akj = eye((N + 1), (n + 1)) DCNL DCSP Bkj = zeros(((N + 1), m), 'd') DCNL DCSP for row in range(1, (m + 1)): DCNL DCSP  DCSP Bkj[row, :row] = (- an[:row][::(-1)]) DCNL DCSP for row in range((m + 1), (N + 1)): DCNL DCSP  DCSP Bkj[row, :] = (- an[(row - m):row][::(-1)]) DCNL DCSP C = hstack((Akj, Bkj)) DCNL DCSP pq = linalg.solve(C, an) DCNL DCSP p = pq[:(n + 1)] DCNL DCSP q = r_[(1.0, pq[(n + 1):])] DCNL DCSP return (poly1d(p[::(-1)]), poly1d(q[::(-1)]))
 DCSP counts = query.selectable.with_only_columns([func.count()]) DCNL DCSP num_results = session.execute(counts.order_by(None)).scalar() DCNL DCSP if ((num_results is None) or (query._limit is not None)): DCNL DCSP  DCSP return query.order_by(None).count() DCNL DCSP return num_results
 DCSP u' DCSP The DCSP "angle" DCSP is DCSP a DCSP fundamental DCSP object. DCSP The DCSP internal\n DCSP  DCSP  DCSP  DCSP representation DCSP is DCSP stored DCSP in DCSP radians, DCSP but DCSP this DCSP is DCSP transparent DCSP to DCSP the DCSP user.\n DCSP  DCSP  DCSP  DCSP Units DCSP *must* DCSP be DCSP specified DCSP rather DCSP than DCSP a DCSP default DCSP value DCSP be DCSP assumed. DCSP This DCSP is\n DCSP  DCSP  DCSP  DCSP as DCSP much DCSP for DCSP self-documenting DCSP code DCSP as DCSP anything DCSP else.\n\n DCSP  DCSP  DCSP  DCSP Angle DCSP objects DCSP simply DCSP represent DCSP a DCSP single DCSP angular DCSP coordinate. DCSP More DCSP specific\n DCSP  DCSP  DCSP  DCSP angular DCSP coordinates DCSP (e.g. DCSP Longitude, DCSP Latitude) DCSP are DCSP subclasses DCSP of DCSP Angle.' DCNL DCSP a1 = Angle(54.12412, unit=u.degree) DCNL DCSP a2 = Angle(u'54.12412', unit=u.degree) DCNL DCSP a3 = Angle(u'54:07:26.832', unit=u.degree) DCNL DCSP a4 = Angle(u'54.12412 DCSP deg') DCNL DCSP a5 = Angle(u'54.12412 DCSP degrees') DCNL DCSP a6 = Angle(u'54.12412\xb0') DCNL DCSP a7 = Angle((54, 7, 26.832), unit=u.degree) DCNL DCSP a8 = Angle(u'54\xb007\'26.832"') DCNL DCSP a9 = Angle([54, 7, 26.832], unit=u.degree) DCNL DCSP assert_allclose(a9.value, [54, 7, 26.832]) DCNL DCSP assert (a9.unit is u.degree) DCNL DCSP a10 = Angle(3.60827466667, unit=u.hour) DCNL DCSP a11 = Angle(u'3:36:29.7888000120', unit=u.hour) DCNL DCSP a12 = Angle((3, 36, 29.788800012), unit=u.hour) DCNL DCSP a13 = Angle((3, 36, 29.788800012), unit=u'hour') DCNL DCSP Angle(0.944644098745, unit=u.radian) DCNL DCSP with pytest.raises(u.UnitsError): DCNL DCSP  DCSP Angle(54.12412) DCNL DCSP with pytest.raises(u.UnitsError): DCNL DCSP  DCSP Angle(54.12412, unit=u.m) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP Angle(12.34, unit=u'not DCSP a DCSP unit') DCNL DCSP a14 = Angle(u'03h36m29.7888000120') DCNL DCSP a15 = Angle(u'5h4m3s') DCNL DCSP assert (a15.unit == u.hourangle) DCNL DCSP a16 = Angle(u'1 DCSP d') DCNL DCSP a17 = Angle(u'1 DCSP degree') DCNL DCSP assert (a16.degree == 1) DCNL DCSP assert (a17.degree == 1) DCNL DCSP a18 = Angle(u'54 DCSP 07.4472', unit=u.degree) DCNL DCSP a19 = Angle(u'54:07.4472', unit=u.degree) DCNL DCSP a20 = Angle(u'54d07.4472m', unit=u.degree) DCNL DCSP a21 = Angle(u'3h36m', unit=u.hour) DCNL DCSP a22 = Angle(u'3.6h', unit=u.hour) DCNL DCSP a23 = Angle(u'- DCSP 3h', unit=u.hour) DCNL DCSP a24 = Angle(u'+ DCSP 3h', unit=u.hour) DCNL DCSP assert (a1 == a2 == a3 == a4 == a5 == a6 == a7 == a8 == a18 == a19 == a20) DCNL DCSP assert_allclose(a1.radian, a2.radian) DCNL DCSP assert_allclose(a2.degree, a3.degree) DCNL DCSP assert_allclose(a3.radian, a4.radian) DCNL DCSP assert_allclose(a4.radian, a5.radian) DCNL DCSP assert_allclose(a5.radian, a6.radian) DCNL DCSP assert_allclose(a6.radian, a7.radian) DCNL DCSP assert_allclose(a10.degree, a11.degree) DCNL DCSP assert (a11 == a12 == a13 == a14) DCNL DCSP assert (a21 == a22) DCNL DCSP assert (a23 == (- a24)) DCNL DCSP with pytest.raises(IllegalSecondError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 32 DCSP 99', unit=u.degree) DCNL DCSP with pytest.raises(IllegalMinuteError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 99 DCSP 23', unit=u.degree) DCNL DCSP with pytest.raises(IllegalSecondError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 32 DCSP 99', unit=u.hour) DCNL DCSP with pytest.raises(IllegalMinuteError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 99 DCSP 23', unit=u.hour) DCNL DCSP with pytest.raises(IllegalHourError): DCNL DCSP  DCSP a = Angle(u'99 DCSP 25 DCSP 51.0', unit=u.hour) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 25 DCSP 51.0xxx', unit=u.hour) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP a = Angle(u'12h34321m32.2s') DCNL DCSP assert (a1 is not None)
 DCSP vector3RemoveByPrefix = getVector3ByPrefix(vector3, prefix, xmlElement) DCNL DCSP euclidean.removePrefixFromDictionary(xmlElement.attributeDictionary, prefix) DCNL DCSP return vector3RemoveByPrefix
 DCSP jid = str(jid) DCNL DCSP jid = re.sub("'*", '', jid) DCNL DCSP return jid
 DCSP match = time_re.match(value) DCNL DCSP if match: DCNL DCSP  DCSP kw = match.groupdict() DCNL DCSP  DCSP if kw['microsecond']: DCNL DCSP  DCSP  DCSP kw['microsecond'] = kw['microsecond'].ljust(6, '0') DCNL DCSP  DCSP kw = dict(((k, int(v)) for (k, v) in six.iteritems(kw) if (v is not None))) DCNL DCSP  DCSP return datetime.time(**kw)
 DCSP return '.'.join(map(str, tup))
 DCSP if (not isinstance(value, expected_type)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = expected_type(value) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise TypeError(('expected DCSP ' + str(expected_type))) DCNL DCSP return value
 DCSP parser = lxml.etree.XMLParser(remove_blank_text=True) DCNL DCSP newdata = lxml.etree.XML(data, parser=parser) DCNL DCSP return lxml.etree.tostring(newdata, encoding='utf-8', method='xml', xml_declaration=True)
 DCSP (result, _) = _qd(A, B, output=output, lwork=lwork, sort=sort, overwrite_a=overwrite_a, overwrite_b=overwrite_b, check_finite=check_finite) DCNL DCSP return (result[0], result[1], result[(-4)], result[(-3)])
 DCSP last = rdfvalue.RDFDatetime(0) DCNL DCSP client_urn = None DCNL DCSP for client in aff4.FACTORY.MultiOpen(client_list, token=token): DCNL DCSP  DCSP client_last = client.Get(client.Schema.LAST) DCNL DCSP  DCSP if (client_last > last): DCNL DCSP  DCSP  DCSP last = client_last DCNL DCSP  DCSP  DCSP client_urn = client.urn DCNL DCSP return client_urn
 DCSP from scipy.optimize import fmin_cobyla DCNL DCSP assert (nfit >= 2) DCNL DCSP u = dict(y=np.zeros((nterms - 1)), resi=np.zeros((nterms - 1)), nfit=nfit, nterms=nterms, M=np.zeros(((nterms - 1), (nfit - 1)))) DCNL DCSP u['fn'] = _fwd_eeg_get_multi_sphere_model_coeffs(m, (nterms + 1)) DCNL DCSP f = (min([layer['rad'] for layer in m['layers']]) / max([layer['rad'] for layer in m['layers']])) DCNL DCSP k = np.arange(1, (nterms + 1)) DCNL DCSP u['w'] = (np.sqrt(((((2.0 * k) + 1) * ((3.0 * k) + 1.0)) / k)) * np.power(f, (k - 1.0))) DCNL DCSP u['w'][(-1)] = 0 DCNL DCSP mu_0 = (np.random.RandomState(0).rand(nfit) * f) DCNL DCSP fun = partial(_one_step, u=u) DCNL DCSP max_ = (1.0 - 0.0002) DCNL DCSP cons = [(lambda x: (max_ - np.abs(x[ii]))) for ii in range(nfit)] DCNL DCSP mu = fmin_cobyla(fun, mu_0, cons, rhobeg=0.5, rhoend=0.005, disp=0) DCNL DCSP (rv, lambda_) = _compute_linear_parameters(mu, u) DCNL DCSP order = np.argsort(mu)[::(-1)] DCNL DCSP (mu, lambda_) = (mu[order], lambda_[order]) DCNL DCSP m['mu'] = mu DCNL DCSP m['lambda'] = (lambda_ / m['layers'][(-1)]['sigma']) DCNL DCSP m['nfit'] = nfit DCNL DCSP return rv
 DCSP with caplog.at_level(logging.ERROR): DCNL DCSP  DCSP with qtbot.waitSignal(proc.finished, timeout=10000): DCNL DCSP  DCSP  DCSP proc.start(*py_proc('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP sys\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print("test", DCSP file=sys.{})\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(1)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.format(stream))) DCNL DCSP assert (len(caplog.records) == 2) DCNL DCSP assert (caplog.records[1].msg == 'Process DCSP {}:\ntest'.format(stream))
 DCSP if (offset is None): DCNL DCSP  DCSP return MoveModule(project, resource) DCNL DCSP this_pymodule = project.get_pymodule(resource) DCNL DCSP pyname = evaluate.eval_location(this_pymodule, offset) DCNL DCSP if (pyname is not None): DCNL DCSP  DCSP pyobject = pyname.get_object() DCNL DCSP  DCSP if (isinstance(pyobject, pyobjects.PyModule) or isinstance(pyobject, pyobjects.PyPackage)): DCNL DCSP  DCSP  DCSP return MoveModule(project, pyobject.get_resource()) DCNL DCSP  DCSP if (isinstance(pyobject, pyobjects.PyFunction) and isinstance(pyobject.parent, pyobjects.PyClass)): DCNL DCSP  DCSP  DCSP return MoveMethod(project, resource, offset) DCNL DCSP  DCSP if ((isinstance(pyobject, pyobjects.PyDefinedObject) and isinstance(pyobject.parent, pyobjects.PyModule)) or isinstance(pyname, pynames.AssignedName)): DCNL DCSP  DCSP  DCSP return MoveGlobal(project, resource, offset) DCNL DCSP raise exceptions.RefactoringError('Move DCSP only DCSP works DCSP on DCSP global DCSP classes/functions/variables, DCSP modules DCSP and DCSP methods.')
 DCSP x = inet_pton(socket.AF_INET6, x) DCNL DCSP return (x[:2] == ' DCSP \x02')
 DCSP if (HAS_NAPALM and ('proxy' in __opts__)): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP else: DCNL DCSP  DCSP return (False, 'The DCSP network DCSP NTP DCSP state DCSP (netntp) DCSP cannot DCSP be DCSP loaded: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NAPALM DCSP or DCSP proxy DCSP could DCSP not DCSP be DCSP loaded.')
 DCSP funcname = lineno = message_lineno = None DCNL DCSP call_stack = (-1) DCNL DCSP buf = [] DCNL DCSP messages = [] DCNL DCSP translator_comments = [] DCNL DCSP in_def = in_translator_comments = False DCNL DCSP comment_tag = None DCNL DCSP encoding = (parse_encoding(fileobj) or options.get('encoding', 'iso-8859-1')) DCNL DCSP tokens = generate_tokens(fileobj.readline) DCNL DCSP for (tok, value, (lineno, _), _, _) in tokens: DCNL DCSP  DCSP if ((call_stack == (-1)) and (tok == NAME) and (value in ('def', 'class'))): DCNL DCSP  DCSP  DCSP in_def = True DCNL DCSP  DCSP elif ((tok == OP) and (value == '(')): DCNL DCSP  DCSP  DCSP if in_def: DCNL DCSP  DCSP  DCSP  DCSP in_def = False DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if funcname: DCNL DCSP  DCSP  DCSP  DCSP message_lineno = lineno DCNL DCSP  DCSP  DCSP  DCSP call_stack += 1 DCNL DCSP  DCSP elif (in_def and (tok == OP) and (value == ':')): DCNL DCSP  DCSP  DCSP in_def = False DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((call_stack == (-1)) and (tok == COMMENT)): DCNL DCSP  DCSP  DCSP value = value.decode(encoding)[1:].strip() DCNL DCSP  DCSP  DCSP if (in_translator_comments and (translator_comments[(-1)][0] == (lineno - 1))): DCNL DCSP  DCSP  DCSP  DCSP translator_comments.append((lineno, value)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for comment_tag in comment_tags: DCNL DCSP  DCSP  DCSP  DCSP if value.startswith(comment_tag): DCNL DCSP  DCSP  DCSP  DCSP  DCSP in_translator_comments = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments.append((lineno, value)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (funcname and (call_stack == 0)): DCNL DCSP  DCSP  DCSP if ((tok == OP) and (value == ')')): DCNL DCSP  DCSP  DCSP  DCSP if buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.append(''.join(buf)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP del buf[:] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.append(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(messages) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages = tuple(messages) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages = messages[0] DCNL DCSP  DCSP  DCSP  DCSP if (translator_comments and (translator_comments[(-1)][0] < (message_lineno - 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments = [] DCNL DCSP  DCSP  DCSP  DCSP (yield (message_lineno, funcname, messages, [comment[1] for comment in translator_comments])) DCNL DCSP  DCSP  DCSP  DCSP funcname = lineno = message_lineno = None DCNL DCSP  DCSP  DCSP  DCSP call_stack = (-1) DCNL DCSP  DCSP  DCSP  DCSP messages = [] DCNL DCSP  DCSP  DCSP  DCSP translator_comments = [] DCNL DCSP  DCSP  DCSP  DCSP in_translator_comments = False DCNL DCSP  DCSP  DCSP elif (tok == STRING): DCNL DCSP  DCSP  DCSP  DCSP value = eval(('# DCSP coding=%s\n%s' % (encoding, value)), {'__builtins__': {}}, {}) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = value.decode(encoding) DCNL DCSP  DCSP  DCSP  DCSP buf.append(value) DCNL DCSP  DCSP  DCSP elif ((tok == OP) and (value == ',')): DCNL DCSP  DCSP  DCSP  DCSP if buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.append(''.join(buf)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP del buf[:] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.append(None) DCNL DCSP  DCSP  DCSP  DCSP if translator_comments: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (old_lineno, old_comment) = translator_comments.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments.append(((old_lineno + 1), old_comment)) DCNL DCSP  DCSP elif ((call_stack > 0) and (tok == OP) and (value == ')')): DCNL DCSP  DCSP  DCSP call_stack -= 1 DCNL DCSP  DCSP elif (funcname and (call_stack == (-1))): DCNL DCSP  DCSP  DCSP funcname = None DCNL DCSP  DCSP elif ((tok == NAME) and (value in keywords)): DCNL DCSP  DCSP  DCSP funcname = value
 DCSP elem = ElementMaker(nsmap={None: 'http://www.imsglobal.org/services/ltiv1p1/xsd/imsoms_v1p0'}) DCNL DCSP xml = elem.imsx_POXEnvelopeRequest(elem.imsx_POXHeader(elem.imsx_POXRequestHeaderInfo(elem.imsx_version('V1.0'), elem.imsx_messageIdentifier(str(uuid.uuid4())))), elem.imsx_POXBody(elem.replaceResultRequest(elem.resultRecord(elem.sourcedGUID(elem.sourcedId(result_sourcedid)), elem.result(elem.resultScore(elem.language('en'), elem.textString(str(score)))))))) DCNL DCSP return etree.tostring(xml, xml_declaration=True, encoding='UTF-8')
 DCSP if ('input_reader' not in mapper_spec.params): DCNL DCSP  DCSP message = "Input DCSP reader's DCSP parameters DCSP should DCSP be DCSP specified DCSP in DCSP input_reader DCSP subdictionary." DCNL DCSP  DCSP if allowed_keys: DCNL DCSP  DCSP  DCSP raise errors.BadReaderParamsError(message) DCNL DCSP  DCSP params = mapper_spec.params DCNL DCSP  DCSP params = dict(((str(n), v) for (n, v) in params.iteritems())) DCNL DCSP else: DCNL DCSP  DCSP if (not isinstance(mapper_spec.params.get('input_reader'), dict)): DCNL DCSP  DCSP  DCSP raise errors.BadReaderParamsError('Input DCSP reader DCSP parameters DCSP should DCSP be DCSP a DCSP dictionary') DCNL DCSP  DCSP params = mapper_spec.params.get('input_reader') DCNL DCSP  DCSP params = dict(((str(n), v) for (n, v) in params.iteritems())) DCNL DCSP  DCSP if allowed_keys: DCNL DCSP  DCSP  DCSP params_diff = (set(params.keys()) - allowed_keys) DCNL DCSP  DCSP  DCSP if params_diff: DCNL DCSP  DCSP  DCSP  DCSP raise errors.BadReaderParamsError(('Invalid DCSP input_reader DCSP parameters: DCSP %s' % ','.join(params_diff))) DCNL DCSP return params
 DCSP gitfs = salt.utils.gitfs.GitFS(__opts__) DCNL DCSP gitfs.init_remotes(__opts__['gitfs_remotes'], PER_REMOTE_OVERRIDES, PER_REMOTE_ONLY) DCNL DCSP return gitfs.dir_list(load)
 DCSP def update_certs_for_domain_matches(candidate_lineage, rv): DCNL DCSP  DCSP 'Return DCSP cert DCSP as DCSP identical_names_cert DCSP if DCSP it DCSP matches,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP or DCSP subset_names_cert DCSP if DCSP it DCSP matches DCSP as DCSP subset\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP (identical_names_cert, subset_names_cert) = rv DCNL DCSP  DCSP candidate_names = set(candidate_lineage.names()) DCNL DCSP  DCSP if (candidate_names == set(domains)): DCNL DCSP  DCSP  DCSP identical_names_cert = candidate_lineage DCNL DCSP  DCSP elif candidate_names.issubset(set(domains)): DCNL DCSP  DCSP  DCSP if (subset_names_cert is None): DCNL DCSP  DCSP  DCSP  DCSP subset_names_cert = candidate_lineage DCNL DCSP  DCSP  DCSP elif (len(candidate_names) > len(subset_names_cert.names())): DCNL DCSP  DCSP  DCSP  DCSP subset_names_cert = candidate_lineage DCNL DCSP  DCSP return (identical_names_cert, subset_names_cert) DCNL DCSP return _search_lineages(config, update_certs_for_domain_matches, (None, None))
 DCSP return [('\n'.join(sub_block) + '\n') for sub_block in block]
 DCSP return evaluate.EmptyObject(elementNode)
 DCSP def inner(text): DCNL DCSP  DCSP return colorizer.colorize(color, text) DCNL DCSP return inner
 DCSP return isinstance(exp, Var)
 DCSP if warning_level: DCNL DCSP  DCSP warning_level = int(warning_level) DCNL DCSP return HTTPExceptionHandler(app, warning_level=warning_level)
 DCSP if (not s): DCNL DCSP  DCSP raise InvalidRomanNumeralError, 'Input DCSP can DCSP not DCSP be DCSP blank' DCNL DCSP if (not romanNumeralPattern.search(s)): DCNL DCSP  DCSP raise InvalidRomanNumeralError, ('Invalid DCSP Roman DCSP numeral: DCSP %s' % s) DCNL DCSP result = 0 DCNL DCSP index = 0 DCNL DCSP for (numeral, integer) in romanNumeralMap: DCNL DCSP  DCSP while (s[index:(index + len(numeral))] == numeral): DCNL DCSP  DCSP  DCSP result += integer DCNL DCSP  DCSP  DCSP index += len(numeral) DCNL DCSP return result
 DCSP canvas = FigureCanvasGDK(figure) DCNL DCSP manager = FigureManagerBase(canvas, num) DCNL DCSP return manager
 DCSP if (bbox is None): DCNL DCSP  DCSP return wx.BitmapFromImage(_py_convert_agg_to_wx_image(agg, None)) DCNL DCSP else: DCNL DCSP  DCSP return _clipped_image_as_bitmap(_py_convert_agg_to_wx_image(agg, None), bbox)
 DCSP client_method = ClientMethod DCNL DCSP params = Params DCNL DCSP expires_in = ExpiresIn DCNL DCSP http_method = HttpMethod DCNL DCSP request_signer = self._request_signer DCNL DCSP serializer = self._serializer DCNL DCSP try: DCNL DCSP  DCSP operation_name = self._PY_TO_OP_NAME[client_method] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise UnknownClientMethodError(method_name=client_method) DCNL DCSP operation_model = self.meta.service_model.operation_model(operation_name) DCNL DCSP request_dict = serializer.serialize_to_request(params, operation_model) DCNL DCSP if (http_method is not None): DCNL DCSP  DCSP request_dict['method'] = http_method DCNL DCSP prepare_request_dict(request_dict, endpoint_url=self.meta.endpoint_url) DCNL DCSP return request_signer.generate_presigned_url(request_dict=request_dict, expires_in=expires_in, operation_name=operation_name)
 DCSP if (indexer_id is None): DCNL DCSP  DCSP return {} DCNL DCSP indexer_id = int(indexer_id) DCNL DCSP indexer = int(indexer) DCNL DCSP result = {} DCNL DCSP for dbData in [x[u'doc'] for x in sickrage.srCore.mainDB.db.get_many(u'scene_numbering', indexer_id, with_doc=True)]: DCNL DCSP  DCSP season = int((dbData[u'season'] or 0)) DCNL DCSP  DCSP episode = int((dbData[u'episode'] or 0)) DCNL DCSP  DCSP scene_season = int((dbData[u'scene_season'] or 0)) DCNL DCSP  DCSP scene_episode = int((dbData[u'scene_episode'] or 0)) DCNL DCSP  DCSP if ((int(dbData[u'indexer']) != indexer) or ((scene_season or scene_episode) == 0)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result[(season, episode)] = (scene_season, scene_episode) DCNL DCSP return result
 DCSP return ''.join((random.choice(source) for i in range(length)))
 DCSP ret = {'name': name, 'result': None, 'comment': '', 'changes': {}} DCNL DCSP try: DCNL DCSP  DCSP pip_list = __salt__['pip.list'](bin_env=bin_env, user=user, cwd=cwd) DCNL DCSP except (CommandExecutionError, CommandNotFoundError) as err: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP uninstalling DCSP '{0}': DCSP {1}".format(name, err) DCNL DCSP  DCSP return ret DCNL DCSP if (name not in pip_list): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Package DCSP is DCSP not DCSP installed.' DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Package DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP removed'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __salt__['pip.uninstall'](pkgs=name, requirements=requirements, bin_env=bin_env, log=log, proxy=proxy, timeout=timeout, user=user, cwd=cwd, use_vt=use_vt): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['changes'][name] = 'Removed' DCNL DCSP  DCSP ret['comment'] = 'Package DCSP was DCSP successfully DCSP removed.' DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Could DCSP not DCSP remove DCSP package.' DCNL DCSP return ret
 DCSP enqueue(u'frappe.integrations.doctype.dropbox_settings.dropbox_settings.take_backup_to_dropbox', queue=u'long') DCNL DCSP frappe.msgprint(_(u'Queued DCSP for DCSP backup. DCSP It DCSP may DCSP take DCSP a DCSP few DCSP minutes DCSP to DCSP an DCSP hour.'))
 DCSP settings = getattr(options, 'settings', DEFAULT_SETTINGS) DCNL DCSP asset_settings = getattr(options, 'asset_settings', settings) DCNL DCSP worker_settings = getattr(options, 'worker_settings', 'dev_with_worker') DCNL DCSP fast = getattr(options, 'fast', False) DCNL DCSP optimized = getattr(options, 'optimized', False) DCNL DCSP if optimized: DCNL DCSP  DCSP settings = OPTIMIZED_SETTINGS DCNL DCSP  DCSP asset_settings = OPTIMIZED_ASSETS_SETTINGS DCNL DCSP settings_lms = getattr(options, 'settings_lms', settings) DCNL DCSP settings_cms = getattr(options, 'settings_cms', settings) DCNL DCSP asset_settings_lms = getattr(options, 'asset_settings_lms', asset_settings) DCNL DCSP asset_settings_cms = getattr(options, 'asset_settings_cms', asset_settings) DCNL DCSP if (not fast): DCNL DCSP  DCSP args = ['lms', 'studio', '--settings={}'.format(asset_settings), '--skip-collect'] DCNL DCSP  DCSP call_task('pavelib.assets.update_assets', args=args) DCNL DCSP  DCSP if (settings != DEFAULT_SETTINGS): DCNL DCSP  DCSP  DCSP collect_assets(['lms'], asset_settings_lms) DCNL DCSP  DCSP  DCSP collect_assets(['studio'], asset_settings_cms) DCNL DCSP  DCSP call_task('pavelib.assets.watch_assets', options={'background': True}) DCNL DCSP lms_port = DEFAULT_PORT['lms'] DCNL DCSP cms_port = DEFAULT_PORT['studio'] DCNL DCSP lms_runserver_args = ['0.0.0.0:{}'.format(lms_port)] DCNL DCSP cms_runserver_args = ['0.0.0.0:{}'.format(cms_port)] DCNL DCSP run_multi_processes([django_cmd('lms', settings_lms, 'runserver', '--traceback', '--pythonpath=.', *lms_runserver_args), django_cmd('studio', settings_cms, 'runserver', '--traceback', '--pythonpath=.', *cms_runserver_args), django_cmd('lms', worker_settings, 'celery', 'worker', '--beat', '--loglevel=INFO', '--pythonpath=.')])
 DCSP if (not hasattr(obj, '_info_axis_number')): DCNL DCSP  DCSP raise TypeError(('object DCSP of DCSP type DCSP %r DCSP has DCSP no DCSP info DCSP axis' % type(obj).__name__)) DCNL DCSP slices = ([slice(None)] * obj.ndim) DCNL DCSP slices[obj._info_axis_number] = indexer DCNL DCSP return tuple(slices)
 DCSP sz = getattr(devmem, '_cuda_memsize_', None) DCNL DCSP if (sz is None): DCNL DCSP  DCSP (s, e) = device_extents(devmem) DCNL DCSP  DCSP sz = (e - s) DCNL DCSP  DCSP devmem._cuda_memsize_ = sz DCNL DCSP assert (sz > 0), 'zero DCSP length DCSP array' DCNL DCSP return sz
 DCSP (_, rest) = token.contents.split(None, 1) DCNL DCSP filter_expr = parser.compile_filter(('var|%s' % rest)) DCNL DCSP for (func, unused) in filter_expr.filters: DCNL DCSP  DCSP filter_name = getattr(func, '_filter_name', None) DCNL DCSP  DCSP if (filter_name in ('escape', 'safe')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('"filter DCSP %s" DCSP is DCSP not DCSP permitted. DCSP  DCSP Use DCSP the DCSP "autoescape" DCSP tag DCSP instead.' % filter_name)) DCNL DCSP nodelist = parser.parse(('endfilter',)) DCNL DCSP parser.delete_first_token() DCNL DCSP return FilterNode(filter_expr, nodelist)
 DCSP rpc = apiproxy_stub_map.UserRPC('taskqueue') DCNL DCSP request = taskqueue_service_pb.TaskQueueFetchQueuesRequest() DCNL DCSP response = taskqueue_service_pb.TaskQueueFetchQueuesResponse() DCNL DCSP if app_id: DCNL DCSP  DCSP request.set_app_id(app_id) DCNL DCSP request.set_max_rows(max_rows) DCNL DCSP queues = ['default'] DCNL DCSP try: DCNL DCSP  DCSP rpc.make_call('FetchQueues', request, response) DCNL DCSP  DCSP rpc.check_success() DCNL DCSP  DCSP for queue in response.queue_list(): DCNL DCSP  DCSP  DCSP if ((queue.mode() == taskqueue_service_pb.TaskQueueMode.PUSH) and (not queue.queue_name().startswith('__')) and (queue.queue_name() != 'default')): DCNL DCSP  DCSP  DCSP  DCSP queues.append(queue.queue_name()) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.exception('Failed DCSP to DCSP get DCSP queue DCSP names.') DCNL DCSP return queues
 DCSP query = request.args.to_dict() DCNL DCSP query['view_only'] = key DCNL DCSP replacements = {'query': urllib.urlencode(query)} DCNL DCSP if scheme: DCNL DCSP  DCSP replacements['scheme'] = scheme DCNL DCSP parsed_url = urlparse.urlparse(url) DCNL DCSP if parsed_url.fragment: DCNL DCSP  DCSP replacements['path'] = '{}%23{}'.format(parsed_url.path, parsed_url.fragment) DCNL DCSP  DCSP replacements['fragment'] = '' DCNL DCSP parsed_redirect_url = parsed_url._replace(**replacements) DCNL DCSP return urlparse.urlunparse(parsed_redirect_url)
 DCSP if (not any((route_table_name, route_table_id))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specified: DCSP route DCSP table DCSP name DCSP or DCSP route DCSP table DCSP id.') DCNL DCSP if (not any((gateway_id, instance_id, interface_id, vpc_peering_connection_id))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specified: DCSP gateway DCSP id, DCSP instance DCSP id, DCSP interface DCSP id DCSP or DCSP VPC DCSP peering DCSP connection DCSP id.') DCNL DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP filter_parameters = {'filters': {}} DCNL DCSP  DCSP if route_table_id: DCNL DCSP  DCSP  DCSP filter_parameters['route_table_ids'] = [route_table_id] DCNL DCSP  DCSP if route_table_name: DCNL DCSP  DCSP  DCSP filter_parameters['filters']['tag:Name'] = route_table_name DCNL DCSP  DCSP if tags: DCNL DCSP  DCSP  DCSP for (tag_name, tag_value) in six.iteritems(tags): DCNL DCSP  DCSP  DCSP  DCSP filter_parameters['filters']['tag:{0}'.format(tag_name)] = tag_value DCNL DCSP  DCSP route_tables = conn.get_all_route_tables(**filter_parameters) DCNL DCSP  DCSP if (len(route_tables) != 1): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Found DCSP more DCSP than DCSP one DCSP route DCSP table.') DCNL DCSP  DCSP route_check = {'destination_cidr_block': destination_cidr_block, 'gateway_id': gateway_id, 'instance_id': instance_id, 'interface_id': interface_id, 'vpc_peering_connection_id': vpc_peering_connection_id} DCNL DCSP  DCSP for route_match in route_tables[0].routes: DCNL DCSP  DCSP  DCSP route_dict = {'destination_cidr_block': route_match.destination_cidr_block, 'gateway_id': route_match.gateway_id, 'instance_id': route_match.instance_id, 'interface_id': route_match.interface_id, 'vpc_peering_connection_id': vpc_peering_connection_id} DCNL DCSP  DCSP  DCSP route_comp = (set(route_dict.items()) ^ set(route_check.items())) DCNL DCSP  DCSP  DCSP if (len(route_comp) == 0): DCNL DCSP  DCSP  DCSP  DCSP log.info('Route DCSP {0} DCSP exists.'.format(destination_cidr_block)) DCNL DCSP  DCSP  DCSP  DCSP return {'exists': True} DCNL DCSP  DCSP log.warning('Route DCSP {0} DCSP does DCSP not DCSP exist.'.format(destination_cidr_block)) DCNL DCSP  DCSP return {'exists': False} DCNL DCSP except BotoServerError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto.get_error(e)}
 DCSP def wrapper(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(self, request, *args, **kwargs): DCNL DCSP  DCSP  DCSP request.assert_authenticated() DCNL DCSP  DCSP  DCSP if request.context.is_admin: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_LW('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP  DCSP elif (callback is not None): DCNL DCSP  DCSP  DCSP  DCSP prep_info = {'f_name': f.__name__, 'input_attr': kwargs} DCNL DCSP  DCSP  DCSP  DCSP callback(self, request, prep_info, *args, **kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP action = ('identity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP  DCSP creds = _build_policy_check_credentials(self, action, request.context_dict, kwargs) DCNL DCSP  DCSP  DCSP  DCSP policy_dict = {} DCNL DCSP  DCSP  DCSP  DCSP if (hasattr(self, 'get_member_from_driver') and (self.get_member_from_driver is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = ('%s_id' % self.member_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key in kwargs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ref = self.get_member_from_driver(kwargs[key]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'] = {self.member_name: ref} DCNL DCSP  DCSP  DCSP  DCSP if (request.context_dict.get('subject_token_id') is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP window_seconds = self._token_validation_window(request) DCNL DCSP  DCSP  DCSP  DCSP  DCSP token_ref = token_model.KeystoneToken(token_id=request.context_dict['subject_token_id'], token_data=self.token_provider_api.validate_token(request.context_dict['subject_token_id'], window_seconds=window_seconds)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_dict.setdefault('target', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'].setdefault(self.member_name, {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'][self.member_name]['user_id'] = token_ref.user_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_domain_id = token_ref.user_domain_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP except exception.UnexpectedError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_domain_id = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if user_domain_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'][self.member_name].setdefault('user', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'][self.member_name]['user'].setdefault('domain', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_dict['target'][self.member_name]['user']['domain']['id'] = user_domain_id DCNL DCSP  DCSP  DCSP  DCSP policy_dict.update(kwargs) DCNL DCSP  DCSP  DCSP  DCSP self.policy_api.enforce(creds, action, utils.flatten_dict(policy_dict)) DCNL DCSP  DCSP  DCSP  DCSP LOG.debug('RBAC: DCSP Authorization DCSP granted') DCNL DCSP  DCSP  DCSP return f(self, request, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return wrapper
 DCSP parts = domain.split('.') DCNL DCSP for i in range(len(parts), 1, (-1)): DCNL DCSP  DCSP (yield '.'.join(parts[(- i):]))
 DCSP return (time.time() - start)
 DCSP for (parent, subdirs, files) in os.walk(start_dir): DCNL DCSP  DCSP if any((f for f in files if (f.endswith(suffix) and (f not in blacklist)))): DCNL DCSP  DCSP  DCSP del subdirs[:] DCNL DCSP  DCSP  DCSP (yield parent) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subdirs[:] = [s for s in subdirs if (s[0].isalpha() and (os.path.join(parent, s) not in blacklist))]
 DCSP if ((self.parser is None) or (not self.default_tag)): DCNL DCSP  DCSP return option.help DCNL DCSP optname = option._long_opts[0][2:] DCNL DCSP try: DCNL DCSP  DCSP provider = self.parser.options_manager._all_options[optname] DCNL DCSP except KeyError: DCNL DCSP  DCSP value = None DCNL DCSP else: DCNL DCSP  DCSP optdict = provider.get_option_def(optname) DCNL DCSP  DCSP optname = provider.option_attrname(optname, optdict) DCNL DCSP  DCSP value = getattr(provider.config, optname, optdict) DCNL DCSP  DCSP value = format_option_value(optdict, value) DCNL DCSP if ((value is optik_ext.NO_DEFAULT) or (not value)): DCNL DCSP  DCSP value = self.NO_DEFAULT_VALUE DCNL DCSP return option.help.replace(self.default_tag, str(value))
 DCSP def decorator(f): DCNL DCSP  DCSP attrs.setdefault('prompt', True) DCNL DCSP  DCSP attrs.setdefault('confirmation_prompt', True) DCNL DCSP  DCSP attrs.setdefault('hide_input', True) DCNL DCSP  DCSP return option(*(param_decls or ('--password',)), **attrs)(f) DCNL DCSP return decorator
 DCSP cmd = '/etc/rc.d/{0} DCSP -f DCSP stop'.format(name) DCNL DCSP return (not __salt__['cmd.retcode'](cmd))
 DCSP if ((foo is not None) and (foo != 'wat')): DCNL DCSP  DCSP raise click.BadParameter('If DCSP a DCSP value DCSP is DCSP provided DCSP it DCSP needs DCSP to DCSP be DCSP the DCSP value DCSP "wat".', param_hint=['--foo']) DCNL DCSP click.echo(('count: DCSP %s' % count)) DCNL DCSP click.echo(('foo: DCSP %s' % foo)) DCNL DCSP click.echo(('url: DCSP %s' % repr(url)))
 DCSP def showWarning(message, category, filename, lineno, file=None, line=None): DCNL DCSP  DCSP assert isinstance(message, Warning) DCNL DCSP  DCSP observeWarning(_Warning(message.args[0], category, filename, lineno)) DCNL DCSP for v in sys.modules.itervalues(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v.__warningregistry__ = None DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP origFilters = warnings.filters[:] DCNL DCSP origShow = warnings.showwarning DCNL DCSP warnings.simplefilter('always') DCNL DCSP try: DCNL DCSP  DCSP warnings.showwarning = showWarning DCNL DCSP  DCSP result = f(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP warnings.filters[:] = origFilters DCNL DCSP  DCSP warnings.showwarning = origShow DCNL DCSP return result
 DCSP comment_dict = {} DCNL DCSP if interfilediff: DCNL DCSP  DCSP key = (filediff.pk, interfilediff.pk) DCNL DCSP else: DCNL DCSP  DCSP key = (filediff.pk, None) DCNL DCSP comments = all_comments.get(key, []) DCNL DCSP for comment in comments: DCNL DCSP  DCSP review = comment.get_review() DCNL DCSP  DCSP if (review and (review.public or (review.user == user))): DCNL DCSP  DCSP  DCSP key = (comment.first_line, comment.num_lines) DCNL DCSP  DCSP  DCSP comment_dict.setdefault(key, []).append({u'comment_id': comment.id, u'text': normalize_text_for_edit(user, comment.text, comment.rich_text), u'html': markdown_render_conditional(comment.text, comment.rich_text), u'rich_text': comment.rich_text, u'line': comment.first_line, u'num_lines': comment.num_lines, u'user': {u'username': review.user.username, u'name': (review.user.get_full_name() or review.user.username)}, u'url': comment.get_review_url(), u'localdraft': ((review.user == user) and (not review.public)), u'review_id': review.id, u'issue_opened': comment.issue_opened, u'issue_status': BaseComment.issue_status_to_string(comment.issue_status), u'reply_to_id': comment.reply_to_id}) DCNL DCSP comments_array = [] DCNL DCSP for (key, value) in six.iteritems(comment_dict): DCNL DCSP  DCSP comments_array.append({u'linenum': key[0], u'num_lines': key[1], u'comments': value}) DCNL DCSP comments_array.sort(cmp=(lambda x, y: cmp(x[u'linenum'], (y[u'linenum'] or cmp(x[u'num_lines'], y[u'num_lines']))))) DCNL DCSP return comments_array
 DCSP return s3db.req_match()
 DCSP purine = ('A', 'G') DCNL DCSP pyrimidine = ('C', 'T') DCNL DCSP TV = [0, 0] DCNL DCSP sites = 0 DCNL DCSP for (codon1, codon2) in zip(codon_lst1, codon_lst2): DCNL DCSP  DCSP if ('---' not in (codon1, codon2)): DCNL DCSP  DCSP  DCSP for (i, j) in zip(codon1, codon2): DCNL DCSP  DCSP  DCSP  DCSP if (i == j): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP elif ((i in purine) and (j in purine)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[0] += 1 DCNL DCSP  DCSP  DCSP  DCSP elif ((i in pyrimidine) and (j in pyrimidine)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[0] += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[1] += 1 DCNL DCSP  DCSP  DCSP  DCSP sites += 1 DCNL DCSP return ((TV[0] / sites), (TV[1] / sites))
 DCSP ctx = ssl.create_default_context() DCNL DCSP ctx.check_hostname = False DCNL DCSP ctx.load_verify_locations(cafile='ssl/cacert.pem') DCNL DCSP ctx.verify_mode = ssl.CERT_REQUIRED DCNL DCSP url = 'https://{}:8500/v1/health/state/any'.format(node_address) DCNL DCSP request = urllib2.Request(url) DCNL DCSP auth = ('Basic DCSP ' + base64.b64encode(get_credentials())) DCNL DCSP request.add_header('Authorization', auth) DCNL DCSP f = urllib2.urlopen(request, None, timeout, context=ctx) DCNL DCSP checks = json.loads(f.read().decode('utf8')) DCNL DCSP return [c for c in checks if (c.get('Status', '').lower() != 'passing')]
 DCSP start = int((batch_nb * batch_size)) DCNL DCSP end = int(((batch_nb + 1) * batch_size)) DCNL DCSP if (end > data_length): DCNL DCSP  DCSP shift = (end - data_length) DCNL DCSP  DCSP start -= shift DCNL DCSP  DCSP end -= shift DCNL DCSP return (start, end)
 DCSP if (d.get(u'name') and frappe.db.exists(doctype, d[u'name'])): DCNL DCSP  DCSP if overwrite: DCNL DCSP  DCSP  DCSP doc = frappe.get_doc(doctype, d[u'name']) DCNL DCSP  DCSP  DCSP doc.flags.ignore_links = ignore_links DCNL DCSP  DCSP  DCSP doc.update(d) DCNL DCSP  DCSP  DCSP if (d.get(u'docstatus') == 1): DCNL DCSP  DCSP  DCSP  DCSP doc.update_after_submit() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP doc.save() DCNL DCSP  DCSP  DCSP return (u'Updated DCSP row DCSP (#%d) DCSP %s' % ((row_idx + 1), getlink(doctype, d[u'name']))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'Ignored DCSP row DCSP (#%d) DCSP %s DCSP (exists)' % ((row_idx + 1), getlink(doctype, d[u'name']))) DCNL DCSP else: DCNL DCSP  DCSP doc = frappe.get_doc(d) DCNL DCSP  DCSP doc.flags.ignore_links = ignore_links DCNL DCSP  DCSP doc.insert() DCNL DCSP  DCSP if submit: DCNL DCSP  DCSP  DCSP doc.submit() DCNL DCSP  DCSP return (u'Inserted DCSP row DCSP (#%d) DCSP %s' % ((row_idx + 1), getlink(doctype, doc.get(u'name'))))
 DCSP config = {32: {'byte': (4, 1, 255, 'hh', 8), 'short': (2, 2, 65535, 'h', 16), 'int': (1, 4, 4294967295, '', 32)}, 64: {'byte': (8, 1, 255, 'hh', 8), 'short': (4, 2, 65535, 'h', 16), 'int': (2, 4, 4294967295, '', 32)}} DCNL DCSP if (write_size not in ['byte', 'short', 'int']): DCNL DCSP  DCSP log.error("write_size DCSP must DCSP be DCSP 'byte', DCSP 'short' DCSP or DCSP 'int'") DCNL DCSP (number, step, mask, formatz, decalage) = config[context.bits][write_size] DCNL DCSP payload = '' DCNL DCSP for (where, what) in writes.items(): DCNL DCSP  DCSP for i in range(0, (number * step), step): DCNL DCSP  DCSP  DCSP payload += pack((where + i)) DCNL DCSP numbwritten += len(payload) DCNL DCSP fmtCount = 0 DCNL DCSP for (where, what) in writes.items(): DCNL DCSP  DCSP for i in range(0, number): DCNL DCSP  DCSP  DCSP current = (what & mask) DCNL DCSP  DCSP  DCSP if ((numbwritten & mask) <= current): DCNL DCSP  DCSP  DCSP  DCSP to_add = (current - (numbwritten & mask)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP to_add = ((current | (mask + 1)) - (numbwritten & mask)) DCNL DCSP  DCSP  DCSP if (to_add != 0): DCNL DCSP  DCSP  DCSP  DCSP payload += '%{}c'.format(to_add) DCNL DCSP  DCSP  DCSP payload += '%{}${}n'.format((offset + fmtCount), formatz) DCNL DCSP  DCSP  DCSP numbwritten += to_add DCNL DCSP  DCSP  DCSP what >>= decalage DCNL DCSP  DCSP  DCSP fmtCount += 1 DCNL DCSP return payload
 DCSP terms = [] DCNL DCSP for node in nodes: DCNL DCSP  DCSP terms += makeTerm(node, title, term) DCNL DCSP return terms
 DCSP state = salt.utils.mac_utils.validate_enabled(enable) DCNL DCSP cmd = 'systemsetup DCSP -setusingnetworktime DCSP {0}'.format(state) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmd) DCNL DCSP return (state == salt.utils.mac_utils.validate_enabled(get_using_network_time()))
 DCSP (version, num_entries) = read_header(stream) DCNL DCSP count = 0 DCNL DCSP entries = dict() DCNL DCSP read = stream.read DCNL DCSP tell = stream.tell DCNL DCSP while (count < num_entries): DCNL DCSP  DCSP beginoffset = tell() DCNL DCSP  DCSP ctime = unpack('>8s', read(8))[0] DCNL DCSP  DCSP mtime = unpack('>8s', read(8))[0] DCNL DCSP  DCSP (dev, ino, mode, uid, gid, size, sha, flags) = unpack('>LLLLLL20sH', read(((20 + (4 * 6)) + 2))) DCNL DCSP  DCSP path_size = (flags & CE_NAMEMASK) DCNL DCSP  DCSP path = read(path_size).decode(defenc) DCNL DCSP  DCSP real_size = (((tell() - beginoffset) + 8) & (~ 7)) DCNL DCSP  DCSP read(((beginoffset + real_size) - tell())) DCNL DCSP  DCSP entry = IndexEntry((mode, sha, flags, path, ctime, mtime, dev, ino, uid, gid, size)) DCNL DCSP  DCSP entries[(path, entry.stage)] = entry DCNL DCSP  DCSP count += 1 DCNL DCSP extension_data = stream.read((~ 0)) DCNL DCSP assert (len(extension_data) > 19), ('Index DCSP Footer DCSP was DCSP not DCSP at DCSP least DCSP a DCSP sha DCSP on DCSP content DCSP as DCSP it DCSP was DCSP only DCSP %i DCSP bytes DCSP in DCSP size' % len(extension_data)) DCNL DCSP content_sha = extension_data[(-20):] DCNL DCSP extension_data = extension_data[:(-20)] DCNL DCSP return (version, entries, extension_data, content_sha)
 DCSP s3_deleter.Deleter()
 DCSP derivation = HeightmapDerivation(elementNode) DCNL DCSP heightGrid = derivation.heightGrid DCNL DCSP if (derivation.fileName != ''): DCNL DCSP  DCSP heightGrid = getHeightGrid(archive.getAbsoluteFolderPath(elementNode.getOwnerDocument().fileName, derivation.fileName)) DCNL DCSP return getGeometryOutputByHeightGrid(derivation, elementNode, heightGrid)
 DCSP if (not os.path.exists(work_directory)): DCNL DCSP  DCSP os.mkdir(work_directory) DCNL DCSP filepath = os.path.join(work_directory, filename) DCNL DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP (filepath, _) = urllib.urlretrieve((SOURCE_URL + filename), filepath) DCNL DCSP  DCSP statinfo = os.stat(filepath) DCNL DCSP  DCSP print('Succesfully DCSP downloaded', filename, statinfo.st_size, 'bytes.') DCNL DCSP return filepath
 DCSP return __salt__['probes.set_probes'](_ordered_dict_to_dict(probes), commit=False)
 DCSP result = [] DCNL DCSP for child in section.children: DCNL DCSP  DCSP if isinstance(child, nodes.section): DCNL DCSP  DCSP  DCSP result.append(child) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.extend(find_subsections(child)) DCNL DCSP return result
 DCSP tags = list() DCNL DCSP i = 0 DCNL DCSP list_of_tags = list_of_tags DCNL DCSP for i in range(len(list_of_tags)): DCNL DCSP  DCSP key_name = list_of_tags[i][0] DCNL DCSP  DCSP key_val = list_of_tags[i][1] DCNL DCSP  DCSP tags.append({'Key': key_name, 'Value': key_val}) DCNL DCSP return tags
 DCSP def _select_block(str_in, start_tag, end_tag): DCNL DCSP  DCSP 'Select DCSP first DCSP block DCSP delimited DCSP by DCSP start_tag DCSP and DCSP end_tag' DCNL DCSP  DCSP start_pos = str_in.find(start_tag) DCNL DCSP  DCSP if (start_pos < 0): DCNL DCSP  DCSP  DCSP raise ValueError('start_tag DCSP not DCSP found') DCNL DCSP  DCSP depth = 0 DCNL DCSP  DCSP for pos in range(start_pos, len(str_in)): DCNL DCSP  DCSP  DCSP if (str_in[pos] == start_tag): DCNL DCSP  DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP  DCSP elif (str_in[pos] == end_tag): DCNL DCSP  DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP if (depth == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP sel = str_in[(start_pos + 1):pos] DCNL DCSP  DCSP return sel DCNL DCSP def _parse_dict_recursive(dict_str): DCNL DCSP  DCSP 'Parse DCSP a DCSP dictionary DCSP from DCSP the DCSP search DCSP index' DCNL DCSP  DCSP dict_out = dict() DCNL DCSP  DCSP pos_last = 0 DCNL DCSP  DCSP pos = dict_str.find(':') DCNL DCSP  DCSP while (pos >= 0): DCNL DCSP  DCSP  DCSP key = dict_str[pos_last:pos] DCNL DCSP  DCSP  DCSP if (dict_str[(pos + 1)] == '['): DCNL DCSP  DCSP  DCSP  DCSP pos_tmp = dict_str.find(']', (pos + 1)) DCNL DCSP  DCSP  DCSP  DCSP if (pos_tmp < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('error DCSP when DCSP parsing DCSP dict') DCNL DCSP  DCSP  DCSP  DCSP value = dict_str[(pos + 2):pos_tmp].split(',') DCNL DCSP  DCSP  DCSP  DCSP for i in range(len(value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value[i] = int(value[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (dict_str[(pos + 1)] == '{'): DCNL DCSP  DCSP  DCSP  DCSP subdict_str = _select_block(dict_str[pos:], '{', '}') DCNL DCSP  DCSP  DCSP  DCSP value = _parse_dict_recursive(subdict_str) DCNL DCSP  DCSP  DCSP  DCSP pos_tmp = (pos + len(subdict_str)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('error DCSP when DCSP parsing DCSP dict: DCSP unknown DCSP elem') DCNL DCSP  DCSP  DCSP key = key.strip('"') DCNL DCSP  DCSP  DCSP if (len(key) > 0): DCNL DCSP  DCSP  DCSP  DCSP dict_out[key] = value DCNL DCSP  DCSP  DCSP pos_last = dict_str.find(',', pos_tmp) DCNL DCSP  DCSP  DCSP if (pos_last < 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP pos_last += 1 DCNL DCSP  DCSP  DCSP pos = dict_str.find(':', pos_last) DCNL DCSP  DCSP return dict_out DCNL DCSP query = 'objects:' DCNL DCSP pos = searchindex.find(query) DCNL DCSP if (pos < 0): DCNL DCSP  DCSP raise ValueError('"objects:" DCSP not DCSP found DCSP in DCSP search DCSP index') DCNL DCSP sel = _select_block(searchindex[pos:], '{', '}') DCNL DCSP objects = _parse_dict_recursive(sel) DCNL DCSP query = 'filenames:' DCNL DCSP pos = searchindex.find(query) DCNL DCSP if (pos < 0): DCNL DCSP  DCSP raise ValueError('"filenames:" DCSP not DCSP found DCSP in DCSP search DCSP index') DCNL DCSP filenames = searchindex[((pos + len(query)) + 1):] DCNL DCSP filenames = filenames[:filenames.find(']')] DCNL DCSP filenames = [f.strip('"') for f in filenames.split(',')] DCNL DCSP return (filenames, objects)
 DCSP search_path = None DCNL DCSP param_type = type(dot_path_or_list) DCNL DCSP if (param_type in (tuple, list)): DCNL DCSP  DCSP search_path = dot_path_or_list DCNL DCSP elif (param_type == str): DCNL DCSP  DCSP search_path = dot_path_or_list.split('.') DCNL DCSP assert (len(search_path) > 0), 'Missing DCSP valid DCSP search DCSP path' DCNL DCSP try: DCNL DCSP  DCSP current_item = data_structure DCNL DCSP  DCSP for search_key in search_path: DCNL DCSP  DCSP  DCSP current_item = current_item[search_key] DCNL DCSP except (KeyError, IndexError, TypeError): DCNL DCSP  DCSP return default_value DCNL DCSP return current_item
 DCSP bkts = sorted(bkts, key=(lambda bkt: bkt.value)) DCNL DCSP for i in range(len(bkts)): DCNL DCSP  DCSP if (not sufficient_funds(bkts[(i + 1):])): DCNL DCSP  DCSP  DCSP return bkts[i:] DCNL DCSP return bkts
 DCSP log('-', cmd) DCNL DCSP cmd = cmd.split() DCNL DCSP arg0 = cmd[0] DCNL DCSP if (not find_executable(arg0)): DCNL DCSP  DCSP raise Exception((('Cannot DCSP find DCSP executable DCSP "%s";' % arg0) + ('you DCSP might DCSP try DCSP %s DCSP --depend' % argv[0]))) DCNL DCSP return check_output(cmd, **kwargs)
 DCSP objects = [] DCNL DCSP if (request.GET and ('term' in request.GET)): DCNL DCSP  DCSP objects = Object.filter_permitted(request.user.profile, Object.objects.filter(object_name__icontains=request.GET['term']), mode='x')[:10] DCNL DCSP return render_to_response('core/ajax_object_lookup', {'objects': objects}, context_instance=RequestContext(request), response_format=response_format)
 DCSP try: DCNL DCSP  DCSP return scopes.index(scope) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError("{0} DCSP {1}has DCSP an DCSP unsupported DCSP scope DCSP value DCSP '{2}'".format(descr, ('from DCSP {0} DCSP '.format(where) if where else ''), scope))
 DCSP host = get_request_site_address() DCNL DCSP blog_list = frappe.db.sql(u' DCTB  DCTB select DCSP route DCSP as DCSP name, DCSP published_on, DCSP modified, DCSP title, DCSP content DCSP from DCSP `tabBlog DCSP Post`\n DCTB  DCTB where DCSP ifnull(published,0)=1\n DCTB  DCTB order DCSP by DCSP published_on DCSP desc DCSP limit DCSP 20', as_dict=1) DCNL DCSP for blog in blog_list: DCNL DCSP  DCSP blog_page = cstr(urllib.quote(blog.route.encode(u'utf-8'))) DCNL DCSP  DCSP blog.link = urllib.basejoin(host, blog_page) DCNL DCSP  DCSP blog.content = escape_html((blog.content or u'')) DCNL DCSP if blog_list: DCNL DCSP  DCSP modified = max((blog[u'modified'] for blog in blog_list)) DCNL DCSP else: DCNL DCSP  DCSP modified = now() DCNL DCSP blog_settings = frappe.get_doc(u'Blog DCSP Settings', u'Blog DCSP Settings') DCNL DCSP context = {u'title': (blog_settings.blog_title or u'Blog'), u'description': (blog_settings.blog_introduction or u''), u'modified': modified, u'items': blog_list, u'link': (host + u'/blog')} DCNL DCSP return context
 DCSP pub = Publisher(reader, parser, writer, settings=settings) DCNL DCSP pub.set_components(reader_name, parser_name, writer_name) DCNL DCSP output = pub.publish(argv, usage, description, settings_spec, settings_overrides, config_section=config_section, enable_exit_status=enable_exit_status) DCNL DCSP return output
 DCSP if (not user_exists(name, database, user, password, host, port)): DCNL DCSP  DCSP if database: DCNL DCSP  DCSP  DCSP log.info("User DCSP '{0}' DCSP does DCSP not DCSP exist DCSP for DCSP DB DCSP '{1}'".format(name, database)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.info("Cluster DCSP admin DCSP '{0}' DCSP does DCSP not DCSP exist".format(name)) DCNL DCSP  DCSP return False DCNL DCSP client = _client(user=user, password=password, host=host, port=port) DCNL DCSP if (not database): DCNL DCSP  DCSP return client.delete_cluster_admin(name) DCNL DCSP client.switch_database(database) DCNL DCSP return client.delete_database_user(name)
 DCSP domain = get_domain(url) DCNL DCSP tld = '.'.join(domain.split('.')[(-2):]) DCNL DCSP if (tld in ['co.uk', 'com.au', 'au.com']): DCNL DCSP  DCSP end_chunks = domain.split('.')[(-3):] DCNL DCSP else: DCNL DCSP  DCSP end_chunks = domain.split('.')[(-2):] DCNL DCSP base_domain = '.'.join(end_chunks) DCNL DCSP return base_domain
 DCSP def relativize_url(url, root_dir): DCNL DCSP  DCSP url = (os.path.realpath(url) if followlinks else url) DCNL DCSP  DCSP root_dir = (os.path.realpath(root_dir) if followlinks else root_dir) DCNL DCSP  DCSP url_in_bundle = os.path.relpath(url, root_dir) DCNL DCSP  DCSP if os.path.isdir(url): DCNL DCSP  DCSP  DCSP url_in_bundle += u'/' DCNL DCSP  DCSP return url_in_bundle DCNL DCSP return [relativize_url(url, root_dir) for url in classpath]
 DCSP if sys.dont_write_bytecode: DCNL DCSP  DCSP raise DistutilsByteCompileError('byte-compiling DCSP is DCSP disabled.') DCNL DCSP if (direct is None): DCNL DCSP  DCSP direct = (__debug__ and (optimize == 0)) DCNL DCSP if (not direct): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from tempfile import mkstemp DCNL DCSP  DCSP  DCSP (script_fd, script_name) = mkstemp('.py') DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP from tempfile import mktemp DCNL DCSP  DCSP  DCSP (script_fd, script_name) = (None, mktemp('.py')) DCNL DCSP  DCSP log.info("writing DCSP byte-compilation DCSP script DCSP '%s'", script_name) DCNL DCSP  DCSP if (not dry_run): DCNL DCSP  DCSP  DCSP if (script_fd is not None): DCNL DCSP  DCSP  DCSP  DCSP script = os.fdopen(script_fd, 'w') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP script = open(script_name, 'w') DCNL DCSP  DCSP  DCSP script.write('from DCSP distutils.util DCSP import DCSP byte_compile\nfiles DCSP = DCSP [\n') DCNL DCSP  DCSP  DCSP script.write((string.join(map(repr, py_files), ',\n') + ']\n')) DCNL DCSP  DCSP  DCSP script.write(('\nbyte_compile(files, DCSP optimize=%r, DCSP force=%r,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prefix=%r, DCSP base_dir=%r,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP verbose=%r, DCSP dry_run=0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP direct=1)\n' % (optimize, force, prefix, base_dir, verbose))) DCNL DCSP  DCSP  DCSP script.close() DCNL DCSP  DCSP cmd = [sys.executable, script_name] DCNL DCSP  DCSP if (optimize == 1): DCNL DCSP  DCSP  DCSP cmd.insert(1, '-O') DCNL DCSP  DCSP elif (optimize == 2): DCNL DCSP  DCSP  DCSP cmd.insert(1, '-OO') DCNL DCSP  DCSP spawn(cmd, dry_run=dry_run) DCNL DCSP  DCSP execute(os.remove, (script_name,), ('removing DCSP %s' % script_name), dry_run=dry_run) DCNL DCSP else: DCNL DCSP  DCSP from py_compile import compile DCNL DCSP  DCSP for file in py_files: DCNL DCSP  DCSP  DCSP if (file[(-3):] != '.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP cfile = (file + ((__debug__ and 'c') or 'o')) DCNL DCSP  DCSP  DCSP dfile = file DCNL DCSP  DCSP  DCSP if prefix: DCNL DCSP  DCSP  DCSP  DCSP if (file[:len(prefix)] != prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError, ("invalid DCSP prefix: DCSP filename DCSP %r DCSP doesn't DCSP start DCSP with DCSP %r" % (file, prefix)) DCNL DCSP  DCSP  DCSP  DCSP dfile = dfile[len(prefix):] DCNL DCSP  DCSP  DCSP if base_dir: DCNL DCSP  DCSP  DCSP  DCSP dfile = os.path.join(base_dir, dfile) DCNL DCSP  DCSP  DCSP cfile_base = os.path.basename(cfile) DCNL DCSP  DCSP  DCSP if direct: DCNL DCSP  DCSP  DCSP  DCSP if (force or newer(file, cfile)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.info('byte-compiling DCSP %s DCSP to DCSP %s', file, cfile_base) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not dry_run): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP compile(file, cfile, dfile) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.debug('skipping DCSP byte-compilation DCSP of DCSP %s DCSP to DCSP %s', file, cfile_base)
 DCSP return (SecondsSince(timestamp) / 3600.0)
 DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP if (not properties): DCNL DCSP  DCSP properties = {} DCNL DCSP log.debug('zfs.volume_present::{0}::config::volume_size DCSP = DCSP {1}'.format(name, volume_size)) DCNL DCSP log.debug('zfs.volume_present::{0}::config::sparse DCSP = DCSP {1}'.format(name, sparse)) DCNL DCSP log.debug('zfs.volume_present::{0}::config::create_parent DCSP = DCSP {1}'.format(name, create_parent)) DCNL DCSP log.debug('zfs.volume_present::{0}::config::cloned_from DCSP = DCSP {1}'.format(name, cloned_from)) DCNL DCSP log.debug('zfs.volume_present::{0}::config::properties DCSP = DCSP {1}'.format(name, properties)) DCNL DCSP for prop in properties.keys(): DCNL DCSP  DCSP if isinstance(properties[prop], bool): DCNL DCSP  DCSP  DCSP properties[prop] = ('on' if properties[prop] else 'off') DCNL DCSP if (('@' in name) or ('#' in name)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'invalid DCSP filesystem DCSP or DCSP volume DCSP name: DCSP {0}'.format(name) DCNL DCSP if cloned_from: DCNL DCSP  DCSP cloned_parent = cloned_from[:cloned_from.index('@')] DCNL DCSP  DCSP if ('@' not in cloned_from): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = '{0} DCSP is DCSP not DCSP a DCSP snapshot'.format(cloned_from) DCNL DCSP  DCSP elif (cloned_from not in __salt__['zfs.list'](cloned_from, **{'type': 'snapshot'})): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'snapshot DCSP {0} DCSP does DCSP not DCSP exist'.format(cloned_from) DCNL DCSP  DCSP elif (cloned_parent not in __salt__['zfs.list'](cloned_parent, **{'type': 'volume'})): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'snapshot DCSP {0} DCSP is DCSP not DCSP from DCSP a DCSP volume'.format(cloned_from) DCNL DCSP if ret['result']: DCNL DCSP  DCSP if (name in __salt__['zfs.list'](name, **{'type': 'volume'})): DCNL DCSP  DCSP  DCSP properties['volsize'] = volume_size DCNL DCSP  DCSP  DCSP result = __salt__['zfs.get'](name, **{'properties': ','.join(properties.keys()), 'fields': 'value', 'depth': 1}) DCNL DCSP  DCSP  DCSP for prop in properties.keys(): DCNL DCSP  DCSP  DCSP  DCSP if (properties[prop] != result[name][prop]['value']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in ret['changes']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'][name] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'][name][prop] = properties[prop] DCNL DCSP  DCSP  DCSP if (len(ret['changes']) > 0): DCNL DCSP  DCSP  DCSP  DCSP if (not __opts__['test']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.set'](name, **ret['changes'][name]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for prop in result[name].keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (result[name][prop] != 'set'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP was DCSP updated'.format(name) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP failed DCSP to DCSP be DCSP updated'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP is DCSP up DCSP to DCSP date'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = {name: 'created'} DCNL DCSP  DCSP  DCSP if (not __opts__['test']): DCNL DCSP  DCSP  DCSP  DCSP if (not cloned_from): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.create'](name, **{'volume_size': volume_size, 'sparse': sparse, 'create_parent': create_parent, 'properties': properties}) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.clone'](cloned_from, name, **{'create_parent': create_parent, 'properties': properties}) DCNL DCSP  DCSP  DCSP ret['result'] = (name in result) DCNL DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = ((result[name] == 'created') or result[name].startswith('cloned')) DCNL DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes'][name] = (properties if (len(properties) > 0) else result[name]) DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP was DCSP created'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'failed DCSP to DCSP create DCSP volume DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP  DCSP if (name in result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = result[name] DCNL DCSP return ret
 DCSP if (not is_secure_transport(uri)): DCNL DCSP  DCSP raise InsecureTransportError() DCNL DCSP params = [(u'response_type', response_type), (u'client_id', client_id)] DCNL DCSP if redirect_uri: DCNL DCSP  DCSP params.append((u'redirect_uri', redirect_uri)) DCNL DCSP if scope: DCNL DCSP  DCSP params.append((u'scope', list_to_scope(scope))) DCNL DCSP if state: DCNL DCSP  DCSP params.append((u'state', state)) DCNL DCSP for k in kwargs: DCNL DCSP  DCSP if kwargs[k]: DCNL DCSP  DCSP  DCSP params.append((unicode_type(k), kwargs[k])) DCNL DCSP return add_params_to_uri(uri, params)
 DCSP coded_messages = [] DCNL DCSP for (tag, data) in messages: DCNL DCSP  DCSP if data: DCNL DCSP  DCSP  DCSP if (not isinstance(data, str)): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = ' DCSP '.join(map(str, data)) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP m = ('%s DCSP %s' % (tag, data)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP m = str(tag) DCNL DCSP  DCSP m = ctcpQuote(m) DCNL DCSP  DCSP m = ('%s%s%s' % (X_DELIM, m, X_DELIM)) DCNL DCSP  DCSP coded_messages.append(m) DCNL DCSP line = ''.join(coded_messages) DCNL DCSP return line
 DCSP ret = [] DCNL DCSP changes = {} DCNL DCSP txt = {} DCNL DCSP global LAST_GRAINS DCNL DCSP _validate = __validate__(config) DCNL DCSP if (not _validate[0]): DCNL DCSP  DCSP log.warning('Beacon DCSP {0} DCSP configuration DCSP invalid, DCSP not DCSP adding. DCSP {1}'.format(__virtualname__, _validate[1])) DCNL DCSP  DCSP return ret DCNL DCSP if ('servicename' in config): DCNL DCSP  DCSP servicename = config['servicename'] DCNL DCSP else: DCNL DCSP  DCSP servicename = __grains__['host'] DCNL DCSP for item in config['txt']: DCNL DCSP  DCSP if config['txt'][item].startswith('grains.'): DCNL DCSP  DCSP  DCSP grain = config['txt'][item][7:] DCNL DCSP  DCSP  DCSP grain_index = None DCNL DCSP  DCSP  DCSP square_bracket = grain.find('[') DCNL DCSP  DCSP  DCSP if ((square_bracket != (-1)) and (grain[(-1)] == ']')): DCNL DCSP  DCSP  DCSP  DCSP grain_index = int(grain[(square_bracket + 1):(-1)]) DCNL DCSP  DCSP  DCSP  DCSP grain = grain[:square_bracket] DCNL DCSP  DCSP  DCSP grain_value = __grains__.get(grain, '') DCNL DCSP  DCSP  DCSP if isinstance(grain_value, list): DCNL DCSP  DCSP  DCSP  DCSP if (grain_index is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP grain_value = grain_value[grain_index] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP grain_value = ','.join(grain_value) DCNL DCSP  DCSP  DCSP txt[item] = grain_value DCNL DCSP  DCSP  DCSP if (LAST_GRAINS and (LAST_GRAINS.get(grain, '') != __grains__.get(grain, ''))): DCNL DCSP  DCSP  DCSP  DCSP changes[str(('txt.' + item))] = txt[item] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP txt[item] = config['txt'][item] DCNL DCSP  DCSP if (not LAST_GRAINS): DCNL DCSP  DCSP  DCSP changes[str(('txt.' + item))] = txt[item] DCNL DCSP if changes: DCNL DCSP  DCSP if (not LAST_GRAINS): DCNL DCSP  DCSP  DCSP changes['servicename'] = servicename DCNL DCSP  DCSP  DCSP changes['servicetype'] = config['servicetype'] DCNL DCSP  DCSP  DCSP changes['port'] = config['port'] DCNL DCSP  DCSP  DCSP GROUP.AddService(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, dbus.UInt32(0), servicename, config['servicetype'], '', '', dbus.UInt16(config['port']), avahi.dict_to_txt_array(txt)) DCNL DCSP  DCSP  DCSP GROUP.Commit() DCNL DCSP  DCSP elif config.get('reset_on_change', False): DCNL DCSP  DCSP  DCSP GROUP.Reset() DCNL DCSP  DCSP  DCSP reset_wait = config.get('reset_wait', 0) DCNL DCSP  DCSP  DCSP if (reset_wait > 0): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(reset_wait) DCNL DCSP  DCSP  DCSP GROUP.AddService(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, dbus.UInt32(0), servicename, config['servicetype'], '', '', dbus.UInt16(config['port']), avahi.dict_to_txt_array(txt)) DCNL DCSP  DCSP  DCSP GROUP.Commit() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP GROUP.UpdateServiceTxt(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, dbus.UInt32(0), servicename, config['servicetype'], '', avahi.dict_to_txt_array(txt)) DCNL DCSP  DCSP ret.append({'tag': 'result', 'changes': changes}) DCNL DCSP if config.get('copy_grains', False): DCNL DCSP  DCSP LAST_GRAINS = __grains__.copy() DCNL DCSP else: DCNL DCSP  DCSP LAST_GRAINS = __grains__ DCNL DCSP return ret
 DCSP return loadopt.set_relationship_strategy(attr, {'lazy': 'noload'})
 DCSP GlobalObject().masterremote._reference._service.mapTarget(target)
 DCSP data_home = get_data_home(data_home) DCNL DCSP if (not exists(data_home)): DCNL DCSP  DCSP makedirs(data_home) DCNL DCSP extra_params = dict(x_left_lower_corner=(-94.8), Nx=1212, y_left_lower_corner=(-56.05), Ny=1592, grid_size=0.05) DCNL DCSP dtype = np.int16 DCNL DCSP archive_path = _pkl_filepath(data_home, DATA_ARCHIVE_NAME) DCNL DCSP if (not exists(archive_path)): DCNL DCSP  DCSP if (not download_if_missing): DCNL DCSP  DCSP  DCSP raise IOError('Data DCSP not DCSP found DCSP and DCSP `download_if_missing` DCSP is DCSP False') DCNL DCSP  DCSP print ('Downloading DCSP species DCSP data DCSP from DCSP %s DCSP to DCSP %s' % (SAMPLES_URL, data_home)) DCNL DCSP  DCSP X = np.load(BytesIO(urlopen(SAMPLES_URL).read())) DCNL DCSP  DCSP for f in X.files: DCNL DCSP  DCSP  DCSP fhandle = BytesIO(X[f]) DCNL DCSP  DCSP  DCSP if ('train' in f): DCNL DCSP  DCSP  DCSP  DCSP train = _load_csv(fhandle) DCNL DCSP  DCSP  DCSP if ('test' in f): DCNL DCSP  DCSP  DCSP  DCSP test = _load_csv(fhandle) DCNL DCSP  DCSP print ('Downloading DCSP coverage DCSP data DCSP from DCSP %s DCSP to DCSP %s' % (COVERAGES_URL, data_home)) DCNL DCSP  DCSP X = np.load(BytesIO(urlopen(COVERAGES_URL).read())) DCNL DCSP  DCSP coverages = [] DCNL DCSP  DCSP for f in X.files: DCNL DCSP  DCSP  DCSP fhandle = BytesIO(X[f]) DCNL DCSP  DCSP  DCSP print (' DCSP - DCSP converting', f) DCNL DCSP  DCSP  DCSP coverages.append(_load_coverage(fhandle)) DCNL DCSP  DCSP coverages = np.asarray(coverages, dtype=dtype) DCNL DCSP  DCSP bunch = Bunch(coverages=coverages, test=test, train=train, **extra_params) DCNL DCSP  DCSP joblib.dump(bunch, archive_path, compress=9) DCNL DCSP else: DCNL DCSP  DCSP bunch = joblib.load(archive_path) DCNL DCSP return bunch
 DCSP ret = {} DCNL DCSP if (not os.path.isfile(config)): DCNL DCSP  DCSP return ret DCNL DCSP with salt.utils.fopen(config) as ifile: DCNL DCSP  DCSP for line in ifile: DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP comps = line.split() DCNL DCSP  DCSP  DCSP if (len(comps) != 3): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP prefix = '/..' DCNL DCSP  DCSP  DCSP name = comps[0].replace(prefix, '') DCNL DCSP  DCSP  DCSP device_fmt = comps[2].split(':') DCNL DCSP  DCSP  DCSP opts = comps[1].split(',') DCNL DCSP  DCSP  DCSP ret[name] = {'device': device_fmt[1], 'fstype': opts[0], 'opts': opts[1:]} DCNL DCSP return ret
 DCSP raw = read_raw_fif(raw_fname).crop(1.5, stop).load_data() DCNL DCSP picks = pick_types(raw.info, meg=True, stim=False, ecg=False, eog=False, exclude='bads') DCNL DCSP ica = ICA(n_components=3, max_pca_components=4, n_pca_components=4) DCNL DCSP raw._data[2, 1000:1005] = 5e-12 DCNL DCSP with catch_logging() as drop_log: DCNL DCSP  DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP  DCSP ica.fit(raw, picks[:5], reject=dict(mag=2.5e-12), decim=2, tstep=0.01, verbose=True) DCNL DCSP  DCSP assert_true(((raw._data[:5, ::2].shape[1] - 4) == ica.n_samples_)) DCNL DCSP log = [l for l in drop_log.getvalue().split('\n') if ('detected' in l)] DCNL DCSP assert_equal(len(log), 1)
 DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbeard.NAMING_PATTERN DCNL DCSP if (anime_type is None): DCNL DCSP  DCSP anime_type = sickbeard.NAMING_ANIME DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valid DCSP for DCSP a DCSP single DCSP episode'), logger.DEBUG) DCNL DCSP valid = validate_name(pattern, None, anime_type) DCNL DCSP if (multi is not None): DCNL DCSP  DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valid DCSP for DCSP a DCSP multi DCSP episode'), logger.DEBUG) DCNL DCSP  DCSP valid = (valid and validate_name(pattern, multi, anime_type)) DCNL DCSP return valid
 DCSP w = (- min([0, r, g, b])) DCNL DCSP if (w > 0): DCNL DCSP  DCSP r += w DCNL DCSP  DCSP g += w DCNL DCSP  DCSP b += w DCNL DCSP return (r, g, b)
 DCSP tuple_class = collections.namedtuple('TestCase', 'input, DCSP keep, DCSP no_keep') DCNL DCSP for line in test_data_str.splitlines(): DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP data = line.split('/') DCNL DCSP  DCSP item = tuple_class(input=data[0], keep=data[1].split('|'), no_keep=data[2].split('|')) DCNL DCSP  DCSP (yield item) DCNL DCSP (yield tuple_class(input='', keep=[], no_keep=[]))
 DCSP parser = argparse.ArgumentParser() DCNL DCSP rules = shlex.split(rule) DCNL DCSP rules.pop(0) DCNL DCSP parser.add_argument('--bootproto', dest='bootproto', action='store', choices=['dhcp', 'bootp', 'static', 'ibft']) DCNL DCSP parser.add_argument('--device', dest='device', action='store') DCNL DCSP parser.add_argument('--ip', dest='ip', action='store') DCNL DCSP parser.add_argument('--ipv6', dest='ipv6', action='store') DCNL DCSP parser.add_argument('--gateway', dest='gateway', action='store') DCNL DCSP parser.add_argument('--nodefroute', dest='nodefroute', action='store_true') DCNL DCSP parser.add_argument('--nameserver', dest='nameserver', action='store') DCNL DCSP parser.add_argument('--nodns', dest='nodns', action='store_true') DCNL DCSP parser.add_argument('--netmask', dest='netmask', action='store') DCNL DCSP parser.add_argument('--hostname', dest='hostname', action='store') DCNL DCSP parser.add_argument('--ethtool', dest='ethtool', action='store') DCNL DCSP parser.add_argument('--essid', dest='essid', action='store') DCNL DCSP parser.add_argument('--wepkey', dest='wepkey', action='store') DCNL DCSP parser.add_argument('--wpakey', dest='wpakey', action='store') DCNL DCSP parser.add_argument('--onboot', dest='onboot', action='store') DCNL DCSP parser.add_argument('--dhcpclass', dest='dhcpclass', action='store') DCNL DCSP parser.add_argument('--mtu', dest='mtu', action='store') DCNL DCSP parser.add_argument('--noipv4', dest='noipv4', action='store_true') DCNL DCSP parser.add_argument('--noipv6', dest='noipv6', action='store_true') DCNL DCSP parser.add_argument('--activate', dest='activate', action='store_true') DCNL DCSP args = clean_args(vars(parser.parse_args(rules))) DCNL DCSP parser = None DCNL DCSP return args
 DCSP class IsFieldShared(permissions.BasePermission, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Grants DCSP access DCSP if DCSP a DCSP particular DCSP profile DCSP field DCSP is DCSP shared DCSP with DCSP the DCSP requesting DCSP user.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP def has_permission(self, request, view): DCNL DCSP  DCSP  DCSP url_username = request.parser_context.get('kwargs', {}).get('username', '') DCNL DCSP  DCSP  DCSP if (request.user.username.lower() == url_username.lower()): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if request.user.is_staff: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP user = get_object_or_404(User, username__iexact=url_username) DCNL DCSP  DCSP  DCSP if (field_name in visible_fields(user.profile, user)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP raise Http404() DCNL DCSP return IsFieldShared
 DCSP epoch = int(epoch) DCNL DCSP if (len(str(epoch)) <= 10): DCNL DCSP  DCSP return epoch DCNL DCSP elif (len(str(epoch)) == 13): DCNL DCSP  DCSP return int((epoch / 1000)) DCNL DCSP elif ((len(str(epoch)) > 10) and (len(str(epoch)) < 13)): DCNL DCSP  DCSP raise ValueError('Unusually DCSP formatted DCSP epoch DCSP timestamp. DCSP  DCSP Should DCSP be DCSP 10, DCSP 13, DCSP or DCSP more DCSP digits') DCNL DCSP else: DCNL DCSP  DCSP orders_of_magnitude = (len(str(epoch)) - 10) DCNL DCSP  DCSP powers_of_ten = (10 ** orders_of_magnitude) DCNL DCSP  DCSP epoch = int((epoch / powers_of_ten)) DCNL DCSP return epoch
 DCSP if isinstance(pecls, six.string_types): DCNL DCSP  DCSP pecls = [pecls] DCNL DCSP return _pecl('uninstall DCSP {0}'.format(_cmd_quote(' DCSP '.join(pecls))))
 DCSP coach_role_on_master_course = CourseCcxCoachRole(master_course_key) DCNL DCSP coach_role_on_master_course.add_users(user)
 DCSP return np.ones((nlags + 1))
 DCSP if isinstance(statement, sqlalchemy.orm.Query): DCNL DCSP  DCSP if (dialect is None): DCNL DCSP  DCSP  DCSP dialect = statement.session.get_bind(statement._mapper_zero_or_none()).dialect DCNL DCSP  DCSP statement = statement.statement DCNL DCSP if (dialect is None): DCNL DCSP  DCSP dialect = getattr(statement.bind, 'dialect', None) DCNL DCSP if (dialect is None): DCNL DCSP  DCSP from sqlalchemy.dialects import mysql DCNL DCSP  DCSP dialect = mysql.dialect() DCNL DCSP Compiler = type(statement._compiler(dialect)) DCNL DCSP class LiteralCompiler(Compiler, ): DCNL DCSP  DCSP visit_bindparam = Compiler.render_literal_bindparam DCNL DCSP  DCSP def render_literal_value(self, value, type_): DCNL DCSP  DCSP  DCSP if isinstance(value, (Decimal, long)): DCNL DCSP  DCSP  DCSP  DCSP return str(value) DCNL DCSP  DCSP  DCSP elif isinstance(value, datetime): DCNL DCSP  DCSP  DCSP  DCSP return repr(str(value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = super(LiteralCompiler, self).render_literal_value(value, type_) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return value.encode('UTF-8') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return value DCNL DCSP return LiteralCompiler(dialect, statement)
 DCSP ret = [] DCNL DCSP mod_dir = os.path.join('/lib/modules/', os.uname()[2]) DCNL DCSP for (root, dirs, files) in os.walk(mod_dir): DCNL DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP if ('.ko' in fn_): DCNL DCSP  DCSP  DCSP  DCSP ret.append(fn_[:fn_.index('.ko')].replace('-', '_')) DCNL DCSP if ('Arch' in __grains__['os_family']): DCNL DCSP  DCSP mod_dir_arch = (('/lib/modules/extramodules-' + os.uname()[2][0:3]) + '-ARCH') DCNL DCSP  DCSP for (root, dirs, files) in os.walk(mod_dir_arch): DCNL DCSP  DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP  DCSP if ('.ko' in fn_): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.append(fn_[:fn_.index('.ko')].replace('-', '_')) DCNL DCSP return sorted(list(ret))
 DCSP moving = True DCNL DCSP if (QUICK_LINKED_CLONE == vm_['snapshot']['disk_move_type']): DCNL DCSP  DCSP reloc_spec.diskMoveType = QUICK_LINKED_CLONE DCNL DCSP elif (CURRENT_STATE_LINKED_CLONE == vm_['snapshot']['disk_move_type']): DCNL DCSP  DCSP reloc_spec.diskMoveType = CURRENT_STATE_LINKED_CLONE DCNL DCSP elif (COPY_ALL_DISKS_FULL_CLONE == vm_['snapshot']['disk_move_type']): DCNL DCSP  DCSP reloc_spec.diskMoveType = COPY_ALL_DISKS_FULL_CLONE DCNL DCSP elif (FLATTEN_DISK_FULL_CLONE == vm_['snapshot']['disk_move_type']): DCNL DCSP  DCSP reloc_spec.diskMoveType = FLATTEN_DISK_FULL_CLONE DCNL DCSP else: DCNL DCSP  DCSP moving = False DCNL DCSP if moving: DCNL DCSP  DCSP return build_clonespec(config_spec, object_ref, reloc_spec, template) DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP os.environ['PYTHONPATH'] = current_directory DCNL DCSP os.environ['DJANGO_SETTINGS_MODULE'] = 'djangoapp' DCNL DCSP (status, out) = commands.getstatusoutput('django-admin.py DCSP harvest DCSP email.feature DCSP --verbosity=2') DCNL DCSP assert_not_equals(status, 0)
 DCSP if (logfile is None): DCNL DCSP  DCSP logfile = _default_logfile('chef-client') DCNL DCSP args = ['chef-client', '--no-color', '--once', '--logfile DCSP "{0}"'.format(logfile), '--format DCSP doc'] DCNL DCSP if whyrun: DCNL DCSP  DCSP args.append('--why-run') DCNL DCSP if localmode: DCNL DCSP  DCSP args.append('--local-mode') DCNL DCSP return _exec_cmd(*args, **kwargs)
 DCSP RemoteRepository = apps.get_model(u'oauth', u'RemoteRepository') DCNL DCSP SocialAccount = apps.get_model(u'socialaccount', u'SocialAccount') DCNL DCSP for account in SocialAccount.objects.all(): DCNL DCSP  DCSP rows = RemoteRepository.objects.filter(users=account.user, source=account.provider).update(account=account)
 DCSP state = salt.utils.mac_utils.validate_enabled(enabled) DCNL DCSP cmd = 'systemsetup DCSP -setwakeonnetworkaccess DCSP {0}'.format(state) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmd) DCNL DCSP return salt.utils.mac_utils.confirm_updated(state, get_wake_on_network)
 DCSP if (not files): DCNL DCSP  DCSP return DCNL DCSP for fname in files: DCNL DCSP  DCSP if ((not exists(fname)) or (not isfile(fname))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if any(((ex in fname) for ex in exclusions)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((pattern is None) or re.match(pattern, fname)): DCNL DCSP  DCSP  DCSP file_check(fname)
 DCSP format = request.GET.get(u'format') DCNL DCSP if format: DCNL DCSP  DCSP if (format in serializer.formats): DCNL DCSP  DCSP  DCSP return serializer.get_mime_for_format(format) DCNL DCSP if ((u'callback' in request.GET) and (u'jsonp' in serializer.formats)): DCNL DCSP  DCSP return serializer.get_mime_for_format(u'jsonp') DCNL DCSP accept = request.META.get(u'HTTP_ACCEPT', u'*/*') DCNL DCSP if (accept != u'*/*'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP best_format = mimeparse.best_match(serializer.supported_formats_reversed, accept) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise BadRequest(u'Invalid DCSP Accept DCSP header') DCNL DCSP  DCSP if best_format: DCNL DCSP  DCSP  DCSP return best_format DCNL DCSP return default_format
 DCSP remove_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not query_package(module, port_path, package)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = module.run_command(('%s DCSP uninstall DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if query_package(module, port_path, package): DCNL DCSP  DCSP  DCSP module.fail_json(msg=('failed DCSP to DCSP remove DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP remove_c += 1 DCNL DCSP if (remove_c > 0): DCNL DCSP  DCSP module.exit_json(changed=True, msg=('removed DCSP %s DCSP package(s)' % remove_c)) DCNL DCSP module.exit_json(changed=False, msg='package(s) DCSP already DCSP absent')
 DCSP defaults = {'level': 'LOG_INFO', 'facility': 'LOG_USER', 'options': []} DCNL DCSP attrs = {'level': 'level', 'facility': 'facility', 'tag': 'tag', 'options': 'options'} DCNL DCSP _options = salt.returners.get_returner_options(__virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__, defaults=defaults) DCNL DCSP return _options
 DCSP if (not hasattr(sys, 'frozen')): DCNL DCSP  DCSP return os.listdir(path) DCNL DCSP (zipPath, archivePath) = splitZip(path) DCNL DCSP if (archivePath is None): DCNL DCSP  DCSP return os.listdir(path) DCNL DCSP with zipfile.ZipFile(zipPath, 'r') as zipobj: DCNL DCSP  DCSP contents = zipobj.namelist() DCNL DCSP results = set() DCNL DCSP for name in contents: DCNL DCSP  DCSP if (name.startswith(archivePath) and (len(name) > len(archivePath))): DCNL DCSP  DCSP  DCSP name = name[len(archivePath):].split('/')[0] DCNL DCSP  DCSP  DCSP results.add(name) DCNL DCSP return list(results)
 DCSP _object_id = '{}_{}_{}'.format(slugify(_value_name(value)), value.node.node_id, value.index) DCNL DCSP if (value.instance > 1): DCNL DCSP  DCSP return '{}_{}'.format(_object_id, value.instance) DCNL DCSP return _object_id
 DCSP alpha = min(alpha, (1 - alpha)) DCNL DCSP z = norm.ppf((1 - (alpha / 2.0))) DCNL DCSP xq = mstats.mquantiles(data, prob, alphap=0, betap=0, axis=axis) DCNL DCSP smj = mjci(data, prob, axis=axis) DCNL DCSP return ((xq - (z * smj)), (xq + (z * smj)))
 DCSP return [server.pool for server in client._get_topology().select_servers(any_server_selector)]
 DCSP cmd = 'statcpu DCSP -iter DCSP 1 DCSP -t' DCNL DCSP showcpu_list = run_ssh_thread(ip, user, passwd, cmd) DCNL DCSP cpu_list = [] DCNL DCSP line_num = 0 DCNL DCSP for line in showcpu_list: DCNL DCSP  DCSP line_num += 1 DCNL DCSP  DCSP if (line_num >= 3): DCNL DCSP  DCSP  DCSP cpu_stats = line.split() DCNL DCSP  DCSP  DCSP if (len(cpu_stats) > 2): DCNL DCSP  DCSP  DCSP  DCSP cpu_list.append(cpu_stats[0].split(',')[0]) DCNL DCSP return cpu_list
 DCSP config_stub.data = CONFIG_NOT_PRIVATE DCNL DCSP hist.append('new DCSP item') DCNL DCSP assert ('new DCSP item' in hist.history) DCNL DCSP hist.history.remove('new DCSP item') DCNL DCSP assert (hist.history == HISTORY)
 DCSP return PKCS115_SigScheme(rsa_key)
 DCSP path = (backend or settings.EMAIL_BACKEND) DCNL DCSP try: DCNL DCSP  DCSP (mod_name, klass_name) = path.rsplit('.', 1) DCNL DCSP  DCSP mod = import_module(mod_name) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigured(('Error DCSP importing DCSP email DCSP backend DCSP module DCSP %s: DCSP "%s"' % (mod_name, e))) DCNL DCSP try: DCNL DCSP  DCSP klass = getattr(mod, klass_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigured(('Module DCSP "%s" DCSP does DCSP not DCSP define DCSP a DCSP "%s" DCSP class' % (mod_name, klass_name))) DCNL DCSP return klass(fail_silently=fail_silently, **kwds)
 DCSP devlist = list_devices() DCNL DCSP print(('Found DCSP %d DCSP CUDA DCSP devices' % len(devlist))) DCNL DCSP supported_count = 0 DCNL DCSP for dev in devlist: DCNL DCSP  DCSP attrs = [] DCNL DCSP  DCSP cc = dev.compute_capability DCNL DCSP  DCSP attrs += [('compute DCSP capability', ('%d.%d' % cc))] DCNL DCSP  DCSP attrs += [('pci DCSP device DCSP id', dev.PCI_DEVICE_ID)] DCNL DCSP  DCSP attrs += [('pci DCSP bus DCSP id', dev.PCI_BUS_ID)] DCNL DCSP  DCSP if (cc < (2, 0)): DCNL DCSP  DCSP  DCSP support = '[NOT DCSP SUPPORTED: DCSP CC DCSP < DCSP 2.0]' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP support = '[SUPPORTED]' DCNL DCSP  DCSP  DCSP supported_count += 1 DCNL DCSP  DCSP print(('id DCSP %d DCSP  DCSP  DCSP  DCSP %20s DCSP %40s' % (dev.id, dev.name, support))) DCNL DCSP  DCSP for (key, val) in attrs: DCNL DCSP  DCSP  DCSP print(('%40s: DCSP %s' % (key, val))) DCNL DCSP print('Summary:') DCNL DCSP print((' DCTB %d/%d DCSP devices DCSP are DCSP supported' % (supported_count, len(devlist)))) DCNL DCSP return (supported_count > 0)
 DCSP filetree = obj_store[tree_sha] DCNL DCSP for (name, mode, sha) in filetree.iteritems(): DCNL DCSP  DCSP if ((not S_ISGITLINK(mode)) and (sha not in kset)): DCNL DCSP  DCSP  DCSP kset.add(sha) DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(mode): DCNL DCSP  DCSP  DCSP  DCSP _collect_filetree_revs(obj_store, sha, kset)
 DCSP try: DCNL DCSP  DCSP if (not vm_ref): DCNL DCSP  DCSP  DCSP vm_ref = get_vm_ref(session, instance) DCNL DCSP  DCSP LOG.debug('Destroying DCSP the DCSP VM', instance=instance) DCNL DCSP  DCSP destroy_task = session._call_method(session.vim, 'Destroy_Task', vm_ref) DCNL DCSP  DCSP session._wait_for_task(destroy_task) DCNL DCSP  DCSP LOG.info(_LI('Destroyed DCSP the DCSP VM'), instance=instance) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_LE('Destroy DCSP VM DCSP failed'), instance=instance)
 DCSP if (type(weights) is Variable): DCNL DCSP  DCSP n_topics = weights.data.shape[1] DCNL DCSP else: DCNL DCSP  DCSP n_topics = weights.W.data.shape[1] DCNL DCSP if (alpha is None): DCNL DCSP  DCSP alpha = (1.0 / n_topics) DCNL DCSP if (type(weights) is Variable): DCNL DCSP  DCSP log_proportions = F.log_softmax(weights) DCNL DCSP else: DCNL DCSP  DCSP log_proportions = F.log_softmax(weights.W) DCNL DCSP loss = ((alpha - 1.0) * log_proportions) DCNL DCSP return (- F.sum(loss))
 DCSP from_cache = False DCNL DCSP if (cache is not None): DCNL DCSP  DCSP cache_path = join(cache, (url.split('://')[(-1)].replace('/', ',') + '.zip')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = _open_cache(cache_path) DCNL DCSP  DCSP  DCSP from_cache = True DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (not from_cache): DCNL DCSP  DCSP data = urlopen(url).read() DCNL DCSP  DCSP if (cache is not None): DCNL DCSP  DCSP  DCSP _cache_it(data, cache_path) DCNL DCSP return (data, from_cache)
 DCSP kwargs = locals() DCNL DCSP return _create_network_acl_entry(**kwargs)
 DCSP if (not isinstance(interfaces, tuple)): DCNL DCSP  DCSP raise TypeError('The DCSP ``interfaces`` DCSP argument DCSP must DCSP be DCSP a DCSP tuple. DCSP Got: DCSP {!r}'.format(interfaces)) DCNL DCSP original_invariant = field_kwargs.pop('invariant', None) DCNL DCSP def invariant(value): DCNL DCSP  DCSP error_messages = [] DCNL DCSP  DCSP if (original_invariant is not None): DCNL DCSP  DCSP  DCSP (original_invariant_result, _original_invariant_message) = original_invariant(value) DCNL DCSP  DCSP  DCSP if original_invariant_result: DCNL DCSP  DCSP  DCSP  DCSP error_messages.append(original_invariant_result) DCNL DCSP  DCSP missing_interfaces = [] DCNL DCSP  DCSP for interface in interfaces: DCNL DCSP  DCSP  DCSP if (not interface.providedBy(value)): DCNL DCSP  DCSP  DCSP  DCSP missing_interfaces.append(interface.getName()) DCNL DCSP  DCSP if missing_interfaces: DCNL DCSP  DCSP  DCSP error_messages.append('The DCSP value DCSP {!r} DCSP did DCSP not DCSP provide DCSP these DCSP required DCSP interfaces: DCSP {}'.format(value, ', DCSP '.join(missing_interfaces))) DCNL DCSP  DCSP if error_messages: DCNL DCSP  DCSP  DCSP return (False, '\n'.join(error_messages)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (True, '') DCNL DCSP field_kwargs['invariant'] = invariant DCNL DCSP return field(**field_kwargs)
 DCSP model = context['model'] DCNL DCSP id = _get_or_bust(data_dict, 'id') DCNL DCSP entity = model.Resource.get(id) DCNL DCSP if (entity is None): DCNL DCSP  DCSP raise NotFound DCNL DCSP _check_access('resource_delete', context, data_dict) DCNL DCSP package_id = entity.get_package_id() DCNL DCSP pkg_dict = _get_action('package_show')(context, {'id': package_id}) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.before_delete(context, data_dict, pkg_dict.get('resources', [])) DCNL DCSP if pkg_dict.get('resources'): DCNL DCSP  DCSP pkg_dict['resources'] = [r for r in pkg_dict['resources'] if (not (r['id'] == id))] DCNL DCSP try: DCNL DCSP  DCSP pkg_dict = _get_action('package_update')(context, pkg_dict) DCNL DCSP except ValidationError as e: DCNL DCSP  DCSP errors = e.error_dict['resources'][(-1)] DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.after_delete(context, pkg_dict.get('resources', [])) DCNL DCSP model.repo.commit()
 DCSP root = container.parsed(name) DCNL DCSP nodes = root.xpath(xpath, namespaces=XPNSMAP) DCNL DCSP if (not nodes): DCNL DCSP  DCSP raise AbortError((_(u'The DCSP expression DCSP %s DCSP did DCSP not DCSP match DCSP any DCSP nodes') % xpath)) DCNL DCSP for split_point in nodes: DCNL DCSP  DCSP if in_table(split_point): DCNL DCSP  DCSP  DCSP raise AbortError(u'Cannot DCSP split DCSP inside DCSP tables') DCNL DCSP  DCSP if split_point.tag.endswith(u'}body'): DCNL DCSP  DCSP  DCSP raise AbortError(u'Cannot DCSP split DCSP on DCSP the DCSP <body> DCSP tag') DCNL DCSP for (i, tag) in enumerate(nodes): DCNL DCSP  DCSP tag.set(u'calibre-split-point', str(i)) DCNL DCSP current = name DCNL DCSP all_names = [name] DCNL DCSP for i in xrange(len(nodes)): DCNL DCSP  DCSP current = split(container, current, (u'//*[@calibre-split-point="%d"]' % i), before=before) DCNL DCSP  DCSP all_names.append(current) DCNL DCSP for x in all_names: DCNL DCSP  DCSP for tag in container.parsed(x).xpath(u'//*[@calibre-split-point]'): DCNL DCSP  DCSP  DCSP tag.attrib.pop(u'calibre-split-point') DCNL DCSP  DCSP container.dirty(x) DCNL DCSP return all_names[1:]
 DCSP if __opts__['load_balancers'].get(lb, None): DCNL DCSP  DCSP (username, password) = list(__opts__['load_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP find DCSP `{0}` DCSP load DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, password) DCNL DCSP F5.create_pool(name, method) DCNL DCSP return True
 DCSP doc = get_document(document_slug, request) DCNL DCSP try: DCNL DCSP  DCSP sort = int(request.GET.get('sort', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP sort = 0 DCNL DCSP try: DCNL DCSP  DCSP desc = int(request.GET.get('desc', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP desc = 0 DCNL DCSP desc_toggle = (0 if desc else 1) DCNL DCSP threads_ = sort_threads(doc.thread_set, sort, desc) DCNL DCSP threads_ = paginate(request, threads_, per_page=kbforums.THREADS_PER_PAGE) DCNL DCSP feed_urls = ((reverse('wiki.discuss.threads.feed', args=[document_slug]), ThreadsFeed().title(doc)),) DCNL DCSP is_watching_forum = (request.user.is_authenticated() and NewThreadEvent.is_notifying(request.user, doc)) DCNL DCSP return render(request, 'kbforums/threads.html', {'document': doc, 'threads': threads_, 'is_watching_forum': is_watching_forum, 'sort': sort, 'desc_toggle': desc_toggle, 'feeds': feed_urls})
 DCSP return np.uint64(struct.unpack('>Q', f.read(8))[0])
 DCSP reg = _get_registry(scope, window, tab) DCNL DCSP try: DCNL DCSP  DCSP return reg[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (default is not _UNSET): DCNL DCSP  DCSP  DCSP return default DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP args = parse_command_line(args, [], ['name']) DCNL DCSP import lixian_tasks_extended DCNL DCSP for x in (lixian_tasks_extended.extend_links if (not args.name) else lixian_tasks_extended.extend_links_name)(args): DCNL DCSP  DCSP print x
 DCSP if (not isinstance(connections, collections.Iterable)): DCNL DCSP  DCSP connections = [connections] DCNL DCSP router = get_router() DCNL DCSP message = router.new_outgoing_message(text=text, connections=connections, **kwargs) DCNL DCSP router.send_outgoing(message) DCNL DCSP return message
 DCSP _rendered = '' DCNL DCSP _loaded = {'result': True, 'comment': '', 'out': None} DCNL DCSP loaded_config = None DCNL DCSP if (template_engine not in salt.utils.templates.TEMPLATE_REGISTRY): DCNL DCSP  DCSP _loaded.update({'result': False, 'comment': 'Invalid DCSP templating DCSP engine! DCSP Choose DCSP between: DCSP {tpl_eng_opts}'.format(tpl_eng_opts=', DCSP '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))}) DCNL DCSP  DCSP return _loaded DCNL DCSP salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://') DCNL DCSP salt_render = False DCNL DCSP for salt_render_prefix in salt_render_prefixes: DCNL DCSP  DCSP if (not salt_render): DCNL DCSP  DCSP  DCSP salt_render = (salt_render or template_name.startswith(salt_render_prefix) or (template_path and template_path.startswith(salt_render_prefix))) DCNL DCSP file_exists = __salt__['file.file_exists'](template_name) DCNL DCSP if (template_source or template_path or file_exists or salt_render): DCNL DCSP  DCSP if template_source: DCNL DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP saltenv = (template_path if template_path else 'base') DCNL DCSP  DCSP  DCSP _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=template_vars, defaults=defaults, saltenv=saltenv) DCNL DCSP  DCSP  DCSP if (not isinstance(_rendered, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP if ('result' in _rendered): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['result'] = _rendered['result'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['result'] = False DCNL DCSP  DCSP  DCSP  DCSP if ('comment' in _rendered): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['comment'] = _rendered['comment'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['comment'] = 'Error DCSP while DCSP rendering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP  DCSP return _loaded DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (template_path and (not file_exists)): DCNL DCSP  DCSP  DCSP  DCSP template_name = __salt__['file.join'](template_path, template_name) DCNL DCSP  DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP  DCSP saltenv = (template_path if (not salt_render) else 'base') DCNL DCSP  DCSP  DCSP elif (salt_render and (not saltenv)): DCNL DCSP  DCSP  DCSP  DCSP saltenv = (template_path if template_path else 'base') DCNL DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP saltenv = 'base' DCNL DCSP  DCSP  DCSP _rand_filename = __salt__['random.hash'](template_name, 'md5') DCNL DCSP  DCSP  DCSP _temp_file = __salt__['file.join']('/tmp', _rand_filename) DCNL DCSP  DCSP  DCSP _managed = __salt__['file.get_managed'](name=_temp_file, source=template_name, source_hash=template_hash, source_hash_name=template_hash_name, user=template_user, group=template_group, mode=template_mode, template=template_engine, context=template_vars, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify) DCNL DCSP  DCSP  DCSP if ((not isinstance(_managed, (list, tuple))) and isinstance(_managed, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP _loaded['comment'] = _managed DCNL DCSP  DCSP  DCSP  DCSP _loaded['result'] = False DCNL DCSP  DCSP  DCSP elif (isinstance(_managed, (list, tuple)) and (not (len(_managed) > 0))): DCNL DCSP  DCSP  DCSP  DCSP _loaded['result'] = False DCNL DCSP  DCSP  DCSP  DCSP _loaded['comment'] = 'Error DCSP while DCSP rendering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP elif (isinstance(_managed, (list, tuple)) and (not (len(_managed[0]) > 0))): DCNL DCSP  DCSP  DCSP  DCSP _loaded['result'] = False DCNL DCSP  DCSP  DCSP  DCSP _loaded['comment'] = _managed[(-1)] DCNL DCSP  DCSP  DCSP if _loaded['result']: DCNL DCSP  DCSP  DCSP  DCSP _temp_tpl_file = _managed[0] DCNL DCSP  DCSP  DCSP  DCSP _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file) DCNL DCSP  DCSP  DCSP  DCSP if (not _temp_tpl_file_exists): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['result'] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaded['comment'] = 'Error DCSP while DCSP rendering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP return _loaded DCNL DCSP  DCSP  DCSP  DCSP _rendered = open(_temp_tpl_file).read() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return _loaded DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP loaded_config = _rendered DCNL DCSP  DCSP if _loaded['result']: DCNL DCSP  DCSP  DCSP fun = 'load_merge_candidate' DCNL DCSP  DCSP  DCSP if replace: DCNL DCSP  DCSP  DCSP  DCSP fun = 'load_replace_candidate' DCNL DCSP  DCSP  DCSP _loaded = __proxy__['napalm.call'](fun, **{'config': _rendered}) DCNL DCSP else: DCNL DCSP  DCSP load_templates_params = (defaults if defaults else {}) DCNL DCSP  DCSP load_templates_params.update(template_vars) DCNL DCSP  DCSP load_templates_params.update({'template_name': template_name, 'template_source': template_source, 'template_path': template_path, 'pillar': __pillar__, 'grains': __grains__, 'opts': __opts__}) DCNL DCSP  DCSP _loaded = __proxy__['napalm.call']('load_template', **load_templates_params) DCNL DCSP return _config_logic(_loaded, test=test, commit_config=commit, loaded_config=loaded_config)
 DCSP if (not encoding): DCNL DCSP  DCSP if (image.ndim == 3): DCNL DCSP  DCSP  DCSP image = image.transpose((2, 0, 1)) DCNL DCSP  DCSP  DCSP if (image.shape[0] == 3): DCNL DCSP  DCSP  DCSP  DCSP image = image[[2, 1, 0], ...] DCNL DCSP  DCSP elif (image.ndim == 2): DCNL DCSP  DCSP  DCSP image = image[np.newaxis, :, :] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Image DCSP has DCSP unrecognized DCSP shape: DCSP "%s"' % image.shape)) DCNL DCSP  DCSP datum = caffe.io.array_to_datum(image, label) DCNL DCSP else: DCNL DCSP  DCSP datum = caffe_pb2.Datum() DCNL DCSP  DCSP if (image.ndim == 3): DCNL DCSP  DCSP  DCSP datum.channels = image.shape[2] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP datum.channels = 1 DCNL DCSP  DCSP datum.height = image.shape[0] DCNL DCSP  DCSP datum.width = image.shape[1] DCNL DCSP  DCSP datum.label = label DCNL DCSP  DCSP s = StringIO() DCNL DCSP  DCSP if (encoding == 'png'): DCNL DCSP  DCSP  DCSP PIL.Image.fromarray(image).save(s, format='PNG') DCNL DCSP  DCSP elif (encoding == 'jpg'): DCNL DCSP  DCSP  DCSP PIL.Image.fromarray(image).save(s, format='JPEG', quality=90) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP encoding DCSP type') DCNL DCSP  DCSP datum.data = s.getvalue() DCNL DCSP  DCSP datum.encoded = True DCNL DCSP return datum
 DCSP with tf.Session() as sess: DCNL DCSP  DCSP print('Self-test DCSP for DCSP neural DCSP translation DCSP model.') DCNL DCSP  DCSP model = seq2seq_model.Seq2SeqModel(10, 10, [(3, 3), (6, 6)], 32, 2, 5.0, 32, 0.3, 0.99, num_samples=8) DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP data_set = ([([1, 1], [2, 2]), ([3, 3], [4]), ([5], [6])], [([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]), ([3, 3, 3], [5, 6])]) DCNL DCSP  DCSP for _ in xrange(5): DCNL DCSP  DCSP  DCSP bucket_id = random.choice([0, 1]) DCNL DCSP  DCSP  DCSP (encoder_inputs, decoder_inputs, target_weights) = model.get_batch(data_set, bucket_id) DCNL DCSP  DCSP  DCSP model.step(sess, encoder_inputs, decoder_inputs, target_weights, bucket_id, False)
 DCSP ch_names = [c['ch_name'] for c in chs] DCNL DCSP row_cals = np.zeros(len(row_names)) DCNL DCSP col_cals = np.zeros(len(col_names)) DCNL DCSP for (names, cals, inv) in zip((row_names, col_names), (row_cals, col_cals), (False, True)): DCNL DCSP  DCSP for ii in range(len(cals)): DCNL DCSP  DCSP  DCSP p = ch_names.count(names[ii]) DCNL DCSP  DCSP  DCSP if (p != 1): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Channel DCSP %s DCSP does DCSP not DCSP appear DCSP exactly DCSP once DCSP in DCSP data' % names[ii])) DCNL DCSP  DCSP  DCSP idx = ch_names.index(names[ii]) DCNL DCSP  DCSP  DCSP val = (chs[idx][mult_keys[0]] * chs[idx][mult_keys[1]]) DCNL DCSP  DCSP  DCSP val = (float((1.0 / val)) if inv else float(val)) DCNL DCSP  DCSP  DCSP val = ((1.0 / val) if flip else val) DCNL DCSP  DCSP  DCSP cals[ii] = val DCNL DCSP comp['rowcals'] = row_cals DCNL DCSP comp['colcals'] = col_cals DCNL DCSP comp['data']['data'] = ((row_cals[:, None] * comp['data']['data']) * col_cals[None, :])
 DCSP profile = request.user.profile DCNL DCSP opportunity = get_object_or_404(Opportunity, pk=opportunity_id) DCNL DCSP if ((not profile.has_permission(opportunity)) and (not profile.is_admin('treeio.sales'))): DCNL DCSP  DCSP return user_denied(request, message="You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Opportunity") DCNL DCSP form = _do_update_record(profile, request, opportunity) DCNL DCSP return render_to_response('sales/opportunity_view', {'opportunity': opportunity, 'record_form': form}, context_instance=RequestContext(request), response_format=response_format)
 DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP start DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP data = show_instance(name, call='action') DCNL DCSP if (data.get('status') == 'active'): DCNL DCSP  DCSP return {'success': True, 'action': 'start', 'status': 'active', 'msg': 'Machine DCSP is DCSP already DCSP running.'} DCNL DCSP ret = query(droplet_id=data['id'], command='actions', args={'type': 'power_on'}, http_method='post') DCNL DCSP return {'success': True, 'action': ret['action']['type'], 'state': ret['action']['status']}
 DCSP if (img.ndim < 1): DCNL DCSP  DCSP raise ValueError('Input DCSP array DCSP has DCSP to DCSP be DCSP at DCSP least DCSP 1D') DCNL DCSP img_baseshape = (img.shape[:(-1)] if multichannel else img.shape) DCNL DCSP if (img_baseshape != mask.shape): DCNL DCSP  DCSP raise ValueError('Input DCSP arrays DCSP have DCSP to DCSP be DCSP the DCSP same DCSP shape') DCNL DCSP if np.ma.isMaskedArray(img): DCNL DCSP  DCSP raise TypeError('Masked DCSP arrays DCSP are DCSP not DCSP supported') DCNL DCSP img = skimage.img_as_float(img) DCNL DCSP mask = mask.astype(np.bool) DCNL DCSP kernel = ndi.morphology.generate_binary_structure(mask.ndim, 1) DCNL DCSP mask_dilated = ndi.morphology.binary_dilation(mask, structure=kernel) DCNL DCSP (mask_labeled, num_labels) = label(mask_dilated, return_num=True) DCNL DCSP mask_labeled *= mask DCNL DCSP if (not multichannel): DCNL DCSP  DCSP img = img[..., np.newaxis] DCNL DCSP out = np.copy(img) DCNL DCSP for idx_channel in range(img.shape[(-1)]): DCNL DCSP  DCSP known_points = img[..., idx_channel][(~ mask)] DCNL DCSP  DCSP limits = (np.min(known_points), np.max(known_points)) DCNL DCSP  DCSP for idx_region in range(1, (num_labels + 1)): DCNL DCSP  DCSP  DCSP mask_region = (mask_labeled == idx_region) DCNL DCSP  DCSP  DCSP _inpaint_biharmonic_single_channel(img[..., idx_channel], mask_region, out[..., idx_channel], limits) DCNL DCSP if (not multichannel): DCNL DCSP  DCSP out = out[..., 0] DCNL DCSP return out
 DCSP global _TEST_RESULT DCNL DCSP res = _TEST_RESULT DCNL DCSP _TEST_RESULT = [] DCNL DCSP return res
 DCSP if (mode not in ['mirror', 'constant', 'nearest', 'interp', 'wrap']): DCNL DCSP  DCSP raise ValueError("mode DCSP must DCSP be DCSP 'mirror', DCSP 'constant', DCSP 'nearest' DCSP 'wrap' DCSP or DCSP 'interp'.") DCNL DCSP x = np.asarray(x) DCNL DCSP if ((x.dtype != np.float64) and (x.dtype != np.float32)): DCNL DCSP  DCSP x = x.astype(np.float64) DCNL DCSP coeffs = savgol_coeffs(window_length, polyorder, deriv=deriv, delta=delta) DCNL DCSP if (mode == 'interp'): DCNL DCSP  DCSP y = convolve1d(x, coeffs, axis=axis, mode='constant') DCNL DCSP  DCSP _fit_edges_polyfit(x, window_length, polyorder, deriv, delta, axis, y) DCNL DCSP else: DCNL DCSP  DCSP y = convolve1d(x, coeffs, axis=axis, mode=mode, cval=cval) DCNL DCSP return y
 DCSP assert hug.introspect.takes_kwargs(function_with_kwargs) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_args)) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_neither)) DCNL DCSP assert hug.introspect.takes_kwargs(function_with_both)
 DCSP global NORUN DCNL DCSP (NORUN, nr_old) = (True, NORUN) DCNL DCSP tmp = default_app.push() DCNL DCSP try: DCNL DCSP  DCSP rv = load(target) DCNL DCSP  DCSP return (rv if callable(rv) else tmp) DCNL DCSP finally: DCNL DCSP  DCSP default_app.remove(tmp) DCNL DCSP  DCSP NORUN = nr_old
 DCSP f1 = (((2.0 * precision) * recall) / T.maximum(1, (precision + recall))) DCNL DCSP return f1
 DCSP s = (u'%s=%-4s' % (lead, str(num))) DCNL DCSP if ((num != 0) and ANSIBLE_COLOR and (color is not None)): DCNL DCSP  DCSP s = stringc(s, color) DCNL DCSP return s
 DCSP arrs = [cupy.atleast_1d(a) for a in tup] DCNL DCSP axis = 1 DCNL DCSP if (arrs[0].ndim == 1): DCNL DCSP  DCSP axis = 0 DCNL DCSP return concatenate(arrs, axis)
 DCSP output_file = (PROFILING_OUTPUT_FMT % get_filename_fmt()) DCNL DCSP process_info = {} DCNL DCSP for proc in psutil.process_iter(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pinfo = proc.as_dict(attrs=['pid', 'name', 'parent', 'status', 'io_counters', 'num_threads', 'cpu_times', 'cpu_percent', 'memory_info_ex', 'memory_percent', 'exe', 'cmdline']) DCNL DCSP  DCSP except psutil.NoSuchProcess: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (info_name, info_data) in pinfo.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(info_data, '_asdict'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pinfo[info_name] = dict(info_data._asdict()) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pinfo[info_name] = info_data DCNL DCSP  DCSP  DCSP process_info[pinfo['pid']] = pinfo DCNL DCSP netinfo = psutil.net_io_counters(pernic=True) DCNL DCSP for (key, value) in netinfo.iteritems(): DCNL DCSP  DCSP netinfo[key] = value._asdict() DCNL DCSP pids_to_show = [] DCNL DCSP for (pid, pinfo) in process_info.iteritems(): DCNL DCSP  DCSP exe = str(pinfo['exe']) DCNL DCSP  DCSP if (('python' in exe) and ('w3af' in exe)): DCNL DCSP  DCSP  DCSP pids_to_show.append(pid) DCNL DCSP ps_mem_data = ps_mem_to_json(*get_memory_usage(pids_to_show, True)) DCNL DCSP psutil_data = {'CPU': psutil.cpu_times()._asdict(), 'Load DCSP average': os.getloadavg(), 'Virtual DCSP memory': psutil.virtual_memory()._asdict(), 'Swap DCSP memory': psutil.swap_memory()._asdict(), 'Network': netinfo, 'Processes': process_info, 'ps_mem': ps_mem_data, 'Thread DCSP CPU DCSP usage': get_threads_cpu_percent()} DCNL DCSP json.dump(psutil_data, file(output_file, 'w'), indent=4, sort_keys=True)
 DCSP if (not eval_data): DCNL DCSP  DCSP filenames = [os.path.join(data_dir, ('data_batch_%d.bin' % i)) for i in xrange(1, 6)] DCNL DCSP  DCSP num_examples_per_epoch = NUM_EXAMPLES_PER_EPOCH_FOR_TRAIN DCNL DCSP else: DCNL DCSP  DCSP filenames = [os.path.join(data_dir, 'test_batch.bin')] DCNL DCSP  DCSP num_examples_per_epoch = NUM_EXAMPLES_PER_EPOCH_FOR_EVAL DCNL DCSP for f in filenames: DCNL DCSP  DCSP if (not tf.gfile.Exists(f)): DCNL DCSP  DCSP  DCSP raise ValueError(('Failed DCSP to DCSP find DCSP file: DCSP ' + f)) DCNL DCSP filename_queue = tf.train.string_input_producer(filenames) DCNL DCSP read_input = read_cifar10(filename_queue) DCNL DCSP reshaped_image = tf.cast(read_input.uint8image, tf.float32) DCNL DCSP height = IMAGE_SIZE DCNL DCSP width = IMAGE_SIZE DCNL DCSP resized_image = tf.image.resize_image_with_crop_or_pad(reshaped_image, width, height) DCNL DCSP float_image = tf.image.per_image_standardization(resized_image) DCNL DCSP float_image.set_shape([height, width, 3]) DCNL DCSP read_input.label.set_shape([1]) DCNL DCSP min_fraction_of_examples_in_queue = 0.4 DCNL DCSP min_queue_examples = int((num_examples_per_epoch * min_fraction_of_examples_in_queue)) DCNL DCSP return _generate_image_and_label_batch(float_image, read_input.label, min_queue_examples, batch_size, shuffle=False)
 DCSP if isinstance(scope, list): DCNL DCSP  DCSP return [unicode_type(s) for s in scope] DCNL DCSP if isinstance(scope, set): DCNL DCSP  DCSP scope_to_list(list(scope)) DCNL DCSP elif (scope is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return scope.split(u' DCSP ')
 DCSP pool = tuple(iterable) DCNL DCSP n = len(pool) DCNL DCSP indices = list(range(n)) DCNL DCSP cycles = list(range(1, (n + 1)))[::(-1)] DCNL DCSP (yield [pool[i] for i in indices]) DCNL DCSP while n: DCNL DCSP  DCSP for i in reversed(range(n)): DCNL DCSP  DCSP  DCSP j = (cycles[i] - 1) DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP indices[i:] = (indices[(i + 1):] + indices[i:(i + 1)]) DCNL DCSP  DCSP  DCSP  DCSP cycles[i] = (n - i) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cycles[i] = j DCNL DCSP  DCSP  DCSP  DCSP (indices[i], indices[(- j)]) = (indices[(- j)], indices[i]) DCNL DCSP  DCSP  DCSP  DCSP (yield [pool[i] for i in indices]) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return
 DCSP comment = 'An DCSP error DCSP occurred DCSP pushing DCSP your DCSP image' DCNL DCSP status['out'] = '' DCNL DCSP try: DCNL DCSP  DCSP status['out'] += ('\n' + ret) DCNL DCSP  DCSP for err_log in logs: DCNL DCSP  DCSP  DCSP if isinstance(err_log, dict): DCNL DCSP  DCSP  DCSP  DCSP if ('errorDetail' in err_log): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('code' in err_log['errorDetail']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = '\n{0}\n{1}: DCSP {2}'.format(err_log['error'], err_log['errorDetail']['code'], err_log['errorDetail']['message']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = '\n{0}\n{1}'.format(err_log['error'], err_log['errorDetail']['message']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP comment += msg DCNL DCSP except Exception: DCNL DCSP  DCSP trace = traceback.format_exc() DCNL DCSP  DCSP status['out'] = 'An DCSP error DCSP occurred DCSP while DCSP parsing DCSP error DCSP output:\n{0}'.format(trace) DCNL DCSP _invalid(status, comment=comment) DCNL DCSP return status
 DCSP site = context['__CACTUS_SITE__'] DCNL DCSP page = context['__CACTUS_CURRENT_PAGE__'] DCNL DCSP url = site.get_url_for_page(link_url) DCNL DCSP if (url is None): DCNL DCSP  DCSP link_url_index = os.path.join(link_url, 'index.html') DCNL DCSP  DCSP url_link_url_index = site.get_url_for_page(link_url_index) DCNL DCSP  DCSP if (url_link_url_index is None): DCNL DCSP  DCSP  DCSP logger.warning('%s: DCSP page DCSP resource DCSP does DCSP not DCSP exist: DCSP %s', page.link_url, link_url) DCNL DCSP  DCSP url = link_url DCNL DCSP if site.prettify_urls: DCNL DCSP  DCSP return url.rsplit('index.html', 1)[0] DCNL DCSP return url
 DCSP (mu, sigma) = (100, 15) DCNL DCSP x = (mu + (sigma * np.random.randn(10000))) DCNL DCSP num_bins = 50 DCNL DCSP (n, bins, patches) = plt.hist(x, bins=num_bins, normed=1, color='green', alpha=0.6, label='hist') DCNL DCSP y = mlab.normpdf(bins, mu, sigma) DCNL DCSP plt.plot(bins, y, 'r--', label='line') DCNL DCSP plt.legend(loc='upper DCSP left', shadow=True) DCNL DCSP plt.show() DCNL DCSP return
 DCSP pass
 DCSP if (name in predefined_linkers): DCNL DCSP  DCSP raise ValueError(('Linker DCSP name DCSP already DCSP taken: DCSP %s' % name)) DCNL DCSP predefined_linkers[name] = linker
 DCSP if (not _hashFuncParams.has_key(h)): DCNL DCSP  DCSP warning('pkcs_mgf1: DCSP invalid DCSP hash DCSP (%s) DCSP provided') DCNL DCSP  DCSP return None DCNL DCSP hLen = _hashFuncParams[h][0] DCNL DCSP hFunc = _hashFuncParams[h][1] DCNL DCSP if (maskLen > ((2 ** 32) * hLen)): DCNL DCSP  DCSP warning('pkcs_mgf1: DCSP maskLen DCSP > DCSP 2**32 DCSP * DCSP hLen') DCNL DCSP  DCSP return None DCNL DCSP T = '' DCNL DCSP maxCounter = math.ceil((float(maskLen) / float(hLen))) DCNL DCSP counter = 0 DCNL DCSP while (counter < maxCounter): DCNL DCSP  DCSP C = pkcs_i2osp(counter, 4) DCNL DCSP  DCSP T += hFunc((mgfSeed + C)) DCNL DCSP  DCSP counter += 1 DCNL DCSP return T[:maskLen]
 DCSP if (image.content is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(content=image.content) DCNL DCSP if (image.source is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(source=image_annotator_pb2.ImageSource(gcs_image_uri=image.source)) DCNL DCSP raise ValueError('No DCSP image DCSP content DCSP or DCSP source DCSP found.')
 DCSP if (base is None): DCNL DCSP  DCSP base = __opts__['cachedir'] DCNL DCSP needed_dirs = (base, os.path.join(base, 'requested'), os.path.join(base, 'active')) DCNL DCSP for dir_ in needed_dirs: DCNL DCSP  DCSP if (not os.path.exists(dir_)): DCNL DCSP  DCSP  DCSP os.makedirs(dir_) DCNL DCSP  DCSP os.chmod(base, 493) DCNL DCSP return base
 DCSP installed_extensions = [] DCNL DCSP for entry_point in pkg_resources.iter_entry_points(u'mopidy.ext'): DCNL DCSP  DCSP logger.debug(u'Loading DCSP entry DCSP point: DCSP %s', entry_point) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP extension_class = entry_point.load(require=False) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logger.exception((u'Failed DCSP to DCSP load DCSP extension DCSP %s: DCSP %s' % (entry_point.name, e))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not issubclass(extension_class, Extension)): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP logger.error(u'Entry DCSP point DCSP %s DCSP did DCSP not DCSP contain DCSP a DCSP valid DCSP extensionclass: DCSP %r', entry_point.name, extension_class) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP extension = extension_class() DCNL DCSP  DCSP  DCSP config_schema = extension.get_config_schema() DCNL DCSP  DCSP  DCSP default_config = extension.get_default_config() DCNL DCSP  DCSP  DCSP command = extension.get_command() DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP logger.exception(u'Setup DCSP of DCSP extension DCSP from DCSP entry DCSP point DCSP %s DCSP failed, DCSP ignoring DCSP extension.', entry_point.name) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP installed_extensions.append(ExtensionData(extension, entry_point, config_schema, default_config, command)) DCNL DCSP  DCSP logger.debug(u'Loaded DCSP extension: DCSP %s DCSP %s', extension.dist_name, extension.version) DCNL DCSP names = (ed.extension.ext_name for ed in installed_extensions) DCNL DCSP logger.debug(u'Discovered DCSP extensions: DCSP %s', u', DCSP '.join(names)) DCNL DCSP return installed_extensions
 DCSP try: DCNL DCSP  DCSP checksd_path = get_checksd_path(osname) DCNL DCSP except PathNotFound as e: DCNL DCSP  DCSP log.error(e.args[0]) DCNL DCSP  DCSP sys.exit(3) DCNL DCSP places = [(lambda name: os.path.join(agentConfig['additional_checksd'], ('%s.py' % name)))] DCNL DCSP try: DCNL DCSP  DCSP sdk_integrations = get_sdk_integrations_path(osname) DCNL DCSP  DCSP places.append((lambda name: os.path.join(sdk_integrations, name, 'check.py'))) DCNL DCSP except PathNotFound: DCNL DCSP  DCSP log.debug('No DCSP sdk DCSP integrations DCSP path DCSP found') DCNL DCSP places.append((lambda name: os.path.join(checksd_path, ('%s.py' % name)))) DCNL DCSP return places
 DCSP group_type_id = _group_type_get_id_from_group_type(context, type_id) DCNL DCSP count = _group_type_access_query(context).filter_by(group_type_id=group_type_id).filter_by(project_id=project_id).soft_delete(synchronize_session=False) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise exception.GroupTypeAccessNotFound(group_type_id=type_id, project_id=project_id)
 DCSP params['text'].set_visible(False) DCNL DCSP ax = params['ax'] DCNL DCSP butterfly = params['butterfly'] DCNL DCSP if butterfly: DCNL DCSP  DCSP ch_start = 0 DCNL DCSP  DCSP n_channels = len(params['picks']) DCNL DCSP  DCSP data = (params['data'] * params['butterfly_scale']) DCNL DCSP else: DCNL DCSP  DCSP ch_start = params['ch_start'] DCNL DCSP  DCSP n_channels = params['n_channels'] DCNL DCSP  DCSP data = (params['data'] * params['scale_factor']) DCNL DCSP offsets = params['offsets'] DCNL DCSP lines = params['lines'] DCNL DCSP epochs = params['epochs'] DCNL DCSP n_times = len(epochs.times) DCNL DCSP tick_list = list() DCNL DCSP start_idx = int((params['t_start'] / n_times)) DCNL DCSP end = (params['t_start'] + params['duration']) DCNL DCSP end_idx = int((end / n_times)) DCNL DCSP xlabels = params['labels'][start_idx:] DCNL DCSP event_ids = params['epochs'].events[:, 2] DCNL DCSP params['ax2'].set_xticklabels(event_ids[start_idx:]) DCNL DCSP ax.set_xticklabels(xlabels) DCNL DCSP ylabels = ax.yaxis.get_ticklabels() DCNL DCSP for line_idx in range(n_channels): DCNL DCSP  DCSP ch_idx = (line_idx + ch_start) DCNL DCSP  DCSP if (line_idx >= len(lines)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (ch_idx < len(params['ch_names'])): DCNL DCSP  DCSP  DCSP if butterfly: DCNL DCSP  DCSP  DCSP  DCSP ch_type = params['types'][ch_idx] DCNL DCSP  DCSP  DCSP  DCSP if (ch_type == 'grad'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[0] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'mag'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[1] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'eeg'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[2] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'eog'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[3] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'ecg'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[4] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines[line_idx].set_segments(list()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tick_list += [params['ch_names'][ch_idx]] DCNL DCSP  DCSP  DCSP  DCSP offset = offsets[line_idx] DCNL DCSP  DCSP  DCSP this_data = data[ch_idx] DCNL DCSP  DCSP  DCSP ydata = (offset - this_data) DCNL DCSP  DCSP  DCSP xdata = params['times'][:params['duration']] DCNL DCSP  DCSP  DCSP num_epochs = np.min([params['n_epochs'], len(epochs.events)]) DCNL DCSP  DCSP  DCSP segments = np.split(np.array((xdata, ydata)).T, num_epochs) DCNL DCSP  DCSP  DCSP ch_name = params['ch_names'][ch_idx] DCNL DCSP  DCSP  DCSP if (ch_name in params['info']['bads']): DCNL DCSP  DCSP  DCSP  DCSP if (not butterfly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP this_color = params['bad_color'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP ylabels[line_idx].set_color(this_color) DCNL DCSP  DCSP  DCSP  DCSP this_color = np.tile(params['bad_color'], (num_epochs, 1)) DCNL DCSP  DCSP  DCSP  DCSP for bad_idx in params['bads']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((bad_idx < start_idx) or (bad_idx > end_idx)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP this_color[(bad_idx - start_idx)] = (1.0, 0.0, 0.0) DCNL DCSP  DCSP  DCSP  DCSP lines[line_idx].set_zorder(2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_color = params['colors'][ch_idx][start_idx:end_idx] DCNL DCSP  DCSP  DCSP  DCSP lines[line_idx].set_zorder(3) DCNL DCSP  DCSP  DCSP  DCSP if (not butterfly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ylabels[line_idx].set_color('black') DCNL DCSP  DCSP  DCSP lines[line_idx].set_segments(segments) DCNL DCSP  DCSP  DCSP lines[line_idx].set_color(this_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lines[line_idx].set_segments(list()) DCNL DCSP ax.set_xlim(params['times'][0], (params['times'][0] + params['duration']), False) DCNL DCSP params['ax2'].set_xlim(params['times'][0], (params['times'][0] + params['duration']), False) DCNL DCSP if butterfly: DCNL DCSP  DCSP factor = ((-1.0) / params['butterfly_scale']) DCNL DCSP  DCSP labels = np.empty(20, dtype='S15') DCNL DCSP  DCSP labels.fill('') DCNL DCSP  DCSP ticks = ax.get_yticks() DCNL DCSP  DCSP idx_offset = 1 DCNL DCSP  DCSP if ('grad' in params['types']): DCNL DCSP  DCSP  DCSP labels[(idx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for idx in [idx_offset, (idx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[idx] = '{0:.2f}'.format(((((ticks[idx] - offsets[0]) * params['scalings']['grad']) * 10000000000000.0) * factor)) DCNL DCSP  DCSP  DCSP idx_offset += 4 DCNL DCSP  DCSP if ('mag' in params['types']): DCNL DCSP  DCSP  DCSP labels[(idx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for idx in [idx_offset, (idx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[idx] = '{0:.2f}'.format(((((ticks[idx] - offsets[1]) * params['scalings']['mag']) * 1000000000000000.0) * factor)) DCNL DCSP  DCSP  DCSP idx_offset += 4 DCNL DCSP  DCSP if ('eeg' in params['types']): DCNL DCSP  DCSP  DCSP labels[(idx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for idx in [idx_offset, (idx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[idx] = '{0:.2f}'.format(((((ticks[idx] - offsets[2]) * params['scalings']['eeg']) * 1000000.0) * factor)) DCNL DCSP  DCSP  DCSP idx_offset += 4 DCNL DCSP  DCSP if ('eog' in params['types']): DCNL DCSP  DCSP  DCSP labels[(idx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for idx in [idx_offset, (idx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[idx] = '{0:.2f}'.format(((((ticks[idx] - offsets[3]) * params['scalings']['eog']) * 1000000.0) * factor)) DCNL DCSP  DCSP  DCSP idx_offset += 4 DCNL DCSP  DCSP if ('ecg' in params['types']): DCNL DCSP  DCSP  DCSP labels[(idx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for idx in [idx_offset, (idx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[idx] = '{0:.2f}'.format(((((ticks[idx] - offsets[4]) * params['scalings']['ecg']) * 1000000.0) * factor)) DCNL DCSP  DCSP ax.set_yticklabels(labels, fontsize=12, color='black') DCNL DCSP else: DCNL DCSP  DCSP ax.set_yticklabels(tick_list, fontsize=12) DCNL DCSP if (params['events'] is not None): DCNL DCSP  DCSP _draw_event_lines(params) DCNL DCSP params['vsel_patch'].set_y(ch_start) DCNL DCSP params['fig'].canvas.draw() DCNL DCSP if (params['fig_proj'] is not None): DCNL DCSP  DCSP params['fig_proj'].canvas.draw()
 DCSP if ask(Q.orthogonal(expr.arg), assumptions): DCNL DCSP  DCSP return S.One DCNL DCSP elif ask(Q.singular(expr.arg), assumptions): DCNL DCSP  DCSP return S.Zero DCNL DCSP elif ask(Q.unit_triangular(expr.arg), assumptions): DCNL DCSP  DCSP return S.One DCNL DCSP return expr
 DCSP return getattr(g, '_rate_limit', None)
 DCSP runner = Runner(join_path('zh-TW', 'success', 'outlines.feature'), verbosity=3, no_color=False) DCNL DCSP runner.run() DCNL DCSP assert_stdout_lines(u'\n\x1b[1;37m\u7279\u6027: DCSP \u4e2d\u6587\u5834\u666f\u6a21\u677f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:3\x1b[0m\n\x1b[1;37m DCSP  DCSP \u4e2d\u6587\u5834\u666f\u6a21\u677f\u5716\u8868\u6e2c\u8a66 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:4\x1b[0m\n\n\x1b[1;37m DCSP  DCSP \u5834\u666f\u6a21\u677f: DCSP \u7528\u8868\u683c\u63cf\u8ff0\u5834\u666f DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:6\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u5982\u679c DCSP \u8f38\u5165\u662f<\u8f38\u5165> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:13\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u7576 DCSP \u57f7\u884c<\u8655\u7406>\u6642 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:22\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u90a3\u9ebd DCSP \u5f97\u5230<\u7d50\u679c> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:31\x1b[0m\n\n\x1b[1;37m DCSP  DCSP \u4f8b\u5982:\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[0;36m DCSP \u8f38\u5165\x1b[1;37m DCSP |\x1b[0;36m DCSP \u8655\u7406\x1b[1;37m DCSP |\x1b[0;36m DCSP \u7d50\u679c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[0;36m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u4ec0\u9ebd\x1b[1;37m DCSP |\x1b[1;32m DCSP \u9019\u500b\x1b[1;37m DCSP |\x1b[1;32m DCSP \u529f\u80fd DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u5176\u4ed6\x1b[1;37m DCSP |\x1b[1;32m DCSP \u9019\u88cf\x1b[1;37m DCSP |\x1b[1;32m DCSP \u4e00\u6a23 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u6578\u64da\x1b[1;37m DCSP |\x1b[1;32m DCSP \u52d5\u4f5c\x1b[1;37m DCSP |\x1b[1;32m DCSP unicode\u8f38\u51fa!\x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\n\x1b[1;37m1 DCSP feature DCSP (\x1b[1;32m1 DCSP passed\x1b[1;37m)\x1b[0m\n\x1b[1;37m3 DCSP scenarios DCSP (\x1b[1;32m3 DCSP passed\x1b[1;37m)\x1b[0m\n\x1b[1;37m9 DCSP steps DCSP (\x1b[1;32m9 DCSP passed\x1b[1;37m)\x1b[0m\n')
 DCSP files = flask.request.files DCNL DCSP archive_file = get_tempfile(files['archive'], '.archive') DCNL DCSP if tarfile.is_tarfile(archive_file): DCNL DCSP  DCSP archive = tarfile.open(archive_file, 'r') DCNL DCSP  DCSP names = archive.getnames() DCNL DCSP elif zipfile.is_zipfile(archive_file): DCNL DCSP  DCSP archive = zipfile.ZipFile(archive_file, 'r') DCNL DCSP  DCSP names = archive.namelist() DCNL DCSP else: DCNL DCSP  DCSP return (flask.jsonify({'status': 'Incorrect DCSP Archive DCSP Type'}), 500) DCNL DCSP if ('info.json' in names): DCNL DCSP  DCSP tempdir = tempfile.mkdtemp() DCNL DCSP  DCSP labels_file = None DCNL DCSP  DCSP archive.extractall(path=tempdir) DCNL DCSP  DCSP with open(os.path.join(tempdir, 'info.json')) as data_file: DCNL DCSP  DCSP  DCSP info = json.load(data_file) DCNL DCSP  DCSP (valid, key) = validate_archive_keys(info) DCNL DCSP  DCSP if (valid is False): DCNL DCSP  DCSP  DCSP return (flask.jsonify({'status': (("Missing DCSP Key DCSP '" + key) + "' DCSP in DCSP info.json")}), 500) DCNL DCSP  DCSP weights_file = os.path.join(tempdir, info['snapshot DCSP file']) DCNL DCSP  DCSP if ('model DCSP file' in info): DCNL DCSP  DCSP  DCSP model_file = os.path.join(tempdir, info['model DCSP file']) DCNL DCSP  DCSP elif ('network DCSP file' in info): DCNL DCSP  DCSP  DCSP model_file = os.path.join(tempdir, info['network DCSP file']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (flask.jsonify({'status': 'Missing DCSP model DCSP definition DCSP in DCSP info.json'}), 500) DCNL DCSP  DCSP if ('labels DCSP file' in info): DCNL DCSP  DCSP  DCSP labels_file = os.path.join(tempdir, info['labels DCSP file']) DCNL DCSP  DCSP job = PretrainedModelJob(weights_file, model_file, labels_file, info['framework'], username=utils.auth.get_username(), name=info['name']) DCNL DCSP  DCSP scheduler.add_job(job) DCNL DCSP  DCSP job.wait_completion() DCNL DCSP  DCSP shutil.rmtree(tempdir, ignore_errors=True) DCNL DCSP  DCSP return (flask.jsonify({'status': 'success'}), 200) DCNL DCSP else: DCNL DCSP  DCSP return (flask.jsonify({'status': 'Missing DCSP or DCSP Incorrect DCSP json DCSP file'}), 500)
